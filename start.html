<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="Cache-control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <link rel="shortcut icon" type="image/ico" href="favicon.ico" />
    <title>Gleisplan</title>
    <link rel="stylesheet" href="start.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN"
        crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
    <script src="code/preLoader.js"></script>
    <script src="code/signaling.js"></script>

    <script src="tools.js"></script>
    <script src="code/track.js?02"></script>


    <style type="text/css">

    </style>
    <script>
        const VERSION = '0.43'
        const EXCLUDE_JSON = [];

        const MODE_PLAY = 1;
        const MODE_EDIT = 2;
        const MODE_DELETE = 4;


        const MOUSE_ACTION = {
            NONE: 0,
            SCROLL: 1,
            DRAW: 2,
            MOVE_ITEM: 3,
            DND_SIGNAL: 4
        }




        'use strict';
        var grid_size = 60;
        var signale_scale = 0.3;
        var main_container, overlay_container, ui_container;
        var drawingCanvas;
        var color = "#000000";
        var stroke = 4;
        var startpoint;
        var previousTouch;
        var showGrid = true;
        var mode = MODE_EDIT;
        var pl;
        var mouseMoved;
        var mouseAction = null;



        var tracks = [];
        var signals = [];

        var signalTemplates = {}

        $(() => { init(); });

        function create_buttonGroup(items) {
            return $("<div>", { class: "btn-group", role: "group" }).append(items);
        }

        function create_toggleButtonX(text, id, onclick) {
            return $("<button>", {
                type: "button",
                id: id,
                class: "btn btn-secondary btn-sm"
            }).html(text).click(() => { onclick(); });
        }

        function checkModeButtons() {
            $("button[data-mode]").removeClass("active");
            $("button[data-mode=" + mode + "]").addClass("active");

            /*  $("button[data-mode]").each((x, y) => {
                 if (y.attr("data-mode") == mode)
                     y.addClass("active");
                 else
                     y.removeClass("active");
             }); */
        }

        function init() {

            pl = new preLoader("images");
            initSignals();
            Promise.all([pl.add("ks")]).then(() => {
                pl.start();
            });


            stage = new createjs.Stage(myCanvas);
            stage.autoClear = true;
            stage.enableDOMEvents(true);
            console.log(createjs.Touch.isSupported());
            if (createjs.Touch.isSupported())
                createjs.Touch.enable(stage);
            createjs.Ticker.framerate = 24;

            main_container = new createjs.Container();
            main_container.name = "main";
            main_container.mouseChildren = true;
            stage.addChild(main_container);

            ui_container = new createjs.Container();
            ui_container.name = "ui";
            stage.addChild(ui_container);

            overlay_container = new createjs.Container();
            overlay_container.name = "overlay";
            stage.addChild(overlay_container);


            stage.on("stagemousedown", handleStageMouseDown);
            stage.on("stagemouseup", handleStageMouseUp);

            /* document.oncontextmenu = function () {
                return false;
            }; */
            myCanvas.addEventListener('wheel', (event) => {
                event.preventDefault();

                main_container.scale -= 0.1 * (event.deltaY / Math.abs(event.deltaY));
                if (main_container.scale < 0.3) main_container.scale = 0.3;
                drawGrid(main_container);
                stage.update();
                //console.log("scale: " + main_container.scale);
                save();
            });
            if (createjs.Touch.isSupported()) {
                myCanvas.addEventListener('touchstart', (event) => {
                    if (event.touches.length === 1) {
                        let touch = event.touches[0];
                        startTrackDrawing(main_container.globalToLocal(touch.clientX, touch.clientY));
                    }


                    /* console.log("touch:" + event.touches.length);
                    for (let index = 0; index < event.touches.length; index++) {
                        const item = event.touches[index];
                        console.log("x:" + item.clientX + ":" + item.clientY);
                    } */
                });

                myCanvas.addEventListener('touchmove', (event) => {
                    if (event.touches.length === 2) {
                        let touch = event.touches[0];

                        if (previousTouch) {
                            // be aware that these only store the movement of the first touch in the touches array
                            main_container.x += touch.clientX - previousTouch.clientX;
                            main_container.y += touch.clientY - previousTouch.clientY;

                            drawGrid(main_container);
                        };

                        previousTouch = touch;
                    }

                });
            }

            $("#btnPlay").click((e) => {
                mode = MODE_PLAY;
                checkModeButtons();
            })
            $("#btnDrawTracks").click((e) => {
                mode = MODE_EDIT;
                checkModeButtons();
            })
            $("#btnSignal").click(() => {

            })

            $("#btnGrid").click(() => { showGrid = !showGrid; drawGrid(main_container); stage.update(); })

            $("#btnClear").click(() => { tracks = []; main_container.removeAllChildren(); drawGrid(main_container); save(); stage.update(); })

            $("#btnCenter").click(() => { main_container.scale = 1; main_container.x = 0; main_container.y = 0; save(); drawGrid(main_container); stage.update(); })

            $(btn_test).click((e) => {
                e.preventDefault();
                $([myCanvas, sidebar]).toggleClass("toggled");
            });

            $("#btnImage").click((e) => {
                let sg = showGrid;
                showGrid = false;
                drawGrid(main_container);
                stage.update();
                let img = main_container.toDataURL("#00000000", "image/png");
                console.log(img.slice(0, 50));

                showGrid = sg;
                drawGrid(main_container);
                stage.update();
                //e.target.href = img;

                let a = $("<a>", { download: "gleisplan.png", href: img });
                a[0].click();
            })

            new_ks.addEventListener("mousedown", (e) => {

                mouseAction = {
                    type: MOUSE_ACTION.DND_SIGNAL,
                    template: signalTemplates[e.target.attributes['data-signal'].value]
                };

                //mouseup beim document anmelden, weil mouseup im stage nicht ausgelÃ¶st wird, wenn mousedown nicht auch auf der stage war                
                document.addEventListener("mouseup", handleStageMouseUp, { once: true });

                stage.addEventListener("stagemousemove", handleMouseMove);
                startDragAndDropSignal(e.offsetX,e.offsetY);
            });



            loadRecent();
            onResizeWindow();
            checkModeButtons();

            $(window).resize(() => onResizeWindow());
        }

        function onResizeWindow() {
            $(myCanvas).attr("height", $(CanvasContainer).height() - 5);
            $(myCanvas).attr("width", $(CanvasContainer).width());
            drawGrid(main_container);
            stage.update();
        }

        function drawGrid() {
            let oldGrid = main_container.getChildByName("grid");
            if (oldGrid != null)
                main_container.removeChild(oldGrid);
            if (showGrid) {
                let grid = new createjs.Shape();
                grid.name = "grid";
                grid.mouseEnabled = false;
                grid.graphics.c().setStrokeStyle(1, "round").setStrokeDash([5, 5], 2 - Math.floor(main_container.y / (2 * main_container.scale)) * 2).beginStroke("#eee");
                let bounds = stage.canvas.getBoundingClientRect();

                let i = Math.floor(main_container.x / (grid_size * main_container.scale)) * -(grid_size);
                while (i < (bounds.width / main_container.scale) - (main_container.x / main_container.scale)) { //spalten                
                    grid.graphics.moveTo(i, 0 - main_container.y / main_container.scale).lineTo(i, (bounds.height / main_container.scale) - main_container.y / main_container.scale);
                    i += grid_size;
                }
                grid.graphics.setStrokeDash([5, 5], 2 - Math.floor(main_container.x / (2 * main_container.scale)) * 2).beginStroke("#eee");
                i = Math.floor(main_container.y / (grid_size * main_container.scale)) * -grid_size;
                while (i < (bounds.height / main_container.scale) - main_container.y / main_container.scale) { //zeilen
                    grid.graphics.moveTo(0 - main_container.x / main_container.scale, i).lineTo((bounds.width / main_container.scale) - main_container.x / main_container.scale, i);
                    i += grid_size;
                }
                main_container.addChildAt(grid, 0);
            }
        }


        function handleStageMouseDown(event) {

            mouseMoved = false;

            //console.log(main_container.mouseX + "/" + main_container.mouseY);

            let hittest = getHitTest();

            if (hittest != null) {
                console.log(hittest.name);
            }

            if (event.nativeEvent.which == 1 && mode === MODE_EDIT && hittest?.name != "signal") {//(hittest == null || hittest.name == "track" || hittest.name == "grid")) {
                stage.addEventListener("stagemousemove", handleMouseMove);
                startTrackDrawing();
                mouseAction = { type: MOUSE_ACTION.DRAW };
            }

            if (event.nativeEvent.which == 3) {
                stage.addEventListener("stagemousemove", handleMouseMove);
                mouseAction = { type: MOUSE_ACTION.SCROLL };
            }
        }

        function getHitTest() {
            return stage.getObjectUnderPoint(stage.mouseX, stage.mouseY, 1);
        }

        function findTrack() {
            let local_point = main_container.globalToLocal(stage.mouseX, stage.mouseY);
            let circle = { x: local_point.x, y: local_point.y, radius: grid_size / 2 };
            let r;
            for (let index = 0; index < tracks.length; index++) {
                const track = tracks[index];
                if (r = LineIsInCircle(track, circle))
                    return r;
            }
        }

        function createSignalContainer(parent_container, signal) {
            let c = new createjs.Container();
            c.name = "signal";
            c.signal = signal;

            c.scale = signale_scale;
            parent_container.addChild(c);

            signal.draw(c);
            let sig_bounds = c.getBounds();
            c.regX = sig_bounds.width;
            c.regY = sig_bounds.height;

            return c;
        }

        function bindSignal2Track(c_sig, track, pos) {

            c_sig.x = Math.cos(deg2rad(track.deg)) * pos.km + track.start.x;
            c_sig.y = Math.sin(deg2rad(track.deg)) * -pos.km + track.start.y;


            if (pos.above) {
                c_sig.rotation = 270 - track.deg;
                c_sig.y -= Math.cos(deg2rad(track.deg)) * (grid_size / 2);
                c_sig.x -= Math.sin(deg2rad(track.deg)) * (grid_size / 2);
            }
            else {
                c_sig.rotation = 90 - track.deg;
                c_sig.y += Math.cos(deg2rad(track.deg)) * (grid_size / 2);
                c_sig.x += Math.sin(deg2rad(track.deg)) * (grid_size / 2);
            }
        }

        function startDragAndDropSignal(mouseX,mouseY) {
            let signal = new signalShape(mouseAction.template);
            signal._template.elements.hp0.setEnabled(signal, true);
            mouseAction.container = createSignalContainer(overlay_container, signal);
            mouseAction.container.x = mouseX;
            mouseAction.container.y = mouseY;

            /* let circle = new createjs.Shape();
            circle.name = "circle";
            circle.graphics.setStrokeStyle(1).beginStroke("#e00").drawCircle(0, 0, grid_size / 2);
            mouseAction.container.addChild(circle); */
            stage.update();
        }

        function startTrackDrawing() {
            startpoint = main_container.globalToLocal(stage.mouseX, stage.mouseY);
            drawingCanvas = new createjs.Shape();
            main_container.addChild(drawingCanvas);
            drawingCanvas.graphics.c().setStrokeStyle(stroke).beginStroke(color).moveTo(startpoint.x, startpoint.y);
        }

        function handleMouseMove(event) {
            if (!event.primary) { return; }
            mouseMoved = true;
            if (mouseAction == null) return;
            if (mouseAction.type === MOUSE_ACTION.DND_SIGNAL) {

                mouseAction.container.x = stage.mouseX;
                mouseAction.container.y = stage.mouseY;

                
                mouseAction.hit_track = findTrack();
                if (mouseAction.hit_track) {
                    mouseAction.pos = {
                        km: mouseAction.hit_track.km,
                        signal: mouseAction.container.signal,
                        above: mouseAction.hit_track.above,
                        flipped: false
                    }
                    bindSignal2Track(mouseAction.container,mouseAction.hit_track.track,mouseAction.pos);
                } else {
                    mouseAction.container.rotation = 0;
                }
            } else if (mouseAction.type === MOUSE_ACTION.DRAW) {
                let p = main_container.globalToLocal(stage.mouseX, stage.mouseY);
                drawingCanvas.graphics.lineTo(p.x, p.y);
            }
            else if (mouseAction.type === MOUSE_ACTION.SCROLL) {
                main_container.x += event.nativeEvent.movementX;
                main_container.y += event.nativeEvent.movementY;
                drawGrid(main_container);
            }

            stage.update();
        }

        function handleStageMouseUp(event) {

            stage.removeEventListener("stagemousemove", handleMouseMove);
            let p2 = main_container.globalToLocal(stage.mouseX, stage.mouseY);
            if (mouseAction == null) return;
            if (mouseAction.type === MOUSE_ACTION.DND_SIGNAL) {
                overlay_container.removeChild(mouseAction.container);
                if (mouseAction.hit_track) {                                       
                    main_container.addChild(mouseAction.container);

                    mouseAction.hit_track.track.AddSignal(mouseAction.pos);
                    save();
                    //addSignal2Canvas(signalTemplates.ks, mouseAction.hit_track.point, mouseAction.hit_track.track, mouseAction.hit_track.above);
                }
                stage.update();
            } else if (mouseAction.type === MOUSE_ACTION.DRAW) {
                main_container.removeChild(drawingCanvas);
                //main_container.clear();

                let p1 = startpoint;


                if (Math.abs(p1.x - p2.x) >= grid_size || Math.abs(p1.y - p2.y) >= grid_size) {

                    let diagonal = (Math.abs(p1.x - p2.x) / Math.abs(p1.y - p2.y)) < 4;
                    if (diagonal) {
                        p2.x = startpoint.x + Math.abs(p2.y - startpoint.y) * ((startpoint.x > p2.x) ? -1 : 1);
                    }
                    else
                        p2.y = startpoint.y;

                    p1.y = Math.round(p1.y / grid_size) * grid_size;
                    p1.x = Math.round(p1.x / grid_size) * grid_size;

                    p2.y = Math.round(p2.y / grid_size) * grid_size;
                    p2.x = Math.round(p2.x / grid_size) * grid_size;

                    if (p1.x - p2.x != 0) {
                        createTrack(p1, p2);
                        save();
                    }
                }
                stage.update();
                connection = null;
            } /* else if (mode === MODE_EDIT && !mouseMoved) {
                let p1 = main_container.globalToLocal(main_container.mouseX, main_container.mouseY);
                let hittest = main_container.getObjectUnderPoint(main_container.mouseX, main_container.mouseY);

            } */


            mouseAction = null;
        }

        function createTrack(p1, p2) {
            let track = new trackShape(p1, p2);
            track.draw(main_container);
            tracks.push(track);
        }



        function addSignal2Canvas(template, p, track, above) {
            let signal = new signalShape(template);
            template.elements.hp0.setEnabled(signal, true);

            let c = new createjs.Container();
            c.name = "signal";
            signal.draw(c);
            let sig_bounds = c.getBounds();
            c.regX = sig_bounds.width;
            c.regY = sig_bounds.height;
            c.x = p.x;
            if (above) {
                c.rotation = 270 - track.deg;
                c.y = p.y - grid_size / 2;
            }
            else {
                c.rotation = 90 - track.deg;
                c.y = p.y + grid_size / 2;
            }
            c.scale = signale_scale;
            c.mouseChildren = false;
            c.signal = signal;
            main_container.addChild(c);
            signals.push(signal);

        }

        function replacer(key, value) {
            if (value != null && typeof value.stringify === "function") {
                return value.stringify();
            } else {
                if (EXCLUDE_JSON.includes(key))
                    return undefined
                else
                    return value;
            }
        }

        function getSaveString() {
            return JSON.stringify({
                tracks: tracks,
                //signals: signals,
                version: 0.13,
                zoom: main_container.scale,
                scrollX: main_container.x,
                scrollY: main_container.y
            }, replacer);
        }

        function save() {
            localStorage.setItem("bahnhof_last1", getSaveString());
        }

        function loadRecent() {
            let x = localStorage.getItem('bahnhof_last1');
            if (x != null) {
                //loadFromJson(x);
                stage.update();
            }
        }

        function receiver(key, value) {
            if (key == "signal")
                return signalShape.FromObject(value);
            if (key == "tracks")
                value.map((item) => {
                    return trackShape.FromObject(item);
                })

            return value;
        }

        function loadFromJson(json) {
            let loaded = JSON.parse(json, receiver);
            if (loaded.version >= 0.13) {
                main_container.x = loaded.scrollX;
                main_container.y = loaded.scrollY;
                main_container.scale = loaded.zoom;
                tracks = loaded.tracks;
                /* loaded.tracks.forEach(s => {
                    createTrack(s.start, s.end);
                }); */
            }
        }


    </script>
</head>

<body>
    <div class="visually-hidden" style="font-family: DIN condenced;">dummy to load font face</div>
    <div id="container">
        <div id="toolbar">
            <button id="btnPlay" type="button" data-mode="1" class="btn btn-secondary btn-sm" title="Signale bedienen">
                <i class="bi bi-cursor-fill"></i>
            </button>
            <button id="btnDrawTracks" type="button" data-mode="2" class="btn btn-secondary btn-sm active"
                title="Gleise zeichnen">
                <i class="bi bi-pencil"></i>
            </button>
            <button id="btnGrid" type="button" class="btn btn-secondary btn-sm active" title="zeige Gitter">
                <i class="bi bi-grid-3x3"></i>
            </button>
            <button id="btnClear" type="button" class="btn btn-secondary btn-sm" title="alles entfernen">
                <i class="bi bi-trash"></i>
            </button>
            <button id="btnRemove" type="button" disabled="true" class="btn btn-secondary btn-sm"
                title="Element entfernen">
                <i class="bi bi-eraser"></i>
            </button>
            <button id="btnCenter" type="button" class="btn btn-secondary btn-sm" title="Ansicht zentrieren">
                <i class="bi bi-bullseye"></i>
            </button>
            <button id="btnImage" type="button" class="btn btn-secondary btn-sm" title="Ansicht als Bild herunterladen">
                <i class="bi bi-camera"></i>
            </button>
            <button id="btnSignal" type="button" class="btn btn-secondary btn-sm" data-bs-container="body"
                data-bs-placement="bottom">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                    class="bi bi-stoplights" viewBox="0 0 16 16">
                    <path
                        d="M8 5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm0 4a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm1.5 2.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z" />
                    <path
                        d="M4 2a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2h2c-.167.5-.8 1.6-2 2v2h2c-.167.5-.8 1.6-2 2v2h2c-.167.5-.8 1.6-2 2v1a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-1c-1.2-.4-1.833-1.5-2-2h2V8c-1.2-.4-1.833-1.5-2-2h2V4c-1.2-.4-1.833-1.5-2-2h2zm2-1a1 1 0 0 0-1 1v11a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6z" />
                </svg>
            </button>
            <button id="btn_test" class="btn btn-secondary btn-sm" type="button">
                Toggle width collapse
            </button>

        </div>
        <div id="CanvasContainer">
            <div id="sidebar" class="toggled">
                <div class="accordion" id="accordionExample">
                    <div class="accordion-item">
                        <h4 class="accordion-header" id="headingOne">
                            <button class="accordion-button user-select-none" type="button" data-bs-toggle="collapse"
                                data-bs-target="#collapseOne">
                                Hauptsignal
                            </button>
                        </h4>
                        <div id="collapseOne" class="accordion-collapse collapse show" aria-labelledby="headingOne"
                            data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                <div id="new_ks" data-signal="ks" class="rounded bg-secondary"
                                    style="width: 75px; height: 75px;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="accordion-item">
                        <h2 class="accordion-header" id="headingTwo">
                            <button class="accordion-button collapsed user-select-none" type="button"
                                data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false"
                                aria-controls="collapseTwo">
                                Vorsignal
                            </button>
                        </h2>
                        <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo"
                            data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                <strong>This is the second item's accordion body.</strong> It is hidden by default,
                                until the collapse plugin adds the appropriate classes that we use to style each
                                element. These classes control the overall appearance, as well as the showing and hiding
                                via CSS transitions. You can modify any of this with custom CSS or overriding our
                                default variables. It's also worth noting that just about any HTML can go within the
                                <code>.accordion-body</code>, though the transition does limit overflow.
                            </div>
                        </div>
                    </div>
                    <div class="accordion-item">
                        <h2 class="accordion-header" id="headingThree">
                            <button class="accordion-button collapsed user-select-none" type="button"
                                data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false"
                                aria-controls="collapseThree">
                                Lf-Signale
                            </button>
                        </h2>
                        <div id="collapseThree" class="accordion-collapse collapse" aria-labelledby="headingThree"
                            data-bs-parent="#accordionExample">
                            <div class="accordion-body">
                                <strong>This is the third item's accordion body.</strong> It is hidden by default, until
                                the collapse plugin adds the appropriate classes that we use to style each element.
                                These classes control the overall appearance, as well as the showing and hiding via CSS
                                transitions. You can modify any of this with custom CSS or overriding our default
                                variables. It's also worth noting that just about any HTML can go within the
                                <code>.accordion-body</code>, though the transition does limit overflow.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <canvas id="myCanvas" width="10" height="10" class="toggled"></canvas>



        </div>
    </div>


</body>

</html>
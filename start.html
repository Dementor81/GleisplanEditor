<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="Cache-control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <link rel="shortcut icon" type="image/ico" href="favicon.ico" />
    <title>Gleisplan</title>
    <link rel="stylesheet" href="start.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN"
        crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
    <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
    <script src="code/preLoader.js"></script> 
    <script src="code/signaling.js"></script>
       
    <script src="tools.js"></script>
    <script src="track.js?02"></script>


    <style type="text/css">

    </style>
    <script>
        const VERSION = '0.43'
        const EXCLUDE_JSON = ["_shape", "_signaldavor", "_signaldanach", "_canvas", "_main_container", "_position", "_imgCatalog", "_signalbilder"];

        const MODE_PLAY = 1;
        const MODE_EDIT = 2;
        const MODE_DELETE = 4;

        const MOUSE_NONE = 0;
        const MOUSE_SCROLL = 1;
        const MOUSE_DRAW = 2;
        const MOUSE_MOVE_ITEM = 3;
        const MOUSE_DND_SIGNAL = 4;


        'use strict';
        var grid_size = 30;
        var canvas, main_container, main_container, ui_container;
        var drawingCanvas;
        var color = "#000000";
        var stroke = 4;
        var startpoint;
        var previousTouch;
        var showGrid = true;
        var mode = MODE_EDIT;
        var pl;
        var mouseMoved;
        var mouseAction = MOUSE_NONE;

        var dnd_Signal;


        var tracks = [];
        var signals = [];

        var signalTemplates = {}

        $(() => { init(); });

        function create_buttonGroup(items) {
            return $("<div>", { class: "btn-group", role: "group" }).append(items);
        }

        function create_toggleButtonX(text, id, onclick) {
            return $("<button>", {
                type: "button",
                id: id,
                class: "btn btn-secondary btn-sm"
            }).html(text).click(() => { onclick(); });
        }

        function checkModeButtons() {
            $("button[data-mode]").removeClass("active");
            $("button[data-mode=" + mode + "]").addClass("active");

            /*  $("button[data-mode]").each((x, y) => {
                 if (y.attr("data-mode") == mode)
                     y.addClass("active");
                 else
                     y.removeClass("active");
             }); */
        }

        function init() {
            pl = new preLoader("images");
            initSignals();



            canvas = document.getElementById("myCanvas");
            stage = new createjs.Stage(canvas);
            stage.autoClear = true;
            stage.enableDOMEvents(true);
            console.log(createjs.Touch.isSupported());
            if (createjs.Touch.isSupported())
                createjs.Touch.enable(stage);
            createjs.Ticker.framerate = 24;

            main_container = new createjs.Container();
            main_container.name = "main";
            main_container.mouseChildren = false;
            stage.addChild(main_container);

            ui_container = new createjs.Container();
            ui_container.name = "ui";
            stage.addChild(ui_container);

            overlay_container = new createjs.Container();
            overlay_container.name = "overlay";
            stage.addChild(overlay_container);


            var md = stage.on("stagemousedown", handleMouseDown);
            var mu = stage.on("stagemouseup", handleMouseUp);

            document.oncontextmenu = function () {
                return false;
            };
            canvas.addEventListener('wheel', (event) => {
                event.preventDefault();

                main_container.scale -= 0.1 * (event.deltaY / Math.abs(event.deltaY));
                if (main_container.scale < 0.3) main_container.scale = 0.3;
                drawGrid(main_container);
                stage.update();
                //console.log("scale: " + main_container.scale);
                save();
            });
            if (createjs.Touch.isSupported()) {
                canvas.addEventListener('touchstart', (event) => {
                    if (event.touches.length === 1) {
                        let touch = event.touches[0];
                        startTrackDrawing(main_container.globalToLocal(touch.clientX, touch.clientY));
                    }


                    /* console.log("touch:" + event.touches.length);
                    for (let index = 0; index < event.touches.length; index++) {
                        const item = event.touches[index];
                        console.log("x:" + item.clientX + ":" + item.clientY);
                    } */
                });

                canvas.addEventListener('touchmove', (event) => {
                    if (event.touches.length === 2) {
                        let touch = event.touches[0];

                        if (previousTouch) {
                            // be aware that these only store the movement of the first touch in the touches array
                            main_container.x += touch.clientX - previousTouch.clientX;
                            main_container.y += touch.clientY - previousTouch.clientY;

                            drawGrid(main_container);
                        };

                        previousTouch = touch;
                    }

                });
            }

            $("#btnPlay").click((e) => {
                mode = MODE_PLAY;
                checkModeButtons();
            })
            $("#btnDrawTracks").click((e) => {
                mode = MODE_EDIT;
                checkModeButtons();
            })
            $("#btnSignal").click(() => {

            })

            $("#btnGrid").click(() => { showGrid = !showGrid; drawGrid(main_container); stage.update(); })

            $("#btnClear").click(() => { tracks = []; main_container.removeAllChildren(); drawGrid(main_container); save(); stage.update(); })

            $("#btnCenter").click(() => { main_container.scale = 1; main_container.x = 0; main_container.y = 0; save(); drawGrid(main_container); stage.update(); })



            $("#btnImage").click((e) => {
                let sg = showGrid;
                showGrid = false;
                drawGrid(main_container);
                stage.update();
                let img = main_container.toDataURL("#00000000", "image/png");
                console.log(img.slice(0, 50));

                showGrid = sg;
                drawGrid(main_container);
                stage.update();
                //e.target.href = img;

                let a = $("<a>", { download: "gleisplan.png", href: img });
                a[0].click();
            })

            draw_SignalMenu()

            loadRecent();
            onResizeWindow();
            checkModeButtons();

            $(window).resize(() => onResizeWindow());
        }


        function draw_SignalMenu() {
            menu = new createjs.Container();
            menu.name = "signal_menu";
            ui_container.addChild(menu);

            var bg = new createjs.Shape();
            bg.graphics.beginFill("#eee").drawRoundRect(0, 0, 80, 300, 5);
            menu.addChild(bg);

            var btn = new createjs.Shape();
            btn.name = "Hauptsignal";
            menu.addChild(btn);
            btn.graphics.beginFill("#333").drawRoundRect(10, 20, 64, 64, 5);
            //btn.on("click", () => { alert("test") });




            stage.update();
        }

        function onResizeWindow() {
            $("#myCanvas").attr("height", $("#CanvasContainer").height() - 5);
            $("#myCanvas").attr("width", $("#CanvasContainer").width());
            drawGrid(main_container);
            stage.update();
        }

        function drawGrid() {
            let oldGrid = main_container.getChildByName("grid");
            if (oldGrid != null)
                main_container.removeChild(oldGrid);
            if (showGrid) {
                let grid = new createjs.Shape();
                grid.name = "grid";
                grid.mouseEnabled = false;
                grid.graphics.c().setStrokeStyle(1, "round").setStrokeDash([5, 5], 2 - Math.floor(main_container.y / (2 * main_container.scale)) * 2).beginStroke("#eee");
                let bounds = stage.canvas.getBoundingClientRect();

                let i = Math.floor(main_container.x / (grid_size * main_container.scale)) * -(grid_size);
                while (i < (bounds.width / main_container.scale) - (main_container.x / main_container.scale)) { //spalten                
                    grid.graphics.moveTo(i, 0 - main_container.y / main_container.scale).lineTo(i, (bounds.height / main_container.scale) - main_container.y / main_container.scale);
                    i += grid_size;
                }
                grid.graphics.setStrokeDash([5, 5], 2 - Math.floor(main_container.x / (2 * main_container.scale)) * 2).beginStroke("#eee");
                i = Math.floor(main_container.y / (grid_size * main_container.scale)) * -grid_size;
                while (i < (bounds.height / main_container.scale) - main_container.y / main_container.scale) { //zeilen
                    grid.graphics.moveTo(0 - main_container.x / main_container.scale, i).lineTo((bounds.width / main_container.scale) - main_container.x / main_container.scale, i);
                    i += grid_size;
                }
                main_container.addChildAt(grid, 0);
            }
        }


        function handleMouseDown(event) {
            if (!event.primary) { return; }
            mouseMoved = false;

            //console.log(main_container.mouseX + "/" + main_container.mouseY);

            let hittest = getHitTest();

            if (hittest != null) {
                console.log(hittest.name);
            }

            if (event.nativeEvent.which == 1 && mode === MODE_EDIT && (hittest != null && hittest.name == "Hauptsignal")) {
                stage.addEventListener("stagemousemove", handleMouseMove);
                startDragAndDropSignal();
                mouseAction = MOUSE_DND_SIGNAL;
            }

            if (event.nativeEvent.which == 1 && mode === MODE_EDIT && (hittest == null || hittest.name == "track")) {
                stage.addEventListener("stagemousemove", handleMouseMove);
                startTrackDrawing();
                mouseAction = MOUSE_DRAW;
            }

            if (event.nativeEvent.which == 3) {
                stage.addEventListener("stagemousemove", handleMouseMove);
                mouseAction = MOUSE_SCROLL;
            }
        }

        function getHitTest() {
            /* for (let i = 0; i < main_container.numChildren; i++) {
                let child = main_container.getChildAt(i);
                var pt = child.globalToLocal(stage.mouseX, stage.mouseY);
                if (stage.mouseInBounds && child.hitTest(pt.x, pt.y) && child.name != "grid")
                    return child;
            }
            return null; */
            return stage.getObjectUnderPoint(stage.mouseX, stage.mouseY);
        }

        function startDragAndDropSignal() {
            dnd_Signal = new createjs.Bitmap("signal.png");
            dnd_Signal.x = stage.mouseX;
            dnd_Signal.y = stage.mouseY;
            dnd_Signal.scale = 0.5;
            dnd_Signal.rotation = 90;

            overlay_container.addChild(dnd_Signal);

            /* var test = new createjs.Shape();
            test.graphics.beginFill("#e00").drawCircle(100,100,30);

            overlay_container.addChild(test); */

            stage.update();
        }

        function startTrackDrawing() {
            startpoint = main_container.globalToLocal(stage.mouseX, stage.mouseY);
            drawingCanvas = new createjs.Shape();
            main_container.addChild(drawingCanvas);
            drawingCanvas.graphics.c().setStrokeStyle(stroke).beginStroke(color).moveTo(startpoint.x, startpoint.y);
        }

        function handleMouseMove(event) {
            if (!event.primary) { return; }
            mouseMoved = true;
            if (mouseAction === MOUSE_DND_SIGNAL) {
                dnd_Signal.x = stage.mouseX;
                dnd_Signal.y = stage.mouseY;
            } else if (mouseAction === MOUSE_DRAW) {
                let p = main_container.globalToLocal(stage.mouseX, stage.mouseY);
                drawingCanvas.graphics.lineTo(p.x, p.y);
            }
            else if (mouseAction === MOUSE_SCROLL) {
                main_container.x += event.nativeEvent.movementX;
                main_container.y += event.nativeEvent.movementY;
                drawGrid(main_container);
            }

            stage.update();
        }

        function handleMouseUp(event) {
            if (!event.primary) { return; }
            stage.removeEventListener("stagemousemove", handleMouseMove);

            if (mouseAction === MOUSE_DND_SIGNAL) {
                overlay_container.removeAllChildren();
                addSignal2Canvas(signalTemplates.ks);
                stage.update();
            } else if (mouseAction === MOUSE_DRAW) {
                main_container.removeChild(drawingCanvas);
                //main_container.clear();

                let p1 = startpoint;
                let p2 = main_container.globalToLocal(stage.mouseX, stage.mouseY);

                if (Math.abs(p1.x - p2.x) >= grid_size || Math.abs(p1.y - p2.y) >= grid_size) {

                    let diagonal = (Math.abs(p1.x - p2.x) / Math.abs(p1.y - p2.y)) < 4;
                    if (diagonal) {
                        p2.x = startpoint.x + Math.abs(p2.y - startpoint.y) * ((startpoint.x > p2.x) ? -1 : 1);
                    }
                    else
                        p2.y = startpoint.y;

                    p1.y = Math.round(p1.y / grid_size) * grid_size;
                    p1.x = Math.round(p1.x / grid_size) * grid_size;

                    p2.y = Math.round(p2.y / grid_size) * grid_size;
                    p2.x = Math.round(p2.x / grid_size) * grid_size;

                    if (p1.x - p2.x != 0) {
                        createTrack(p1, p2);
                        save();
                    }
                }
                stage.update();
                connection = null;
            } else if (mode === MODE_EDIT && !mouseMoved) {
                let p1 = main_container.globalToLocal(main_container.mouseX, main_container.mouseY);
                let hittest = main_container.getObjectUnderPoint(main_container.mouseX, main_container.mouseY);

            }


            mouseAction = MOUSE_NONE;
        }

        function createTrack(p1, p2) {
            let track = new trackShape(p1, p2, main_container);
            track.drawTrack();
            tracks.push(track);
        }



        function addSignal2Canvas(s) {
            let signal = new signalShape(main_container.globalToLocal(stage.mouseX, stage.mouseY), s, main_container);
            signal.drawSignal();
            signals.push(signal);
            stage.update();
        }

        function replacer(key, value) {
            if (EXCLUDE_JSON.includes(key))
                return undefined
            else
                return value;
        }

        function getSaveString() {
            return JSON.stringify({
                tracks: tracks,
                signals: signals,
                version: 0.13,
                zoom: main_container.scale,
                scrollX: main_container.x,
                scrollY: main_container.y
            }, replacer);
        }

        function save() {
            //localStorage.setItem("last1", getSaveString());
        }

        function loadRecent() {
            let x = localStorage.getItem('last1');
            if (x != null) {
                loadFromJson(x);
                stage.update();
            }
        }

        function loadFromJson(json) {
            let loaded = JSON.parse(json);
            if (loaded.version >= 0.13) {
                main_container.x = loaded.scrollX;
                main_container.y = loaded.scrollY;
                main_container.scale = loaded.zoom;
                loaded.tracks.forEach(s => {
                    createTrack(s._startPnt, s._endPnt);
                });
            }
        }


    </script>
</head>

<body id="mybody">
    <div class="visually-hidden" style="font-family: DIN condenced;">dummy to load font face</div>
    <div id="container">
        <div id="toolbar">
            <button id="btnPlay" type="button" data-mode="1" class="btn btn-secondary btn-sm" title="Signale bedienen">
                <i class="bi bi-cursor-fill"></i>
            </button>
            <button id="btnDrawTracks" type="button" data-mode="2" class="btn btn-secondary btn-sm active"
                title="Gleise zeichnen">
                <i class="bi bi-pencil"></i>
            </button>
            <button id="btnGrid" type="button" class="btn btn-secondary btn-sm active" title="zeige Gitter">
                <i class="bi bi-grid-3x3"></i>
            </button>
            <button id="btnClear" type="button" class="btn btn-secondary btn-sm" title="alles entfernen">
                <i class="bi bi-trash"></i>
            </button>
            <button id="btnRemove" type="button" disabled="true" class="btn btn-secondary btn-sm"
                title="Element entfernen">
                <i class="bi bi-eraser"></i>
            </button>
            <button id="btnCenter" type="button" class="btn btn-secondary btn-sm" title="Ansicht zentrieren">
                <i class="bi bi-bullseye"></i>
            </button>
            <button id="btnImage" type="button" class="btn btn-secondary btn-sm" title="Ansicht als Bild herunterladen">
                <i class="bi bi-camera"></i>
            </button>
            <button id="btnSignal" type="button" class="btn btn-secondary btn-sm" data-bs-container="body"
                data-bs-placement="bottom">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                    class="bi bi-stoplights" viewBox="0 0 16 16">
                    <path
                        d="M8 5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm0 4a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm1.5 2.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z" />
                    <path
                        d="M4 2a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2h2c-.167.5-.8 1.6-2 2v2h2c-.167.5-.8 1.6-2 2v2h2c-.167.5-.8 1.6-2 2v1a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-1c-1.2-.4-1.833-1.5-2-2h2V8c-1.2-.4-1.833-1.5-2-2h2V4c-1.2-.4-1.833-1.5-2-2h2zm2-1a1 1 0 0 0-1 1v11a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6z" />
                </svg>
            </button>
        </div>
        <div id="CanvasContainer">
            <canvas id="myCanvas" width="10" height="10"></canvas>
        </div>
    </div>







</body>

</html>
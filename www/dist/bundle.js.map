{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO,IAAI;AACX,0CAA0C,MAAM;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,6CAA6C;;AAExD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,uBAAuB;AAC5C,cAAc,OAAO,uBAAuB;AAC5C,cAAc,OAAO,uBAAuB;AAC5C,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,IAAI;AACJ;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb,wBAAwB,qBAAqB;AAC7C;AACA,IAAI;AACJ;AACA,0BAA0B,mCAAmC;AAC7D,IAAI;AACJ;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA,mBAAmB,+FAA+F;AAClH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV,WAAW;AACX;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,oCAAoC,mCAAmC;AACvE;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAA0C;AACjF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA,UAAU;AACV;;AAEA,2BAA2B,0BAA0B;AACrD,6BAA6B,wBAAwB;AACrD,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,mBAAmB,qEAAqE;AACxF;AACA,IAAI;AACJ;AACA,0BAA0B,UAAU;AACpC,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,QAAQ;AACR,uBAAuB;AACvB;AACA,IAAI;AACJ;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ,oBAAoB,qBAAqB;;AAEzC,oBAAoB,wCAAwC;;AAE5D;AACA;AACA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC,IAAI;;AAEJ;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,IAAI;AACJ;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,8BAA8B;AACpD;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,gEAAgE;AAC9E;AACA;AACA;AACA;AACA;AACA,oCAAoC,mEAAmE;AACvG;AACA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;;AAEA;AACA;AACA;AACA,gFAAgF,4CAA4C;AAC5H;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,yBAAyB,0BAA0B;AACnD,IAAI;;AAEJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,IAAI;;AAEJ;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD,4BAA4B,6DAA6D;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,UAAU;AACV,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,2FAA2F;AAC3F;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,aAAa;AACb;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;;AAEA,kCAAkC,UAAU,SAAS,IAAI;AACzD;;;;;;;UCnlCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;ACNmC;;AAEnC,cAAc,4CAAK;;AAEnB,4D","sources":["webpack://gleisplaneditor/./www/code/tools.js","webpack://gleisplaneditor/webpack/bootstrap","webpack://gleisplaneditor/webpack/runtime/define property getters","webpack://gleisplaneditor/webpack/runtime/hasOwnProperty shorthand","webpack://gleisplaneditor/webpack/runtime/make namespace object","webpack://gleisplaneditor/./www/code/test-entry.js"],"sourcesContent":["\"use strict\";\n\nconst Ï€ = Math.PI;\n\nNumber.prototype.between = function (a, b) {\n   var min = Math.min.apply(Math, [a, b]),\n      max = Math.max.apply(Math, [a, b]);\n   return this >= min && this <= max;\n};\n\nNumber.prototype.outoff = function (a, b) {\n   var min = Math.min.apply(Math, [a, b]),\n      max = Math.max.apply(Math, [a, b]);\n   return this < min || this > max;\n};\n\nMath.minmax = function (min, value, max) {\n   return Math.max(min, Math.min(max, value));\n};\n\nNumber.prototype.is = function (a) {\n   return Array.from(arguments).includes(this);\n};\n\nNumber.prototype.round = function (places) {\n   const x = Math.pow(10, places);\n   return Math.round(this * x) / x;\n};\n\nNumber.prototype.closeToBy = function (y, z) {\n   const mod = this % y;\n   return Math.min(mod, y - mod) < z;\n};\n\nArray.prototype.remove = function (item) {\n   const index = this.indexOf(item);\n   if (index > -1) {\n      this.splice(index, 1);\n   }\n};\n\nArray.prototype.justNull = function () {\n   if (this.every((i) => i == null)) return null;\n   else return this;\n};\n\nArray.prototype.last = function () {\n   if (this.length > 0) {\n      return this[this.length - 1];\n   } else return null;\n};\n\nArray.prototype.first = function () {\n   if (this.length > 0) {\n      return this[0];\n   } else return null;\n};\n\n//removes all null items from the array\nArray.prototype.clean = function () {\n   return this.filter((n) => n);\n};\n\n//returns a random item from the array\nArray.prototype.random = function () {\n   if (this.length == 0) return;\n   return this[Math.randomInt(this.length - 1)];\n};\n\nArray.prototype.countNonUnique = function() {\n   const counts = {};\n   let nonUniqueCount = 0;\n   for (const item of this) {\n      if (counts[item] === 1) nonUniqueCount++; // Only increment on second occurrence\n      counts[item] = (counts[item] || 0) + 1;\n   }\n   return nonUniqueCount;\n}\n\n//will only add the element if the array does not already contain it.\nArray.prototype.pushUnique = function (newElement) {\n   if (this.indexOf(newElement) === -1) {\n      this.push(newElement);\n      return true;\n   }\n   return false;\n};\n\nArray.prototype.groupBy = function (propertyPath) {\n   // `data` is an array of objects, `key` is the key (or property accessor) to group by\n   // reduce runs this anonymous function on each element of `data` (the `item` parameter,\n   // returning the `storage` parameter at the end\n\n   return Object.values(\n      this.reduce(function (storage, item) {\n         let property = propertyPath.split(\".\").reduce((acc, key) => acc[key], item);\n         // get the first instance of the key by which we're grouping\n         let group = property;\n\n         // set `storage` for this instance of group to the outer scope (if not empty) or initialize it\n         storage[group] = storage[group] || [];\n\n         // add this item to its group within `storage`\n         storage[group].push(item);\n\n         // return the updated storage to the reduce function, which will then loop through the next\n         return storage;\n      }, {})\n   ).sort((a, b) => b.length - a.length); // {} is the initial value of the storage\n};\n\nfunction nll(o) {\n   return o == null;\n}\n\nfunction findFieldNameForObject(container, ref) {\n   for (let key of Object.keys(container)) {\n      if (container[key] === ref) {\n         return key;\n      }\n   }\n   return null;\n}\n\nfunction type(value) {\n   if (value === null) {\n      return \"null\";\n   }\n   const baseType = typeof value;\n   // Primitive types\n   if (![\"object\", \"function\"].includes(baseType)) {\n      return baseType;\n   }\n\n   // Symbol.toStringTag often specifies the \"display name\" of the\n   // object's class. It's used in Object.prototype.toString().\n   const tag = value[Symbol.toStringTag];\n   if (typeof tag === \"string\") {\n      return tag;\n   }\n\n   // If it's a function whose source code starts with the \"class\" keyword\n   if (baseType === \"function\" && Function.prototype.toString.call(value).startsWith(\"class\")) {\n      return \"class\";\n   }\n\n   // The name of the constructor; for example `Array`, `GeneratorFunction`,\n   // `Number`, `String`, `Boolean` or `MyCustomClass`\n   const className = value.constructor.name;\n   if (typeof className === \"string\" && className !== \"\") {\n      return className;\n   }\n\n   // At this point there's no robust way to get the type of value,\n   // so we use the base implementation.\n   return baseType;\n}\n\nfunction swap(current, value1, value2) {\n   return current === value1 ? value2 : value1;\n}\n\n//returns a copy where the given item is missing\nArray.prototype.without = function (item) {\n   return this.filter((i) => i != item);\n};\n\nMath.randomInt = function (max) {\n   return Math.floor(Math.random() * (max + 1));\n};\n\nfunction deepEqual(x, y) {\n   const ok = Object.keys,\n      tx = typeof x,\n      ty = typeof y;\n   return x && y && tx === \"object\" && tx === ty\n      ? ok(x).length === ok(y).length && ok(x).every((key) => deepEqual(x[key], y[key]))\n      : x === y;\n}\n\nfunction clone(obj) {\n   var copy;\n\n   // Handle the 3 simple types, and null or undefined\n   if (null == obj || \"object\" != typeof obj) return obj;\n\n   // Handle Date\n   if (obj instanceof Date) {\n      copy = new Date();\n      copy.setTime(obj.getTime());\n      return copy;\n   }\n\n   // Handle Array\n   if (obj instanceof Array) {\n      copy = [];\n      for (var i = 0, len = obj.length; i < len; i++) {\n         copy[i] = clone(obj[i]);\n      }\n      return copy;\n   }\n\n   // Handle Object\n   if (obj instanceof Object) {\n      copy = {};\n      for (var attr in obj) {\n         if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\n      }\n      return copy;\n   }\n\n   throw new Error(\"Unable to copy obj! Its type isn't supported.\");\n}\n\nfunction uuidv4() {\n   return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>\n      (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n   );\n}\n\nfunction isPointInsideBox(point, box, rotationAngle) {\n   const { topLeft, topRight, bottomRight, bottomLeft } = box;\n\n   // Translate the point to align with the box's axes based on the given rotation angle\n   const translatedPoint = {\n      x: (point.x - topLeft.x) * Math.cos(-rotationAngle) - (point.y - topLeft.y) * Math.sin(-rotationAngle),\n      y: (point.x - topLeft.x) * Math.sin(-rotationAngle) + (point.y - topLeft.y) * Math.cos(-rotationAngle),\n   };\n\n   // Check if the translated point is inside the aligned box\n   const isInsideX = translatedPoint.x > 0 && translatedPoint.x < Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\n   const isInsideY = translatedPoint.y > 0 && translatedPoint.y < Math.hypot(bottomLeft.x - topLeft.x, bottomLeft.y - topLeft.y);\n\n   return isInsideX && isInsideY;\n}\nconst TOOLS = {\n   /**\n    * Finds the nearest point on a line segment to a given point\n    * @param {Point|{x: number, y: number}} start - Start point of the line segment\n    * @param {Point|{x: number, y: number}} end - End point of the line segment\n    * @param {Point|{x: number, y: number}} point - Point to find nearest position to\n    * @returns {Point} The nearest point on the line segment\n    */\n   nearestPointOnLine(start, end, point) {\n      const lineDeltaX = end.x - start.x;\n      const lineDeltaY = end.y - start.y;\n      \n      // Handle degenerate case where start and end are the same point\n      if (lineDeltaX === 0 && lineDeltaY === 0) {\n         return new Point(start.x, start.y);\n      }\n\n      // Find the closest point on the line to the point\n      // We can avoid the sqrt in lineLength by using squared values\n      const lengthSquared = lineDeltaX * lineDeltaX + lineDeltaY * lineDeltaY;\n      let u = ((point.x - start.x) * lineDeltaX + (point.y - start.y) * lineDeltaY) / lengthSquared;\n\n      // Clamp u to the range [0, 1]\n      u = Math.max(0, Math.min(1, u));\n\n      // Calculate the closest point on the line segment\n      return new Point(\n         start.x + u * lineDeltaX,\n         start.y + u * lineDeltaY\n      );\n   },\n};\n\nfunction deg2rad(deg) {\n   return deg * (Math.PI / 180);\n}\n\nconst ui = {\n   create_toggleButton: function (text) {\n      return $(\"<button>\", {\n         type: \"button\",\n         id: \"btn_\" + text.replace(\" \", \"_\"),\n         class: \"btn btn-primary btn-sm\",\n      }).html(text);\n   },\n   create_Input: function (text, stellung, signal) {\n      const id = uuidv4();\n      return $(\"<div>\", { class: \"form-floating\" }).append([\n         $(\"<input>\", {\n            type: \"number\",\n            id: id,\n            class: \"form-control  form-control-sm\",\n            value: signal.get(stellung),\n         })\n            .attr(\"data_signal\", stellung)\n            .on(\"input\", (e) => {\n               signal.set_stellung(stellung, e.target.value);\n            }),\n         $(\"<label>\", { for: id, text: text }),\n      ]);\n   },\n   create_buttonGroup: function (items) {\n      return $(\"<div>\", { class: \"btn-group\", role: \"group\" }).append(items);\n   },\n   showPopup: function (r, title, content, parent) {\n      let $dummy = $(\"#dummy\");\n      let rect = parent[0].getBoundingClientRect();\n      if ($dummy.length == 0) {\n         $dummy = $(\"<div>\", { id: \"dummy\" });\n         $(document.body).append($dummy);\n      }\n      $dummy.css({ position: \"absolute\", left: r.x + rect.x, top: r.y + rect.y, width: r.width, height: r.height });\n      let popup = bootstrap.Popover.getOrCreateInstance($dummy);\n      if (popup) {\n         $(document).off(\"mousedown\");\n         popup.dispose();\n      }\n\n      popup = new bootstrap.Popover($dummy, {\n         html: true,\n         trigger: \"manual\",\n         title: title,\n         placement: \"bottom\",\n         sanitize: false,\n         content: content,\n      });\n      $dummy[0].addEventListener(\n         \"hidden.bs.popover\",\n         (e) => {\n            $(document).off(\"mousedown\");\n            let p = bootstrap.Popover.getOrCreateInstance(e.target);\n            if (p) p.dispose();\n            $(e.target).remove();\n         },\n         { once: true }\n      );\n      $dummy[0].addEventListener(\n         \"shown.bs.popover\",\n         (e) => {\n            $(document).on(\"mousedown\", (event) => {\n               let $target = $(event.target);\n\n               if ($target.closest(\"div.popover\").length == 0) {\n                  let p = bootstrap.Popover.getOrCreateInstance(e.target);\n                  if (p) p.hide();\n               }\n            });\n         },\n         { once: true }\n      );\n      popup.show();\n      return popup;\n   },\n\n   /* showContextMenu: function (point, parent, items, signal) {\n      const createDropDownItems = function (items, dd) {\n         return items.map((item) => {\n            if (item.text) {\n               const li = $(\"<li>\");\n               const a = $(\"<a>\", { class: \"dropdown-item\", href: \"#\" }).text(item.text);\n               if (item.childs) {\n                  li.addClass(\"dropend\");\n                  a.addClass(\"dropdown-toggle submenu\");\n                  a.attr(\"type\", \"button\");\n                  a.attr(\"data-bs-toggle\", \"dropdown\");\n                  a.append($(\"<ul>\", { class: \"dropdown-menu dropdown-menu-end\" }).append(createDropDownItems(item.childs, dd)));\n               } else {\n                  a.attr(\"data-signal-option\", item.option);\n                  a.toggleClass(\"active\", signal.matchFeature(item.option));\n                  a.click(() => {\n                     signal.setFeature(item.option, !a.hasClass(\"active\"));\n                     dd.hide();\n                     renderer.reDrawEverything();\n                     stage.update();\n                     STORAGE.save();\n                  });\n               }\n               li.append(a);\n               return li;\n            } else {\n               const id = uuidv4();\n               return ui.div(\"dropdown-item\").append(\n                  $(\"<div>\", { class: \"form-floating\" }).append([\n                     $(\"<input>\", {\n                        type: \"text\",\n                        id: id,\n                        class: \"form-control  form-control-sm\",\n                        value: signal.getFeature(\"bez\"),\n                     }).on(\"input\", (e) => {\n                        signal.setFeature(\"bez\", e.target.value);\n                        renderer.reDrawEverything();\n                        STORAGE.save();\n                     }),\n                     $(\"<label>\", { for: id, text: item.input }),\n                  ])\n               );\n            }\n         });\n      }; \n\n      const a = $(\"<a>\", { class: \"visually-hidden\" }).attr(\"data-bs-toggle\", \"dropdown\").attr(\"data-bs-auto-close\", \"false\");\n      const ul = $(\"<ul>\", { class: \"dropdown-menu\" });\n      const div = $(\"<div>\", { id: \"generated_menu\", class: \"dropdown\" }).append([a, ul]);\n      $(document.body).append(div);\n      const dropdownList = bootstrap.Dropdown.getOrCreateInstance(a);\n      ul.append(createDropDownItems(items, dropdownList));\n      setTimeout(() => (dropdownList._config.autoClose = \"outside\"), 2);\n      dropdownList._parent.addEventListener(\"hidden.bs.dropdown\", (e) => {\n         const t = $(e.target);\n         if (!t.hasClass(\"submenu\")) $(e.target).parent().remove();\n      });\n      let $dummy = $(dropdownList._parent);\n      let rect = parent[0].getBoundingClientRect();\n\n      $dummy.css({ position: \"absolute\", left: point.x + rect.x, top: point.y + rect.y });\n      dropdownList.show();\n   },*/\n   div: function (c, i) {\n      return $(\"<div>\", { class: c }).append(i);\n   },\n\n   showModalDialog: function (content, ok_function) {\n      // Create modal div\n      let modal_div = $(\"<div/>\", {\n         id: \"myModal\",\n         class: \"modal fade\",\n         role: \"dialog\",\n      }).append(\n         ui.div(\"modal-dialog  modal-xl modal-dialog-centered\").append(\n            ui.div(\"modal-content\").append([\n               ui.div(\"modal-header\").append([\n                  $(\"<h4/>\", {\n                     class: \"modal-title\",\n                     text: \"Als Bild speichern\",\n                  }),\n                  $(\"<button/>\", {\n                     type: \"button\",\n                     class: \"btn-close\",\n                     \"data-bs-dismiss\": \"modal\",\n                  }),\n               ]),\n               ui.div(\"modal-body\").append(content),\n               ui.div(\"modal-footer\").append(\n                  $(\"<button/>\", {\n                     type: \"button\",\n                     class: \"btn btn-default\",\n                     \"data-dismiss\": \"modal\",\n                     text: \"Herunterladen\",\n                     click: ok_function,\n                  })\n               ),\n            ])\n         )\n      );\n      modal_div.appendTo(\"body\");\n\n      let modal = new bootstrap.Modal(modal_div[0]);\n      modal.show();\n      return modal;\n   },\n};\n\nconst geometry = {\n   PRECISION: 3,\n   distance: function (p1, p2) {\n      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)).round(this.PRECISION);\n   },\n   length: function (v) {\n      return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2)).round(this.PRECISION);\n   },\n   slope: function (p1, p2) {\n      return (p1.y - p2.y) / (p1.x - p2.x);\n   },\n\n   //checks if point c is between a and b\n   within: function (pA, pB, pC, exclude) {\n      if (exclude && (deepEqual(pA, pC) || deepEqual(pB, pC))) return false;\n      if (pC.x.outoff(pA.x, pB.x) || pC.y.outoff(pA.y, pB.y)) return false;\n      return (pB.x - pA.x) * (pC.y - pA.y) == (pC.x - pA.x) * (pB.y - pA.y);\n   },\n   getIntersectionPoint: function (line1, line2) {\n      const denominator =\n         (line2.end.y - line2.start.y) * (line1.end.x - line1.start.x) -\n         (line2.end.x - line2.start.x) * (line1.end.y - line1.start.y);\n\n      // If the denominator is 0, the lines are parallel and don't intersect\n      if (denominator === 0) {\n         return null;\n      }\n\n      const ua =\n         ((line2.end.x - line2.start.x) * (line1.start.y - line2.start.y) -\n            (line2.end.y - line2.start.y) * (line1.start.x - line2.start.x)) /\n         denominator;\n      const ub =\n         ((line1.end.x - line1.start.x) * (line1.start.y - line2.start.y) -\n            (line1.end.y - line1.start.y) * (line1.start.x - line2.start.x)) /\n         denominator;\n\n      // If ua or ub is less than 0 or greater than 1, the intersection point is outside of the segments\n      if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n         return null;\n      }\n\n      // Calculate the intersection point\n      const intersectionX = line1.start.x + ua * (line1.end.x - line1.start.x);\n      const intersectionY = line1.start.y + ua * (line1.end.y - line1.start.y);\n\n      return new Point(intersectionX, intersectionY);\n   },\n\n   //returns the intersection point of 2 lines, regardless of their length\n   getIntersectionPointX: function (p1, d1, p2, d2) {\n      // Solve for t and s using the equations:\n      const denominator = d1.x * d2.y - d1.y * d2.x;\n      if (denominator === 0) return null; // Vectors are parallel or collinear\n      // Compute parameters t and s\n      const t = ((p2.x - p1.x) * d2.y - (p2.y - p1.y) * d2.x) / denominator;\n      // Compute the intersection point using either vector\n      return new Point(p1.x + t * d1.x, p1.y + t * d1.y);\n   },\n\n   /**\n    * Checks if a target point lies on the line segment defined by two points.\n    * @param {Object} point1 - The first point of the line segment.\n    * @param {number} point1.x - The x-coordinate of the first point.\n    * @param {number} point1.y - The y-coordinate of the first point.\n    * @param {Object} point2 - The second point of the line segment.\n    * @param {number} point2.x - The x-coordinate of the second point.\n    * @param {number} point2.y - The y-coordinate of the second point.\n    * @param {Object} targetPoint - The point to check.\n    * @param {number} targetPoint.x - The x-coordinate of the target point.\n    * @param {number} targetPoint.y - The y-coordinate of the target point.\n    * @returns {boolean} True if the target point lies on the line segment, false otherwise.\n    */\n   pointOnLine: function (point1, point2, targetPoint) {\n      // Extract coordinates from the objects\n      let x1 = point1.x,\n         y1 = point1.y;\n      let x2 = point2.x,\n         y2 = point2.y;\n      let px = targetPoint.x,\n         py = targetPoint.y;\n\n      //if(x1==px && y1==py || x2==px && y2 == py) return false;\n\n      // Calculate parameters for the parametric equations\n      let tX = px == x1 && x1 == x2 ? 0 : (px - x1) / (x2 - x1);\n      let tY = py == y1 && y1 == y2 ? 0 : (py - y1) / (y2 - y1);\n\n      // Check if the point is on the line (within the segment boundaries)\n      if (tX >= 0 && tX <= 1 && tY >= 0 && tY <= 1) {\n         return true; // Point lies on the line segment\n      } else {\n         return false; // Point is outside the line segment\n      }\n   },\n   areSegmentsOverlapping2D: function (p1, p2, p3, p4) {\n\n      if (p1.x === p3.x && p1.y === p3.y && p2.x === p4.x && p2.y === p4.y) return true;\n\n      if ((p2.x === p3.x && p2.y === p3.y) || (p1.x === p4.x && p1.y === p4.y)) return false;\n\n      // Check if the segments are parallel\n      const slopeCheck = (p2.y - p1.y) * (p4.x - p3.x) === (p4.y - p3.y) * (p2.x - p1.x);\n\n      // Check if they lie on the same line\n      const colinearCheck = (p3.y - p1.y) * (p2.x - p1.x) === (p3.x - p1.x) * (p2.y - p1.y);\n\n      if (!slopeCheck || !colinearCheck) {\n         return false; // Not parallel or not colinear\n      }\n\n      // Check for overlap in projections (dominant axis)\n      const overlapX = Math.max(p1.x, p2.x) >= Math.min(p3.x, p4.x) && Math.max(p3.x, p4.x) >= Math.min(p1.x, p2.x);\n      const overlapY = Math.max(p1.y, p2.y) >= Math.min(p3.y, p4.y) && Math.max(p3.y, p4.y) >= Math.min(p1.y, p2.y);\n\n      return overlapX && overlapY;\n   },\n   //returns true if 2 line, described by 4 points intersect, each other\n   doLineSegmentsIntersect: function (p1, q1, p2, q2) {\n      const orientation = (p, q, r) => {\n         const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n         return val === 0 ? 0 : val > 0 ? 1 : 2;\n      };\n\n      const onSegment = (p, q, r) => {\n         return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n      };\n\n      const o1 = orientation(p1, q1, p2);\n      const o2 = orientation(p1, q1, q2);\n      const o3 = orientation(p2, q2, p1);\n      const o4 = orientation(p2, q2, q1);\n\n      if (o1 !== o2 && o3 !== o4) {\n         return true; // Segments intersect\n      }\n\n      if (o1 === 0 && onSegment(p1, p2, q1)) return true;\n      if (o2 === 0 && onSegment(p1, q2, q1)) return true;\n      if (o3 === 0 && onSegment(p2, p1, q2)) return true;\n      if (o4 === 0 && onSegment(p2, q1, q2)) return true;\n\n      return false; // No intersection\n   },\n   pointOnArc: function (radius, rad, centerpoint) {\n      const v = {\n         x: radius * Math.cos(rad) + centerpoint?.x,\n         y: radius * Math.sin(rad) + centerpoint?.y,\n      };\n\n      return v;\n   },\n\n   //returns the distance between a point and a line\n   pointToSegmentDistance: function(point, start, end) {\n      const dx = end.x - start.x;\n      const dy = end.y - start.y;\n      \n      // Handle degenerate case where start and end are the same point\n      if (dx === 0 && dy === 0) {\n          return Math.hypot(point.x - start.x, point.y - start.y);\n      }\n      \n      // Compute the projection of the point onto the line defined by start and end\n      const t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / (dx * dx + dy * dy);\n      \n      // Clamp t to the range [0,1] to restrict to the segment\n      const tClamped = Math.max(0, Math.min(1, t));\n      \n      // Find the closest point on the segment\n      const closestX = start.x + tClamped * dx;\n      const closestY = start.y + tClamped * dy;\n      \n      // Return the Euclidean distance\n      return Math.hypot(point.x - closestX, point.y - closestY);\n  },\n\n   //calculates a point which is perpendicular to the given vector\n   perpendicular: function (p, deg, distance) {\n      return {\n         y: p.y + Math.sin(deg2rad(deg + 90)) * distance,\n         x: p.x + Math.cos(deg2rad(deg + 90)) * distance,\n      };\n   },\n\n   //calculates a point which is perpendicular to the given vector\n   perpendicularX: function (v) {\n      return new V2({\n         y: v.x,\n         x: -v.y,\n      });\n   },\n\n   parallel: function (deg, distance) {\n      return {\n         y: Math.sin(deg2rad(deg)) * -distance,\n         x: Math.cos(deg2rad(deg)) * distance,\n      };\n   },\n\n   //returns the unit vector of the given vector\n   unit: function (v, l) {\n      const length = l ? l : this.length(v);\n      return this.multiply(v, 1 / length);\n   },\n\n   multiply: function (v, s) {\n      return {\n         x: (v.x * s).round(this.PRECISION),\n         y: (v.y * s).round(this.PRECISION),\n      };\n   },\n\n   add: function (v1, v2) {\n      return new Point(v1.x + v2.x, v1.y + v2.y);\n   },\n\n   sub: function (v1, v2) {\n      return new Point(v1.x - v2.x, v1.y - v2.y);\n   },\n\n   flipY: (v) => ({ x: v.x, y: v.y * -1 }),\n\n   round: (v) => ({ x: Math.round(v.x), y: Math.round(v.y) }),\n\n   calculateAngle: function (reference, point1, point2) {\n      // Calculate vectors\n      const v1 = { x: point1.x - reference.x, y: point1.y - reference.y };\n      const v2 = { x: point2.x - reference.x, y: point2.y - reference.y };\n\n      // Dot product\n      const dotProduct = v1.x * v2.x + v1.y * v2.y;\n\n      // Magnitudes\n      const magnitudeV1 = Math.sqrt(v1.x ** 2 + v1.y ** 2);\n      const magnitudeV2 = Math.sqrt(v2.x ** 2 + v2.y ** 2);\n\n      // Cosine of the angle\n      const cosTheta = dotProduct / (magnitudeV1 * magnitudeV2);\n\n      // Angle in radians\n      const theta = Math.acos(cosTheta);\n\n      // Convert to degrees (optional)\n      return theta * (180 / Math.PI); // Return the angle in degrees\n   },\n\n   /**\n    * Returns the midpoint between two points\n    * @param {Object} p1 - First point\n    * @param {number} p1.x - X coordinate of first point\n    * @param {number} p1.y - Y coordinate of first point\n    * @param {Object} p2 - Second point\n    * @param {number} p2.x - X coordinate of second point\n    * @param {number} p2.y - Y coordinate of second point\n    * @returns {Point} The midpoint between p1 and p2\n    */\n   midpoint: function(p1, p2) {\n      return new Point(\n         ((p1.x + p2.x) / 2).round(this.PRECISION),\n         ((p1.y + p2.y) / 2).round(this.PRECISION)\n      );\n   },\n\n   /**\n    * Returns the angle bisector of two normalized vectors\n    * @param {Object} v1 - First normalized vector\n    * @param {number} v1.x - X component of first vector\n    * @param {number} v1.y - Y component of first vector\n    * @param {Object} v2 - Second normalized vector\n    * @param {number} v2.x - X component of second vector\n    * @param {number} v2.y - Y component of second vector\n    * @returns {Point} The angle bisector vector (normalized)\n    */\n   angleBisector: function(v1, v2) {\n      // Add the two vectors to get the bisector\n      const bisector = this.add(v1, v2);    \n      \n      \n      // Normalize the bisector using the existing normalize function\n      return this.unit(bisector);\n   },\n\n   /**\n    * Returns a point along the angle bisector of two unit vectors at a given distance\n    * @param {Object} v1 - First normalized vector\n    * @param {number} v1.x - X component of first vector\n    * @param {number} v1.y - Y component of first vector\n    * @param {Object} v2 - Second normalized vector\n    * @param {number} v2.x - X component of second vector\n    * @param {number} v2.y - Y component of second vector\n    * @param {number} distance - Distance to move along the bisector\n    * @returns {Point} The point at the specified distance along the angle bisector\n    */\n   pointAlongBisector: function(v1, v2, distance) {\n      // Get the angle bisector vector\n      const bisector = this.angleBisector(v1, v2);\n      \n      // Scale the bisector by the desired distance\n      const scaledBisector = this.multiply(bisector, distance);\n      \n      return scaledBisector;\n   },\n\n   /**\n    * Inverts a given vector by negating both x and y components\n    * @param {Object} v - Vector to invert\n    * @param {number} v.x - X component of vector\n    * @param {number} v.y - Y component of vector\n    * @returns {Point} The inverted vector\n    */\n   invert: function(v) {\n      return new Point(-v.x, -v.y);\n   },\n};\n\n\n\nfunction rotatePointAroundPivot(angle, pivot, point) {\n   var cos = Math.cos(angle);\n   var sin = Math.sin(angle);\n   var dx = point.x - pivot.x;\n   var dy = point.y - pivot.y;\n   var x = dx * cos - dy * sin + pivot.x;\n   var y = dy * cos + dx * sin + pivot.y;\n   return { x: x, y: y };\n}\n\nclass V2 {\n   static fromV2(v) {\n      return new V2(v);\n   }\n\n   #_length = null;\n\n   get length() {\n      if (this.#_length == null) this.#_length = geometry.length(this);\n      return this.#_length;\n   }\n\n   get x() {\n      return this._p.x;\n   }\n\n   get y() {\n      return this._p.y;\n   }\n\n   constructor(p) {\n      this._p = p;\n   }\n\n   add(v) {\n      return new V2(geometry.add(this, v));\n   }\n\n   sub(v) {\n      return new V2(geometry.sub(this, v));\n   }\n\n   multiply(s) {\n      return new V2(geometry.multiply(this, s));\n   }\n\n   unit() {\n      return new V2(geometry.unit(this));\n   }\n   invert() {\n      return new V2({ x: -this._p.x, y: -this._p.y });\n   }\n}\n\nexport class Point {\n   static fromPoint(p) {\n      return new Point(p.x, p.y);\n   }\n\n   constructor(x, y) {\n      this.x = x;\n      this.y = y;\n   }\n\n   add(v) {\n      return new Point(this.x + v.x, this.y + v.y);\n   }\n\n   sub(v) {\n      return new Point(this.x - v.x, this.y - v.y);\n   }\n\n   equals(p) {\n      return p.x == this.x && p.y == this.y;\n   }\n}\n\n// Function to create a toast element\nconst createToast = (title, txt) => {\n   return ui\n      .div(\"toast\")\n      .attr({ role: \"alert\", \"aria-live\": \"assertive\", \"aria-atomic\": \"true\" })\n      .append([\n         $(\"<div>\")\n            .addClass(\"toast-header\")\n            .append([\n               $(\"<strong>\").addClass(\"me-auto\").text(title),\n               $(\"<button>\").attr({ type: \"button\", \"data-bs-dismiss\": \"toast\", \"aria-label\": \"Close\" }).addClass(\"btn-close\"),\n            ]),\n         $(\"<div>\")\n            .addClass(\"toast-body\")\n            .append([$(\"<p>\", { text: txt })]),\n      ]);\n};\n\nconst getToastContainer = () => {\n   let container = $(\"#toast-container\");\n   if (container.length === 0) {\n      container = ui.div(\"toast-container\").attr(\"id\", \"toast-container\").css({ position: \"fixed\", bottom: \"0\", right: \"0\" });\n      $(\"body\").append(container);\n   }\n   return container;\n};\n\n// Function to show the toast\nconst showErrorToast = (error) => {\n   console.error(error);\n   const toast = createToast(\"Ups, Da gabs einen Fehler\", error.message);\n   getToastContainer().prepend(ui.div(\"p-3\").append(toast));\n   $(toast).toast({ autohide: true, delay: 10000 }).toast(\"show\");\n   $(toast).on(\"hidden.bs.toast\", function () {\n      $(this).parent().remove();\n   });\n};\n\nconst showInfoToast = (txt) => {\n   console.info(txt);\n   const toast = createToast(\"Information:\", txt);\n   getToastContainer().prepend(ui.div(\"p-3\").append(toast));\n   $(toast).toast({ autohide: true, delay: 10000 }).toast(\"show\");\n   $(toast).on(\"hidden.bs.toast\", function () {\n      $(this).parent().remove();\n   });\n};\n\nconst BS = {\n   createListGroupItem(items) {\n      return $(\"<li>\", { class: \"list-group-item\" }).append(items);\n   },\n\n   create_buttonToolbar(items) {\n      return ui.div(\"btn-toolbar\", items).attr(\"role\", \"toolbar\");\n   },\n   create_buttonGroup(items) {\n      return ui.div(\"btn-group\", items);\n   },\n   create_DropDownItem(text, value) {\n      return $(\"<a>\", {\n         class: \"dropdown-item\",\n         text: text,\n         href: \"#\",\n         value: value ?? text,\n      });\n   },\n\n   createAccordionItem(title, parent, items, open = false) {\n      let id = uuidv4();\n      return ui.div(\"accordion-item\", [\n         $(\"<h2>\", { class: \"accordion-header\" }).append(\n            $(\"<button>\", { class: \"accordion-button  user-select-none\", type: \"button\" })\n               .attr(\"data-bs-toggle\", \"collapse\")\n               .attr(\"data-bs-target\", \"#\" + id)\n               .text(title)\n               .toggleClass(\"collapsed\", !open)\n         ),\n         ui\n            .div(\"accordion-collapse collapse\", ui.div(\"accordion-body\", items))\n            .attr(\"id\", id)\n            .attr(\"data-bs-parent\", parent)\n            .toggleClass(\"show\", open),\n      ]);\n   },\n\n   create_DropDown(items, text, onChange) {\n      return ui\n         .div(\"dropdown d-grid\", [\n            $(\"<button>\", {\n               class: \"btn btn-primary dropdown-toggle btn-sm\",\n               type: \"button\",\n               text: text,\n               id: \"btn_\" + text.replace(\" \", \"_\"),\n            }).attr(\"data-bs-toggle\", \"dropdown\"),\n            ui.div(\n               \"dropdown-menu\",\n               items.map((item) => BS.create_DropDownItem(...item.split(\"|\")))\n            ),\n         ])\n         .on(\"hide.bs.dropdown\", (e) => {\n            if (e.clickEvent?.target && e.clickEvent?.target.nodeName == \"A\") {\n               const value = $(e.clickEvent.target).attr(\"value\");\n               $(e.currentTarget).attr(\"value\", value);\n               if (onChange) onChange(value);\n            }\n         })\n         .on(\"show.bs.dropdown\", (e) => {\n            const targetValue = $(e.currentTarget).attr(\"value\");\n            if (!targetValue) return;\n            $(\".dropdown-item\", e.currentTarget)\n               .removeClass(\"active\")\n               .each(function () {\n                  if ($(this).attr(\"value\") === targetValue) {\n                     $(this).addClass(\"active\");\n                  }\n               });\n         });\n   },\n\n   createSwitchStructure(mainLabel, subLabels, onchange) {\n      let [text, value, enabled] = mainLabel;\n      if (!enabled && subLabels.length == 0) return null;\n      let $mainDiv;\n      $mainDiv = ui.div(\"\", [\n         enabled == null || enabled\n            ? ui.div(\"form-check form-switch\", [\n                 $(\"<input/>\", {\n                    class: \"form-check-input\",\n                    type: \"checkbox\",\n                    role: \"switch\",\n                    id: \"switch_\" + text,\n                 })\n                    .on(\"change\", function () {\n                       const isChecked = $(this).is(\":checked\");\n                       /* $(\"input\", $mainDiv.children()[1]).prop(\"disabled\", !isChecked); */\n                       if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                    })\n                    .attr(\"value\", value ?? text)\n                    .attr(\"data-master_switch\", \"\"),\n\n                 $(\"<label/>\", {\n                    class: \"form-check-label\",\n                    for: \"switch_\" + text,\n                    text: text,\n                 }),\n              ])\n            : $(\"<label/>\", {\n                 text: text,\n              }),\n\n         ui.div(\n            \"ps-3\",\n            subLabels\n               .filter((x) => x[2] == null || x[2] == true)\n               .map(function (label) {\n                  [text, value, enabled] = label;\n                  return ui.div(\"form-check form-switch\", [\n                     $(\"<input/>\", {\n                        class: \"form-check-input\",\n                        type: \"checkbox\",\n                        role: \"switch\",\n                        id: \"switch_\" + text,\n                        checked: true, // Default to checked as per your example\n                     })\n                        .on(\"change\", function () {\n                           const isChecked = $(this).is(\":checked\");\n                           if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                        })\n                        .attr(\"value\", value ?? text),\n                     $(\"<label/>\", {\n                        class: \"form-check-label\",\n                        for: \"switch_\" + text,\n                        text: text,\n                     }),\n                  ]);\n               })\n         ),\n      ]);\n      return $mainDiv;\n   },\n   createOptionGroup(header, options, inputType = \"radio\", onchange) {\n      return ui.div(\"\", [\n         $(\"<label>\").text(header),\n         ui.div(\n            \"ps-3\",\n            options.map(function (option) {\n               let [text, value, enabled] = option;\n               let id = \"input_\" + text;\n               // Create the div for each form-check-inline\n               return ui.div(\"form-check form-check-inline\", [\n                  $(\"<input>\")\n                     .addClass(\"form-check-input\")\n                     .attr(\"id\", id)\n                     .attr(\"name\", \"OptionGroup_\" + header)\n                     .attr(\"type\", inputType)\n                     .attr(\"value\", value ?? text)\n                     .attr(\"disabled\", enabled != null && !enabled)\n                     .on(\"change\", function () {\n                        const isChecked = $(this).is(\":checked\");\n                        if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                     }),\n                  $(\"<label>\").addClass(\"form-check-label\").attr(\"for\", id).text(text),\n               ]);\n            })\n         ),\n      ]);\n   },\n\n   lightBulb() {\n      return $(\n         \"<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-lightbulb' viewBox='0 0 16 16'>\" +\n            \"<path d='M2 6a6 6 0 1 1 10.174 4.31c-.203.196-.359.4-.453.619l-.762 1.769A.5.5 0 0 1 10.5 13a.5.5 0 0 1 0 1 .5.5 0 0 1 0 1l-.224.447a1 1 0 0 1-.894.553H6.618a1 1 0 0 1-.894-.553L5.5 15a.5.5 0 0 1 0-1 .5.5 0 0 1 0-1 .5.5 0 0 1-.46-.302l-.761-1.77a1.964 1.964 0 0 0-.453-.618A5.984 5.984 0 0 1 2 6zm6-5a5 5 0 0 0-3.479 8.592c.263.254.514.564.676.941L5.83 12h4.342l.632-1.467c.162-.377.413-.687.676-.941A5 5 0 0 0 8 1z'/> </svg>\"\n      );\n   },\n\n   createAndAppendZs3(listGroup, signal, label) {\n      listGroup.append(\n         this.create_ListGroupItem([this.create_label(label), this.createButtonContainer(this.create_Zs3DropDown(signal))])\n      );\n   },\n};\n\ncreatejs.Graphics.prototype.drawArrow = function (length, size) {\n   this.mt(0, 0)\n      .lt(length, 0)\n      .mt(length - size, -size / 2)\n      .lt(length, 0)\n      .lt(length - size, size / 2);\n};\n\ncreatejs.Graphics.prototype.drawTriangle = function(color, p1, p2, p3) {\n   this.beginFill(color)\n      .mt(p1.x, p1.y)\n      .lt(p2.x, p2.y)\n      .lt(p3.x, p3.y)\n      .lt(p1.x, p1.y);\n};\n\n\ncreatejs.Container.prototype.countContainers = function () {\n   return this.children.filter((c) => c instanceof createjs.Container).reduce((count, c) => count + c.countContainers(), 0) + 1;\n};\n\nfunction testPerformance(f, txt) {\n   const startTime = performance.now();\n\n   for (let i = 0; i < 1000; i++) {\n      f();\n   }\n\n   let endTime = performance.now();\n   let timeDiff = Math.round((endTime - startTime) / 10);\n\n   console.log(`Execution time: ${timeDiff} ms for ${txt}`);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Point } from './tools.js';\n\nconst p = new Point(10, 20);\n\nconsole.log('Webpack test successful! Imported Point:', p); "],"names":[],"sourceRoot":""}
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./www/code/generic_object.js":
/*!************************************!*\
  !*** ./www/code/generic_object.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GenericObject: () => (/* binding */ GenericObject)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n\n\n// ES6 Module imports\n\n\n\nclass GenericObject {\n   static OBJECT_TYPE = {\n      none: 0,\n      text: 1,\n      plattform: 2,\n   };\n\n   static all_objects = [];\n\n   static FromObject(o) {\n      return new GenericObject().pos(o.pos).size(o.size.width,o.size.height).type(o.type).content(o.content);\n   }\n\n   static removeObject(o) {\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.remove(this.all_objects, o);\n      window.renderer.renderAllGenericObjects();\n      window.stage.update();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.saveUndoHistory();\n   }\n\n   static initEditMenu(o) {\n      let header_text;\n      switch (o.type()) {\n         case GenericObject.OBJECT_TYPE.text:\n            header_text = \"Text\";\n            break;\n            case GenericObject.OBJECT_TYPE.plattform:\n               header_text = \"Bahnsteig\";\n               break;\n         default:\n            break;\n      }\n      $(\"#editObjectMenu h5\").text(header_text);\n\n      \n      $(\"#inputContent\")\n         .off()\n         .val(o.content())\n         .on(\"input\", function (e) {\n            o.content($(this).val());\n            window.renderer.renderAllGenericObjects();\n            window.renderer.updateSelection();\n            window.stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n         });\n\n      $(\"#btnRemoveObject\")\n         .off()\n         .click(() => {\n            this.removeObject(o);\n            window.selectObject()\n         });\n\n      setTimeout(() => {\n         $(\"#inputContent\").focus();\n      }, 50);\n   }\n\n   #_pos = { x: 0, y: 0 };\n   #_size = { width: 0, height: 0 };\n   #_type = GenericObject.OBJECT_TYPE.none;\n   #_content = \"\";\n\n   constructor(t = GenericObject.OBJECT_TYPE.none) {\n      this.#_type = t;\n   }\n\n   pos(p) {\n      if (p === undefined) return this.#_pos;\n      this.#_pos = p;\n      return this;\n   }\n\n   size(w,h) {\n      if (w === undefined) return this.#_size;\n      this.#_size.width = w;\n      this.#_size.height = h;\n      return this;\n   }\n\n   type(t) {\n      if (t === undefined) return this.#_type;\n      this.#_type = t;\n      return this;\n   }\n\n   content(c) {\n      if (c === undefined) return this.#_content;\n      this.#_content = c;\n      return this;\n   }\n\n   stringify() {\n      return { _class: \"GenericObject\", pos: this.#_pos, size: this.#_size, type: this.#_type, content: this.#_content };\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9nZW5lcmljX29iamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTs7QUFFYjtBQUN3QztBQUNEOztBQUVoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxpREFBVTtBQUNoQjtBQUNBO0FBQ0EsTUFBTSxnREFBTztBQUNiLE1BQU0sZ0RBQU87QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFPO0FBQ25CLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxhQUFhO0FBQ2IsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2xlaXNwbGFuZWRpdG9yLy4vd3d3L2NvZGUvZ2VuZXJpY19vYmplY3QuanM/MjlmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gRVM2IE1vZHVsZSBpbXBvcnRzXG5pbXBvcnQgeyBBcnJheVV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBTVE9SQUdFIH0gZnJvbSAnLi9zdG9yYWdlLmpzJztcblxuZXhwb3J0IGNsYXNzIEdlbmVyaWNPYmplY3Qge1xuICAgc3RhdGljIE9CSkVDVF9UWVBFID0ge1xuICAgICAgbm9uZTogMCxcbiAgICAgIHRleHQ6IDEsXG4gICAgICBwbGF0dGZvcm06IDIsXG4gICB9O1xuXG4gICBzdGF0aWMgYWxsX29iamVjdHMgPSBbXTtcblxuICAgc3RhdGljIEZyb21PYmplY3Qobykge1xuICAgICAgcmV0dXJuIG5ldyBHZW5lcmljT2JqZWN0KCkucG9zKG8ucG9zKS5zaXplKG8uc2l6ZS53aWR0aCxvLnNpemUuaGVpZ2h0KS50eXBlKG8udHlwZSkuY29udGVudChvLmNvbnRlbnQpO1xuICAgfVxuXG4gICBzdGF0aWMgcmVtb3ZlT2JqZWN0KG8pIHtcbiAgICAgIEFycmF5VXRpbHMucmVtb3ZlKHRoaXMuYWxsX29iamVjdHMsIG8pO1xuICAgICAgd2luZG93LnJlbmRlcmVyLnJlbmRlckFsbEdlbmVyaWNPYmplY3RzKCk7XG4gICAgICB3aW5kb3cuc3RhZ2UudXBkYXRlKCk7XG4gICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICB9XG5cbiAgIHN0YXRpYyBpbml0RWRpdE1lbnUobykge1xuICAgICAgbGV0IGhlYWRlcl90ZXh0O1xuICAgICAgc3dpdGNoIChvLnR5cGUoKSkge1xuICAgICAgICAgY2FzZSBHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLnRleHQ6XG4gICAgICAgICAgICBoZWFkZXJfdGV4dCA9IFwiVGV4dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEdlbmVyaWNPYmplY3QuT0JKRUNUX1RZUEUucGxhdHRmb3JtOlxuICAgICAgICAgICAgICAgaGVhZGVyX3RleHQgPSBcIkJhaG5zdGVpZ1wiO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAkKFwiI2VkaXRPYmplY3RNZW51IGg1XCIpLnRleHQoaGVhZGVyX3RleHQpO1xuXG4gICAgICBcbiAgICAgICQoXCIjaW5wdXRDb250ZW50XCIpXG4gICAgICAgICAub2ZmKClcbiAgICAgICAgIC52YWwoby5jb250ZW50KCkpXG4gICAgICAgICAub24oXCJpbnB1dFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgby5jb250ZW50KCQodGhpcykudmFsKCkpO1xuICAgICAgICAgICAgd2luZG93LnJlbmRlcmVyLnJlbmRlckFsbEdlbmVyaWNPYmplY3RzKCk7XG4gICAgICAgICAgICB3aW5kb3cucmVuZGVyZXIudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB3aW5kb3cuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgIH0pO1xuXG4gICAgICAkKFwiI2J0blJlbW92ZU9iamVjdFwiKVxuICAgICAgICAgLm9mZigpXG4gICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVPYmplY3Qobyk7XG4gICAgICAgICAgICB3aW5kb3cuc2VsZWN0T2JqZWN0KClcbiAgICAgICAgIH0pO1xuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICQoXCIjaW5wdXRDb250ZW50XCIpLmZvY3VzKCk7XG4gICAgICB9LCA1MCk7XG4gICB9XG5cbiAgICNfcG9zID0geyB4OiAwLCB5OiAwIH07XG4gICAjX3NpemUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICNfdHlwZSA9IEdlbmVyaWNPYmplY3QuT0JKRUNUX1RZUEUubm9uZTtcbiAgICNfY29udGVudCA9IFwiXCI7XG5cbiAgIGNvbnN0cnVjdG9yKHQgPSBHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLm5vbmUpIHtcbiAgICAgIHRoaXMuI190eXBlID0gdDtcbiAgIH1cblxuICAgcG9zKHApIHtcbiAgICAgIGlmIChwID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLiNfcG9zO1xuICAgICAgdGhpcy4jX3BvcyA9IHA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cblxuICAgc2l6ZSh3LGgpIHtcbiAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLiNfc2l6ZTtcbiAgICAgIHRoaXMuI19zaXplLndpZHRoID0gdztcbiAgICAgIHRoaXMuI19zaXplLmhlaWdodCA9IGg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cblxuICAgdHlwZSh0KSB7XG4gICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy4jX3R5cGU7XG4gICAgICB0aGlzLiNfdHlwZSA9IHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cblxuICAgY29udGVudChjKSB7XG4gICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy4jX2NvbnRlbnQ7XG4gICAgICB0aGlzLiNfY29udGVudCA9IGM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cblxuICAgc3RyaW5naWZ5KCkge1xuICAgICAgcmV0dXJuIHsgX2NsYXNzOiBcIkdlbmVyaWNPYmplY3RcIiwgcG9zOiB0aGlzLiNfcG9zLCBzaXplOiB0aGlzLiNfc2l6ZSwgdHlwZTogdGhpcy4jX3R5cGUsIGNvbnRlbnQ6IHRoaXMuI19jb250ZW50IH07XG4gICB9XG59XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/generic_object.js\n\n}");

/***/ }),

/***/ "./www/code/preLoader.js":
/*!*******************************!*\
  !*** ./www/code/preLoader.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   preLoader: () => (/* binding */ preLoader)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n\n\n// ES6 Module imports\n\n\n\nclass preLoader {\n    constructor(basefolder) {\n        this._promises = [];\n        this._basefolder = basefolder;\n        if (basefolder.length > 0) this._basefolder += \"/\";\n        this._jsonFiles = [];\n        this._loadedItems = 0;\n        this._totalItems = 0;\n        this.onProgress = (progress) => {};\n        this._loadQueue = new createjs.LoadQueue(false, basefolder, false);\n        this._loadQueue.setMaxConnections(99);\n        /* this._loadQueue.on(\"fileload\", (e) => {\n            this._loadedItems++;\n            this.onProgress(this._loadedItems / this._totalItems);\n        }); */\n    }\n\n    get loaded() {\n        return this._loadQueue.loaded;\n    }\n\n    addSpriteSheet(json_file) {\n        if(!_utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.pushUnique(this._jsonFiles, json_file))return null;\n        \n        let p = new Promise((resolve, reject) => {\n            preLoader.getJson(this._basefolder + json_file + \".json\" + \"?\" + window.VERSION).then((imgCatalog) => {\n                let i = 0;\n                let img;\n                while (i < imgCatalog.length) {\n                    img = imgCatalog[i];\n                    img.src = json_file + \".png\" + \"?\" + window.VERSION;\n                    img.id = json_file + img.signal;\n                    i++;\n                }\n                this._totalItems+=imgCatalog.length;\n                this._loadQueue.loadManifest(imgCatalog, false, this._basefolder);\n                resolve();\n            });\n        });\n        this._promises.push(p);\n        return p;\n    }\n\n    addImage(src, id) {\n        this._totalItems++;\n        this._loadQueue.loadFile({ id: id, src: src, type: createjs.LoadQueue.IMAGE }, false, this._basefolder);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            Promise.all(this._promises).then(() => {\n                this._loadQueue.addEventListener(\"error\", (e) => {\n                    _ui_js__WEBPACK_IMPORTED_MODULE_1__.ui.showInfoToast(e.title + \":\" + e.data.id);\n                });\n                this._loadQueue.addEventListener(\"fileload\", () => { this._loadedItems++; });\n                this._loadQueue.addEventListener(\"complete\", () => {\n                    resolve();\n                });\n\n                this._loadQueue.setPaused(false);\n            });\n        });\n    }\n\n    getSprite(json_file, texture_name) {\n        if (texture_name == null || texture_name == \"\") throw \"kein texture_name übergeben\";\n        if (json_file == null || json_file == \"\") throw \"kein signal_name übergeben\";\n        const id = json_file + texture_name;\n        const img = this._loadQueue.getResult(id);\n        if (img != null) {\n            let item = this._loadQueue._loadItemsById[id];\n            return new createjs.Bitmap(img).set({\n                name:texture_name,\n                y: item.pos.top,\n                x: item.pos.left,\n                sourceRect: new createjs.Rectangle(item.sourceRect.x, item.sourceRect.y, item.sourceRect.width, item.sourceRect.height),\n            });\n        } else console.log(id + \" nicht gefunden, nicht vom preLoader geladen\");\n\n        return null;\n    }\n\n    getImage(id) {\n        return this._loadQueue.getResult(id);\n    }\n\n    static getJson(file) {\n        return new Promise((resolve, reject) => {\n            $.getJSON(file, (data) => resolve(data));\n        });\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9wcmVMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7O0FBRWI7QUFDd0M7QUFDWDs7QUFFdEI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksaURBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsa0RBQWtEO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFFO0FBQ3RCLGlCQUFpQjtBQUNqQixxRUFBcUUsc0JBQXNCO0FBQzNGO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nbGVpc3BsYW5lZGl0b3IvLi93d3cvY29kZS9wcmVMb2FkZXIuanM/NzZhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gRVM2IE1vZHVsZSBpbXBvcnRzXG5pbXBvcnQgeyBBcnJheVV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB1aSB9IGZyb20gJy4vdWkuanMnO1xuXG5leHBvcnQgY2xhc3MgcHJlTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlZm9sZGVyKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2VzID0gW107XG4gICAgICAgIHRoaXMuX2Jhc2Vmb2xkZXIgPSBiYXNlZm9sZGVyO1xuICAgICAgICBpZiAoYmFzZWZvbGRlci5sZW5ndGggPiAwKSB0aGlzLl9iYXNlZm9sZGVyICs9IFwiL1wiO1xuICAgICAgICB0aGlzLl9qc29uRmlsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9hZGVkSXRlbXMgPSAwO1xuICAgICAgICB0aGlzLl90b3RhbEl0ZW1zID0gMDtcbiAgICAgICAgdGhpcy5vblByb2dyZXNzID0gKHByb2dyZXNzKSA9PiB7fTtcbiAgICAgICAgdGhpcy5fbG9hZFF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZShmYWxzZSwgYmFzZWZvbGRlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9sb2FkUXVldWUuc2V0TWF4Q29ubmVjdGlvbnMoOTkpO1xuICAgICAgICAvKiB0aGlzLl9sb2FkUXVldWUub24oXCJmaWxlbG9hZFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkSXRlbXMrKztcbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh0aGlzLl9sb2FkZWRJdGVtcyAvIHRoaXMuX3RvdGFsSXRlbXMpO1xuICAgICAgICB9KTsgKi9cbiAgICB9XG5cbiAgICBnZXQgbG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFF1ZXVlLmxvYWRlZDtcbiAgICB9XG5cbiAgICBhZGRTcHJpdGVTaGVldChqc29uX2ZpbGUpIHtcbiAgICAgICAgaWYoIUFycmF5VXRpbHMucHVzaFVuaXF1ZSh0aGlzLl9qc29uRmlsZXMsIGpzb25fZmlsZSkpcmV0dXJuIG51bGw7XG4gICAgICAgIFxuICAgICAgICBsZXQgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHByZUxvYWRlci5nZXRKc29uKHRoaXMuX2Jhc2Vmb2xkZXIgKyBqc29uX2ZpbGUgKyBcIi5qc29uXCIgKyBcIj9cIiArIHdpbmRvdy5WRVJTSU9OKS50aGVuKChpbWdDYXRhbG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBpbWc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpbWdDYXRhbG9nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbWcgPSBpbWdDYXRhbG9nW2ldO1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0ganNvbl9maWxlICsgXCIucG5nXCIgKyBcIj9cIiArIHdpbmRvdy5WRVJTSU9OO1xuICAgICAgICAgICAgICAgICAgICBpbWcuaWQgPSBqc29uX2ZpbGUgKyBpbWcuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsSXRlbXMrPWltZ0NhdGFsb2cubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRRdWV1ZS5sb2FkTWFuaWZlc3QoaW1nQ2F0YWxvZywgZmFsc2UsIHRoaXMuX2Jhc2Vmb2xkZXIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZXMucHVzaChwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgYWRkSW1hZ2Uoc3JjLCBpZCkge1xuICAgICAgICB0aGlzLl90b3RhbEl0ZW1zKys7XG4gICAgICAgIHRoaXMuX2xvYWRRdWV1ZS5sb2FkRmlsZSh7IGlkOiBpZCwgc3JjOiBzcmMsIHR5cGU6IGNyZWF0ZWpzLkxvYWRRdWV1ZS5JTUFHRSB9LCBmYWxzZSwgdGhpcy5fYmFzZWZvbGRlcik7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbCh0aGlzLl9wcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFF1ZXVlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1aS5zaG93SW5mb1RvYXN0KGUudGl0bGUgKyBcIjpcIiArIGUuZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFF1ZXVlLmFkZEV2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiLCAoKSA9PiB7IHRoaXMuX2xvYWRlZEl0ZW1zKys7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRRdWV1ZS5hZGRFdmVudExpc3RlbmVyKFwiY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkUXVldWUuc2V0UGF1c2VkKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRTcHJpdGUoanNvbl9maWxlLCB0ZXh0dXJlX25hbWUpIHtcbiAgICAgICAgaWYgKHRleHR1cmVfbmFtZSA9PSBudWxsIHx8IHRleHR1cmVfbmFtZSA9PSBcIlwiKSB0aHJvdyBcImtlaW4gdGV4dHVyZV9uYW1lIMO8YmVyZ2ViZW5cIjtcbiAgICAgICAgaWYgKGpzb25fZmlsZSA9PSBudWxsIHx8IGpzb25fZmlsZSA9PSBcIlwiKSB0aHJvdyBcImtlaW4gc2lnbmFsX25hbWUgw7xiZXJnZWJlblwiO1xuICAgICAgICBjb25zdCBpZCA9IGpzb25fZmlsZSArIHRleHR1cmVfbmFtZTtcbiAgICAgICAgY29uc3QgaW1nID0gdGhpcy5fbG9hZFF1ZXVlLmdldFJlc3VsdChpZCk7XG4gICAgICAgIGlmIChpbWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLl9sb2FkUXVldWUuX2xvYWRJdGVtc0J5SWRbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjcmVhdGVqcy5CaXRtYXAoaW1nKS5zZXQoe1xuICAgICAgICAgICAgICAgIG5hbWU6dGV4dHVyZV9uYW1lLFxuICAgICAgICAgICAgICAgIHk6IGl0ZW0ucG9zLnRvcCxcbiAgICAgICAgICAgICAgICB4OiBpdGVtLnBvcy5sZWZ0LFxuICAgICAgICAgICAgICAgIHNvdXJjZVJlY3Q6IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoaXRlbS5zb3VyY2VSZWN0LngsIGl0ZW0uc291cmNlUmVjdC55LCBpdGVtLnNvdXJjZVJlY3Qud2lkdGgsIGl0ZW0uc291cmNlUmVjdC5oZWlnaHQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBjb25zb2xlLmxvZyhpZCArIFwiIG5pY2h0IGdlZnVuZGVuLCBuaWNodCB2b20gcHJlTG9hZGVyIGdlbGFkZW5cIik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0SW1hZ2UoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRRdWV1ZS5nZXRSZXN1bHQoaWQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRKc29uKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICQuZ2V0SlNPTihmaWxlLCAoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/preLoader.js\n\n}");

/***/ }),

/***/ "./www/code/signal.js":
/*!****************************!*\
  !*** ./www/code/signal.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sig_UI: () => (/* binding */ Sig_UI),\n/* harmony export */   Signal: () => (/* binding */ Signal),\n/* harmony export */   SignalRenderer: () => (/* binding */ SignalRenderer)\n/* harmony export */ });\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _signaling_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./signaling.js */ \"./www/code/signaling.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\nclass SignalRenderer {\n   static #renderingState = new WeakMap();\n\n   static draw(signal, container, force = false) {\n      if (!SignalRenderer.#renderingState.has(signal) && (force || signal._changed)) {\n         SignalRenderer.#renderingState.set(signal, { container });\n\n         container.removeAllChildren();\n\n         signal._dontCache = false;\n         signal._template.elements.forEach((ve) => this.drawVisualElement(signal, ve));\n         signal._changed = false;\n         SignalRenderer.#renderingState.delete(signal);\n      }\n   }\n\n   static createSignalContainer(signal) {\n      let c = new createjs.Container();\n      c.name = \"signal\";\n      c.data = signal;\n      c.mouseChildren = false;\n      c.snapToPixel = true;\n      c.scale = signal._template.scale;\n   \n      signal.draw(c, true);\n      let sig_bounds = c.getBounds();\n      if (sig_bounds) {\n         // schläft fehl, wenn nichts gezeichnet wurde\n         let hit = new createjs.Shape();\n         hit.graphics.beginFill(\"#000\").drawRect(sig_bounds.x, sig_bounds.y, sig_bounds.width, sig_bounds.height);\n         c.hitArea = hit;\n   \n         c.regX = sig_bounds.width / 2 + sig_bounds.x;\n         c.regY = sig_bounds.height + sig_bounds.y;\n      } else console.error(\"Wahrscheinlich fehler beim Zeichen des Signals!\");\n   \n      return c;\n   }\n\n   static drawVisualElement(signal, ve) {\n      if (Array.isArray(ve)) ve.forEach((e) => this.drawVisualElement(signal, e));\n      else if (typeof ve == \"string\") {\n         this.addImageElement(signal, ve);\n      } else if (ve instanceof _signaling_js__WEBPACK_IMPORTED_MODULE_3__.TextElement) {\n         this.drawTextElement(signal, ve);\n      } else if (ve instanceof _signaling_js__WEBPACK_IMPORTED_MODULE_3__.VisualElement) {\n         if (ve.isAllowed(signal) && ve.isEnabled(signal)) {\n            if (ve.image) this.addImageElement(signal, ve, ve.blinkt());\n            ve.childs()?.forEach((c) => this.drawVisualElement(signal, c));\n         }\n      } else console.log(\"unknown type of VisualElement: \" + ve);\n      return false;\n   }\n\n   static drawTextElement(signal, ve) {\n      if (!ve.pos()) throw new Error(\"TextElement doesnt have a position\");\n      if (ve.isAllowed(signal) && ve.isEnabled(signal)) {\n         const formatString = (f) => `${f[2] ? \"bold\" : \"\"} ${f[0]}px ${f[1]}`;\n\n         let txt = ve.getText(signal);\n         if (txt == null) return false;\n         if (typeof txt == \"string\") txt = txt.replace(\"-\", \"\\n\");\n         let ar = (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.clone)(ve.format);\n         const displayObject = new createjs.Text(txt, formatString(ar), ve.color);\n         [displayObject.x, displayObject.y] = ve.pos();\n         displayObject.textAlign = \"center\";\n\n         let current_bounds, max_bounds;\n         do {\n            current_bounds = displayObject.getBounds();\n            max_bounds = ve.bounds();\n            if (max_bounds && (current_bounds.width > max_bounds[0] || current_bounds.height > max_bounds[1])) {\n               ar[0] -= 5;\n               displayObject.font = formatString(ar);\n               displayObject.lineHeight = ar[0];\n            } else break;\n         } while (true);\n         const state = SignalRenderer.#renderingState.get(signal);\n         state.container.addChild(displayObject);\n      }\n   }\n\n   static addImageElement(signal, ve, blinkt = false) {\n      const textureName = typeof ve == \"string\" ? ve : ve.image;\n\n      if (textureName == null || textureName == \"\") return;\n\n      if (textureName.includes(\",\", 1)) textureName.split(\",\").forEach((x) => this.addImageElement(signal, x));\n      else {\n         const state = SignalRenderer.#renderingState.get(signal);\n         if (!state.container.getChildByName(textureName)) {\n            //check if this texture was already drawn. Some texture are the same for different signals like Zs1 and Zs8\n            let bmp = window.pl.getSprite(signal._template.json_file, textureName);\n            if (bmp != null) {\n               state.container.addChild(bmp);\n\n               if (blinkt) {\n                  signal._dontCache = true;\n                  createjs.Tween.get(bmp, { loop: true }).wait(1000).to({ alpha: 0 }, 200).wait(800).to({ alpha: 1 }, 50);\n               }\n\n               return bmp;\n            } else console.log(textureName + \" nicht gezeichnet, da sprite für \" + textureName + \" nicht erstellt wurde\");\n         }\n      }\n   }\n\n   static drawPreview(template, container) {\n      container.removeAllChildren();\n      // Create a minimal context for preview rendering\n      const previewContext = {\n         _template: template,\n         _signalStellung: {},\n         check: () => true, // For preview, always show all elements\n         get: () => null\n      };\n      \n      SignalRenderer.#renderingState.set(previewContext, { container });\n      // Use existing drawVisualElement but with our preview context\n      template.elements.forEach(ve => \n         this.drawVisualElement(previewContext, ve)\n      );\n      SignalRenderer.#renderingState.delete(previewContext);\n   }\n}\n\nclass Signal {\n   static allSignals = new Set();\n\n   static removeSignal(s) {\n      const track = _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.allTracks.find((t) => t.signals.includes(s));\n      if (track) {\n         track.removeSignal(s);\n      }\n      Signal.allSignals.delete(s);\n   }\n\n   \n\n   _template = null;\n   _signalStellung = {};\n   _positioning = {\n      track: null,\n      km: 0,\n      above: false,\n      flipped: false,\n   };\n   _changed = false;\n   _dontCache = false;\n\n   \n\n   constructor(template) {\n      this._template = template;\n      this._positioning = {\n         track: null,\n         km: 0,\n         above: false,\n         flipped: false\n      };\n      Signal.allSignals.add(this);\n      if (template.initialSignalStellung) template.initialSignalStellung.forEach((i) => this.set_stellung(i, true, false));\n   }\n\n   get title() {\n      let title = \"\";\n      if (this.check(\"HPsig\"))\n         switch (this.get(\"verw\")) {\n            case \"zsig\":\n               title += \"Zsig\";\n               break;\n            case \"esig\":\n               title += \"Esig\";\n               break;\n            case \"asig\":\n               title += \"Asig\";\n               break;\n            case \"bksig\":\n               title += \"Bk\";\n               break;\n            case \"sbk\":\n               title += \"Sbk\";\n               break;\n\n            default:\n               break;\n         }\n\n      const bez = this.get(\"bez\");\n      if (bez) title += (\" \" + bez).replace(\"-\", \" \");\n\n      return title;\n   }\n\n   //Setzt die Signalstellung, 2 Möglichkeiten:\n   //set(\"zs3\",60)\n   //set(\"hp\",1)\n   //oder\n   //set(\"hp=0\")\n   //set(\"ersatz=zs7\")\n   //set(\"hp=0,1\") der Value hat vorrang vor dem in stellung enthaltenen Value\n   //value=false schaltet die Signalstellung auf -1, also aus. Wird vom Menü zum ausschalten einer Signalstellung verwendet\n   //chain=false verhindert, dass das Signal versucht das davor und dahinterliegende Signal zu informieren\n   set_stellung(command, overideValue = true, chain = true) {\n      /* if (subkey == undefined) [command, subkey] = command.split(\"=\");\n      else [command] = command.split(\"=\"); */\n      let setting, value;\n      [setting, value] = command.split(\"=\");\n      if (overideValue === false) value = null; //false would be better but in javascript hp=0 and hp=false is the same\n      else if (value == undefined) value = overideValue;\n\n      if (this.get(setting) != value) {\n         if (value == null) this._signalStellung[setting] = null;\n         else if (!isNaN(value)) this._signalStellung[setting] = Number(value);\n         else this._signalStellung[setting] = value;\n\n         this._changed = true;\n      }\n\n      //Signal is actual positioned at a track (e.g. When Signal is created, there isnt a track yet)\n      //and the signal indication actualy changed\n      if (this._positioning.track && this._changed && chain) {\n         let stop = false;\n         if (this.check([\"HPsig||master\"])) {\n            let prevSignal = this;\n            do {\n               prevSignal = this.search4Signal(prevSignal, window.DIRECTION.RIGHT_2_LEFT);\n               if (prevSignal && prevSignal._template.checkSignalDependency)\n                  stop = prevSignal._template.checkSignalDependency(prevSignal, this);\n            } while (!stop && prevSignal);\n         }\n         if (this.check([\"VRsig||slave\"]) && this._template.checkSignalDependency) {\n            let nextSignal = this;\n            do {\n               nextSignal = this.search4Signal(nextSignal, window.DIRECTION.LEFT_2_RIGTH);\n               if (nextSignal && nextSignal._template.checkSignalDependency)\n                  stop = nextSignal._template.checkSignalDependency(this, nextSignal, [\"HPsig||master\"]);\n            } while (!stop && nextSignal);\n         }\n      }\n\n      if (this._changed)\n         this._template.rules.forEach(\n            function (rule) {\n               let trigger = rule[0];\n               let signal_aspect = rule[1];\n               if (!this.check(signal_aspect) && this.check(trigger)) this.set_stellung(signal_aspect);\n            }.bind(this)\n         );\n   }\n\n   //get value for a specific Stellung\n   //e.g. get(\"hp\") returns 0 for Hp 0\n   //can be used like this: get(\"hp\") > 0\n   get(stellung) {\n      let value = this._signalStellung[stellung];\n      if (value != undefined) return value;\n      else return null;\n   }\n\n   static _splitEquation(equation) {\n      const ret = {};\n      //the order is important, otherwise it would find '=' before '!='\n      //and OR ist prioritised before AND\n      const operators = [\"||\", \"&&\", \"!=\", \"<=\", \">=\", \"=\", \">\", \"<\"];\n      let parts;\n      for (let op of operators) {\n         parts = equation.split(op);\n         if (parts.length > 1) {\n            ret.operands = parts;\n            ret.operator = op;\n            break;\n         }\n      }\n\n      if (!ret.operator) return null;\n\n      return ret;\n   }\n\n   //checks if a specific Stellung is set\n   //e.g. get(\"hp=0\") returns true for Hp 0\n   check(stellung) {\n      if (stellung == null) return true;\n\n      if (Array.isArray(stellung)) return stellung.every(this.check.bind(this));\n\n      const equation = Signal._splitEquation(stellung);\n      if (equation == null) return this.get(stellung) != null;\n\n      switch (equation.operator) {\n         case \"&&\":\n            return equation.operands.every(this.check, this);\n         case \"||\":\n            return equation.operands.some(this.check, this);\n      }\n\n      let data = this.get(equation.operands[0].trim());\n      if (data === null) data = \"null\";\n      if (equation.operator == \"=\") return data == equation.operands[1].trim();\n      else {\n         const right = Number.parseInt(equation.operands[1].trim());\n         if (equation.operator == \"<\") return data < right;\n         else if (equation.operator == \"<=\") return data <= right;\n         else if (equation.operator == \">=\") return data >= right;\n         else if (equation.operator == \">\") return data > right;\n         else if (equation.operator == \"!=\") return data != right;\n      }\n   }\n\n   draw(c, force = false) {\n      SignalRenderer.draw(this, c, force);\n   }\n\n   search4Signal(signal, dir, feature) {\n      if (signal._positioning.above != signal._positioning.flipped) dir *= -1;\n\n      let track = signal._positioning.track;\n      let index = track.signals.indexOf(signal) + dir;\n      let sw = null;\n\n      //function checks, if this signal and the given signal belong together\n      /* above flipped above flipped result\n        0   \t0\t    0   \t0   \t1\n        0\t    1\t    0   \t0   \t0\n        0   \t0   \t0   \t1   \t0\n        0   \t1\t    0   \t1\t    1\n        1   \t0   \t0   \t0   \t0\n        0   \t0   \t1   \t0   \t0\n        1   \t0   \t1   \t0   \t1\n        0   \t0   \t1\t    1   \t1\n        1   \t1   \t0\t    0\t    1\n        0   \t1   \t1\t    0   \t1\n        1   \t0   \t0   \t1\t    1\n        1   \t1   \t1   \t0   \t0\n        0   \t1\t    1   \t1\t    0\n        1   \t1\t    1   \t1\t    1 \n        the hack is, that wehen all above and flipped are added, the number is even if they belong together*/\n      const check = function (pos) {\n         return (\n            (Number(signal._positioning.above) + Number(signal._positioning.flipped) + Number(pos.flipped) + Number(pos.above)) %\n               2 ==\n            0\n         );\n      };\n\n      const getTrackAtBranch = function (sw, track) {\n         if (track == sw.from) return sw.branch;\n         if (track == sw.branch) return sw.from;\n\n         return null;\n      };\n\n      while (track) {\n         while (dir == 1 ? index >= 0 && index < track.signals.length : index >= 0) {\n            let nextSignal = track.signals[index];\n            if (nextSignal.check(feature) && check(nextSignal._positioning)) {\n               return nextSignal; //hauptsignal gefunden\n            } else index = index + dir;\n         }\n\n         if ((sw = track.switches[dir == 1 ? 1 : 0])) {\n            if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.type)(sw) == \"Track\") track = sw;\n            else track = getTrackAtBranch(sw, track);\n\n            if (track) {\n               index = track.signals.length - 1;\n               if (dir == DIRECTION.LEFT_2_RIGTH) index = Math.min(0, index);\n            }\n         } else track = null;\n      }\n   }\n\n   setTrack(track,km) {\n      if (this._positioning.track) {\n         _utils_js__WEBPACK_IMPORTED_MODULE_1__.ArrayUtils.remove(this._positioning.track.signals, this);\n      }\n      this._positioning.track = track;\n      this._positioning.km = km;\n      if (track) {\n         track.signals.push(this);\n      }\n   }\n\n   stringify() {\n      return {\n         _class: \"Signal\",\n         _template: (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.findFieldNameForObject)(window.signalTemplates, this._template),\n         _signalStellung: this._signalStellung,\n         _positioning: {\n            km: this._positioning.km,\n            above: this._positioning.above,\n            flipped: this._positioning.flipped,\n         },\n      };\n   }\n\n   static FromObject(o) {\n      let s = new Signal(window.signalTemplates[o._template]);      \n      s._signalStellung = o._signalStellung;\n      s._positioning = o._positioning;\n      return s;\n   }\n}\n\nconst Sig_UI = {\n   create_SpeedDropDown(signal, text, onChange) {\n      const items = Array.from({ length: 10 }, (_, i) => `${i}0|${signal}=${i}`);\n      items[0] = `aus|${signal}=-1`;\n      return _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.create_DropDown(items, text, onChange);\n   },\n   initSignalMenu() {\n      const conditions = window.selection.object._template.getAllVisualElementConditions();\n      const update = function (command, isOn) {\n         window.selection.object.set_stellung(command, isOn);\n         Sig_UI.syncSignalMenu(window.selection.object);\n         window.renderer.reDrawEverything();\n         _storage_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.save();\n      };\n      $(\"#btnRemoveSignal\").click((e) => window.deleteSelectedObject());\n      $(\"#navFeatures\").empty();\n               if (window.selection.object.check(\"HPsig\"))\n         $(\"#navFeatures\").append(\n            _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.div(\n               \"p-3 border-bottom\",\n               _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.create_DropDown(\n                  \"Esig,Asig,Zsig,Bksig,Sbk\".split(\",\").map((x) => x + \"|verw=\" + x.toLowerCase()),\n                  \"Verwendung\",\n                  update\n               )\n            )\n         );\n      $(\"#navFeatures\").append(\n         _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.createSwitchStructure(\n            [\"Vorsignalfunktion\", \"VRsig\", conditions.includes(\"VRsig\")],\n            [\n               ...(conditions.includes(\"vr_op=verk\") ? [[\"verkürzt\", \"vr_op=verk\"]] : []),\n               ...(conditions.includes(\"vr_op=wdh\") ? [[\"wiederholer\", \"vr_op=wdh\"]] : []),\n            ],\n            update\n         )?.addClass(\"p-3 border-bottom\")\n      );\n      if (conditions.includes(\"mastschild=wrw\") && conditions.includes(\"mastschild=wgwgw\"))\n         $(\"#navFeatures\").append(\n            _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.createOptionGroup(\n               \"Mastschild\",\n               [\n                  [\"W-R-W\", \"mastschild=wrw\"],\n                  [\"W-G-W-G-W\", \"mastschild=wgwgw\"],\n               ],\n               \"radio\",\n               update\n            ).addClass(\"p-3 border-bottom\")\n         );\n      if (conditions.includes(\"zusatz_unten\") || conditions.includes(\"zusatz_oben\")) {\n         const a = [\n            [\"unten\", \"zusatz_unten\"],\n            [\"oben\", \"zusatz_oben\"],\n         ];\n         a.forEach((x) => x.push(conditions.includes(x[1])));\n\n         $(\"#navFeatures\").append(_ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.createOptionGroup(\"Zusatzanzeiger\", a, \"checkbox\", update).addClass(\"p-3 border-bottom\"));\n      }\n   },\n   syncSignalMenu(signal) {\n      //header\n      $(\"#signalEditMenuHeader .card-title\").text(signal._template.title);\n      $(\"#signalEditMenuHeader .card-text>span\").text(signal.title);\n      //feature Menu\n      $(\"#navFeatures>div a\").each(function () {\n         const $a = $(this);\n         $a.toggleClass(\"active\", signal.check($a.attr(\"value\")));\n      });\n\n      $(\"#navFeatures>div input\").each(function () {\n         const input = $(this);\n         const v = signal.check(input.attr(\"value\"));\n         input.prop(\"checked\", v ? \"checked\" : null);\n         if (input.attr(\"data-master_switch\") != null) $(\"input\", input.parent().next()).prop(\"disabled\", !v);\n      });\n   },\n\n   getHTML(signal) {\n      if (signal._template.signalMenu?.length) {\n         const ul = _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.div(\"d-flex flex-column bd-highlight mb-3\");\n\n         const updateFunc = function (command, active) {\n            signal.set_stellung(command, !active);\n            window.renderer.reDrawEverything();\n            window.stage.update();\n            Sig_UI.checkBootstrapMenu(signal, signal._template.signalMenu, ul);\n            _storage_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.save();\n         };\n\n         ul.append(signal._template.signalMenu.map((data) => Sig_UI.createBootstrapMenuItems(signal, data, updateFunc)));\n\n         Sig_UI.checkBootstrapMenu(signal, signal._template.signalMenu, ul);\n\n         return ul;\n      }\n      return \"\";\n   },\n\n   createBootstrapMenuItems(signal, menu_item, update) {\n      if (menu_item) {\n         if (Array.isArray(menu_item)) {\n            let items = _utils_js__WEBPACK_IMPORTED_MODULE_1__.ArrayUtils.cleanUp(menu_item.map((item) => Sig_UI.createBootstrapMenuItems(signal, item, update)));\n            if (items) {\n               return _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.div(\"p-3 border-bottom\", _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.create_buttonToolbar(items));\n            } else return null;\n         } else if (menu_item.type == \"buttonGroup\" || menu_item.type == \"btn\") {\n            let buttons = menu_item.type == \"buttonGroup\" ? menu_item.items : [menu_item];\n            buttons = buttons\n               .filter(\n                  (mi) =>\n                     mi.visual_elements?.length > 0 &&\n                     mi.visual_elements.every((ve) => {\n                        let on = ve.on();\n                        if (Array.isArray(on)) {\n                           if (on.includes(mi.command)) on = on.toSpliced(on.indexOf(mi.command), 1);\n                        } else if (on == mi.command) return true;\n\n                        return signal.check(on);\n                     })\n               )\n               .map((item) =>\n                  _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui\n                     .create_toggleButton(item.text, item.command)\n                     .on(\"click\", (e) => update.bind(signal)(item.command, $(e.target).hasClass(\"active\")))\n               )\n            buttons = _utils_js__WEBPACK_IMPORTED_MODULE_1__.ArrayUtils.cleanUp(buttons);\n            if (buttons) return _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.create_buttonGroup(buttons);\n            else return null;\n         } else if (menu_item.type == \"dropdown\") {\n            return Sig_UI.create_SpeedDropDown(menu_item.command, menu_item.text, update.bind(signal));\n         }\n      }\n   },\n\n   checkBootstrapMenu(signal, data, popup) {\n      if (data) {\n         if (Array.isArray(data)) {\n            data.forEach((item) => Sig_UI.checkBootstrapMenu(signal, item, popup));\n         } else if (data.type == \"buttonGroup\") {\n            data.items.forEach((item) => {\n               let button = $(\"#btn_\" + item.text.replace(\" \", \"_\"), popup);\n               if (button.length == 1) {\n                  button.toggleClass(\"active\", signal.check(item.command));\n                  if (item.visual_elements.every((ve) => ve.isAllowed(signal))) button.removeAttr(\"disabled\");\n                  else button.attr(\"disabled\", \"disabled\");\n               }\n            });\n         } else if (data.type == \"dropdown\") {\n            let button = $(\"#btn_\" + data.text.replace(\" \", \"_\"), popup);\n            if (button.length == 1) {\n               const v = signal.get(data.command);\n               button.text(data.text + (v > 0 ? \" Kz \" + v : \" aus\"));\n            }\n         } else if (data.type == \"btn\") {\n            let button = $(\"#btn_\" + data.text.replace(\" \", \"_\"), popup);\n            if (button.length == 1) {\n               button.toggleClass(\"active\", signal.check(data.command));\n               if (data.visual_elements.every((ve) => ve.isAllowed(signal))) button.removeAttr(\"disabled\");\n               else button.attr(\"disabled\", \"disabled\");\n            }\n         }\n      }\n   },\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9zaWduYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWE7O0FBRWI7QUFDNkI7QUFDVztBQUN5QjtBQUNMO0FBQ3pCO0FBQ0k7O0FBRWhDO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCxXQUFXOztBQUVqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQXVCLHNEQUFXO0FBQzFDO0FBQ0EsUUFBUSx1QkFBdUIsd0RBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CLEVBQUUsS0FBSyxLQUFLLEtBQUs7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnREFBSztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWSxrQkFBa0IsVUFBVSxzQkFBc0IsVUFBVTtBQUNwSDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQSxvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxnQkFBZ0IsK0NBQUk7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUVBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsaUNBQWlDLFlBQVksZUFBZSxFQUFFLElBQUksT0FBTyxHQUFHLEVBQUU7QUFDOUUsd0JBQXdCLE9BQU87QUFDL0IsYUFBYSxzQ0FBRTtBQUNmLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdEQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNDQUFFO0FBQ2Q7QUFDQSxlQUFlLHNDQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQ0FBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0Msc0NBQUU7QUFDcEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFJOztBQUVKO0FBQ0E7QUFDQSxvQkFBb0Isc0NBQUU7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFPO0FBQ25COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFVO0FBQ2xDO0FBQ0Esc0JBQXNCLHNDQUFFLDBCQUEwQixzQ0FBRTtBQUNwRCxjQUFjO0FBQ2QsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQixzQ0FBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQVU7QUFDaEMsZ0NBQWdDLHNDQUFFO0FBQ2xDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3NpZ25hbC5qcz8xNjQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IHVpIH0gZnJvbSAnLi91aS5qcyc7XG5pbXBvcnQgeyBBcnJheVV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBjbG9uZSwgZmluZEZpZWxkTmFtZUZvck9iamVjdCwgdHlwZSB9IGZyb20gJy4vdG9vbHMuanMnO1xuaW1wb3J0IHsgVmlzdWFsRWxlbWVudCwgVGV4dEVsZW1lbnQgfSBmcm9tICcuL3NpZ25hbGluZy5qcyc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vdHJhY2suanMnO1xuaW1wb3J0IHsgU1RPUkFHRSB9IGZyb20gJy4vc3RvcmFnZS5qcyc7XG5cbmV4cG9ydCBjbGFzcyBTaWduYWxSZW5kZXJlciB7XG4gICBzdGF0aWMgI3JlbmRlcmluZ1N0YXRlID0gbmV3IFdlYWtNYXAoKTtcblxuICAgc3RhdGljIGRyYXcoc2lnbmFsLCBjb250YWluZXIsIGZvcmNlID0gZmFsc2UpIHtcbiAgICAgIGlmICghU2lnbmFsUmVuZGVyZXIuI3JlbmRlcmluZ1N0YXRlLmhhcyhzaWduYWwpICYmIChmb3JjZSB8fCBzaWduYWwuX2NoYW5nZWQpKSB7XG4gICAgICAgICBTaWduYWxSZW5kZXJlci4jcmVuZGVyaW5nU3RhdGUuc2V0KHNpZ25hbCwgeyBjb250YWluZXIgfSk7XG5cbiAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICAgICBzaWduYWwuX2RvbnRDYWNoZSA9IGZhbHNlO1xuICAgICAgICAgc2lnbmFsLl90ZW1wbGF0ZS5lbGVtZW50cy5mb3JFYWNoKCh2ZSkgPT4gdGhpcy5kcmF3VmlzdWFsRWxlbWVudChzaWduYWwsIHZlKSk7XG4gICAgICAgICBzaWduYWwuX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgIFNpZ25hbFJlbmRlcmVyLiNyZW5kZXJpbmdTdGF0ZS5kZWxldGUoc2lnbmFsKTtcbiAgICAgIH1cbiAgIH1cblxuICAgc3RhdGljIGNyZWF0ZVNpZ25hbENvbnRhaW5lcihzaWduYWwpIHtcbiAgICAgIGxldCBjID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgYy5uYW1lID0gXCJzaWduYWxcIjtcbiAgICAgIGMuZGF0YSA9IHNpZ25hbDtcbiAgICAgIGMubW91c2VDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgYy5zbmFwVG9QaXhlbCA9IHRydWU7XG4gICAgICBjLnNjYWxlID0gc2lnbmFsLl90ZW1wbGF0ZS5zY2FsZTtcbiAgIFxuICAgICAgc2lnbmFsLmRyYXcoYywgdHJ1ZSk7XG4gICAgICBsZXQgc2lnX2JvdW5kcyA9IGMuZ2V0Qm91bmRzKCk7XG4gICAgICBpZiAoc2lnX2JvdW5kcykge1xuICAgICAgICAgLy8gc2NobMOkZnQgZmVobCwgd2VubiBuaWNodHMgZ2V6ZWljaG5ldCB3dXJkZVxuICAgICAgICAgbGV0IGhpdCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICAgaGl0LmdyYXBoaWNzLmJlZ2luRmlsbChcIiMwMDBcIikuZHJhd1JlY3Qoc2lnX2JvdW5kcy54LCBzaWdfYm91bmRzLnksIHNpZ19ib3VuZHMud2lkdGgsIHNpZ19ib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgIGMuaGl0QXJlYSA9IGhpdDtcbiAgIFxuICAgICAgICAgYy5yZWdYID0gc2lnX2JvdW5kcy53aWR0aCAvIDIgKyBzaWdfYm91bmRzLng7XG4gICAgICAgICBjLnJlZ1kgPSBzaWdfYm91bmRzLmhlaWdodCArIHNpZ19ib3VuZHMueTtcbiAgICAgIH0gZWxzZSBjb25zb2xlLmVycm9yKFwiV2FocnNjaGVpbmxpY2ggZmVobGVyIGJlaW0gWmVpY2hlbiBkZXMgU2lnbmFscyFcIik7XG4gICBcbiAgICAgIHJldHVybiBjO1xuICAgfVxuXG4gICBzdGF0aWMgZHJhd1Zpc3VhbEVsZW1lbnQoc2lnbmFsLCB2ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmUpKSB2ZS5mb3JFYWNoKChlKSA9PiB0aGlzLmRyYXdWaXN1YWxFbGVtZW50KHNpZ25hbCwgZSkpO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHZlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgIHRoaXMuYWRkSW1hZ2VFbGVtZW50KHNpZ25hbCwgdmUpO1xuICAgICAgfSBlbHNlIGlmICh2ZSBpbnN0YW5jZW9mIFRleHRFbGVtZW50KSB7XG4gICAgICAgICB0aGlzLmRyYXdUZXh0RWxlbWVudChzaWduYWwsIHZlKTtcbiAgICAgIH0gZWxzZSBpZiAodmUgaW5zdGFuY2VvZiBWaXN1YWxFbGVtZW50KSB7XG4gICAgICAgICBpZiAodmUuaXNBbGxvd2VkKHNpZ25hbCkgJiYgdmUuaXNFbmFibGVkKHNpZ25hbCkpIHtcbiAgICAgICAgICAgIGlmICh2ZS5pbWFnZSkgdGhpcy5hZGRJbWFnZUVsZW1lbnQoc2lnbmFsLCB2ZSwgdmUuYmxpbmt0KCkpO1xuICAgICAgICAgICAgdmUuY2hpbGRzKCk/LmZvckVhY2goKGMpID0+IHRoaXMuZHJhd1Zpc3VhbEVsZW1lbnQoc2lnbmFsLCBjKSk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2UgY29uc29sZS5sb2coXCJ1bmtub3duIHR5cGUgb2YgVmlzdWFsRWxlbWVudDogXCIgKyB2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG5cbiAgIHN0YXRpYyBkcmF3VGV4dEVsZW1lbnQoc2lnbmFsLCB2ZSkge1xuICAgICAgaWYgKCF2ZS5wb3MoKSkgdGhyb3cgbmV3IEVycm9yKFwiVGV4dEVsZW1lbnQgZG9lc250IGhhdmUgYSBwb3NpdGlvblwiKTtcbiAgICAgIGlmICh2ZS5pc0FsbG93ZWQoc2lnbmFsKSAmJiB2ZS5pc0VuYWJsZWQoc2lnbmFsKSkge1xuICAgICAgICAgY29uc3QgZm9ybWF0U3RyaW5nID0gKGYpID0+IGAke2ZbMl0gPyBcImJvbGRcIiA6IFwiXCJ9ICR7ZlswXX1weCAke2ZbMV19YDtcblxuICAgICAgICAgbGV0IHR4dCA9IHZlLmdldFRleHQoc2lnbmFsKTtcbiAgICAgICAgIGlmICh0eHQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgaWYgKHR5cGVvZiB0eHQgPT0gXCJzdHJpbmdcIikgdHh0ID0gdHh0LnJlcGxhY2UoXCItXCIsIFwiXFxuXCIpO1xuICAgICAgICAgbGV0IGFyID0gY2xvbmUodmUuZm9ybWF0KTtcbiAgICAgICAgIGNvbnN0IGRpc3BsYXlPYmplY3QgPSBuZXcgY3JlYXRlanMuVGV4dCh0eHQsIGZvcm1hdFN0cmluZyhhciksIHZlLmNvbG9yKTtcbiAgICAgICAgIFtkaXNwbGF5T2JqZWN0LngsIGRpc3BsYXlPYmplY3QueV0gPSB2ZS5wb3MoKTtcbiAgICAgICAgIGRpc3BsYXlPYmplY3QudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblxuICAgICAgICAgbGV0IGN1cnJlbnRfYm91bmRzLCBtYXhfYm91bmRzO1xuICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VycmVudF9ib3VuZHMgPSBkaXNwbGF5T2JqZWN0LmdldEJvdW5kcygpO1xuICAgICAgICAgICAgbWF4X2JvdW5kcyA9IHZlLmJvdW5kcygpO1xuICAgICAgICAgICAgaWYgKG1heF9ib3VuZHMgJiYgKGN1cnJlbnRfYm91bmRzLndpZHRoID4gbWF4X2JvdW5kc1swXSB8fCBjdXJyZW50X2JvdW5kcy5oZWlnaHQgPiBtYXhfYm91bmRzWzFdKSkge1xuICAgICAgICAgICAgICAgYXJbMF0gLT0gNTtcbiAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZm9udCA9IGZvcm1hdFN0cmluZyhhcik7XG4gICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmxpbmVIZWlnaHQgPSBhclswXTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgY29uc3Qgc3RhdGUgPSBTaWduYWxSZW5kZXJlci4jcmVuZGVyaW5nU3RhdGUuZ2V0KHNpZ25hbCk7XG4gICAgICAgICBzdGF0ZS5jb250YWluZXIuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XG4gICAgICB9XG4gICB9XG5cbiAgIHN0YXRpYyBhZGRJbWFnZUVsZW1lbnQoc2lnbmFsLCB2ZSwgYmxpbmt0ID0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHRleHR1cmVOYW1lID0gdHlwZW9mIHZlID09IFwic3RyaW5nXCIgPyB2ZSA6IHZlLmltYWdlO1xuXG4gICAgICBpZiAodGV4dHVyZU5hbWUgPT0gbnVsbCB8fCB0ZXh0dXJlTmFtZSA9PSBcIlwiKSByZXR1cm47XG5cbiAgICAgIGlmICh0ZXh0dXJlTmFtZS5pbmNsdWRlcyhcIixcIiwgMSkpIHRleHR1cmVOYW1lLnNwbGl0KFwiLFwiKS5mb3JFYWNoKCh4KSA9PiB0aGlzLmFkZEltYWdlRWxlbWVudChzaWduYWwsIHgpKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAgY29uc3Qgc3RhdGUgPSBTaWduYWxSZW5kZXJlci4jcmVuZGVyaW5nU3RhdGUuZ2V0KHNpZ25hbCk7XG4gICAgICAgICBpZiAoIXN0YXRlLmNvbnRhaW5lci5nZXRDaGlsZEJ5TmFtZSh0ZXh0dXJlTmFtZSkpIHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhpcyB0ZXh0dXJlIHdhcyBhbHJlYWR5IGRyYXduLiBTb21lIHRleHR1cmUgYXJlIHRoZSBzYW1lIGZvciBkaWZmZXJlbnQgc2lnbmFscyBsaWtlIFpzMSBhbmQgWnM4XG4gICAgICAgICAgICBsZXQgYm1wID0gd2luZG93LnBsLmdldFNwcml0ZShzaWduYWwuX3RlbXBsYXRlLmpzb25fZmlsZSwgdGV4dHVyZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGJtcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICBzdGF0ZS5jb250YWluZXIuYWRkQ2hpbGQoYm1wKTtcblxuICAgICAgICAgICAgICAgaWYgKGJsaW5rdCkge1xuICAgICAgICAgICAgICAgICAgc2lnbmFsLl9kb250Q2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY3JlYXRlanMuVHdlZW4uZ2V0KGJtcCwgeyBsb29wOiB0cnVlIH0pLndhaXQoMTAwMCkudG8oeyBhbHBoYTogMCB9LCAyMDApLndhaXQoODAwKS50byh7IGFscGhhOiAxIH0sIDUwKTtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgcmV0dXJuIGJtcDtcbiAgICAgICAgICAgIH0gZWxzZSBjb25zb2xlLmxvZyh0ZXh0dXJlTmFtZSArIFwiIG5pY2h0IGdlemVpY2huZXQsIGRhIHNwcml0ZSBmw7xyIFwiICsgdGV4dHVyZU5hbWUgKyBcIiBuaWNodCBlcnN0ZWxsdCB3dXJkZVwiKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgc3RhdGljIGRyYXdQcmV2aWV3KHRlbXBsYXRlLCBjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgLy8gQ3JlYXRlIGEgbWluaW1hbCBjb250ZXh0IGZvciBwcmV2aWV3IHJlbmRlcmluZ1xuICAgICAgY29uc3QgcHJldmlld0NvbnRleHQgPSB7XG4gICAgICAgICBfdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgX3NpZ25hbFN0ZWxsdW5nOiB7fSxcbiAgICAgICAgIGNoZWNrOiAoKSA9PiB0cnVlLCAvLyBGb3IgcHJldmlldywgYWx3YXlzIHNob3cgYWxsIGVsZW1lbnRzXG4gICAgICAgICBnZXQ6ICgpID0+IG51bGxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIFNpZ25hbFJlbmRlcmVyLiNyZW5kZXJpbmdTdGF0ZS5zZXQocHJldmlld0NvbnRleHQsIHsgY29udGFpbmVyIH0pO1xuICAgICAgLy8gVXNlIGV4aXN0aW5nIGRyYXdWaXN1YWxFbGVtZW50IGJ1dCB3aXRoIG91ciBwcmV2aWV3IGNvbnRleHRcbiAgICAgIHRlbXBsYXRlLmVsZW1lbnRzLmZvckVhY2godmUgPT4gXG4gICAgICAgICB0aGlzLmRyYXdWaXN1YWxFbGVtZW50KHByZXZpZXdDb250ZXh0LCB2ZSlcbiAgICAgICk7XG4gICAgICBTaWduYWxSZW5kZXJlci4jcmVuZGVyaW5nU3RhdGUuZGVsZXRlKHByZXZpZXdDb250ZXh0KTtcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNpZ25hbCB7XG4gICBzdGF0aWMgYWxsU2lnbmFscyA9IG5ldyBTZXQoKTtcblxuICAgc3RhdGljIHJlbW92ZVNpZ25hbChzKSB7XG4gICAgICBjb25zdCB0cmFjayA9IFRyYWNrLmFsbFRyYWNrcy5maW5kKCh0KSA9PiB0LnNpZ25hbHMuaW5jbHVkZXMocykpO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICB0cmFjay5yZW1vdmVTaWduYWwocyk7XG4gICAgICB9XG4gICAgICBTaWduYWwuYWxsU2lnbmFscy5kZWxldGUocyk7XG4gICB9XG5cbiAgIFxuXG4gICBfdGVtcGxhdGUgPSBudWxsO1xuICAgX3NpZ25hbFN0ZWxsdW5nID0ge307XG4gICBfcG9zaXRpb25pbmcgPSB7XG4gICAgICB0cmFjazogbnVsbCxcbiAgICAgIGttOiAwLFxuICAgICAgYWJvdmU6IGZhbHNlLFxuICAgICAgZmxpcHBlZDogZmFsc2UsXG4gICB9O1xuICAgX2NoYW5nZWQgPSBmYWxzZTtcbiAgIF9kb250Q2FjaGUgPSBmYWxzZTtcblxuICAgXG5cbiAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgdGhpcy5fcG9zaXRpb25pbmcgPSB7XG4gICAgICAgICB0cmFjazogbnVsbCxcbiAgICAgICAgIGttOiAwLFxuICAgICAgICAgYWJvdmU6IGZhbHNlLFxuICAgICAgICAgZmxpcHBlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBTaWduYWwuYWxsU2lnbmFscy5hZGQodGhpcyk7XG4gICAgICBpZiAodGVtcGxhdGUuaW5pdGlhbFNpZ25hbFN0ZWxsdW5nKSB0ZW1wbGF0ZS5pbml0aWFsU2lnbmFsU3RlbGx1bmcuZm9yRWFjaCgoaSkgPT4gdGhpcy5zZXRfc3RlbGx1bmcoaSwgdHJ1ZSwgZmFsc2UpKTtcbiAgIH1cblxuICAgZ2V0IHRpdGxlKCkge1xuICAgICAgbGV0IHRpdGxlID0gXCJcIjtcbiAgICAgIGlmICh0aGlzLmNoZWNrKFwiSFBzaWdcIikpXG4gICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0KFwidmVyd1wiKSkge1xuICAgICAgICAgICAgY2FzZSBcInpzaWdcIjpcbiAgICAgICAgICAgICAgIHRpdGxlICs9IFwiWnNpZ1wiO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXNpZ1wiOlxuICAgICAgICAgICAgICAgdGl0bGUgKz0gXCJFc2lnXCI7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhc2lnXCI6XG4gICAgICAgICAgICAgICB0aXRsZSArPSBcIkFzaWdcIjtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJrc2lnXCI6XG4gICAgICAgICAgICAgICB0aXRsZSArPSBcIkJrXCI7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzYmtcIjpcbiAgICAgICAgICAgICAgIHRpdGxlICs9IFwiU2JrXCI7XG4gICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuXG4gICAgICBjb25zdCBiZXogPSB0aGlzLmdldChcImJlelwiKTtcbiAgICAgIGlmIChiZXopIHRpdGxlICs9IChcIiBcIiArIGJleikucmVwbGFjZShcIi1cIiwgXCIgXCIpO1xuXG4gICAgICByZXR1cm4gdGl0bGU7XG4gICB9XG5cbiAgIC8vU2V0enQgZGllIFNpZ25hbHN0ZWxsdW5nLCAyIE3DtmdsaWNoa2VpdGVuOlxuICAgLy9zZXQoXCJ6czNcIiw2MClcbiAgIC8vc2V0KFwiaHBcIiwxKVxuICAgLy9vZGVyXG4gICAvL3NldChcImhwPTBcIilcbiAgIC8vc2V0KFwiZXJzYXR6PXpzN1wiKVxuICAgLy9zZXQoXCJocD0wLDFcIikgZGVyIFZhbHVlIGhhdCB2b3JyYW5nIHZvciBkZW0gaW4gc3RlbGx1bmcgZW50aGFsdGVuZW4gVmFsdWVcbiAgIC8vdmFsdWU9ZmFsc2Ugc2NoYWx0ZXQgZGllIFNpZ25hbHN0ZWxsdW5nIGF1ZiAtMSwgYWxzbyBhdXMuIFdpcmQgdm9tIE1lbsO8IHp1bSBhdXNzY2hhbHRlbiBlaW5lciBTaWduYWxzdGVsbHVuZyB2ZXJ3ZW5kZXRcbiAgIC8vY2hhaW49ZmFsc2UgdmVyaGluZGVydCwgZGFzcyBkYXMgU2lnbmFsIHZlcnN1Y2h0IGRhcyBkYXZvciB1bmQgZGFoaW50ZXJsaWVnZW5kZSBTaWduYWwgenUgaW5mb3JtaWVyZW5cbiAgIHNldF9zdGVsbHVuZyhjb21tYW5kLCBvdmVyaWRlVmFsdWUgPSB0cnVlLCBjaGFpbiA9IHRydWUpIHtcbiAgICAgIC8qIGlmIChzdWJrZXkgPT0gdW5kZWZpbmVkKSBbY29tbWFuZCwgc3Via2V5XSA9IGNvbW1hbmQuc3BsaXQoXCI9XCIpO1xuICAgICAgZWxzZSBbY29tbWFuZF0gPSBjb21tYW5kLnNwbGl0KFwiPVwiKTsgKi9cbiAgICAgIGxldCBzZXR0aW5nLCB2YWx1ZTtcbiAgICAgIFtzZXR0aW5nLCB2YWx1ZV0gPSBjb21tYW5kLnNwbGl0KFwiPVwiKTtcbiAgICAgIGlmIChvdmVyaWRlVmFsdWUgPT09IGZhbHNlKSB2YWx1ZSA9IG51bGw7IC8vZmFsc2Ugd291bGQgYmUgYmV0dGVyIGJ1dCBpbiBqYXZhc2NyaXB0IGhwPTAgYW5kIGhwPWZhbHNlIGlzIHRoZSBzYW1lXG4gICAgICBlbHNlIGlmICh2YWx1ZSA9PSB1bmRlZmluZWQpIHZhbHVlID0gb3ZlcmlkZVZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5nZXQoc2V0dGluZykgIT0gdmFsdWUpIHtcbiAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB0aGlzLl9zaWduYWxTdGVsbHVuZ1tzZXR0aW5nXSA9IG51bGw7XG4gICAgICAgICBlbHNlIGlmICghaXNOYU4odmFsdWUpKSB0aGlzLl9zaWduYWxTdGVsbHVuZ1tzZXR0aW5nXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICBlbHNlIHRoaXMuX3NpZ25hbFN0ZWxsdW5nW3NldHRpbmddID0gdmFsdWU7XG5cbiAgICAgICAgIHRoaXMuX2NoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvL1NpZ25hbCBpcyBhY3R1YWwgcG9zaXRpb25lZCBhdCBhIHRyYWNrIChlLmcuIFdoZW4gU2lnbmFsIGlzIGNyZWF0ZWQsIHRoZXJlIGlzbnQgYSB0cmFjayB5ZXQpXG4gICAgICAvL2FuZCB0aGUgc2lnbmFsIGluZGljYXRpb24gYWN0dWFseSBjaGFuZ2VkXG4gICAgICBpZiAodGhpcy5fcG9zaXRpb25pbmcudHJhY2sgJiYgdGhpcy5fY2hhbmdlZCAmJiBjaGFpbikge1xuICAgICAgICAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgICAgICAgIGlmICh0aGlzLmNoZWNrKFtcIkhQc2lnfHxtYXN0ZXJcIl0pKSB7XG4gICAgICAgICAgICBsZXQgcHJldlNpZ25hbCA9IHRoaXM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICBwcmV2U2lnbmFsID0gdGhpcy5zZWFyY2g0U2lnbmFsKHByZXZTaWduYWwsIHdpbmRvdy5ESVJFQ1RJT04uUklHSFRfMl9MRUZUKTtcbiAgICAgICAgICAgICAgIGlmIChwcmV2U2lnbmFsICYmIHByZXZTaWduYWwuX3RlbXBsYXRlLmNoZWNrU2lnbmFsRGVwZW5kZW5jeSlcbiAgICAgICAgICAgICAgICAgIHN0b3AgPSBwcmV2U2lnbmFsLl90ZW1wbGF0ZS5jaGVja1NpZ25hbERlcGVuZGVuY3kocHJldlNpZ25hbCwgdGhpcyk7XG4gICAgICAgICAgICB9IHdoaWxlICghc3RvcCAmJiBwcmV2U2lnbmFsKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmICh0aGlzLmNoZWNrKFtcIlZSc2lnfHxzbGF2ZVwiXSkgJiYgdGhpcy5fdGVtcGxhdGUuY2hlY2tTaWduYWxEZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICBsZXQgbmV4dFNpZ25hbCA9IHRoaXM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICBuZXh0U2lnbmFsID0gdGhpcy5zZWFyY2g0U2lnbmFsKG5leHRTaWduYWwsIHdpbmRvdy5ESVJFQ1RJT04uTEVGVF8yX1JJR1RIKTtcbiAgICAgICAgICAgICAgIGlmIChuZXh0U2lnbmFsICYmIG5leHRTaWduYWwuX3RlbXBsYXRlLmNoZWNrU2lnbmFsRGVwZW5kZW5jeSlcbiAgICAgICAgICAgICAgICAgIHN0b3AgPSBuZXh0U2lnbmFsLl90ZW1wbGF0ZS5jaGVja1NpZ25hbERlcGVuZGVuY3kodGhpcywgbmV4dFNpZ25hbCwgW1wiSFBzaWd8fG1hc3RlclwiXSk7XG4gICAgICAgICAgICB9IHdoaWxlICghc3RvcCAmJiBuZXh0U2lnbmFsKTtcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NoYW5nZWQpXG4gICAgICAgICB0aGlzLl90ZW1wbGF0ZS5ydWxlcy5mb3JFYWNoKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgICAgIGxldCB0cmlnZ2VyID0gcnVsZVswXTtcbiAgICAgICAgICAgICAgIGxldCBzaWduYWxfYXNwZWN0ID0gcnVsZVsxXTtcbiAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVjayhzaWduYWxfYXNwZWN0KSAmJiB0aGlzLmNoZWNrKHRyaWdnZXIpKSB0aGlzLnNldF9zdGVsbHVuZyhzaWduYWxfYXNwZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgKTtcbiAgIH1cblxuICAgLy9nZXQgdmFsdWUgZm9yIGEgc3BlY2lmaWMgU3RlbGx1bmdcbiAgIC8vZS5nLiBnZXQoXCJocFwiKSByZXR1cm5zIDAgZm9yIEhwIDBcbiAgIC8vY2FuIGJlIHVzZWQgbGlrZSB0aGlzOiBnZXQoXCJocFwiKSA+IDBcbiAgIGdldChzdGVsbHVuZykge1xuICAgICAgbGV0IHZhbHVlID0gdGhpcy5fc2lnbmFsU3RlbGx1bmdbc3RlbGx1bmddO1xuICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xuICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgIH1cblxuICAgc3RhdGljIF9zcGxpdEVxdWF0aW9uKGVxdWF0aW9uKSB7XG4gICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgIC8vdGhlIG9yZGVyIGlzIGltcG9ydGFudCwgb3RoZXJ3aXNlIGl0IHdvdWxkIGZpbmQgJz0nIGJlZm9yZSAnIT0nXG4gICAgICAvL2FuZCBPUiBpc3QgcHJpb3JpdGlzZWQgYmVmb3JlIEFORFxuICAgICAgY29uc3Qgb3BlcmF0b3JzID0gW1wifHxcIiwgXCImJlwiLCBcIiE9XCIsIFwiPD1cIiwgXCI+PVwiLCBcIj1cIiwgXCI+XCIsIFwiPFwiXTtcbiAgICAgIGxldCBwYXJ0cztcbiAgICAgIGZvciAobGV0IG9wIG9mIG9wZXJhdG9ycykge1xuICAgICAgICAgcGFydHMgPSBlcXVhdGlvbi5zcGxpdChvcCk7XG4gICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0Lm9wZXJhbmRzID0gcGFydHM7XG4gICAgICAgICAgICByZXQub3BlcmF0b3IgPSBvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJldC5vcGVyYXRvcikgcmV0dXJuIG51bGw7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICB9XG5cbiAgIC8vY2hlY2tzIGlmIGEgc3BlY2lmaWMgU3RlbGx1bmcgaXMgc2V0XG4gICAvL2UuZy4gZ2V0KFwiaHA9MFwiKSByZXR1cm5zIHRydWUgZm9yIEhwIDBcbiAgIGNoZWNrKHN0ZWxsdW5nKSB7XG4gICAgICBpZiAoc3RlbGx1bmcgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0ZWxsdW5nKSkgcmV0dXJuIHN0ZWxsdW5nLmV2ZXJ5KHRoaXMuY2hlY2suYmluZCh0aGlzKSk7XG5cbiAgICAgIGNvbnN0IGVxdWF0aW9uID0gU2lnbmFsLl9zcGxpdEVxdWF0aW9uKHN0ZWxsdW5nKTtcbiAgICAgIGlmIChlcXVhdGlvbiA9PSBudWxsKSByZXR1cm4gdGhpcy5nZXQoc3RlbGx1bmcpICE9IG51bGw7XG5cbiAgICAgIHN3aXRjaCAoZXF1YXRpb24ub3BlcmF0b3IpIHtcbiAgICAgICAgIGNhc2UgXCImJlwiOlxuICAgICAgICAgICAgcmV0dXJuIGVxdWF0aW9uLm9wZXJhbmRzLmV2ZXJ5KHRoaXMuY2hlY2ssIHRoaXMpO1xuICAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgICByZXR1cm4gZXF1YXRpb24ub3BlcmFuZHMuc29tZSh0aGlzLmNoZWNrLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSB0aGlzLmdldChlcXVhdGlvbi5vcGVyYW5kc1swXS50cmltKCkpO1xuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIGRhdGEgPSBcIm51bGxcIjtcbiAgICAgIGlmIChlcXVhdGlvbi5vcGVyYXRvciA9PSBcIj1cIikgcmV0dXJuIGRhdGEgPT0gZXF1YXRpb24ub3BlcmFuZHNbMV0udHJpbSgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgICBjb25zdCByaWdodCA9IE51bWJlci5wYXJzZUludChlcXVhdGlvbi5vcGVyYW5kc1sxXS50cmltKCkpO1xuICAgICAgICAgaWYgKGVxdWF0aW9uLm9wZXJhdG9yID09IFwiPFwiKSByZXR1cm4gZGF0YSA8IHJpZ2h0O1xuICAgICAgICAgZWxzZSBpZiAoZXF1YXRpb24ub3BlcmF0b3IgPT0gXCI8PVwiKSByZXR1cm4gZGF0YSA8PSByaWdodDtcbiAgICAgICAgIGVsc2UgaWYgKGVxdWF0aW9uLm9wZXJhdG9yID09IFwiPj1cIikgcmV0dXJuIGRhdGEgPj0gcmlnaHQ7XG4gICAgICAgICBlbHNlIGlmIChlcXVhdGlvbi5vcGVyYXRvciA9PSBcIj5cIikgcmV0dXJuIGRhdGEgPiByaWdodDtcbiAgICAgICAgIGVsc2UgaWYgKGVxdWF0aW9uLm9wZXJhdG9yID09IFwiIT1cIikgcmV0dXJuIGRhdGEgIT0gcmlnaHQ7XG4gICAgICB9XG4gICB9XG5cbiAgIGRyYXcoYywgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgU2lnbmFsUmVuZGVyZXIuZHJhdyh0aGlzLCBjLCBmb3JjZSk7XG4gICB9XG5cbiAgIHNlYXJjaDRTaWduYWwoc2lnbmFsLCBkaXIsIGZlYXR1cmUpIHtcbiAgICAgIGlmIChzaWduYWwuX3Bvc2l0aW9uaW5nLmFib3ZlICE9IHNpZ25hbC5fcG9zaXRpb25pbmcuZmxpcHBlZCkgZGlyICo9IC0xO1xuXG4gICAgICBsZXQgdHJhY2sgPSBzaWduYWwuX3Bvc2l0aW9uaW5nLnRyYWNrO1xuICAgICAgbGV0IGluZGV4ID0gdHJhY2suc2lnbmFscy5pbmRleE9mKHNpZ25hbCkgKyBkaXI7XG4gICAgICBsZXQgc3cgPSBudWxsO1xuXG4gICAgICAvL2Z1bmN0aW9uIGNoZWNrcywgaWYgdGhpcyBzaWduYWwgYW5kIHRoZSBnaXZlbiBzaWduYWwgYmVsb25nIHRvZ2V0aGVyXG4gICAgICAvKiBhYm92ZSBmbGlwcGVkIGFib3ZlIGZsaXBwZWQgcmVzdWx0XG4gICAgICAgIDAgICBcdDBcdCAgICAwICAgXHQwICAgXHQxXG4gICAgICAgIDBcdCAgICAxXHQgICAgMCAgIFx0MCAgIFx0MFxuICAgICAgICAwICAgXHQwICAgXHQwICAgXHQxICAgXHQwXG4gICAgICAgIDAgICBcdDFcdCAgICAwICAgXHQxXHQgICAgMVxuICAgICAgICAxICAgXHQwICAgXHQwICAgXHQwICAgXHQwXG4gICAgICAgIDAgICBcdDAgICBcdDEgICBcdDAgICBcdDBcbiAgICAgICAgMSAgIFx0MCAgIFx0MSAgIFx0MCAgIFx0MVxuICAgICAgICAwICAgXHQwICAgXHQxXHQgICAgMSAgIFx0MVxuICAgICAgICAxICAgXHQxICAgXHQwXHQgICAgMFx0ICAgIDFcbiAgICAgICAgMCAgIFx0MSAgIFx0MVx0ICAgIDAgICBcdDFcbiAgICAgICAgMSAgIFx0MCAgIFx0MCAgIFx0MVx0ICAgIDFcbiAgICAgICAgMSAgIFx0MSAgIFx0MSAgIFx0MCAgIFx0MFxuICAgICAgICAwICAgXHQxXHQgICAgMSAgIFx0MVx0ICAgIDBcbiAgICAgICAgMSAgIFx0MVx0ICAgIDEgICBcdDFcdCAgICAxIFxuICAgICAgICB0aGUgaGFjayBpcywgdGhhdCB3ZWhlbiBhbGwgYWJvdmUgYW5kIGZsaXBwZWQgYXJlIGFkZGVkLCB0aGUgbnVtYmVyIGlzIGV2ZW4gaWYgdGhleSBiZWxvbmcgdG9nZXRoZXIqL1xuICAgICAgY29uc3QgY2hlY2sgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKE51bWJlcihzaWduYWwuX3Bvc2l0aW9uaW5nLmFib3ZlKSArIE51bWJlcihzaWduYWwuX3Bvc2l0aW9uaW5nLmZsaXBwZWQpICsgTnVtYmVyKHBvcy5mbGlwcGVkKSArIE51bWJlcihwb3MuYWJvdmUpKSAlXG4gICAgICAgICAgICAgICAyID09XG4gICAgICAgICAgICAwXG4gICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZ2V0VHJhY2tBdEJyYW5jaCA9IGZ1bmN0aW9uIChzdywgdHJhY2spIHtcbiAgICAgICAgIGlmICh0cmFjayA9PSBzdy5mcm9tKSByZXR1cm4gc3cuYnJhbmNoO1xuICAgICAgICAgaWYgKHRyYWNrID09IHN3LmJyYW5jaCkgcmV0dXJuIHN3LmZyb207XG5cbiAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHRyYWNrKSB7XG4gICAgICAgICB3aGlsZSAoZGlyID09IDEgPyBpbmRleCA+PSAwICYmIGluZGV4IDwgdHJhY2suc2lnbmFscy5sZW5ndGggOiBpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgbmV4dFNpZ25hbCA9IHRyYWNrLnNpZ25hbHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5leHRTaWduYWwuY2hlY2soZmVhdHVyZSkgJiYgY2hlY2sobmV4dFNpZ25hbC5fcG9zaXRpb25pbmcpKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpZ25hbDsgLy9oYXVwdHNpZ25hbCBnZWZ1bmRlblxuICAgICAgICAgICAgfSBlbHNlIGluZGV4ID0gaW5kZXggKyBkaXI7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICgoc3cgPSB0cmFjay5zd2l0Y2hlc1tkaXIgPT0gMSA/IDEgOiAwXSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlKHN3KSA9PSBcIlRyYWNrXCIpIHRyYWNrID0gc3c7XG4gICAgICAgICAgICBlbHNlIHRyYWNrID0gZ2V0VHJhY2tBdEJyYW5jaChzdywgdHJhY2spO1xuXG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgIGluZGV4ID0gdHJhY2suc2lnbmFscy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgaWYgKGRpciA9PSBESVJFQ1RJT04uTEVGVF8yX1JJR1RIKSBpbmRleCA9IE1hdGgubWluKDAsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSB0cmFjayA9IG51bGw7XG4gICAgICB9XG4gICB9XG5cbiAgIHNldFRyYWNrKHRyYWNrLGttKSB7XG4gICAgICBpZiAodGhpcy5fcG9zaXRpb25pbmcudHJhY2spIHtcbiAgICAgICAgIEFycmF5VXRpbHMucmVtb3ZlKHRoaXMuX3Bvc2l0aW9uaW5nLnRyYWNrLnNpZ25hbHMsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcG9zaXRpb25pbmcudHJhY2sgPSB0cmFjaztcbiAgICAgIHRoaXMuX3Bvc2l0aW9uaW5nLmttID0ga207XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgIHRyYWNrLnNpZ25hbHMucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgIH1cblxuICAgc3RyaW5naWZ5KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIF9jbGFzczogXCJTaWduYWxcIixcbiAgICAgICAgIF90ZW1wbGF0ZTogZmluZEZpZWxkTmFtZUZvck9iamVjdCh3aW5kb3cuc2lnbmFsVGVtcGxhdGVzLCB0aGlzLl90ZW1wbGF0ZSksXG4gICAgICAgICBfc2lnbmFsU3RlbGx1bmc6IHRoaXMuX3NpZ25hbFN0ZWxsdW5nLFxuICAgICAgICAgX3Bvc2l0aW9uaW5nOiB7XG4gICAgICAgICAgICBrbTogdGhpcy5fcG9zaXRpb25pbmcua20sXG4gICAgICAgICAgICBhYm92ZTogdGhpcy5fcG9zaXRpb25pbmcuYWJvdmUsXG4gICAgICAgICAgICBmbGlwcGVkOiB0aGlzLl9wb3NpdGlvbmluZy5mbGlwcGVkLFxuICAgICAgICAgfSxcbiAgICAgIH07XG4gICB9XG5cbiAgIHN0YXRpYyBGcm9tT2JqZWN0KG8pIHtcbiAgICAgIGxldCBzID0gbmV3IFNpZ25hbCh3aW5kb3cuc2lnbmFsVGVtcGxhdGVzW28uX3RlbXBsYXRlXSk7ICAgICAgXG4gICAgICBzLl9zaWduYWxTdGVsbHVuZyA9IG8uX3NpZ25hbFN0ZWxsdW5nO1xuICAgICAgcy5fcG9zaXRpb25pbmcgPSBvLl9wb3NpdGlvbmluZztcbiAgICAgIHJldHVybiBzO1xuICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2lnX1VJID0ge1xuICAgY3JlYXRlX1NwZWVkRHJvcERvd24oc2lnbmFsLCB0ZXh0LCBvbkNoYW5nZSkge1xuICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCAoXywgaSkgPT4gYCR7aX0wfCR7c2lnbmFsfT0ke2l9YCk7XG4gICAgICBpdGVtc1swXSA9IGBhdXN8JHtzaWduYWx9PS0xYDtcbiAgICAgIHJldHVybiB1aS5jcmVhdGVfRHJvcERvd24oaXRlbXMsIHRleHQsIG9uQ2hhbmdlKTtcbiAgIH0sXG4gICBpbml0U2lnbmFsTWVudSgpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB3aW5kb3cuc2VsZWN0aW9uLm9iamVjdC5fdGVtcGxhdGUuZ2V0QWxsVmlzdWFsRWxlbWVudENvbmRpdGlvbnMoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IGZ1bmN0aW9uIChjb21tYW5kLCBpc09uKSB7XG4gICAgICAgICB3aW5kb3cuc2VsZWN0aW9uLm9iamVjdC5zZXRfc3RlbGx1bmcoY29tbWFuZCwgaXNPbik7XG4gICAgICAgICBTaWdfVUkuc3luY1NpZ25hbE1lbnUod2luZG93LnNlbGVjdGlvbi5vYmplY3QpO1xuICAgICAgICAgd2luZG93LnJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcoKTtcbiAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgfTtcbiAgICAgICQoXCIjYnRuUmVtb3ZlU2lnbmFsXCIpLmNsaWNrKChlKSA9PiB3aW5kb3cuZGVsZXRlU2VsZWN0ZWRPYmplY3QoKSk7XG4gICAgICAkKFwiI25hdkZlYXR1cmVzXCIpLmVtcHR5KCk7XG4gICAgICAgICAgICAgICBpZiAod2luZG93LnNlbGVjdGlvbi5vYmplY3QuY2hlY2soXCJIUHNpZ1wiKSlcbiAgICAgICAgICQoXCIjbmF2RmVhdHVyZXNcIikuYXBwZW5kKFxuICAgICAgICAgICAgdWkuZGl2KFxuICAgICAgICAgICAgICAgXCJwLTMgYm9yZGVyLWJvdHRvbVwiLFxuICAgICAgICAgICAgICAgdWkuY3JlYXRlX0Ryb3BEb3duKFxuICAgICAgICAgICAgICAgICAgXCJFc2lnLEFzaWcsWnNpZyxCa3NpZyxTYmtcIi5zcGxpdChcIixcIikubWFwKCh4KSA9PiB4ICsgXCJ8dmVydz1cIiArIHgudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICAgICAgICBcIlZlcndlbmR1bmdcIixcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVxuICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgKTtcbiAgICAgICQoXCIjbmF2RmVhdHVyZXNcIikuYXBwZW5kKFxuICAgICAgICAgdWkuY3JlYXRlU3dpdGNoU3RydWN0dXJlKFxuICAgICAgICAgICAgW1wiVm9yc2lnbmFsZnVua3Rpb25cIiwgXCJWUnNpZ1wiLCBjb25kaXRpb25zLmluY2x1ZGVzKFwiVlJzaWdcIildLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgLi4uKGNvbmRpdGlvbnMuaW5jbHVkZXMoXCJ2cl9vcD12ZXJrXCIpID8gW1tcInZlcmvDvHJ6dFwiLCBcInZyX29wPXZlcmtcIl1dIDogW10pLFxuICAgICAgICAgICAgICAgLi4uKGNvbmRpdGlvbnMuaW5jbHVkZXMoXCJ2cl9vcD13ZGhcIikgPyBbW1wid2llZGVyaG9sZXJcIiwgXCJ2cl9vcD13ZGhcIl1dIDogW10pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHVwZGF0ZVxuICAgICAgICAgKT8uYWRkQ2xhc3MoXCJwLTMgYm9yZGVyLWJvdHRvbVwiKVxuICAgICAgKTtcbiAgICAgIGlmIChjb25kaXRpb25zLmluY2x1ZGVzKFwibWFzdHNjaGlsZD13cndcIikgJiYgY29uZGl0aW9ucy5pbmNsdWRlcyhcIm1hc3RzY2hpbGQ9d2d3Z3dcIikpXG4gICAgICAgICAkKFwiI25hdkZlYXR1cmVzXCIpLmFwcGVuZChcbiAgICAgICAgICAgIHVpLmNyZWF0ZU9wdGlvbkdyb3VwKFxuICAgICAgICAgICAgICAgXCJNYXN0c2NoaWxkXCIsXG4gICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBbXCJXLVItV1wiLCBcIm1hc3RzY2hpbGQ9d3J3XCJdLFxuICAgICAgICAgICAgICAgICAgW1wiVy1HLVctRy1XXCIsIFwibWFzdHNjaGlsZD13Z3dnd1wiXSxcbiAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICBcInJhZGlvXCIsXG4gICAgICAgICAgICAgICB1cGRhdGVcbiAgICAgICAgICAgICkuYWRkQ2xhc3MoXCJwLTMgYm9yZGVyLWJvdHRvbVwiKVxuICAgICAgICAgKTtcbiAgICAgIGlmIChjb25kaXRpb25zLmluY2x1ZGVzKFwienVzYXR6X3VudGVuXCIpIHx8IGNvbmRpdGlvbnMuaW5jbHVkZXMoXCJ6dXNhdHpfb2JlblwiKSkge1xuICAgICAgICAgY29uc3QgYSA9IFtcbiAgICAgICAgICAgIFtcInVudGVuXCIsIFwienVzYXR6X3VudGVuXCJdLFxuICAgICAgICAgICAgW1wib2JlblwiLCBcInp1c2F0el9vYmVuXCJdLFxuICAgICAgICAgXTtcbiAgICAgICAgIGEuZm9yRWFjaCgoeCkgPT4geC5wdXNoKGNvbmRpdGlvbnMuaW5jbHVkZXMoeFsxXSkpKTtcblxuICAgICAgICAgJChcIiNuYXZGZWF0dXJlc1wiKS5hcHBlbmQodWkuY3JlYXRlT3B0aW9uR3JvdXAoXCJadXNhdHphbnplaWdlclwiLCBhLCBcImNoZWNrYm94XCIsIHVwZGF0ZSkuYWRkQ2xhc3MoXCJwLTMgYm9yZGVyLWJvdHRvbVwiKSk7XG4gICAgICB9XG4gICB9LFxuICAgc3luY1NpZ25hbE1lbnUoc2lnbmFsKSB7XG4gICAgICAvL2hlYWRlclxuICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciAuY2FyZC10aXRsZVwiKS50ZXh0KHNpZ25hbC5fdGVtcGxhdGUudGl0bGUpO1xuICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciAuY2FyZC10ZXh0PnNwYW5cIikudGV4dChzaWduYWwudGl0bGUpO1xuICAgICAgLy9mZWF0dXJlIE1lbnVcbiAgICAgICQoXCIjbmF2RmVhdHVyZXM+ZGl2IGFcIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICBjb25zdCAkYSA9ICQodGhpcyk7XG4gICAgICAgICAkYS50b2dnbGVDbGFzcyhcImFjdGl2ZVwiLCBzaWduYWwuY2hlY2soJGEuYXR0cihcInZhbHVlXCIpKSk7XG4gICAgICB9KTtcblxuICAgICAgJChcIiNuYXZGZWF0dXJlcz5kaXYgaW5wdXRcIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICBjb25zdCBpbnB1dCA9ICQodGhpcyk7XG4gICAgICAgICBjb25zdCB2ID0gc2lnbmFsLmNoZWNrKGlucHV0LmF0dHIoXCJ2YWx1ZVwiKSk7XG4gICAgICAgICBpbnB1dC5wcm9wKFwiY2hlY2tlZFwiLCB2ID8gXCJjaGVja2VkXCIgOiBudWxsKTtcbiAgICAgICAgIGlmIChpbnB1dC5hdHRyKFwiZGF0YS1tYXN0ZXJfc3dpdGNoXCIpICE9IG51bGwpICQoXCJpbnB1dFwiLCBpbnB1dC5wYXJlbnQoKS5uZXh0KCkpLnByb3AoXCJkaXNhYmxlZFwiLCAhdik7XG4gICAgICB9KTtcbiAgIH0sXG5cbiAgIGdldEhUTUwoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLl90ZW1wbGF0ZS5zaWduYWxNZW51Py5sZW5ndGgpIHtcbiAgICAgICAgIGNvbnN0IHVsID0gdWkuZGl2KFwiZC1mbGV4IGZsZXgtY29sdW1uIGJkLWhpZ2hsaWdodCBtYi0zXCIpO1xuXG4gICAgICAgICBjb25zdCB1cGRhdGVGdW5jID0gZnVuY3Rpb24gKGNvbW1hbmQsIGFjdGl2ZSkge1xuICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhjb21tYW5kLCAhYWN0aXZlKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKCk7XG4gICAgICAgICAgICB3aW5kb3cuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICBTaWdfVUkuY2hlY2tCb290c3RyYXBNZW51KHNpZ25hbCwgc2lnbmFsLl90ZW1wbGF0ZS5zaWduYWxNZW51LCB1bCk7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgIH07XG5cbiAgICAgICAgIHVsLmFwcGVuZChzaWduYWwuX3RlbXBsYXRlLnNpZ25hbE1lbnUubWFwKChkYXRhKSA9PiBTaWdfVUkuY3JlYXRlQm9vdHN0cmFwTWVudUl0ZW1zKHNpZ25hbCwgZGF0YSwgdXBkYXRlRnVuYykpKTtcblxuICAgICAgICAgU2lnX1VJLmNoZWNrQm9vdHN0cmFwTWVudShzaWduYWwsIHNpZ25hbC5fdGVtcGxhdGUuc2lnbmFsTWVudSwgdWwpO1xuXG4gICAgICAgICByZXR1cm4gdWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgIH0sXG5cbiAgIGNyZWF0ZUJvb3RzdHJhcE1lbnVJdGVtcyhzaWduYWwsIG1lbnVfaXRlbSwgdXBkYXRlKSB7XG4gICAgICBpZiAobWVudV9pdGVtKSB7XG4gICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtZW51X2l0ZW0pKSB7XG4gICAgICAgICAgICBsZXQgaXRlbXMgPSBBcnJheVV0aWxzLmNsZWFuVXAobWVudV9pdGVtLm1hcCgoaXRlbSkgPT4gU2lnX1VJLmNyZWF0ZUJvb3RzdHJhcE1lbnVJdGVtcyhzaWduYWwsIGl0ZW0sIHVwZGF0ZSkpKTtcbiAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgcmV0dXJuIHVpLmRpdihcInAtMyBib3JkZXItYm90dG9tXCIsIHVpLmNyZWF0ZV9idXR0b25Ub29sYmFyKGl0ZW1zKSk7XG4gICAgICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgICB9IGVsc2UgaWYgKG1lbnVfaXRlbS50eXBlID09IFwiYnV0dG9uR3JvdXBcIiB8fCBtZW51X2l0ZW0udHlwZSA9PSBcImJ0blwiKSB7XG4gICAgICAgICAgICBsZXQgYnV0dG9ucyA9IG1lbnVfaXRlbS50eXBlID09IFwiYnV0dG9uR3JvdXBcIiA/IG1lbnVfaXRlbS5pdGVtcyA6IFttZW51X2l0ZW1dO1xuICAgICAgICAgICAgYnV0dG9ucyA9IGJ1dHRvbnNcbiAgICAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAobWkpID0+XG4gICAgICAgICAgICAgICAgICAgICBtaS52aXN1YWxfZWxlbWVudHM/Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIG1pLnZpc3VhbF9lbGVtZW50cy5ldmVyeSgodmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbiA9IHZlLm9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbi5pbmNsdWRlcyhtaS5jb21tYW5kKSkgb24gPSBvbi50b1NwbGljZWQob24uaW5kZXhPZihtaS5jb21tYW5kKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9uID09IG1pLmNvbW1hbmQpIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsLmNoZWNrKG9uKTtcbiAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PlxuICAgICAgICAgICAgICAgICAgdWlcbiAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVfdG9nZ2xlQnV0dG9uKGl0ZW0udGV4dCwgaXRlbS5jb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgKGUpID0+IHVwZGF0ZS5iaW5kKHNpZ25hbCkoaXRlbS5jb21tYW5kLCAkKGUudGFyZ2V0KS5oYXNDbGFzcyhcImFjdGl2ZVwiKSkpXG4gICAgICAgICAgICAgICApXG4gICAgICAgICAgICBidXR0b25zID0gQXJyYXlVdGlscy5jbGVhblVwKGJ1dHRvbnMpO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbnMpIHJldHVybiB1aS5jcmVhdGVfYnV0dG9uR3JvdXAoYnV0dG9ucyk7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICAgfSBlbHNlIGlmIChtZW51X2l0ZW0udHlwZSA9PSBcImRyb3Bkb3duXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBTaWdfVUkuY3JlYXRlX1NwZWVkRHJvcERvd24obWVudV9pdGVtLmNvbW1hbmQsIG1lbnVfaXRlbS50ZXh0LCB1cGRhdGUuYmluZChzaWduYWwpKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH0sXG5cbiAgIGNoZWNrQm9vdHN0cmFwTWVudShzaWduYWwsIGRhdGEsIHBvcHVwKSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgoaXRlbSkgPT4gU2lnX1VJLmNoZWNrQm9vdHN0cmFwTWVudShzaWduYWwsIGl0ZW0sIHBvcHVwKSk7XG4gICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PSBcImJ1dHRvbkdyb3VwXCIpIHtcbiAgICAgICAgICAgIGRhdGEuaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgbGV0IGJ1dHRvbiA9ICQoXCIjYnRuX1wiICsgaXRlbS50ZXh0LnJlcGxhY2UoXCIgXCIsIFwiX1wiKSwgcG9wdXApO1xuICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgYnV0dG9uLnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIsIHNpZ25hbC5jaGVjayhpdGVtLmNvbW1hbmQpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnZpc3VhbF9lbGVtZW50cy5ldmVyeSgodmUpID0+IHZlLmlzQWxsb3dlZChzaWduYWwpKSkgYnV0dG9uLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgYnV0dG9uLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PSBcImRyb3Bkb3duXCIpIHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSAkKFwiI2J0bl9cIiArIGRhdGEudGV4dC5yZXBsYWNlKFwiIFwiLCBcIl9cIiksIHBvcHVwKTtcbiAgICAgICAgICAgIGlmIChidXR0b24ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzaWduYWwuZ2V0KGRhdGEuY29tbWFuZCk7XG4gICAgICAgICAgICAgICBidXR0b24udGV4dChkYXRhLnRleHQgKyAodiA+IDAgPyBcIiBLeiBcIiArIHYgOiBcIiBhdXNcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT0gXCJidG5cIikge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9ICQoXCIjYnRuX1wiICsgZGF0YS50ZXh0LnJlcGxhY2UoXCIgXCIsIFwiX1wiKSwgcG9wdXApO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbi5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgYnV0dG9uLnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIsIHNpZ25hbC5jaGVjayhkYXRhLmNvbW1hbmQpKTtcbiAgICAgICAgICAgICAgIGlmIChkYXRhLnZpc3VhbF9lbGVtZW50cy5ldmVyeSgodmUpID0+IHZlLmlzQWxsb3dlZChzaWduYWwpKSkgYnV0dG9uLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgIGVsc2UgYnV0dG9uLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfSxcbn07XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/signal.js\n\n}");

/***/ }),

/***/ "./www/code/signal_library.js":
/*!************************************!*\
  !*** ./www/code/signal_library.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONDITIONS: () => (/* binding */ CONDITIONS),\n/* harmony export */   initSignals: () => (/* binding */ initSignals)\n/* harmony export */ });\n/* harmony import */ var _signaling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signaling.js */ \"./www/code/signaling.js\");\n\n\n// ES6 Module imports\n\n\nconst CONDITIONS = (function () {\n   const BKsig = \"verw=bksig\",\n      SBK = \"verw=sbk\",\n      Esig = \"verw=esig\",\n      Asig = \"verw=asig\",\n      Zsig = \"verw=zsig\",\n      STRECKE = [BKsig, SBK, Esig],\n      GRENZEN = [BKsig, Esig],\n      BAHNHOF = [Asig, Zsig];\n   return { BKsig, SBK, Esig, Asig, Zsig, STRECKE, GRENZEN, BAHNHOF };\n})();\n\nfunction initSignals(signalTemplatesRef) {\n   // Use the passed signalTemplates reference instead of a module-level variable\n   const signalTemplates = signalTemplatesRef;\n   const lightMenu = [\n      [\"hp=0,hp=1,hp=2\", \"zs3\"],\n      [\"vr=0,vr=1,vr=2\", \"verk=1(verk)\", \"zs3v\"],\n      \"ersatz=zs1,ersatz=zs7,ersatz=zs8,ersatz=sh1,ersatz=kennlicht\",\n      \"zs6=1(Zs 6)\",\n   ];\n\n   //signal: ist das signal, dessen Stellung wir gerade setzen\n   //hp: ist das signal, dessen Stellung wir vorsignalisieren wollen\n   const checkSignalDependencyFunction4HV = function (signal, hp) {\n      //make sure we only handle main signals\n      if (!hp.check(\"HPsig\") || !signal.check(\"VRsig\")) return;\n      let stop_propagation = false;\n\n      //-1 heißt, die Vorsignalfunktion ist vom User ausgeschaltet\n      if (signal.get(\"vr\") != -1) {\n         //Das Hauptsignal zeigt nicht Hp 0 oder es ist ein alleinstehndes Vorsignal\n         if (!signal.check(\"HPsig\") || signal.get(\"hp\") != 0) {\n            switch (hp._template.id) {\n               case \"Hv77\":\n               case \"hv_hp\":\n               case \"hv_vr\":\n                  {\n                     signal.set_stellung(\"vr\", hp.get(\"hp\") >= 0 ? hp.get(\"hp\") : 0, false);\n                     if (!signal.check(\"vr_op=wdh\")) stop_propagation = true;\n                  }\n                  break;\n               case \"Hl\":\n               case \"ks\":\n               case \"ks_vr\":\n                  {\n                     signal.set_stellung(\"vr\", hp.get(\"hp\") <= 0 ? 0 : 1, false);\n                     if (!signal.check(\"vr_op=wdh\")) stop_propagation = true;\n                  }\n                  break;\n            }\n\n            if (hp.get(\"zs3\") == 4) {\n               signal.set_stellung(\"zs3v\", 0, false);\n\n               if (signal.get(\"vr\") > 0) signal.set_stellung(\"vr\", 2, false);\n            } else signal.set_stellung(\"zs3v\", hp.get(\"zs3\"), false);\n\n            //if (hp.get(\"zs3\").between(1,6) && hp.get(\"hp\") > 0) signal.set_stellung(\"vr\", 2, false);\n         }\n      }\n\n      return stop_propagation;\n   };\n\n   let t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"hv_hp\",\n      \"Hv Hauptsignal\",\n      \"hv\",\n      [\n         \"mast,hp_schirm\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"wrw\").on(\"mastschild=wrw\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"wgwgw\").on(\"mastschild=wgwgw\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_lichtp\").on(CONDITIONS.BAHNHOF),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_lichtp_unten\").on(CONDITIONS.STRECKE),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_lichtp_oben\").on(CONDITIONS.GRENZEN),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=0\")\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_rot_re\").on(CONDITIONS.BAHNHOF).off(\"ersatz=sh1\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_rot_li\").on(CONDITIONS.BAHNHOF),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_rot_unten_li\").on(CONDITIONS.STRECKE),\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=1\")\n            .off(\"zs3<=6 && zs3>0\") //used by UI to disable the corospoding button\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_gr\").on(CONDITIONS.BAHNHOF),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_gr_unten_re\").on(CONDITIONS.SBK),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_gr_oben_re\").on(CONDITIONS.GRENZEN),\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=2\")\n            .off(\"zs3>6\") //used by UI to disable the corospoding button\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_gelb,hp_asig_gr\").on(CONDITIONS.BAHNHOF),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_gelb_unten_re,hp_bk_gr_oben_re\").on(CONDITIONS.GRENZEN),\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_schuten\").on(CONDITIONS.BAHNHOF),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_schute_unten\").on(CONDITIONS.STRECKE),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_schute_oben\").on(CONDITIONS.GRENZEN),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"VRsig\")\n            .childs([\n               \"vr_schirm\",\n               \"vr_lichtp\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_schirm,vr_zusatz_lichtp\").on(\"vr_op=verk\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_licht\").on(\"vr_op=verk\").on(\"verk=1\").off(\"hp=0\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n                  .off(\"hp=0\")\n                  .childs([\n                     new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_gelb_oben,vr_gelb_unten\").on(\"vr=0\"),\n                     new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_grün_oben,vr_grün_unten\").on(\"vr=1\"),\n                     new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_gelb_unten,vr_grün_oben\").on(\"vr=2\"),\n                  ]),\n               \"vr_schuten\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_schute\").on(\"vr_op=verk\"),\n            ]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(CONDITIONS.BAHNHOF)\n            .childs([\n               \"hp_asig_kennlicht_lichtp\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_kennlicht_licht\").on(\"ersatz=kennlicht\").off(\"hp>=0\"),\n               \"hp_asig_kennlicht_schute\",\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(CONDITIONS.BAHNHOF)\n            .childs([\n               \"hp_asig_sh1_lichtp\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_sh1_licht\").on(\"ersatz=sh1\").off(\"hp>0\"),\n               \"hp_asig_sh1_schute\",\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Asig, CONDITIONS.Zsig, CONDITIONS.SBK])\n            .childs([\"hp_zs1_lichtp\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_zs1_licht\").on(\"ersatz=zs1\").off(\"hp>0\"), \"hp_zs1_schuten\"]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Esig, CONDITIONS.Zsig])\n            .childs([\"hp_zs7_lichtp\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_zs7_licht\").on(\"ersatz=zs7\").off(\"hp>0\"), \"hp_zs7_schuten\"]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Asig, CONDITIONS.BKsig])\n            .childs([\n               \"hp_zs1_lichtp\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_zs1_licht\").on(\"ersatz=zs8\").off(\"hp>0\").blinkt(true),\n               \"hp_zs1_schuten\",\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3>0\")\n            .off(\"zs3=40||zusatz_oben\")\n            .childs([\"zs3\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [80, \"Arial\", 1]).pos([115, 80])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3v>0\")\n            .off(\"zusatz_unten\")\n            .childs([\"zs3v\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [80, \"Arial\", 1], \"#ffde36\").pos([115, 890])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3_licht\")\n            .on(\"zusatz_oben\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [60,\"DOT\"]).pos([120, 78]).on(\"zs3>0\").off(\"hp<=0\")]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3v_licht\")\n            .on(\"zusatz_unten\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [60,\"DOT\"], \"#ffde36\").pos([120, 885]).on(\"zs3v>0\").off(\"hp<=0\")]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Asig, CONDITIONS.BKsig])\n            .on(\"zs6=1\")\n            .off(\"zs3v>0\")\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs6_blech_unten\").off(\"zusatz_unten\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs6_licht_unten\").on(\"zusatz_unten\").on(\"hp>0\"),\n            ]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"schild\").on(\"bez\").childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"bez\", [55,\"condenced\",1], \"#333\").pos([116, 1033]).bounds([52,63])]),\n         ,\n      ],\n      [\"hp=0\", \"vr=0\", \"HPsig\", \"verw=asig\", \"mastschild=wrw\"]\n   );\n   t.scale = 0.15;\n   t.previewsize = 20;\n   t.distance_from_track = 5;\n   t.checkSignalDependency = checkSignalDependencyFunction4HV;\n   t.addRule(\"hp>0 && zs3>6\", \"hp=1\");\n   t.addRule(\"hp>0 && zs3<=6 && zs3>0\", \"hp=2\");\n   t.createSignalCommandMenu(lightMenu);\n   signalTemplates.hv_hp = t;\n\n   t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"hv_vr\",\n      \"Hv Vorsignal\",\n      \"hv\",\n      [\n         \"mast,vr_schirm,vr_lichtp\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ne2\").off(\"vr_op=wdh\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_schirm,vr_zusatz_lichtp\").on([\"vr_op=verk\", \"vr_op=wdh\"]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_licht\").on(\"vr_op=verk\").on(\"verk=1\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_licht\").on(\"vr_op=wdh\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement().childs([\n            new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_gelb_oben,vr_gelb_unten\").on(\"vr=0\"),\n            new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_grün_oben,vr_grün_unten\").on(\"vr=1\"),\n            new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_gelb_unten,vr_grün_oben\").on(\"vr=2\"),\n         ]),\n         \"vr_schuten\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_schute\").on(\"vr_op=verk\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3v>0\")\n            .off(\"zusatz_unten\")\n            .childs([\"zs3v\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [80, \"Arial\", 1], \"#ffde36\").pos([115, 890])]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3v_licht\")\n            .on(\"zusatz_unten\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [60,\"DOT\"], \"#ffde36\").pos([120, 885]).on(\"zs3v>0\")]),\n      ],\n      [\"vr=0\", \"VRsig\"]\n   );\n   t.scale = 0.15;\n   t.distance_from_track = 4;\n   t.checkSignalDependency = checkSignalDependencyFunction4HV;\n   t.createSignalCommandMenu([\"vr=0,vr=1,vr=2\", \"verk=1(verk)\", \"zs3v\"]);\n   signalTemplates.hv_vr = t;\n\n   //KS Hauptsignal\n   t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"ks\",\n      \"Ks Hauptsignal\",\n      \"ks\",\n      [\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3_licht\")\n            .on(\"zusatz_oben\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [85,\"DOT\"]).pos([90, 40]).on(\"zs3>0\").off(\"hp<=0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3>0\")\n            .off(\"!zusatz_oben\")\n            .childs([\"zs3\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [80, \"Arial\", 1]).pos([85, 80])]),\n         \"mast\",\n         \"schirm_hp\",\n         \"wrw\",\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement().on(\"VRsig\").childs([\"ks1_2_optik_hpvr\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks2\").on(\"hp=2\")]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_optik_hp\").off(\"VRsig\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=1\")\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_hpvr\").on(\"VRsig\").on(\"zs3v>0\").blinkt(true),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_hpvr\").on(\"VRsig\").off(\"zs3v>0\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_hp\").off(\"VRsig\").on(\"zs3v>0\").blinkt(true),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_hp\").off(\"VRsig||zs3v>0\"),\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"möhre\").on(\"VRsig\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp0\").on(\"hp=0\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Asig, CONDITIONS.BKsig, CONDITIONS.SBK])\n            .childs([\"zs1_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs1\").on(\"ersatz=zs1\").off(\"hp>0\").blinkt(true)]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Esig, CONDITIONS.Zsig])\n            .childs([\"zs7_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs7\").on(\"ersatz=zs7\").off(\"hp>0\")]),\n         ,\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(CONDITIONS.BAHNHOF)\n            .childs([\"sh1_optik\", \"zs1_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs1,sh1\").on(\"ersatz=sh1\").off(\"hp>0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"vr_op=verk&&VRsig\")\n            .childs([\"kennlicht_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"kennlicht\").on(\"verk=1\").off(\"hp=0||hp=1&&zs3v<=0\")]),\n         ,\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(CONDITIONS.BAHNHOF)\n            .childs([\"kennlicht_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"kennlicht\").on(\"ersatz=kennlicht\").off(\"hp>=0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3v>0\")\n            .off(\"zusatz_unten\")\n            .childs([\"zs3v\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [80, \"Arial\", 1], \"#ffde36\").pos([85, 490])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs6_licht\").on(\"zs6=1\").on(\"zusatz_oben\").off(\"hp<=0||zs3>0\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3v_licht\")\n            .on(\"zusatz_unten\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [85,\"DOT\"], \"#ffde36\").on(\"zs3v>0\").off(\"hp<=0\").pos([90, 520])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"schild\").on(\"bez\").childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"bez\", [55,\"condenced\",1], \"#333\").pos([85, 634])]),\n      ],\n      [\"HPsig\", CONDITIONS.Asig, \"hp=0\"]\n   );\n   t.scale = 0.15;\n   t.distance_from_track = 15;\n   t.createSignalCommandMenu([\n      [\"hp=0,hp=1(Ks 1),hp=2(Ks 2)\", \"zs3\"],\n      \"zs3v\",\n      \"ersatz=zs1,ersatz=zs7,ersatz=zs8,ersatz=sh1,ersatz=kennlicht\",\n      \"verk=1(Verk)\",\n      \"zs6=1(Zs 6)\",\n   ]);\n\n   //signal: ist das signal, dessen Stellung wir gerade setzen\n   //hp: ist das signal, dessen Stellung wir vorsignalisieren wollen\n   t.checkSignalDependency = function (signal, hp) {\n      //make sure we only handle main signals\n      if (!hp.check(\"HPsig\") || !signal.check(\"VRsig\")) return;\n      let stop_propagation = false;\n      //-1 heißt, das Signal ist vom User ausgeschaltet\n      if (signal.get(\"hp\") != -1) {\n         //Das Hauptsignal zeigt nicht Hp 0 oder es ist ein alleinstehndes Vorsignal\n         let anderes_zs3 = hp.get(\"zs3\");\n         let eigenes_zs3 = signal.get(\"zs3\");\n         if (!signal.check(\"HPsig\") || signal.get(\"hp\") != 0) {\n            let x = hp.get(\"hp\");\n\n            switch (hp._template.id) {\n               case \"Hv77\":\n               case \"hv_hp\":\n               case \"hv_vr\":\n                  {\n                     signal.set_stellung(\"hp\", x >= 1 ? 1 : 2, false);\n                     if (x == 2 && anderes_zs3 <= 0) anderes_zs3 = 4;\n\n                     if (!signal.check(\"vr_op=wdh\")) stop_propagation = true;\n                  }\n                  break;\n               case \"Hl\":\n               case \"ks\":\n               case \"ks_vr\":\n                  {\n                     signal.set_stellung(\"hp\", x <= 0 ? 2 : 1, false);\n\n                     if (!signal.check(\"vr_op=wdh\")) stop_propagation = true;\n                  }\n                  break;\n            }\n         }\n         if (eigenes_zs3 <= anderes_zs3 && eigenes_zs3 > 0) anderes_zs3 = -1;\n         signal.set_stellung(\"zs3v\", anderes_zs3, false);\n      }\n\n      return stop_propagation;\n   };\n\n   signalTemplates.ks = t;\n\n   t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"ks_vr\",\n      \"Ks Vorsignal\",\n      \"ks\",\n      [\n         \"mast\",\n         \"schirm_vr\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks2_vr\").on(\"hp=2\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=1\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_vr\").on(\"zs3v>0\").blinkt(true), new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_vr\").off(\"zs3v>0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement().on(\"vr_op.wdh\").childs([\"sh1_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"verk\").off(\"hp=0||hp=1&&zs3v<=0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ne2\").off(\"vr_op.wdh\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement().on(\"vr_op.verk\").childs([\"verk_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"verk\").off(\"hp=0||hp=1&&zs3v<=0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3v>0\")\n            .off(\"zusatz_unten\")\n            .childs([\"zs3v\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [80, \"Arial\", 1], \"#ffde36\").pos([85, 490])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3v_licht\")\n            .on(\"zusatz_unten\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [85,\"DOT\"], \"#ffde36\").on(\"zs3v>0\").off(\"hp<=0\").pos([90, 520])]),\n      ],\n      [\"VRsig\", \"hp=2\"]\n   );\n   t.scale = 0.13;\n   t.distance_from_track = 15;\n   t.createSignalCommandMenu([\"hp=1(Ks 1),hp=2(Ks 2)\", \"zs3v\", \"ersatz=kennlicht\"]);\n\n   t.checkSignalDependency = signalTemplates.ks.checkSignalDependency;\n   signalTemplates.ks_vr = t;\n\n   //ls\n   t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"ls\",\n      \"Lichtsperrsignal\",\n      \"ls\",\n      [\n         \"basis\",\n         \"wrw\",\n         \"lp_r_links\",\n         \"lp_r_rechts\",\n         \"lp_w_oben\",\n         \"lp_w_unten\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"r_links,r_rechts\").on(\"hp=0\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"w_oben,w_unten\").on(\"hp=1\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"w_oben\").on(\"ersatz=kennlicht\"),\n         \"schute_r_links\",\n         \"schute_r_rechts\",\n         \"schute_w_oben\",\n         \"schute_w_unten\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"schild\").on(\"bez\").childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"bez\", [55,\"condenced\",1], \"#333\").pos([210, 125])]),\n      ],\n      \"hp=0\"\n   );\n   t.scale = 0.07;\n   t.createSignalCommandMenu([\"hp=0,hp=1(Sh 1)\", \"ersatz=kennlicht(Kennlicht)\"]);\n   signalTemplates.ls = t;\n\n   signalTemplates.ne4 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"ne4\", \"Ne 4\", \"basis\");\n   signalTemplates.ne4.scale = 0.2;\n   signalTemplates.ne4.previewsize = 10;\n\n   signalTemplates.ne1 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"ne1\", \"Ne 1\", \"basis\", [\n      \"ne1\",\n      new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"ne1\", [20, \"Arial\", 1]).pos([100, 105]),\n   ]);\n   signalTemplates.ne1.scale = 0.15;\n   signalTemplates.ne1.distance_from_track = 5;\n   signalTemplates.ne2 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"ne2\", \"Ne 2\", \"basis\");\n   signalTemplates.ne2.scale = 0.25;\n   signalTemplates.ne2.previewsize = 20;\n\n   signalTemplates.lf6 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"lf6\",\n      \"Lf 6\",\n      \"basis\",\n      [\"lf6\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"geschw\", [110, \"Arial\", 1], \"#333\").pos([98, 8])],\n      [\"slave\", \"geschw=9\"]\n   );\n   signalTemplates.lf6.createSignalCommandMenu([\"geschw()\"]);\n   signalTemplates.lf6.scale = 0.12;\n\n   signalTemplates.lf7 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"lf7\",\n      \"Lf 7\",\n      \"basis\",\n      [\"lf7\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"geschw\", [130, \"Arial\", 1], \"#333\").pos([55, 20])],\n      [\"master\", \"geschw=9\"]\n   );\n   signalTemplates.lf7.createSignalCommandMenu([\"geschw()\"]);\n   signalTemplates.lf7.scale = 0.15;\n   signalTemplates.lf7.previewsize = 30;\n\n   signalTemplates.lf7.checkSignalDependency = signalTemplates.lf6.checkSignalDependency = function (signal, hp) {\n      if (signal._template.id == \"lf6\" && hp._template.id == \"lf7\") {\n         signal.set_stellung(\"geschw\", hp.get(\"geschw\"), false);\n         return true;\n      }\n      return false;\n   };\n\n   signalTemplates.zs3 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"zs3\",\n      \"Zs 3 (alleinst.)\",\n      \"basis\",\n      [\"zs3\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"geschw\",[120, \"Arial\", 1]).pos([90, 60])],\n      \"geschw=9\"\n   );\n\n   signalTemplates.zs3.createSignalCommandMenu([\"geschw()\"]);\n   signalTemplates.zs3.scale = 0.15;\n\n   signalTemplates.zs10 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"zs10\", \"Zs 10\", \"basis\");\n   signalTemplates.zs10.scale = 0.2;\n   signalTemplates.zs10.previewsize = 15;\n\n   signalTemplates.ra10 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"ra10\", \"Ra 10\", \"basis\");\n   signalTemplates.ra10.scale = 0.15;\n\n   signalTemplates.zs6 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"zs6\", \"Zs 6\", \"basis\", [\"zs6_blech_mast\", \"zs6_blech\"]);\n   signalTemplates.zs6.scale = 0.2;\n   signalTemplates.zs6.previewsize = 30;\n\n   signalTemplates.zusatzSignal = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"zusatz\",\n      \"Zusatzanzeiger\",\n      \"basis\",\n      [\n         \"zusatzanzeiger\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs6_licht\").on(\"zs6=1\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [85,\"DOT\"]).pos([70, 40]).off(\"zs6=1\").on(\"zs3>0\"),\n      ],\n      \"zs6=1\"\n   );\n   signalTemplates.zusatzSignal.scale = 0.15;\n   signalTemplates.zusatzSignal.createSignalCommandMenu([[\"zs6=1(Zs 6)\"], \"zs3()\"]);\n   signalTemplates.zusatzSignal.previewsize = 30;\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUE2Qix5REFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLHlEQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qix5REFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4Qix5REFBYztBQUM1QztBQUNBOztBQUVBLDhCQUE4Qix5REFBYztBQUM1Qzs7QUFFQSw2QkFBNkIseURBQWM7QUFDM0M7QUFDQTs7QUFFQSxzQ0FBc0MseURBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQWE7QUFDMUIsYUFBYSxzREFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3NpZ25hbF9saWJyYXJ5LmpzPzc4YzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgVmlzdWFsRWxlbWVudCwgVGV4dEVsZW1lbnQsIFNpZ25hbFRlbXBsYXRlIH0gZnJvbSAnLi9zaWduYWxpbmcuanMnO1xuXG5leHBvcnQgY29uc3QgQ09ORElUSU9OUyA9IChmdW5jdGlvbiAoKSB7XG4gICBjb25zdCBCS3NpZyA9IFwidmVydz1ia3NpZ1wiLFxuICAgICAgU0JLID0gXCJ2ZXJ3PXNia1wiLFxuICAgICAgRXNpZyA9IFwidmVydz1lc2lnXCIsXG4gICAgICBBc2lnID0gXCJ2ZXJ3PWFzaWdcIixcbiAgICAgIFpzaWcgPSBcInZlcnc9enNpZ1wiLFxuICAgICAgU1RSRUNLRSA9IFtCS3NpZywgU0JLLCBFc2lnXSxcbiAgICAgIEdSRU5aRU4gPSBbQktzaWcsIEVzaWddLFxuICAgICAgQkFITkhPRiA9IFtBc2lnLCBac2lnXTtcbiAgIHJldHVybiB7IEJLc2lnLCBTQkssIEVzaWcsIEFzaWcsIFpzaWcsIFNUUkVDS0UsIEdSRU5aRU4sIEJBSE5IT0YgfTtcbn0pKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0U2lnbmFscyhzaWduYWxUZW1wbGF0ZXNSZWYpIHtcbiAgIC8vIFVzZSB0aGUgcGFzc2VkIHNpZ25hbFRlbXBsYXRlcyByZWZlcmVuY2UgaW5zdGVhZCBvZiBhIG1vZHVsZS1sZXZlbCB2YXJpYWJsZVxuICAgY29uc3Qgc2lnbmFsVGVtcGxhdGVzID0gc2lnbmFsVGVtcGxhdGVzUmVmO1xuICAgY29uc3QgbGlnaHRNZW51ID0gW1xuICAgICAgW1wiaHA9MCxocD0xLGhwPTJcIiwgXCJ6czNcIl0sXG4gICAgICBbXCJ2cj0wLHZyPTEsdnI9MlwiLCBcInZlcms9MSh2ZXJrKVwiLCBcInpzM3ZcIl0sXG4gICAgICBcImVyc2F0ej16czEsZXJzYXR6PXpzNyxlcnNhdHo9enM4LGVyc2F0ej1zaDEsZXJzYXR6PWtlbm5saWNodFwiLFxuICAgICAgXCJ6czY9MShacyA2KVwiLFxuICAgXTtcblxuICAgLy9zaWduYWw6IGlzdCBkYXMgc2lnbmFsLCBkZXNzZW4gU3RlbGx1bmcgd2lyIGdlcmFkZSBzZXR6ZW5cbiAgIC8vaHA6IGlzdCBkYXMgc2lnbmFsLCBkZXNzZW4gU3RlbGx1bmcgd2lyIHZvcnNpZ25hbGlzaWVyZW4gd29sbGVuXG4gICBjb25zdCBjaGVja1NpZ25hbERlcGVuZGVuY3lGdW5jdGlvbjRIViA9IGZ1bmN0aW9uIChzaWduYWwsIGhwKSB7XG4gICAgICAvL21ha2Ugc3VyZSB3ZSBvbmx5IGhhbmRsZSBtYWluIHNpZ25hbHNcbiAgICAgIGlmICghaHAuY2hlY2soXCJIUHNpZ1wiKSB8fCAhc2lnbmFsLmNoZWNrKFwiVlJzaWdcIikpIHJldHVybjtcbiAgICAgIGxldCBzdG9wX3Byb3BhZ2F0aW9uID0gZmFsc2U7XG5cbiAgICAgIC8vLTEgaGVpw590LCBkaWUgVm9yc2lnbmFsZnVua3Rpb24gaXN0IHZvbSBVc2VyIGF1c2dlc2NoYWx0ZXRcbiAgICAgIGlmIChzaWduYWwuZ2V0KFwidnJcIikgIT0gLTEpIHtcbiAgICAgICAgIC8vRGFzIEhhdXB0c2lnbmFsIHplaWd0IG5pY2h0IEhwIDAgb2RlciBlcyBpc3QgZWluIGFsbGVpbnN0ZWhuZGVzIFZvcnNpZ25hbFxuICAgICAgICAgaWYgKCFzaWduYWwuY2hlY2soXCJIUHNpZ1wiKSB8fCBzaWduYWwuZ2V0KFwiaHBcIikgIT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChocC5fdGVtcGxhdGUuaWQpIHtcbiAgICAgICAgICAgICAgIGNhc2UgXCJIdjc3XCI6XG4gICAgICAgICAgICAgICBjYXNlIFwiaHZfaHBcIjpcbiAgICAgICAgICAgICAgIGNhc2UgXCJodl92clwiOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhcInZyXCIsIGhwLmdldChcImhwXCIpID49IDAgPyBocC5nZXQoXCJocFwiKSA6IDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmFsLmNoZWNrKFwidnJfb3A9d2RoXCIpKSBzdG9wX3Byb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgY2FzZSBcIkhsXCI6XG4gICAgICAgICAgICAgICBjYXNlIFwia3NcIjpcbiAgICAgICAgICAgICAgIGNhc2UgXCJrc192clwiOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhcInZyXCIsIGhwLmdldChcImhwXCIpIDw9IDAgPyAwIDogMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWduYWwuY2hlY2soXCJ2cl9vcD13ZGhcIikpIHN0b3BfcHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChocC5nZXQoXCJ6czNcIikgPT0gNCkge1xuICAgICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhcInpzM3ZcIiwgMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICBpZiAoc2lnbmFsLmdldChcInZyXCIpID4gMCkgc2lnbmFsLnNldF9zdGVsbHVuZyhcInZyXCIsIDIsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBzaWduYWwuc2V0X3N0ZWxsdW5nKFwienMzdlwiLCBocC5nZXQoXCJ6czNcIiksIGZhbHNlKTtcblxuICAgICAgICAgICAgLy9pZiAoaHAuZ2V0KFwienMzXCIpLmJldHdlZW4oMSw2KSAmJiBocC5nZXQoXCJocFwiKSA+IDApIHNpZ25hbC5zZXRfc3RlbGx1bmcoXCJ2clwiLCAyLCBmYWxzZSk7XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9wX3Byb3BhZ2F0aW9uO1xuICAgfTtcblxuICAgbGV0IHQgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXG4gICAgICBcImh2X2hwXCIsXG4gICAgICBcIkh2IEhhdXB0c2lnbmFsXCIsXG4gICAgICBcImh2XCIsXG4gICAgICBbXG4gICAgICAgICBcIm1hc3QsaHBfc2NoaXJtXCIsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcIndyd1wiKS5vbihcIm1hc3RzY2hpbGQ9d3J3XCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ3Z3dnd1wiKS5vbihcIm1hc3RzY2hpbGQ9d2d3Z3dcIiksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwiaHBfYXNpZ19saWNodHBcIikub24oQ09ORElUSU9OUy5CQUhOSE9GKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwiaHBfYmtfbGljaHRwX3VudGVuXCIpLm9uKENPTkRJVElPTlMuU1RSRUNLRSksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2JrX2xpY2h0cF9vYmVuXCIpLm9uKENPTkRJVElPTlMuR1JFTlpFTiksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcImhwPTBcIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9hc2lnX3JvdF9yZVwiKS5vbihDT05ESVRJT05TLkJBSE5IT0YpLm9mZihcImVyc2F0ej1zaDFcIiksXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2FzaWdfcm90X2xpXCIpLm9uKENPTkRJVElPTlMuQkFITkhPRiksXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2JrX3JvdF91bnRlbl9saVwiKS5vbihDT05ESVRJT05TLlNUUkVDS0UpLFxuICAgICAgICAgICAgXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcImhwPTFcIilcbiAgICAgICAgICAgIC5vZmYoXCJ6czM8PTYgJiYgenMzPjBcIikgLy91c2VkIGJ5IFVJIHRvIGRpc2FibGUgdGhlIGNvcm9zcG9kaW5nIGJ1dHRvblxuICAgICAgICAgICAgLmNoaWxkcyhbXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2FzaWdfZ3JcIikub24oQ09ORElUSU9OUy5CQUhOSE9GKSxcbiAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwiaHBfYmtfZ3JfdW50ZW5fcmVcIikub24oQ09ORElUSU9OUy5TQkspLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9ia19ncl9vYmVuX3JlXCIpLm9uKENPTkRJVElPTlMuR1JFTlpFTiksXG4gICAgICAgICAgICBdKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwiaHA9MlwiKVxuICAgICAgICAgICAgLm9mZihcInpzMz42XCIpIC8vdXNlZCBieSBVSSB0byBkaXNhYmxlIHRoZSBjb3Jvc3BvZGluZyBidXR0b25cbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9hc2lnX2dlbGIsaHBfYXNpZ19nclwiKS5vbihDT05ESVRJT05TLkJBSE5IT0YpLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9ia19nZWxiX3VudGVuX3JlLGhwX2JrX2dyX29iZW5fcmVcIikub24oQ09ORElUSU9OUy5HUkVOWkVOKSxcbiAgICAgICAgICAgIF0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2FzaWdfc2NodXRlblwiKS5vbihDT05ESVRJT05TLkJBSE5IT0YpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9ia19zY2h1dGVfdW50ZW5cIikub24oQ09ORElUSU9OUy5TVFJFQ0tFKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwiaHBfYmtfc2NodXRlX29iZW5cIikub24oQ09ORElUSU9OUy5HUkVOWkVOKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwiVlJzaWdcIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgXCJ2cl9zY2hpcm1cIixcbiAgICAgICAgICAgICAgIFwidnJfbGljaHRwXCIsXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9zY2hpcm0sdnJfenVzYXR6X2xpY2h0cFwiKS5vbihcInZyX29wPXZlcmtcIiksXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9saWNodFwiKS5vbihcInZyX29wPXZlcmtcIikub24oXCJ2ZXJrPTFcIikub2ZmKFwiaHA9MFwiKSxcbiAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgICAgICAgIC5vZmYoXCJocD0wXCIpXG4gICAgICAgICAgICAgICAgICAuY2hpbGRzKFtcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwidnJfZ2VsYl9vYmVuLHZyX2dlbGJfdW50ZW5cIikub24oXCJ2cj0wXCIpLFxuICAgICAgICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ2cl9ncsO8bl9vYmVuLHZyX2dyw7xuX3VudGVuXCIpLm9uKFwidnI9MVwiKSxcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwidnJfZ2VsYl91bnRlbix2cl9ncsO8bl9vYmVuXCIpLm9uKFwidnI9MlwiKSxcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgXCJ2cl9zY2h1dGVuXCIsXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9zY2h1dGVcIikub24oXCJ2cl9vcD12ZXJrXCIpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oQ09ORElUSU9OUy5CQUhOSE9GKVxuICAgICAgICAgICAgLmNoaWxkcyhbXG4gICAgICAgICAgICAgICBcImhwX2FzaWdfa2VubmxpY2h0X2xpY2h0cFwiLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9hc2lnX2tlbm5saWNodF9saWNodFwiKS5vbihcImVyc2F0ej1rZW5ubGljaHRcIikub2ZmKFwiaHA+PTBcIiksXG4gICAgICAgICAgICAgICBcImhwX2FzaWdfa2VubmxpY2h0X3NjaHV0ZVwiLFxuICAgICAgICAgICAgXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihDT05ESVRJT05TLkJBSE5IT0YpXG4gICAgICAgICAgICAuY2hpbGRzKFtcbiAgICAgICAgICAgICAgIFwiaHBfYXNpZ19zaDFfbGljaHRwXCIsXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2FzaWdfc2gxX2xpY2h0XCIpLm9uKFwiZXJzYXR6PXNoMVwiKS5vZmYoXCJocD4wXCIpLFxuICAgICAgICAgICAgICAgXCJocF9hc2lnX3NoMV9zY2h1dGVcIixcbiAgICAgICAgICAgIF0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oW0NPTkRJVElPTlMuQXNpZywgQ09ORElUSU9OUy5ac2lnLCBDT05ESVRJT05TLlNCS10pXG4gICAgICAgICAgICAuY2hpbGRzKFtcImhwX3pzMV9saWNodHBcIiwgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF96czFfbGljaHRcIikub24oXCJlcnNhdHo9enMxXCIpLm9mZihcImhwPjBcIiksIFwiaHBfenMxX3NjaHV0ZW5cIl0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oW0NPTkRJVElPTlMuRXNpZywgQ09ORElUSU9OUy5ac2lnXSlcbiAgICAgICAgICAgIC5jaGlsZHMoW1wiaHBfenM3X2xpY2h0cFwiLCBuZXcgVmlzdWFsRWxlbWVudChcImhwX3pzN19saWNodFwiKS5vbihcImVyc2F0ej16czdcIikub2ZmKFwiaHA+MFwiKSwgXCJocF96czdfc2NodXRlblwiXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihbQ09ORElUSU9OUy5Bc2lnLCBDT05ESVRJT05TLkJLc2lnXSlcbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgXCJocF96czFfbGljaHRwXCIsXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX3pzMV9saWNodFwiKS5vbihcImVyc2F0ej16czhcIikub2ZmKFwiaHA+MFwiKS5ibGlua3QodHJ1ZSksXG4gICAgICAgICAgICAgICBcImhwX3pzMV9zY2h1dGVuXCIsXG4gICAgICAgICAgICBdKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwienMzPjBcIilcbiAgICAgICAgICAgIC5vZmYoXCJ6czM9NDB8fHp1c2F0el9vYmVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtcInpzM1wiLCBuZXcgVGV4dEVsZW1lbnQoXCJ6czNcIiwgWzgwLCBcIkFyaWFsXCIsIDFdKS5wb3MoWzExNSwgODBdKV0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oXCJ6czN2PjBcIilcbiAgICAgICAgICAgIC5vZmYoXCJ6dXNhdHpfdW50ZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1wienMzdlwiLCBuZXcgVGV4dEVsZW1lbnQoXCJ6czN2XCIsIFs4MCwgXCJBcmlhbFwiLCAxXSwgXCIjZmZkZTM2XCIpLnBvcyhbMTE1LCA4OTBdKV0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInpzM19saWNodFwiKVxuICAgICAgICAgICAgLm9uKFwienVzYXR6X29iZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW25ldyBUZXh0RWxlbWVudChcInpzM1wiLCBbNjAsXCJET1RcIl0pLnBvcyhbMTIwLCA3OF0pLm9uKFwienMzPjBcIikub2ZmKFwiaHA8PTBcIildKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwienMzdl9saWNodFwiKVxuICAgICAgICAgICAgLm9uKFwienVzYXR6X3VudGVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtuZXcgVGV4dEVsZW1lbnQoXCJ6czN2XCIsIFs2MCxcIkRPVFwiXSwgXCIjZmZkZTM2XCIpLnBvcyhbMTIwLCA4ODVdKS5vbihcInpzM3Y+MFwiKS5vZmYoXCJocDw9MFwiKV0pLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFtDT05ESVRJT05TLkFzaWcsIENPTkRJVElPTlMuQktzaWddKVxuICAgICAgICAgICAgLm9uKFwienM2PTFcIilcbiAgICAgICAgICAgIC5vZmYoXCJ6czN2PjBcIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czZfYmxlY2hfdW50ZW5cIikub2ZmKFwienVzYXR6X3VudGVuXCIpLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czZfbGljaHRfdW50ZW5cIikub24oXCJ6dXNhdHpfdW50ZW5cIikub24oXCJocD4wXCIpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInNjaGlsZFwiKS5vbihcImJlelwiKS5jaGlsZHMoW25ldyBUZXh0RWxlbWVudChcImJlelwiLCBbNTUsXCJjb25kZW5jZWRcIiwxXSwgXCIjMzMzXCIpLnBvcyhbMTE2LCAxMDMzXSkuYm91bmRzKFs1Miw2M10pXSksXG4gICAgICAgICAsXG4gICAgICBdLFxuICAgICAgW1wiaHA9MFwiLCBcInZyPTBcIiwgXCJIUHNpZ1wiLCBcInZlcnc9YXNpZ1wiLCBcIm1hc3RzY2hpbGQ9d3J3XCJdXG4gICApO1xuICAgdC5zY2FsZSA9IDAuMTU7XG4gICB0LnByZXZpZXdzaXplID0gMjA7XG4gICB0LmRpc3RhbmNlX2Zyb21fdHJhY2sgPSA1O1xuICAgdC5jaGVja1NpZ25hbERlcGVuZGVuY3kgPSBjaGVja1NpZ25hbERlcGVuZGVuY3lGdW5jdGlvbjRIVjtcbiAgIHQuYWRkUnVsZShcImhwPjAgJiYgenMzPjZcIiwgXCJocD0xXCIpO1xuICAgdC5hZGRSdWxlKFwiaHA+MCAmJiB6czM8PTYgJiYgenMzPjBcIiwgXCJocD0yXCIpO1xuICAgdC5jcmVhdGVTaWduYWxDb21tYW5kTWVudShsaWdodE1lbnUpO1xuICAgc2lnbmFsVGVtcGxhdGVzLmh2X2hwID0gdDtcblxuICAgdCA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwiaHZfdnJcIixcbiAgICAgIFwiSHYgVm9yc2lnbmFsXCIsXG4gICAgICBcImh2XCIsXG4gICAgICBbXG4gICAgICAgICBcIm1hc3QsdnJfc2NoaXJtLHZyX2xpY2h0cFwiLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJuZTJcIikub2ZmKFwidnJfb3A9d2RoXCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ2cl96dXNhdHpfc2NoaXJtLHZyX3p1c2F0el9saWNodHBcIikub24oW1widnJfb3A9dmVya1wiLCBcInZyX29wPXdkaFwiXSksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9saWNodFwiKS5vbihcInZyX29wPXZlcmtcIikub24oXCJ2ZXJrPTFcIiksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9saWNodFwiKS5vbihcInZyX29wPXdkaFwiKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KCkuY2hpbGRzKFtcbiAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwidnJfZ2VsYl9vYmVuLHZyX2dlbGJfdW50ZW5cIikub24oXCJ2cj0wXCIpLFxuICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ2cl9ncsO8bl9vYmVuLHZyX2dyw7xuX3VudGVuXCIpLm9uKFwidnI9MVwiKSxcbiAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwidnJfZ2VsYl91bnRlbix2cl9ncsO8bl9vYmVuXCIpLm9uKFwidnI9MlwiKSxcbiAgICAgICAgIF0pLFxuICAgICAgICAgXCJ2cl9zY2h1dGVuXCIsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9zY2h1dGVcIikub24oXCJ2cl9vcD12ZXJrXCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwienMzdj4wXCIpXG4gICAgICAgICAgICAub2ZmKFwienVzYXR6X3VudGVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtcInpzM3ZcIiwgbmV3IFRleHRFbGVtZW50KFwienMzdlwiLCBbODAsIFwiQXJpYWxcIiwgMV0sIFwiI2ZmZGUzNlwiKS5wb3MoWzExNSwgODkwXSldKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwienMzdl9saWNodFwiKVxuICAgICAgICAgICAgLm9uKFwienVzYXR6X3VudGVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtuZXcgVGV4dEVsZW1lbnQoXCJ6czN2XCIsIFs2MCxcIkRPVFwiXSwgXCIjZmZkZTM2XCIpLnBvcyhbMTIwLCA4ODVdKS5vbihcInpzM3Y+MFwiKV0pLFxuICAgICAgXSxcbiAgICAgIFtcInZyPTBcIiwgXCJWUnNpZ1wiXVxuICAgKTtcbiAgIHQuc2NhbGUgPSAwLjE1O1xuICAgdC5kaXN0YW5jZV9mcm9tX3RyYWNrID0gNDtcbiAgIHQuY2hlY2tTaWduYWxEZXBlbmRlbmN5ID0gY2hlY2tTaWduYWxEZXBlbmRlbmN5RnVuY3Rpb240SFY7XG4gICB0LmNyZWF0ZVNpZ25hbENvbW1hbmRNZW51KFtcInZyPTAsdnI9MSx2cj0yXCIsIFwidmVyaz0xKHZlcmspXCIsIFwienMzdlwiXSk7XG4gICBzaWduYWxUZW1wbGF0ZXMuaHZfdnIgPSB0O1xuXG4gICAvL0tTIEhhdXB0c2lnbmFsXG4gICB0ID0gbmV3IFNpZ25hbFRlbXBsYXRlKFxuICAgICAgXCJrc1wiLFxuICAgICAgXCJLcyBIYXVwdHNpZ25hbFwiLFxuICAgICAgXCJrc1wiLFxuICAgICAgW1xuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czNfbGljaHRcIilcbiAgICAgICAgICAgIC5vbihcInp1c2F0el9vYmVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtuZXcgVGV4dEVsZW1lbnQoXCJ6czNcIiwgWzg1LFwiRE9UXCJdKS5wb3MoWzkwLCA0MF0pLm9uKFwienMzPjBcIikub2ZmKFwiaHA8PTBcIildKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwienMzPjBcIilcbiAgICAgICAgICAgIC5vZmYoXCIhenVzYXR6X29iZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1wienMzXCIsIG5ldyBUZXh0RWxlbWVudChcInpzM1wiLCBbODAsIFwiQXJpYWxcIiwgMV0pLnBvcyhbODUsIDgwXSldKSxcbiAgICAgICAgIFwibWFzdFwiLFxuICAgICAgICAgXCJzY2hpcm1faHBcIixcbiAgICAgICAgIFwid3J3XCIsXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KCkub24oXCJWUnNpZ1wiKS5jaGlsZHMoW1wia3MxXzJfb3B0aWtfaHB2clwiLCBuZXcgVmlzdWFsRWxlbWVudChcImtzMlwiKS5vbihcImhwPTJcIildKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwia3MxX29wdGlrX2hwXCIpLm9mZihcIlZSc2lnXCIpLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oXCJocD0xXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtcbiAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwia3MxX2hwdnJcIikub24oXCJWUnNpZ1wiKS5vbihcInpzM3Y+MFwiKS5ibGlua3QodHJ1ZSksXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImtzMV9ocHZyXCIpLm9uKFwiVlJzaWdcIikub2ZmKFwienMzdj4wXCIpLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJrczFfaHBcIikub2ZmKFwiVlJzaWdcIikub24oXCJ6czN2PjBcIikuYmxpbmt0KHRydWUpLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJrczFfaHBcIikub2ZmKFwiVlJzaWd8fHpzM3Y+MFwiKSxcbiAgICAgICAgICAgIF0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcIm3DtmhyZVwiKS5vbihcIlZSc2lnXCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocDBcIikub24oXCJocD0wXCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFtDT05ESVRJT05TLkFzaWcsIENPTkRJVElPTlMuQktzaWcsIENPTkRJVElPTlMuU0JLXSlcbiAgICAgICAgICAgIC5jaGlsZHMoW1wienMxX29wdGlrXCIsIG5ldyBWaXN1YWxFbGVtZW50KFwienMxXCIpLm9uKFwiZXJzYXR6PXpzMVwiKS5vZmYoXCJocD4wXCIpLmJsaW5rdCh0cnVlKV0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oW0NPTkRJVElPTlMuRXNpZywgQ09ORElUSU9OUy5ac2lnXSlcbiAgICAgICAgICAgIC5jaGlsZHMoW1wienM3X29wdGlrXCIsIG5ldyBWaXN1YWxFbGVtZW50KFwienM3XCIpLm9uKFwiZXJzYXR6PXpzN1wiKS5vZmYoXCJocD4wXCIpXSksXG4gICAgICAgICAsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oQ09ORElUSU9OUy5CQUhOSE9GKVxuICAgICAgICAgICAgLmNoaWxkcyhbXCJzaDFfb3B0aWtcIiwgXCJ6czFfb3B0aWtcIiwgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czEsc2gxXCIpLm9uKFwiZXJzYXR6PXNoMVwiKS5vZmYoXCJocD4wXCIpXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcInZyX29wPXZlcmsmJlZSc2lnXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtcImtlbm5saWNodF9vcHRpa1wiLCBuZXcgVmlzdWFsRWxlbWVudChcImtlbm5saWNodFwiKS5vbihcInZlcms9MVwiKS5vZmYoXCJocD0wfHxocD0xJiZ6czN2PD0wXCIpXSksXG4gICAgICAgICAsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oQ09ORElUSU9OUy5CQUhOSE9GKVxuICAgICAgICAgICAgLmNoaWxkcyhbXCJrZW5ubGljaHRfb3B0aWtcIiwgbmV3IFZpc3VhbEVsZW1lbnQoXCJrZW5ubGljaHRcIikub24oXCJlcnNhdHo9a2VubmxpY2h0XCIpLm9mZihcImhwPj0wXCIpXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcInpzM3Y+MFwiKVxuICAgICAgICAgICAgLm9mZihcInp1c2F0el91bnRlblwiKVxuICAgICAgICAgICAgLmNoaWxkcyhbXCJ6czN2XCIsIG5ldyBUZXh0RWxlbWVudChcInpzM3ZcIiwgWzgwLCBcIkFyaWFsXCIsIDFdLCBcIiNmZmRlMzZcIikucG9zKFs4NSwgNDkwXSldKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czZfbGljaHRcIikub24oXCJ6czY9MVwiKS5vbihcInp1c2F0el9vYmVuXCIpLm9mZihcImhwPD0wfHx6czM+MFwiKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czN2X2xpY2h0XCIpXG4gICAgICAgICAgICAub24oXCJ6dXNhdHpfdW50ZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW25ldyBUZXh0RWxlbWVudChcInpzM3ZcIiwgWzg1LFwiRE9UXCJdLCBcIiNmZmRlMzZcIikub24oXCJ6czN2PjBcIikub2ZmKFwiaHA8PTBcIikucG9zKFs5MCwgNTIwXSldKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJzY2hpbGRcIikub24oXCJiZXpcIikuY2hpbGRzKFtuZXcgVGV4dEVsZW1lbnQoXCJiZXpcIiwgWzU1LFwiY29uZGVuY2VkXCIsMV0sIFwiIzMzM1wiKS5wb3MoWzg1LCA2MzRdKV0pLFxuICAgICAgXSxcbiAgICAgIFtcIkhQc2lnXCIsIENPTkRJVElPTlMuQXNpZywgXCJocD0wXCJdXG4gICApO1xuICAgdC5zY2FsZSA9IDAuMTU7XG4gICB0LmRpc3RhbmNlX2Zyb21fdHJhY2sgPSAxNTtcbiAgIHQuY3JlYXRlU2lnbmFsQ29tbWFuZE1lbnUoW1xuICAgICAgW1wiaHA9MCxocD0xKEtzIDEpLGhwPTIoS3MgMilcIiwgXCJ6czNcIl0sXG4gICAgICBcInpzM3ZcIixcbiAgICAgIFwiZXJzYXR6PXpzMSxlcnNhdHo9enM3LGVyc2F0ej16czgsZXJzYXR6PXNoMSxlcnNhdHo9a2VubmxpY2h0XCIsXG4gICAgICBcInZlcms9MShWZXJrKVwiLFxuICAgICAgXCJ6czY9MShacyA2KVwiLFxuICAgXSk7XG5cbiAgIC8vc2lnbmFsOiBpc3QgZGFzIHNpZ25hbCwgZGVzc2VuIFN0ZWxsdW5nIHdpciBnZXJhZGUgc2V0emVuXG4gICAvL2hwOiBpc3QgZGFzIHNpZ25hbCwgZGVzc2VuIFN0ZWxsdW5nIHdpciB2b3JzaWduYWxpc2llcmVuIHdvbGxlblxuICAgdC5jaGVja1NpZ25hbERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoc2lnbmFsLCBocCkge1xuICAgICAgLy9tYWtlIHN1cmUgd2Ugb25seSBoYW5kbGUgbWFpbiBzaWduYWxzXG4gICAgICBpZiAoIWhwLmNoZWNrKFwiSFBzaWdcIikgfHwgIXNpZ25hbC5jaGVjayhcIlZSc2lnXCIpKSByZXR1cm47XG4gICAgICBsZXQgc3RvcF9wcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgICAgLy8tMSBoZWnDn3QsIGRhcyBTaWduYWwgaXN0IHZvbSBVc2VyIGF1c2dlc2NoYWx0ZXRcbiAgICAgIGlmIChzaWduYWwuZ2V0KFwiaHBcIikgIT0gLTEpIHtcbiAgICAgICAgIC8vRGFzIEhhdXB0c2lnbmFsIHplaWd0IG5pY2h0IEhwIDAgb2RlciBlcyBpc3QgZWluIGFsbGVpbnN0ZWhuZGVzIFZvcnNpZ25hbFxuICAgICAgICAgbGV0IGFuZGVyZXNfenMzID0gaHAuZ2V0KFwienMzXCIpO1xuICAgICAgICAgbGV0IGVpZ2VuZXNfenMzID0gc2lnbmFsLmdldChcInpzM1wiKTtcbiAgICAgICAgIGlmICghc2lnbmFsLmNoZWNrKFwiSFBzaWdcIikgfHwgc2lnbmFsLmdldChcImhwXCIpICE9IDApIHtcbiAgICAgICAgICAgIGxldCB4ID0gaHAuZ2V0KFwiaHBcIik7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoaHAuX3RlbXBsYXRlLmlkKSB7XG4gICAgICAgICAgICAgICBjYXNlIFwiSHY3N1wiOlxuICAgICAgICAgICAgICAgY2FzZSBcImh2X2hwXCI6XG4gICAgICAgICAgICAgICBjYXNlIFwiaHZfdnJcIjpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5zZXRfc3RlbGx1bmcoXCJocFwiLCB4ID49IDEgPyAxIDogMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHggPT0gMiAmJiBhbmRlcmVzX3pzMyA8PSAwKSBhbmRlcmVzX3pzMyA9IDQ7XG5cbiAgICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmFsLmNoZWNrKFwidnJfb3A9d2RoXCIpKSBzdG9wX3Byb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgY2FzZSBcIkhsXCI6XG4gICAgICAgICAgICAgICBjYXNlIFwia3NcIjpcbiAgICAgICAgICAgICAgIGNhc2UgXCJrc192clwiOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhcImhwXCIsIHggPD0gMCA/IDIgOiAxLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmFsLmNoZWNrKFwidnJfb3A9d2RoXCIpKSBzdG9wX3Byb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKGVpZ2VuZXNfenMzIDw9IGFuZGVyZXNfenMzICYmIGVpZ2VuZXNfenMzID4gMCkgYW5kZXJlc196czMgPSAtMTtcbiAgICAgICAgIHNpZ25hbC5zZXRfc3RlbGx1bmcoXCJ6czN2XCIsIGFuZGVyZXNfenMzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9wX3Byb3BhZ2F0aW9uO1xuICAgfTtcblxuICAgc2lnbmFsVGVtcGxhdGVzLmtzID0gdDtcblxuICAgdCA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwia3NfdnJcIixcbiAgICAgIFwiS3MgVm9yc2lnbmFsXCIsXG4gICAgICBcImtzXCIsXG4gICAgICBbXG4gICAgICAgICBcIm1hc3RcIixcbiAgICAgICAgIFwic2NoaXJtX3ZyXCIsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImtzMl92clwiKS5vbihcImhwPTJcIiksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcImhwPTFcIilcbiAgICAgICAgICAgIC5jaGlsZHMoW25ldyBWaXN1YWxFbGVtZW50KFwia3MxX3ZyXCIpLm9uKFwienMzdj4wXCIpLmJsaW5rdCh0cnVlKSwgbmV3IFZpc3VhbEVsZW1lbnQoXCJrczFfdnJcIikub2ZmKFwienMzdj4wXCIpXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KCkub24oXCJ2cl9vcC53ZGhcIikuY2hpbGRzKFtcInNoMV9vcHRpa1wiLCBuZXcgVmlzdWFsRWxlbWVudChcInZlcmtcIikub2ZmKFwiaHA9MHx8aHA9MSYmenMzdjw9MFwiKV0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcIm5lMlwiKS5vZmYoXCJ2cl9vcC53ZGhcIiksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KCkub24oXCJ2cl9vcC52ZXJrXCIpLmNoaWxkcyhbXCJ2ZXJrX29wdGlrXCIsIG5ldyBWaXN1YWxFbGVtZW50KFwidmVya1wiKS5vZmYoXCJocD0wfHxocD0xJiZ6czN2PD0wXCIpXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcInpzM3Y+MFwiKVxuICAgICAgICAgICAgLm9mZihcInp1c2F0el91bnRlblwiKVxuICAgICAgICAgICAgLmNoaWxkcyhbXCJ6czN2XCIsIG5ldyBUZXh0RWxlbWVudChcInpzM3ZcIiwgWzgwLCBcIkFyaWFsXCIsIDFdLCBcIiNmZmRlMzZcIikucG9zKFs4NSwgNDkwXSldKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czN2X2xpY2h0XCIpXG4gICAgICAgICAgICAub24oXCJ6dXNhdHpfdW50ZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW25ldyBUZXh0RWxlbWVudChcInpzM3ZcIiwgWzg1LFwiRE9UXCJdLCBcIiNmZmRlMzZcIikub24oXCJ6czN2PjBcIikub2ZmKFwiaHA8PTBcIikucG9zKFs5MCwgNTIwXSldKSxcbiAgICAgIF0sXG4gICAgICBbXCJWUnNpZ1wiLCBcImhwPTJcIl1cbiAgICk7XG4gICB0LnNjYWxlID0gMC4xMztcbiAgIHQuZGlzdGFuY2VfZnJvbV90cmFjayA9IDE1O1xuICAgdC5jcmVhdGVTaWduYWxDb21tYW5kTWVudShbXCJocD0xKEtzIDEpLGhwPTIoS3MgMilcIiwgXCJ6czN2XCIsIFwiZXJzYXR6PWtlbm5saWNodFwiXSk7XG5cbiAgIHQuY2hlY2tTaWduYWxEZXBlbmRlbmN5ID0gc2lnbmFsVGVtcGxhdGVzLmtzLmNoZWNrU2lnbmFsRGVwZW5kZW5jeTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5rc192ciA9IHQ7XG5cbiAgIC8vbHNcbiAgIHQgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXG4gICAgICBcImxzXCIsXG4gICAgICBcIkxpY2h0c3BlcnJzaWduYWxcIixcbiAgICAgIFwibHNcIixcbiAgICAgIFtcbiAgICAgICAgIFwiYmFzaXNcIixcbiAgICAgICAgIFwid3J3XCIsXG4gICAgICAgICBcImxwX3JfbGlua3NcIixcbiAgICAgICAgIFwibHBfcl9yZWNodHNcIixcbiAgICAgICAgIFwibHBfd19vYmVuXCIsXG4gICAgICAgICBcImxwX3dfdW50ZW5cIixcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwicl9saW5rcyxyX3JlY2h0c1wiKS5vbihcImhwPTBcIiksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcIndfb2Jlbix3X3VudGVuXCIpLm9uKFwiaHA9MVwiKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwid19vYmVuXCIpLm9uKFwiZXJzYXR6PWtlbm5saWNodFwiKSxcbiAgICAgICAgIFwic2NodXRlX3JfbGlua3NcIixcbiAgICAgICAgIFwic2NodXRlX3JfcmVjaHRzXCIsXG4gICAgICAgICBcInNjaHV0ZV93X29iZW5cIixcbiAgICAgICAgIFwic2NodXRlX3dfdW50ZW5cIixcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwic2NoaWxkXCIpLm9uKFwiYmV6XCIpLmNoaWxkcyhbbmV3IFRleHRFbGVtZW50KFwiYmV6XCIsIFs1NSxcImNvbmRlbmNlZFwiLDFdLCBcIiMzMzNcIikucG9zKFsyMTAsIDEyNV0pXSksXG4gICAgICBdLFxuICAgICAgXCJocD0wXCJcbiAgICk7XG4gICB0LnNjYWxlID0gMC4wNztcbiAgIHQuY3JlYXRlU2lnbmFsQ29tbWFuZE1lbnUoW1wiaHA9MCxocD0xKFNoIDEpXCIsIFwiZXJzYXR6PWtlbm5saWNodChLZW5ubGljaHQpXCJdKTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5scyA9IHQ7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy5uZTQgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXCJuZTRcIiwgXCJOZSA0XCIsIFwiYmFzaXNcIik7XG4gICBzaWduYWxUZW1wbGF0ZXMubmU0LnNjYWxlID0gMC4yO1xuICAgc2lnbmFsVGVtcGxhdGVzLm5lNC5wcmV2aWV3c2l6ZSA9IDEwO1xuXG4gICBzaWduYWxUZW1wbGF0ZXMubmUxID0gbmV3IFNpZ25hbFRlbXBsYXRlKFwibmUxXCIsIFwiTmUgMVwiLCBcImJhc2lzXCIsIFtcbiAgICAgIFwibmUxXCIsXG4gICAgICBuZXcgVGV4dEVsZW1lbnQoXCJuZTFcIiwgWzIwLCBcIkFyaWFsXCIsIDFdKS5wb3MoWzEwMCwgMTA1XSksXG4gICBdKTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5uZTEuc2NhbGUgPSAwLjE1O1xuICAgc2lnbmFsVGVtcGxhdGVzLm5lMS5kaXN0YW5jZV9mcm9tX3RyYWNrID0gNTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5uZTIgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXCJuZTJcIiwgXCJOZSAyXCIsIFwiYmFzaXNcIik7XG4gICBzaWduYWxUZW1wbGF0ZXMubmUyLnNjYWxlID0gMC4yNTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5uZTIucHJldmlld3NpemUgPSAyMDtcblxuICAgc2lnbmFsVGVtcGxhdGVzLmxmNiA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwibGY2XCIsXG4gICAgICBcIkxmIDZcIixcbiAgICAgIFwiYmFzaXNcIixcbiAgICAgIFtcImxmNlwiLCBuZXcgVGV4dEVsZW1lbnQoXCJnZXNjaHdcIiwgWzExMCwgXCJBcmlhbFwiLCAxXSwgXCIjMzMzXCIpLnBvcyhbOTgsIDhdKV0sXG4gICAgICBbXCJzbGF2ZVwiLCBcImdlc2Nodz05XCJdXG4gICApO1xuICAgc2lnbmFsVGVtcGxhdGVzLmxmNi5jcmVhdGVTaWduYWxDb21tYW5kTWVudShbXCJnZXNjaHcoKVwiXSk7XG4gICBzaWduYWxUZW1wbGF0ZXMubGY2LnNjYWxlID0gMC4xMjtcblxuICAgc2lnbmFsVGVtcGxhdGVzLmxmNyA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwibGY3XCIsXG4gICAgICBcIkxmIDdcIixcbiAgICAgIFwiYmFzaXNcIixcbiAgICAgIFtcImxmN1wiLCBuZXcgVGV4dEVsZW1lbnQoXCJnZXNjaHdcIiwgWzEzMCwgXCJBcmlhbFwiLCAxXSwgXCIjMzMzXCIpLnBvcyhbNTUsIDIwXSldLFxuICAgICAgW1wibWFzdGVyXCIsIFwiZ2VzY2h3PTlcIl1cbiAgICk7XG4gICBzaWduYWxUZW1wbGF0ZXMubGY3LmNyZWF0ZVNpZ25hbENvbW1hbmRNZW51KFtcImdlc2NodygpXCJdKTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5sZjcuc2NhbGUgPSAwLjE1O1xuICAgc2lnbmFsVGVtcGxhdGVzLmxmNy5wcmV2aWV3c2l6ZSA9IDMwO1xuXG4gICBzaWduYWxUZW1wbGF0ZXMubGY3LmNoZWNrU2lnbmFsRGVwZW5kZW5jeSA9IHNpZ25hbFRlbXBsYXRlcy5sZjYuY2hlY2tTaWduYWxEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHNpZ25hbCwgaHApIHtcbiAgICAgIGlmIChzaWduYWwuX3RlbXBsYXRlLmlkID09IFwibGY2XCIgJiYgaHAuX3RlbXBsYXRlLmlkID09IFwibGY3XCIpIHtcbiAgICAgICAgIHNpZ25hbC5zZXRfc3RlbGx1bmcoXCJnZXNjaHdcIiwgaHAuZ2V0KFwiZ2VzY2h3XCIpLCBmYWxzZSk7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH07XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy56czMgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXG4gICAgICBcInpzM1wiLFxuICAgICAgXCJacyAzIChhbGxlaW5zdC4pXCIsXG4gICAgICBcImJhc2lzXCIsXG4gICAgICBbXCJ6czNcIiwgbmV3IFRleHRFbGVtZW50KFwiZ2VzY2h3XCIsWzEyMCwgXCJBcmlhbFwiLCAxXSkucG9zKFs5MCwgNjBdKV0sXG4gICAgICBcImdlc2Nodz05XCJcbiAgICk7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy56czMuY3JlYXRlU2lnbmFsQ29tbWFuZE1lbnUoW1wiZ2VzY2h3KClcIl0pO1xuICAgc2lnbmFsVGVtcGxhdGVzLnpzMy5zY2FsZSA9IDAuMTU7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy56czEwID0gbmV3IFNpZ25hbFRlbXBsYXRlKFwienMxMFwiLCBcIlpzIDEwXCIsIFwiYmFzaXNcIik7XG4gICBzaWduYWxUZW1wbGF0ZXMuenMxMC5zY2FsZSA9IDAuMjtcbiAgIHNpZ25hbFRlbXBsYXRlcy56czEwLnByZXZpZXdzaXplID0gMTU7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy5yYTEwID0gbmV3IFNpZ25hbFRlbXBsYXRlKFwicmExMFwiLCBcIlJhIDEwXCIsIFwiYmFzaXNcIik7XG4gICBzaWduYWxUZW1wbGF0ZXMucmExMC5zY2FsZSA9IDAuMTU7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy56czYgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXCJ6czZcIiwgXCJacyA2XCIsIFwiYmFzaXNcIiwgW1wienM2X2JsZWNoX21hc3RcIiwgXCJ6czZfYmxlY2hcIl0pO1xuICAgc2lnbmFsVGVtcGxhdGVzLnpzNi5zY2FsZSA9IDAuMjtcbiAgIHNpZ25hbFRlbXBsYXRlcy56czYucHJldmlld3NpemUgPSAzMDtcblxuICAgc2lnbmFsVGVtcGxhdGVzLnp1c2F0elNpZ25hbCA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwienVzYXR6XCIsXG4gICAgICBcIlp1c2F0emFuemVpZ2VyXCIsXG4gICAgICBcImJhc2lzXCIsXG4gICAgICBbXG4gICAgICAgICBcInp1c2F0emFuemVpZ2VyXCIsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInpzNl9saWNodFwiKS5vbihcInpzNj0xXCIpLFxuICAgICAgICAgbmV3IFRleHRFbGVtZW50KFwienMzXCIsIFs4NSxcIkRPVFwiXSkucG9zKFs3MCwgNDBdKS5vZmYoXCJ6czY9MVwiKS5vbihcInpzMz4wXCIpLFxuICAgICAgXSxcbiAgICAgIFwienM2PTFcIlxuICAgKTtcbiAgIHNpZ25hbFRlbXBsYXRlcy56dXNhdHpTaWduYWwuc2NhbGUgPSAwLjE1O1xuICAgc2lnbmFsVGVtcGxhdGVzLnp1c2F0elNpZ25hbC5jcmVhdGVTaWduYWxDb21tYW5kTWVudShbW1wienM2PTEoWnMgNilcIl0sIFwienMzKClcIl0pO1xuICAgc2lnbmFsVGVtcGxhdGVzLnp1c2F0elNpZ25hbC5wcmV2aWV3c2l6ZSA9IDMwO1xufVxuXG5cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/code/signal_library.js\n\n}");

/***/ }),

/***/ "./www/code/signaling.js":
/*!*******************************!*\
  !*** ./www/code/signaling.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignalTemplate: () => (/* binding */ SignalTemplate),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   VisualElement: () => (/* binding */ VisualElement)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n\n\n// ES6 Module imports\n\n\n\n//Signals are build of Visual elements. Some elements are always been drawn, like the \"Mast\", others have a varianty of\n//conditions.\n//1st: a VE has conditions, these must match with the Signals features. e.g.: sh1 are only on Zsig and Asig\n//2nd: the visual elemnt must be enabled.\nclass VisualElement {\n   #_blinkt = null;\n   #_image = null;\n   #_pos = 0;\n   #_enabled = null;\n   #_on = [];\n   #_off = null;\n   #_childs = null;\n\n   constructor(image) {\n      this.#_image = image;\n   }\n\n   on(condition, logic_op = \"||\") {\n      if (condition === undefined) return this.#_on;\n      else {\n         if (Array.isArray(condition)) condition = condition.join(logic_op);\n         if (this.#_on == null || !Array.isArray(this.#_on)) this.#_on = condition;\n         else this.#_on.push(condition);\n         return this;\n      }\n   }\n\n   off(condition, logic_op = \"||\") {\n      if (condition === undefined) return this.#_off;\n      else {\n         if (Array.isArray(condition)) condition = condition.join(logic_op);\n         if (this.#_off == null || !Array.isArray(this.#_off)) this.#_off = condition;\n         else this.#_off.push(condition);\n         return this;\n      }\n   }\n\n   childs(childs) {\n      if (childs === undefined) return this.#_childs;\n      else {\n         this.#_childs = childs;\n         return this;\n      }\n   }\n\n   blinkt(blinkt) {\n      if (blinkt === undefined) return this.#_blinkt;\n      else {\n         this.#_blinkt = blinkt;\n         return this;\n      }\n   }\n\n   pos(pos) {\n      if (pos === undefined) return this.#_pos;\n      else {\n         this.#_pos = pos;\n         return this;\n      }\n   }\n\n   get [Symbol.toStringTag]() {\n      return this.#_image;\n   }\n\n   get image() {\n      return this.#_image;\n   }\n\n   //visual elements are visible if the enabled function returns true and the signalstellung is set on the signal\n   //if both are not set, its always enabled\n   isEnabled(signal) {\n      return (this.#_enabled == null || this.#_enabled(signal)) && signal.check(this.#_on);\n   }\n\n   isAllowed(signal) {\n      return this.off() == null || !signal.check(this.off());\n   }\n}\n\nclass TextElement extends VisualElement {\n   #_format;\n   #_color;\n   #_source;\n   #_width_height;\n\n   constructor(source, format = [\"25\",\"Arial\",\"bold\"], color = \"#eee\") {\n      super();\n      this.#_source = source;\n      this.#_format = format;\n      this.#_color = color;\n   }\n\n   \n   get format() {\n      return this.#_format;\n   }\n\n   get color() {\n      return this.#_color;\n   }\n\n\n   //must be an array containing max width and height\n   bounds(width_height){\n      if (width_height === undefined) return this.#_width_height;\n      else {         \n         this.#_width_height = width_height;\n         return this;\n      }\n   }\n\n   getText(signal) {\n      return signal.get(this.#_source);\n   }\n}\n\nclass SignalTemplate {\n   #_id = null;\n   #_title = null;\n   #_start = null;\n   #_json_file = null;\n   #_scale = 0.5;\n   #_signalMenu = null;\n   #_distance_from_track = 0;\n\n   contextMenu = [];\n   elements = [];\n   rules = [];\n\n   get id() {\n      return this.#_id;\n   }\n   get title() {\n      return this.#_title;\n   }\n   get initialSignalStellung() {\n      return this.#_start;\n   }\n   get json_file() {\n      return this.#_json_file;\n   }\n   get scale() {\n      return this.#_scale;\n   }\n   set scale(v) {\n      this.#_scale = v;\n   }\n   get distance_from_track() {\n      return this.#_distance_from_track;\n   }\n   set distance_from_track(v) {\n      this.#_distance_from_track = v;\n   }\n\n   get signalMenu() {\n      return this.#_signalMenu;\n   }\n\n   get start() {\n      return this.#_start;\n   }\n\n   ///creates a structed onbject tree that represents a menu from an array of strings\n   ///array: keeps the array\n   ///comma sperated string e.g.\"hp=0,hp=1,hp=2\": buttonGroup\n   ///single string e.g. \"verk=1(verk)\": btn\n   ///single string without '=' e.g. zs3v: dropdown\n   createSignalCommandMenu(menu_string_array) {\n      let menu_items = menu_string_array.map(\n         function (item) {\n            if (!Array.isArray(item)) item = [item];\n            return item.map(\n               function (str) {\n                  let items = str.split(\",\").map(\n                     function (str) {\n                        let text, command;\n                        let match = str.match(/\\(([^)]*)\\)/);\n                        if (match) {\n                           command = str.split(\"(\")[0];\n                           text = match[1];\n                        } else {\n                           command = str;\n                           // 1. Entferne alles vor und inklusive einem \"=\"\n                           text = command.includes(\"=\") ? command.split(\"=\")[1] : command;\n                           if (text.length == 1) text = command.replace(\"=\", \" \");\n                           else text = text.replace(/(\\d)/, \" $1\");\n                           // 2. Das erste Zeichen in einen Großbuchstaben verwandeln\n                           text = text.charAt(0).toUpperCase() + text.slice(1);\n                        }\n                        return {\n                           type: command.includes(\"=\") ? \"btn\" : \"dropdown\",\n                           text: text,\n                           command: command,\n                           visual_elements: this.getVisualElementsByOnCondition(command),\n                        };\n                     }.bind(this)\n                  );\n\n                  if (items.length > 1)\n                     return {\n                        type: \"buttonGroup\",\n                        items: items,\n                     };\n                  else return items[0];\n               }.bind(this)\n            );\n         }.bind(this)\n      );\n      this.#_signalMenu = menu_items;\n   }\n\n   constructor(id, title, json_file, startElements, initialSignalStellung) {\n      this.#_id = id;\n      this.#_title = title;\n      if (initialSignalStellung) this.#_start = Array.isArray(initialSignalStellung) ? initialSignalStellung : [initialSignalStellung];\n      this.#_json_file = json_file;\n\n      if (startElements) {\n         if (Array.isArray(startElements)) this.elements = startElements;\n         else this.elements = [startElements];\n      } else this.elements = [id];\n\n      window.pl.addSpriteSheet(json_file);\n   }\n\n   getVisualElementsByOnCondition(condition) {\n      let results = [];\n      function iterateItems(ve) {\n         if (Array.isArray(ve)) return ve.some((item) => iterateItems(item));\n         else if (ve instanceof VisualElement) {\n            if (ve.childs()?.some((item) => iterateItems(item)) || [].concat(ve.on()).some((c) => c === condition)) {\n               results.push(ve);\n               return true;\n            }\n         }\n         return false;\n      }\n\n      iterateItems(this.elements);\n\n      return results;\n   }\n\n   ///returns an array with all conditions. Used by UI to determent if a Feauture should be displayed\n   getAllVisualElementConditions() {\n      const stack = [...this.elements];\n      const conditions = [];\n      let ve;\n      while (stack.length > 0) {\n         ve = stack.pop();\n         if (typeof ve == \"object\") {\n            [].concat(ve.on()).forEach((c) => {\n               if (c) c.split(\"&&\").forEach((c) => _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.pushUnique(conditions, c.replace(\"!\", \"\")));\n            });\n\n            if (ve.childs()) stack.push(...ve.childs());\n         }\n      }\n      return conditions;\n   }\n\n   addRule(trigger, setting) {\n      this.rules.push([trigger, setting]);\n   }\n\n   stringify() {\n      return this.id;\n   }\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9zaWduYWxpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhOztBQUViO0FBQ3dDOzs7QUFHeEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaURBQVU7QUFDN0QsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3NpZ25hbGluZy5qcz9iMDhmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IEFycmF5VXRpbHMgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuXG4vL1NpZ25hbHMgYXJlIGJ1aWxkIG9mIFZpc3VhbCBlbGVtZW50cy4gU29tZSBlbGVtZW50cyBhcmUgYWx3YXlzIGJlZW4gZHJhd24sIGxpa2UgdGhlIFwiTWFzdFwiLCBvdGhlcnMgaGF2ZSBhIHZhcmlhbnR5IG9mXG4vL2NvbmRpdGlvbnMuXG4vLzFzdDogYSBWRSBoYXMgY29uZGl0aW9ucywgdGhlc2UgbXVzdCBtYXRjaCB3aXRoIHRoZSBTaWduYWxzIGZlYXR1cmVzLiBlLmcuOiBzaDEgYXJlIG9ubHkgb24gWnNpZyBhbmQgQXNpZ1xuLy8ybmQ6IHRoZSB2aXN1YWwgZWxlbW50IG11c3QgYmUgZW5hYmxlZC5cbmV4cG9ydCBjbGFzcyBWaXN1YWxFbGVtZW50IHtcbiAgICNfYmxpbmt0ID0gbnVsbDtcbiAgICNfaW1hZ2UgPSBudWxsO1xuICAgI19wb3MgPSAwO1xuICAgI19lbmFibGVkID0gbnVsbDtcbiAgICNfb24gPSBbXTtcbiAgICNfb2ZmID0gbnVsbDtcbiAgICNfY2hpbGRzID0gbnVsbDtcblxuICAgY29uc3RydWN0b3IoaW1hZ2UpIHtcbiAgICAgIHRoaXMuI19pbWFnZSA9IGltYWdlO1xuICAgfVxuXG4gICBvbihjb25kaXRpb24sIGxvZ2ljX29wID0gXCJ8fFwiKSB7XG4gICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLiNfb247XG4gICAgICBlbHNlIHtcbiAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmRpdGlvbikpIGNvbmRpdGlvbiA9IGNvbmRpdGlvbi5qb2luKGxvZ2ljX29wKTtcbiAgICAgICAgIGlmICh0aGlzLiNfb24gPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheSh0aGlzLiNfb24pKSB0aGlzLiNfb24gPSBjb25kaXRpb247XG4gICAgICAgICBlbHNlIHRoaXMuI19vbi5wdXNoKGNvbmRpdGlvbik7XG4gICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgIH1cblxuICAgb2ZmKGNvbmRpdGlvbiwgbG9naWNfb3AgPSBcInx8XCIpIHtcbiAgICAgIGlmIChjb25kaXRpb24gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuI19vZmY7XG4gICAgICBlbHNlIHtcbiAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmRpdGlvbikpIGNvbmRpdGlvbiA9IGNvbmRpdGlvbi5qb2luKGxvZ2ljX29wKTtcbiAgICAgICAgIGlmICh0aGlzLiNfb2ZmID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodGhpcy4jX29mZikpIHRoaXMuI19vZmYgPSBjb25kaXRpb247XG4gICAgICAgICBlbHNlIHRoaXMuI19vZmYucHVzaChjb25kaXRpb24pO1xuICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICB9XG5cbiAgIGNoaWxkcyhjaGlsZHMpIHtcbiAgICAgIGlmIChjaGlsZHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuI19jaGlsZHM7XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMuI19jaGlsZHMgPSBjaGlsZHM7XG4gICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgIH1cblxuICAgYmxpbmt0KGJsaW5rdCkge1xuICAgICAgaWYgKGJsaW5rdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy4jX2JsaW5rdDtcbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy4jX2JsaW5rdCA9IGJsaW5rdDtcbiAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgfVxuXG4gICBwb3MocG9zKSB7XG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLiNfcG9zO1xuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLiNfcG9zID0gcG9zO1xuICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICB9XG5cbiAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfaW1hZ2U7XG4gICB9XG5cbiAgIGdldCBpbWFnZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfaW1hZ2U7XG4gICB9XG5cbiAgIC8vdmlzdWFsIGVsZW1lbnRzIGFyZSB2aXNpYmxlIGlmIHRoZSBlbmFibGVkIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBhbmQgdGhlIHNpZ25hbHN0ZWxsdW5nIGlzIHNldCBvbiB0aGUgc2lnbmFsXG4gICAvL2lmIGJvdGggYXJlIG5vdCBzZXQsIGl0cyBhbHdheXMgZW5hYmxlZFxuICAgaXNFbmFibGVkKHNpZ25hbCkge1xuICAgICAgcmV0dXJuICh0aGlzLiNfZW5hYmxlZCA9PSBudWxsIHx8IHRoaXMuI19lbmFibGVkKHNpZ25hbCkpICYmIHNpZ25hbC5jaGVjayh0aGlzLiNfb24pO1xuICAgfVxuXG4gICBpc0FsbG93ZWQoc2lnbmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmYoKSA9PSBudWxsIHx8ICFzaWduYWwuY2hlY2sodGhpcy5vZmYoKSk7XG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUZXh0RWxlbWVudCBleHRlbmRzIFZpc3VhbEVsZW1lbnQge1xuICAgI19mb3JtYXQ7XG4gICAjX2NvbG9yO1xuICAgI19zb3VyY2U7XG4gICAjX3dpZHRoX2hlaWdodDtcblxuICAgY29uc3RydWN0b3Ioc291cmNlLCBmb3JtYXQgPSBbXCIyNVwiLFwiQXJpYWxcIixcImJvbGRcIl0sIGNvbG9yID0gXCIjZWVlXCIpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLiNfc291cmNlID0gc291cmNlO1xuICAgICAgdGhpcy4jX2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgIHRoaXMuI19jb2xvciA9IGNvbG9yO1xuICAgfVxuXG4gICBcbiAgIGdldCBmb3JtYXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4jX2Zvcm1hdDtcbiAgIH1cblxuICAgZ2V0IGNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19jb2xvcjtcbiAgIH1cblxuXG4gICAvL211c3QgYmUgYW4gYXJyYXkgY29udGFpbmluZyBtYXggd2lkdGggYW5kIGhlaWdodFxuICAgYm91bmRzKHdpZHRoX2hlaWdodCl7XG4gICAgICBpZiAod2lkdGhfaGVpZ2h0ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLiNfd2lkdGhfaGVpZ2h0O1xuICAgICAgZWxzZSB7ICAgICAgICAgXG4gICAgICAgICB0aGlzLiNfd2lkdGhfaGVpZ2h0ID0gd2lkdGhfaGVpZ2h0O1xuICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICB9XG5cbiAgIGdldFRleHQoc2lnbmFsKSB7XG4gICAgICByZXR1cm4gc2lnbmFsLmdldCh0aGlzLiNfc291cmNlKTtcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNpZ25hbFRlbXBsYXRlIHtcbiAgICNfaWQgPSBudWxsO1xuICAgI190aXRsZSA9IG51bGw7XG4gICAjX3N0YXJ0ID0gbnVsbDtcbiAgICNfanNvbl9maWxlID0gbnVsbDtcbiAgICNfc2NhbGUgPSAwLjU7XG4gICAjX3NpZ25hbE1lbnUgPSBudWxsO1xuICAgI19kaXN0YW5jZV9mcm9tX3RyYWNrID0gMDtcblxuICAgY29udGV4dE1lbnUgPSBbXTtcbiAgIGVsZW1lbnRzID0gW107XG4gICBydWxlcyA9IFtdO1xuXG4gICBnZXQgaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4jX2lkO1xuICAgfVxuICAgZ2V0IHRpdGxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI190aXRsZTtcbiAgIH1cbiAgIGdldCBpbml0aWFsU2lnbmFsU3RlbGx1bmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy4jX3N0YXJ0O1xuICAgfVxuICAgZ2V0IGpzb25fZmlsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfanNvbl9maWxlO1xuICAgfVxuICAgZ2V0IHNjYWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19zY2FsZTtcbiAgIH1cbiAgIHNldCBzY2FsZSh2KSB7XG4gICAgICB0aGlzLiNfc2NhbGUgPSB2O1xuICAgfVxuICAgZ2V0IGRpc3RhbmNlX2Zyb21fdHJhY2soKSB7XG4gICAgICByZXR1cm4gdGhpcy4jX2Rpc3RhbmNlX2Zyb21fdHJhY2s7XG4gICB9XG4gICBzZXQgZGlzdGFuY2VfZnJvbV90cmFjayh2KSB7XG4gICAgICB0aGlzLiNfZGlzdGFuY2VfZnJvbV90cmFjayA9IHY7XG4gICB9XG5cbiAgIGdldCBzaWduYWxNZW51KCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19zaWduYWxNZW51O1xuICAgfVxuXG4gICBnZXQgc3RhcnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4jX3N0YXJ0O1xuICAgfVxuXG4gICAvLy9jcmVhdGVzIGEgc3RydWN0ZWQgb25iamVjdCB0cmVlIHRoYXQgcmVwcmVzZW50cyBhIG1lbnUgZnJvbSBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAvLy9hcnJheToga2VlcHMgdGhlIGFycmF5XG4gICAvLy9jb21tYSBzcGVyYXRlZCBzdHJpbmcgZS5nLlwiaHA9MCxocD0xLGhwPTJcIjogYnV0dG9uR3JvdXBcbiAgIC8vL3NpbmdsZSBzdHJpbmcgZS5nLiBcInZlcms9MSh2ZXJrKVwiOiBidG5cbiAgIC8vL3NpbmdsZSBzdHJpbmcgd2l0aG91dCAnPScgZS5nLiB6czN2OiBkcm9wZG93blxuICAgY3JlYXRlU2lnbmFsQ29tbWFuZE1lbnUobWVudV9zdHJpbmdfYXJyYXkpIHtcbiAgICAgIGxldCBtZW51X2l0ZW1zID0gbWVudV9zdHJpbmdfYXJyYXkubWFwKFxuICAgICAgICAgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtKSkgaXRlbSA9IFtpdGVtXTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLm1hcChcbiAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IHN0ci5zcGxpdChcIixcIikubWFwKFxuICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQsIGNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBzdHIubWF0Y2goL1xcKChbXildKilcXCkvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IHN0ci5zcGxpdChcIihcIilbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IHN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIEVudGZlcm5lIGFsbGVzIHZvciB1bmQgaW5rbHVzaXZlIGVpbmVtIFwiPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gY29tbWFuZC5pbmNsdWRlcyhcIj1cIikgPyBjb21tYW5kLnNwbGl0KFwiPVwiKVsxXSA6IGNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMSkgdGV4dCA9IGNvbW1hbmQucmVwbGFjZShcIj1cIiwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8oXFxkKS8sIFwiICQxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi4gRGFzIGVyc3RlIFplaWNoZW4gaW4gZWluZW4gR3Jvw59idWNoc3RhYmVuIHZlcndhbmRlbG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4dC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb21tYW5kLmluY2x1ZGVzKFwiPVwiKSA/IFwiYnRuXCIgOiBcImRyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc3VhbF9lbGVtZW50czogdGhpcy5nZXRWaXN1YWxFbGVtZW50c0J5T25Db25kaXRpb24oY29tbWFuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvbkdyb3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogaXRlbXMsXG4gICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gaXRlbXNbMF07XG4gICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICk7XG4gICAgICB0aGlzLiNfc2lnbmFsTWVudSA9IG1lbnVfaXRlbXM7XG4gICB9XG5cbiAgIGNvbnN0cnVjdG9yKGlkLCB0aXRsZSwganNvbl9maWxlLCBzdGFydEVsZW1lbnRzLCBpbml0aWFsU2lnbmFsU3RlbGx1bmcpIHtcbiAgICAgIHRoaXMuI19pZCA9IGlkO1xuICAgICAgdGhpcy4jX3RpdGxlID0gdGl0bGU7XG4gICAgICBpZiAoaW5pdGlhbFNpZ25hbFN0ZWxsdW5nKSB0aGlzLiNfc3RhcnQgPSBBcnJheS5pc0FycmF5KGluaXRpYWxTaWduYWxTdGVsbHVuZykgPyBpbml0aWFsU2lnbmFsU3RlbGx1bmcgOiBbaW5pdGlhbFNpZ25hbFN0ZWxsdW5nXTtcbiAgICAgIHRoaXMuI19qc29uX2ZpbGUgPSBqc29uX2ZpbGU7XG5cbiAgICAgIGlmIChzdGFydEVsZW1lbnRzKSB7XG4gICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdGFydEVsZW1lbnRzKSkgdGhpcy5lbGVtZW50cyA9IHN0YXJ0RWxlbWVudHM7XG4gICAgICAgICBlbHNlIHRoaXMuZWxlbWVudHMgPSBbc3RhcnRFbGVtZW50c107XG4gICAgICB9IGVsc2UgdGhpcy5lbGVtZW50cyA9IFtpZF07XG5cbiAgICAgIHdpbmRvdy5wbC5hZGRTcHJpdGVTaGVldChqc29uX2ZpbGUpO1xuICAgfVxuXG4gICBnZXRWaXN1YWxFbGVtZW50c0J5T25Db25kaXRpb24oY29uZGl0aW9uKSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgICAgZnVuY3Rpb24gaXRlcmF0ZUl0ZW1zKHZlKSB7XG4gICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2ZSkpIHJldHVybiB2ZS5zb21lKChpdGVtKSA9PiBpdGVyYXRlSXRlbXMoaXRlbSkpO1xuICAgICAgICAgZWxzZSBpZiAodmUgaW5zdGFuY2VvZiBWaXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodmUuY2hpbGRzKCk/LnNvbWUoKGl0ZW0pID0+IGl0ZXJhdGVJdGVtcyhpdGVtKSkgfHwgW10uY29uY2F0KHZlLm9uKCkpLnNvbWUoKGMpID0+IGMgPT09IGNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2ZSk7XG4gICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUl0ZW1zKHRoaXMuZWxlbWVudHMpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgIH1cblxuICAgLy8vcmV0dXJucyBhbiBhcnJheSB3aXRoIGFsbCBjb25kaXRpb25zLiBVc2VkIGJ5IFVJIHRvIGRldGVybWVudCBpZiBhIEZlYXV0dXJlIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgIGdldEFsbFZpc3VhbEVsZW1lbnRDb25kaXRpb25zKCkge1xuICAgICAgY29uc3Qgc3RhY2sgPSBbLi4udGhpcy5lbGVtZW50c107XG4gICAgICBjb25zdCBjb25kaXRpb25zID0gW107XG4gICAgICBsZXQgdmU7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgdmUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgIGlmICh0eXBlb2YgdmUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgW10uY29uY2F0KHZlLm9uKCkpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgIGlmIChjKSBjLnNwbGl0KFwiJiZcIikuZm9yRWFjaCgoYykgPT4gQXJyYXlVdGlscy5wdXNoVW5pcXVlKGNvbmRpdGlvbnMsIGMucmVwbGFjZShcIiFcIiwgXCJcIikpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodmUuY2hpbGRzKCkpIHN0YWNrLnB1c2goLi4udmUuY2hpbGRzKCkpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmRpdGlvbnM7XG4gICB9XG5cbiAgIGFkZFJ1bGUodHJpZ2dlciwgc2V0dGluZykge1xuICAgICAgdGhpcy5ydWxlcy5wdXNoKFt0cmlnZ2VyLCBzZXR0aW5nXSk7XG4gICB9XG5cbiAgIHN0cmluZ2lmeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgfVxufVxuXG5cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/code/signaling.js\n\n}");

/***/ }),

/***/ "./www/code/start.js":
/*!***************************!*\
  !*** ./www/code/start.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signalTemplates: () => (/* binding */ signalTemplates)\n/* harmony export */ });\n/* harmony import */ var _preLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./preLoader.js */ \"./www/code/preLoader.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n/* harmony import */ var _trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./trackRendering_basic.js */ \"./www/code/trackRendering_basic.js\");\n/* harmony import */ var _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./trackRendering_textured.js */ \"./www/code/trackRendering_textured.js\");\n/* harmony import */ var _signal_library_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./signal_library.js */ \"./www/code/signal_library.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst VERSION = \"0.5\";\n\nconst DEFAULT_SIMPLIFIED_VIEW = true; // Set to false for textured view by default\n\nconst GRID_SIZE = 100;\nconst GRID_SIZE_2 = GRID_SIZE / 2;\n\nconst SNAP_2_GRID = 10;\nconst MAX_SCALE = 8;\nconst MIN_SCALE = 0.2;\n\nconst MOST_UNDO = 20;\n\nconst DIRECTION = {\n   LEFT_2_RIGTH: 1,\n   RIGHT_2_LEFT: -1,\n};\n\nconst MOUSE_DOWN_ACTION = {\n   NONE: 0,\n   SCROLL: 1,\n   BUILD_TRACK: 2,\n   MOVE_ITEM: 3,\n   DND_SIGNAL: 4,\n   ADD_TRAIN: 5,\n   MOVE_TRAIN: 6,\n   MOVE_OBJECT: 7,\n   DND_TRACK: 8,\n   CUSTOM: 9,\n};\n\nconst CUSTOM_MOUSE_ACTION = {\n   NONE: 0,\n   DRAWING: 1,\n   TEXT: 2,\n   PLATTFORM: 3,\n   TRAIN_COUPLE: 4,\n   TRAIN_DECOUPLE: 5,\n};\n\nconst MENU = {\n   EDIT_SIGNAL: 0,\n   NEW_SIGNAL: 1,\n   EDIT_TRAIN: 2,\n   NEW_TRAIN: 3,\n   NEW_OBJECT: 4,\n   EDIT_OBJECT: 5,\n};\n\nvar stage,\n   debug_container,\n   main_container,\n   overlay_container,\n   ui_container,\n   selection_container,\n   signal_container,\n   track_container,\n   train_container,\n   drawing_container,\n   object_container,\n   grid;\n\nvar previousTouch;\nvar showGrid = true;\nvar edit_mode = true;\nvar custom_mouse_mode = CUSTOM_MOUSE_ACTION.NONE;\nvar pl;\nvar mouseAction = null;\n\nvar renderer;\n\nvar undoHistory = [];\n\nvar signalTemplates = {};\n\nvar selection = {\n   type: \"\",\n   object: null,\n   isSelectedObject: function (test) {\n      if (!test || !this.object || this.type != (0,_tools_js__WEBPACK_IMPORTED_MODULE_10__.type)(test)) return false;\n      if (Array.isArray(this.object)) return this.object.includes(test);\n      else return this.object === test;\n   },\n};\n\n// Make variables globally accessible for other modules during transition\nwindow.VERSION = VERSION;\nwindow.GRID_SIZE = GRID_SIZE;\nwindow.GRID_SIZE_2 = GRID_SIZE_2;\nwindow.DIRECTION = DIRECTION;\nwindow.CUSTOM_MOUSE_ACTION = CUSTOM_MOUSE_ACTION;\nwindow.MOST_UNDO = MOST_UNDO;\nwindow.signalTemplates = signalTemplates;\nwindow.selection = selection;\nwindow.custom_mouse_mode = custom_mouse_mode;\nwindow.undoHistory = undoHistory;\nwindow.updateUndoButtonState = updateUndoButtonState;\nwindow.selectObject = selectObject;\nwindow.selectRenderer = selectRenderer;\nwindow.deleteSelectedObject = deleteSelectedObject;\nwindow.alignSignalContainerWithTrack = alignSignalContainerWithTrack;\n\n$(() => {\n   init();\n});\n\nfunction init() {\n   try {\n      pl = new _preLoader_js__WEBPACK_IMPORTED_MODULE_0__.preLoader(\"images\");\n      window.pl = pl; // Make pl immediately available globally\n      (0,_signal_library_js__WEBPACK_IMPORTED_MODULE_9__.initSignals)(signalTemplates);\n\n      pl.addImage(\"schwellen.png\", \"schwellen\");      \n      pl.addImage(\"bumper1.svg\", \"bumper\");\n   } catch (error) {\n      _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showErrorToast(error);\n   }\n\n   stage = new createjs.Stage(myCanvas);\n   stage.autoClear = true;\n   stage.enableDOMEvents(true);\n   /* console.log(createjs.Touch.isSupported());\n    if (createjs.Touch.isSupported())\n        createjs.Touch.enable(stage); */\n   createjs.Ticker.framerate = 1;\n\n   const create_container = (n) => {\n      let c = new createjs.Container();\n      c.name = n;\n      c.mouseChildren = true;\n      return c;\n   };\n\n   stage.addChild((main_container = create_container(\"main\")));\n   stage.addChild((debug_container = create_container(\"debug\")));\n   main_container.addChild((track_container = create_container(\"tracks\")));\n   main_container.addChild((object_container = create_container(\"objects\")));\n   main_container.addChild((train_container = create_container(\"trains\")));\n   main_container.addChild((signal_container = create_container(\"signals\")));\n   stage.addChild((ui_container = create_container(\"ui\")));\n   stage.addChild((selection_container = create_container(\"selection\")));\n   stage.addChild((overlay_container = create_container(\"overlay\")));\n   stage.addChild((drawing_container = create_container(\"drawing_container\")));\n\n   // Make containers and other variables globally accessible\n   window.stage = stage;\n   window.debug_container = debug_container;\n   window.main_container = main_container;\n   window.overlay_container = overlay_container;\n   window.ui_container = ui_container;\n   window.selection_container = selection_container;\n   window.signal_container = signal_container;\n   window.track_container = track_container;\n   window.train_container = train_container;\n   window.drawing_container = drawing_container;\n   window.object_container = object_container;\n   window.renderer = renderer;\n   window.mouseAction = mouseAction;\n   window.trackRendering_basic = _trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__.trackRendering_basic;\n   window.trackRendering_textured = _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_8__.trackRendering_textured;\n\n   UI.showPreBuildScreen();\n\n   pl.start().then(() => {\n      console.log(`Preloader: ${pl._loadedItems}/${pl._totalItems}`);\n      const id = \"#newItemMenuAccordination\";\n      try {\n         $(id).append([\n            _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\n               \"Hauptsignale\",\n               id,\n               UI.newItemButtons(signalTemplates.hv_hp, signalTemplates.ks, signalTemplates.ls, signalTemplates.zusatzSignal),\n               true\n            ),\n\n            _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\"Vorsignale\", id, UI.newItemButtons(signalTemplates.hv_vr, signalTemplates.ks_vr)),\n            _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\"Lf-Signale\", id, UI.newItemButtons(signalTemplates.lf6, signalTemplates.lf7)),\n            _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\n               \"Ne-Signale\",\n               id,\n               UI.newItemButtons(signalTemplates.ne4, signalTemplates.ne1, signalTemplates.ne2)\n            ),\n            _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\n               \"Weitere\",\n               id,\n               UI.newItemButtons(signalTemplates.zs3, signalTemplates.zs6, signalTemplates.zs10, signalTemplates.ra10)\n            ),\n         ]);\n\n         //STORAGE.loadRecent();\n         selectRenderer(!DEFAULT_SIMPLIFIED_VIEW);\n         updateUndoButtonState();\n      } catch (error) {\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showErrorToast(error);\n      }\n   });\n\n   createjs.Ticker.addEventListener(\"tick\", stage);\n\n   stage.addEventListener(\"stagemousedown\", handleStageMouseDown);\n   stage.addEventListener(\"stagemouseup\", handleStageMouseUp);\n\n   myCanvas.oncontextmenu = () => false;\n   myCanvas.addEventListener(\"wheel\", (event) => {\n      event.preventDefault();\n      if (!myCanvas.prevent_input) {\n         myCanvas.prevent_input = true;\n         let point = new createjs.Point(stage.mouseX, stage.mouseY);\n         let localPoint = stage.globalToLocal(point.x, point.y);\n         let old_scale = stage.scale;\n         let step = event.deltaY / (1000 / stage.scale);\n         stage.scale -= step;\n         stage.scale = Math.min(Math.max(MIN_SCALE, stage.scale), MAX_SCALE);\n\n         if (stage.scale != old_scale) {\n            //if we reached MIN or MAX, the scale value doesnt change anymore\n            // Find where the original point is now\n            let globalPoint = stage.localToGlobal(localPoint.x, localPoint.y);\n            // Move the map by the difference\n            stage.x -= globalPoint.x - point.x;\n            stage.y -= globalPoint.y - point.y;\n            RENDERING.drawGrid();\n            renderer.reDrawEverything();\n            stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n         }\n         myCanvas.prevent_input = false;\n      }\n   });\n   if (createjs.Touch.isSupported()) {\n      myCanvas.addEventListener(\"touchstart\", (event) => {\n         if (event.touches.length === 1) {\n            let touch = event.touches[0];\n            //startTrackDrawing(stage.globalToLocal(touch.clientX, touch.clientY));\n         }\n\n         /* console.log(\"touch:\" + event.touches.length);\n            for (let index = 0; index < event.touches.length; index++) {\n                const item = event.touches[index];\n                console.log(\"x:\" + item.clientX + \":\" + item.clientY);\n            } */\n      });\n\n      myCanvas.addEventListener(\"touchmove\", (event) => {\n         if (event.touches.length === 1) {\n            let touch = event.touches[0];\n\n            if (previousTouch) {\n               // be aware that these only store the movement of the first touch in the touches array\n               stage.x += touch.clientX - previousTouch.clientX;\n               stage.y += touch.clientY - previousTouch.clientY;\n\n               RENDERING.drawGrid(false);\n               renderer.reDrawEverything();\n            }\n\n            previousTouch = touch;\n         }\n      });\n   }\n\n   $(\"#btnDrawTracks,#btnPlay\").click(() => toggleEditMode());\n\n   $(\"#switch_renderer\").on(\"change\", (e) => {\n      selectRenderer(!$(\"#switch_renderer\").is(\":checked\"));\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n   });\n\n   $(\"#btnAddSignals\").click(() => UI.showMenu(MENU.NEW_SIGNAL));\n   $(\"#btnAddTrain\").click(() => UI.showMenu(MENU.NEW_TRAIN));\n   $(\"#btnAddObject\").click(() => UI.showMenu(MENU.NEW_OBJECT));\n\n   $(\"#btnClear\").click(() => {\n      RENDERING.clear();\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n   });\n\n   $(\"#btnCenter\").click(() => {\n      RENDERING.center();\n   });\n\n   $(\"#btnRedraw\").click(() => {\n      //testPerformance(() => renderer.reDrawEverything(true), \"Total redraw time\");\n      renderer.reDrawEverything(true);\n   });\n\n   $(\"#btnImage\").click((e) => {\n      let backup = { x: stage.x, y: stage.y, scale: stage.scale };\n\n      try {\n         const custom_scale = 2;\n         stage.enableDOMEvents(false);\n\n         stage.scale = custom_scale;\n\n         renderer.reDrawEverything(true, true);\n\n         let bounds = main_container.getBounds();\n         if (!bounds) {\n            _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showInfoToast(\"Nix zu sehen\");\n            return;\n         }\n         const anotherCanvas = $(\"<canvas>\", { id: \"test\" })\n            .attr(\"width\", bounds.width * custom_scale)\n            .attr(\"height\", bounds.height * custom_scale);\n         stage.canvas = anotherCanvas[0];\n         stage.x = bounds.x * -custom_scale;\n         stage.y = bounds.y * -custom_scale;\n         grid.visible = false;\n         drawing_container.visible = false;\n         ui_container.visible = false;\n         stage.update();\n\n         let img_data = stage.toDataURL(\"#00000000\", \"image/png\");\n         const img = $(\"<img>\", { src: img_data, width: \"100%\" }).css(\"object-fit\", \"scale-down\").css(\"max-height\", \"50vh\");\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showModalDialog(img, (e) => {\n            const a = $(\"<a>\", { download: \"gleisplan.png\", href: img_data });\n            a[0].click();\n         });\n      } catch (error) {\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showErrorToast(error);\n      } finally {\n         stage.x = backup.x;\n         stage.y = backup.y;\n         stage.scale = backup.scale;\n         stage.canvas = myCanvas;\n         grid.visible = showGrid;\n         drawing_container.visible = true;\n         ui_container.visible = true;\n         renderer.reDrawEverything(true);\n         stage.enableDOMEvents(true);\n         stage.update();\n      }\n   });\n\n   $(\"#btnDraw\").click((e) => {\n      custom_mouse_mode = $(\"#btnDraw\").hasClass(\"active\") ? CUSTOM_MOUSE_ACTION.DRAWING : CUSTOM_MOUSE_ACTION.NONE;\n      window.custom_mouse_mode = custom_mouse_mode; // Update global reference\n      const bsOffcanvas = bootstrap.Offcanvas.getOrCreateInstance(document.getElementById(\"drawingPanel\"));\n      if (custom_mouse_mode === CUSTOM_MOUSE_ACTION.DRAWING) {\n         bsOffcanvas.show();\n      } else {\n         bsOffcanvas.hide();\n      }\n   });\n\n   $(\"#btnDrawingClear\").click((e) => {\n      drawing_container.removeAllChildren();\n      stage.update();\n   });\n\n   $(\"#btnGrundstellung\").click((e) => {\n      if (selection.type == \"Signal\") {\n         [].concat(selection.object).forEach((s) => {\n            s._signalStellung = {};\n            if (s._template.initialSignalStellung)\n               s._template.initialSignalStellung.forEach((i) => s.set_stellung(i, null, true));\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            renderer.reDrawEverything(true);\n            stage.update();\n         });\n      }\n   });\n\n   $(\"#btnUndo\").click((e) => {\n      undo();\n   });\n\n   document.addEventListener(\"keydown\", (e) => {\n      if (e.target.tagName != \"INPUT\" && (e.code == \"Delete\" || e.code == \"Backspace\")) {\n         deleteSelectedObject();\n      }\n   });\n\n   $(\"#signalEditMenuHeader a\").on(\"click\", () => {\n      $(\"#signalEditMenuHeader .card-text\").hide();\n      $(\"#signalEditMenuHeader input\")\n         .val(selection.object.get(\"bez\"))\n         .show()\n         .focus()\n         .on(\"keydown\", function (e) {\n            if (e.key === \"Enter\") {\n               selection.object.set_stellung(\"bez\", $(this).val());\n               $(\"#signalEditMenuHeader .card-text\").show();\n               $(\"#signalEditMenuHeader input\").hide();\n               _signal_js__WEBPACK_IMPORTED_MODULE_1__.Sig_UI.syncSignalMenu(selection.object);\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n               renderer.reDrawEverything(true);\n               stage.update();\n            }\n         })\n         .on(\"blur\", () => {\n            $(\"#signalEditMenuHeader .card-text\").show();\n            $(\"#signalEditMenuHeader input\").hide();\n         });\n   });\n\n   onResizeWindow();\n   toggleEditMode(edit_mode);\n\n   $(window).resize(onResizeWindow);\n   myCanvas.focus();\n}\n\nfunction deleteSelectedObject() {\n   if (selection.object) {\n      if (selection.type == \"Track\") {\n         const removedTracks = [].concat(selection.object);\n         removedTracks.forEach((t) => _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.removeTrack(t));\n         // Check and remove any trains that were on the deleted tracks\n         for (const track of removedTracks) {\n            const trainsOnTrack = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.allTrains.filter((train) => train.track === track);\n            for (const train of trainsOnTrack) {\n               _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.deleteTrain(train);\n            }\n         }\n         _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.createRailNetwork();\n      }\n      if (selection.type == \"Signal\") [].concat(selection.object).forEach((s) => _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal.removeSignal(s, null));\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n      renderer.reDrawEverything(true);\n      stage.update();\n      selectObject();\n   }\n}\n\nfunction updateUndoButtonState() {\n   $(\"#btnUndo\").prop(\"disabled\", undoHistory.length <= 1);\n}\n\nfunction undo() {\n   _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.restoreLastUndoStep();\n   _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n   renderer.reDrawEverything(true);\n   stage.update();\n   updateUndoButtonState();\n}\n\nconst RENDERING = {\n   clear() {\n      selectObject();\n      // Stop any moving trains first\n      _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.stopAllTrains();\n\n      _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.allTracks = [];\n      _switch_js__WEBPACK_IMPORTED_MODULE_3__.Switch.allSwitches = [];\n      _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal.allSignals = new Set();\n      _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.allTrains = [];\n      _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.all_objects = [];\n\n      renderer?.reDrawEverything(true);\n   },\n   center() {\n      stage.scale = 1;\n      stage.x = 0;\n      stage.y = 0;\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n      RENDERING.drawGrid();\n      renderer.reDrawEverything();\n      stage.update();\n   },\n   drawGrid(repaint = true) {\n      if (!grid) {\n         grid = new createjs.Shape();\n         grid.name = \"grid\";\n         grid.mouseEnabled = false;\n         stage.addChildAt(grid, 0);\n         grid.graphics.setStrokeStyle(1, \"round\");\n      }\n\n      grid.visible = showGrid;\n      if (!showGrid) return;\n\n      if (repaint) {\n         const bounds = stage.canvas.getBoundingClientRect();\n         const scale = stage.scale;\n\n         // Calculate visible area in grid coordinates\n         const size = {\n            width: Math.ceil(bounds.width / scale / GRID_SIZE) * GRID_SIZE,\n            height: Math.ceil(bounds.height / scale / GRID_SIZE) * GRID_SIZE,\n         };\n\n         // Add padding to prevent gaps during panning\n         const padding = GRID_SIZE * 2;\n\n         grid.graphics.clear().setStrokeStyle(1, \"round\").setStrokeDash([5, 5], 2).beginStroke(\"#ccc\");\n\n         // Draw vertical lines\n         for (let x = -padding; x <= size.width + padding; x += GRID_SIZE) {\n            grid.graphics.moveTo(x, -padding).lineTo(x, size.height + padding);\n         }\n\n         // Draw horizontal lines\n         for (let y = -padding; y <= size.height + padding; y += GRID_SIZE) {\n            grid.graphics.moveTo(-padding, y).lineTo(size.width + padding, y);\n         }\n\n         // Cache with padding to prevent artifacts\n         grid.cache(-padding, -padding, size.width + padding * 2, size.height + padding * 2, scale);\n      }\n\n      // Align grid to nearest grid line to prevent floating point artifacts\n      const scaled_grid_size = GRID_SIZE * stage.scale;\n      grid.x = Math.floor(stage.x / scaled_grid_size) * -GRID_SIZE;\n      grid.y = Math.floor(stage.y / scaled_grid_size) * -GRID_SIZE;\n   },\n};\n\nwindow.RENDERING = RENDERING;\n\nconst UI = {\n   ///Shows the menu on the right.\n   /// menu==null just hides it.\n   showMenu(menu) {\n      var bsOffcanvas = bootstrap.Offcanvas.getOrCreateInstance($(\"#sidebar\"));\n      $(\"input,button\", bsOffcanvas._element).off().removeClass(\"active\");\n\n      if (menu == null) {\n         bsOffcanvas.hide();\n         return;\n      }\n      const current_id = $('#sidebar>div:not([style*=\"display: none\"])');\n      let div_id;\n      switch (menu) {\n         case MENU.EDIT_SIGNAL:\n            div_id = \"signalEditMenu\";\n            let body = $(\"#nav-home\");\n            body.empty();\n            body.append(_signal_js__WEBPACK_IMPORTED_MODULE_1__.Sig_UI.getHTML(selection.object));\n            _signal_js__WEBPACK_IMPORTED_MODULE_1__.Sig_UI.initSignalMenu();\n            _signal_js__WEBPACK_IMPORTED_MODULE_1__.Sig_UI.syncSignalMenu(selection.object);\n            break;\n         case MENU.NEW_SIGNAL:\n            div_id = \"newItemMenu\";\n            break;\n         case MENU.EDIT_TRAIN:\n            div_id = \"editTrainMenu\";\n            _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.initEditTrainMenu(selection.object);\n            break;\n         case MENU.NEW_TRAIN:\n            div_id = \"newTrainMenu\";\n            $(\"#newTrain\").on(\"mousedown\", (e) => {\n               mouseAction = {\n                  action: MOUSE_DOWN_ACTION.ADD_TRAIN,\n               };\n\n               //mouseup beim document anmelden, weil mouseup im stage nicht ausgelöst wird, wenn mousedown nicht auch auf der stage war\n               //little hack, weil handleStageMouseUp ein event von createjs erwartet\n               document.addEventListener(\"mouseup\", (e) => handleStageMouseUp({ nativeEvent: e }), {\n                  once: true,\n               });\n\n               stage.addEventListener(\"stagemousemove\", handleMouseMove);\n\n               let local_point = stage.globalToLocal(stage.mouseX, stage.mouseY);\n               mouseAction.container = new createjs.Bitmap(\"zug.png\").set({\n                  x: local_point.x,\n                  y: local_point.y,\n                  scale: 0.5,\n                  regY: 96 / 2,\n               });\n\n               overlay_container.addChild(mouseAction.container);\n            });\n            break;\n         case MENU.NEW_OBJECT:\n            div_id = \"newObjectMenu\";\n            $(\"#btnAddText\").click(() => {\n               custom_mouse_mode = $(\"#btnAddText\").hasClass(\"active\") ? CUSTOM_MOUSE_ACTION.TEXT : CUSTOM_MOUSE_ACTION.NONE;\n               window.custom_mouse_mode = custom_mouse_mode; // Update global reference\n               UI.activate_custom_mouse_mode();\n            });\n            $(\"#btnAddPlatform\").click(() => {\n               custom_mouse_mode = $(\"#btnAddPlatform\").hasClass(\"active\")\n                  ? CUSTOM_MOUSE_ACTION.PLATTFORM\n                  : CUSTOM_MOUSE_ACTION.NONE;\n               window.custom_mouse_mode = custom_mouse_mode; // Update global reference\n               UI.activate_custom_mouse_mode();\n            });\n            break;\n         case MENU.EDIT_OBJECT:\n            div_id = \"editObjectMenu\";\n            _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.initEditMenu(selection.object);\n            break;\n         default:\n            throw new Error(\"unknown Menu\");\n      }\n\n      $(\"#sidebar > div\")\n         .not(\"#\" + div_id)\n         .hide();\n      $(\"#sidebar > #\" + div_id).show();\n\n      bsOffcanvas.show();\n      if (bsOffcanvas._isShown) {\n         //bsOffcanvas.show();\n      } else {\n         //bsOffcanvas.hide();\n      }\n   },\n\n   activate_custom_mouse_mode() {\n      switch (custom_mouse_mode) {\n         case CUSTOM_MOUSE_ACTION.TEXT:\n            myCanvas.style.cursor = \"text\";\n            break;\n         default:\n            myCanvas.style.cursor = \"auto\";\n      }\n   },\n\n   showPreBuildScreen() {\n      if (localStorage.getItem(\"bahnhof_last1\") == null) $(btnLoadRecent).attr(\"disabled\", \"disabled\");\n      $(btnStartFromZero).click(UI.hideStartScreen);\n      $(btnLoadRecent).click(() => {\n         _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.loadRecent();\n         UI.hideStartScreen();\n         RENDERING.drawGrid();\n         renderer.reDrawEverything(true);\n      });\n      $(\"#btnLoad2Gleisig,#btnLoad1Gleisig\").on(\"click\", (e) => {\n         const name = $(e.target).attr(\"data\");\n         _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.loadPrebuildbyName(name).then(() => {\n            UI.hideStartScreen();\n            RENDERING.drawGrid();\n            renderer.reDrawEverything(true);\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n         });\n      });\n      /*$(btnLoadFromFile).click(() => { loadSignalsFromFile(); hideStartScreen(); });\n       loadPrebuilds(); */\n      let m = bootstrap.Modal.getOrCreateInstance(loadModal);\n      m._element.addEventListener(\n         \"hidden.bs.modal\",\n         (x) => {\n            bootstrap.Modal.getOrCreateInstance(x.target).dispose();\n            $(btnStartFromZero).off(\"click\");\n            $(btnLoadRecent).off(\"click\");\n            $(btnLoadFromFile).off(\"click\");\n         },\n         { once: true }\n      );\n      m.show();\n   },\n\n   hideStartScreen() {\n      $(\"myCanvas\").focus();\n      bootstrap.Modal.getInstance(loadModal).hide();\n   },\n\n   newItemButtons(...templates) {\n      return templates.map((t) =>\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui\n            .div(\"d-flex newSignalItem align-items-center user-select-none\", [\n               _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui\n                  .div(\"flex-shrink-0 newItem_image\")\n                  .css(\"background-image\", \"url(\" + UI.GetDataURL_FromTemplate(t) + \")\")\n                  .css(\"background-size\", t.previewsize ?? 45),\n               _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.div(\"flex-grow-5 ms-2\", t.title),\n            ])\n            .on(\"mousedown\", (e) => {\n               mouseAction = {\n                  action: MOUSE_DOWN_ACTION.DND_SIGNAL,\n                  template: t,\n               };\n\n               //mouseup beim document anmelden, weil mouseup im stage nicht ausgelöst wird, wenn mousedown nicht auch auf der stage war\n               //little hack, weil handleStageMouseUp ein event von createjs erwartet\n               document.addEventListener(\"mouseup\", (e) => handleStageMouseUp({ nativeEvent: e }), {\n                  once: true,\n               });\n               stage.addEventListener(\"stagemousemove\", handleMouseMove);\n               startDragAndDropSignal(e.offsetX, e.offsetY);\n            })\n      );\n   },\n\n   GetDataURL_FromTemplate(template) {\n      const tmpStage = new createjs.Stage($(\"<canvas>\").attr({ width: 450, height: 450 })[0]);\n      tmpStage.scale = template.scale;\n\n      // Use dedicated preview rendering method\n      _signal_js__WEBPACK_IMPORTED_MODULE_1__.SignalRenderer.drawPreview(template, tmpStage);\n      tmpStage.update();\n\n      const sig_bounds = tmpStage.getBounds();\n      if (sig_bounds == null) throw Error(template.title + \" has no visual Element visible\");\n      tmpStage.cache(sig_bounds.x, sig_bounds.y, sig_bounds.width, sig_bounds.height, 0.5);\n      return tmpStage.bitmapCache.getCacheDataURL();\n   },\n};\n\nfunction toggleEditMode(mode) {\n   edit_mode = mode != undefined ? mode : $(btnDrawTracks).is(\":checked\");\n   showGrid = edit_mode;\n   RENDERING.drawGrid();\n   stage.update();\n   if (mode != undefined) $(btnDrawTracks).prop(\":checked\", edit_mode);\n}\n\nfunction selectRenderer(textured) {\n   if (textured) {\n      renderer = new _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_8__.trackRendering_textured();\n      $(\"#switch_renderer\").prop(\"checked\", false);\n   } else {\n      renderer = new _trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__.trackRendering_basic();\n      $(\"#switch_renderer\").prop(\"checked\", true);\n   }\n   window.renderer = renderer; // Update global reference\n   renderer.reDrawEverything(true);\n   stage.update();\n}\n\nfunction selectObject(object, e) {\n   if (!object) {\n      selection.object = null;\n      selection.type = \"\";\n      renderer?.updateSelection();\n      UI.showMenu();\n      return;\n   }\n   const t = (0,_tools_js__WEBPACK_IMPORTED_MODULE_10__.type)(object);\n   if (object) console.log(object);\n\n   if (t != selection.type) {\n      selection.object = object;\n      selection.type = t;\n   } else {\n      if (e?.nativeEvent?.ctrlKey)\n         selection.object = Array.isArray(selection.object) ? [...selection.object, object] : [selection.object, object];\n      else selection.object = object;\n   }\n   renderer?.updateSelection();\n\n   let menu;\n   switch (t) {\n      case \"Signal\":\n         if (!Array.isArray(selection.object)) menu = MENU.EDIT_SIGNAL;\n         break;\n      case \"Train\":\n         menu = MENU.EDIT_TRAIN;\n         break;\n      case \"GenericObject\":\n         menu = MENU.EDIT_OBJECT;\n         break;\n      default:\n         menu = null;\n         break;\n   }\n\n   UI.showMenu(menu);\n}\n\nfunction onResizeWindow() {\n   $(myCanvas).attr(\"height\", $(CanvasContainer).height() - 5);\n   $(myCanvas).attr(\"width\", $(CanvasContainer).width());\n   RENDERING.drawGrid();\n   stage.update();\n}\n\nfunction handleStageMouseDown(event) {\n   //console.log(\"handleStageMouseDown\", event);\n\n   let hittest = getHitTest();\n\n   console.log(hittest ? hittest : \"nothing hit\");\n\n   mouseAction = {\n      action: custom_mouse_mode != CUSTOM_MOUSE_ACTION.NONE ? MOUSE_DOWN_ACTION.CUSTOM : MOUSE_DOWN_ACTION.NONE,\n      container: hittest,\n      startPoint: stage.globalToLocal(stage.mouseX, stage.mouseY),\n      _distancePoint: new _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point(event.stageX, event.stageY),\n      offset: hittest?.globalToLocal(stage.mouseX, stage.mouseY), //Koordinate auf dem angeklickten Object (zb Signal), damit der Container am Mauszeiger \"klebt\"\n      distance: function () {\n         return _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry.distance(this._distancePoint, new _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point(stage.mouseX, stage.mouseY));\n      },\n   };\n\n   // Check if we clicked on a track endpoint\n   if (mouseAction.container?.name === \"track_endpoint\") {\n      mouseAction.action = MOUSE_DOWN_ACTION.DND_TRACK;\n      mouseAction.track = mouseAction.container.track;\n      mouseAction.endpoint = mouseAction.container.endpoint;\n   }\n\n   if (custom_mouse_mode == CUSTOM_MOUSE_ACTION.DRAWING) {\n      const color = document.querySelector('input[name=\"DrawingColor\"]:checked').value;\n      const width = document.querySelector('input[name=\"DrawingWidth\"]:checked').value;\n\n      drawing_container.addChild((mouseAction.shape = new createjs.Shape()));\n      mouseAction.shape.graphics.setStrokeStyle(width, \"round\", \"round\").beginStroke(color);\n      mouseAction.old_point = new _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point(event.stageX, event.stageY);\n   }\n   //console.log(mouseAction);\n   stage.addEventListener(\"stagemousemove\", handleMouseMove);\n}\n\nfunction getHitTest(container) {\n   let local_point = stage.globalToLocal(stage.mouseX, stage.mouseY);\n\n   return (container ? container : stage).getObjectUnderPoint(local_point.x, local_point.y, 1);\n}\n\nfunction getHitInfoForSignalPositioning(testPoint) {\n   for (const track of _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.allTracks) {\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_11__.NumberUtils.between(testPoint.x, track.start.x, track.end.x)) {\n         const distance = _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry.pointToSegmentDistance(testPoint, track.start, track.end);\n         if (distance <= GRID_SIZE_2) {\n            const point = _tools_js__WEBPACK_IMPORTED_MODULE_10__.TOOLS.nearestPointOnLine(track.start, track.end, testPoint);\n\n            return {\n               track: track,\n               point: point,\n               km: track.getKmfromPoint(point),\n               above: testPoint.y < point.y,\n            };\n         }\n      }\n   }\n}\n\nfunction alignSignalContainerWithTrack(c, pos) {\n   //koordinaten anhand des Strecken KM suchen, wenn sie nicht übergeben worden sind\n\n   const point = pos.track.getPointFromKm(pos.km);\n\n   let p;\n   if (pos.above) {\n      c.rotation = 270 + pos.track.deg;\n      p = point.add(\n         _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry\n            .perpendicular(pos.track.unit)\n            .multiply(-renderer.SIGNAL_DISTANCE_FROM_TRACK - c.data._template.distance_from_track)\n      );\n   } else {\n      c.rotation = 90 + pos.track.deg;\n      p = point.add(\n         _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry\n            .perpendicular(pos.track.unit)\n            .multiply(renderer.SIGNAL_DISTANCE_FROM_TRACK + c.data._template.distance_from_track)\n      );\n   }\n   if (pos.flipped) c.rotation += 180;\n\n   c.x = p.x;\n   c.y = p.y;\n}\n\nfunction startDragAndDropSignal(mouseX, mouseY) {\n   if (mouseAction.container) {\n      mouseAction.container.parent.removeChild(mouseAction.container);\n   } else {\n      let signal = new _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal(mouseAction.template);\n      mouseAction.container = _signal_js__WEBPACK_IMPORTED_MODULE_1__.SignalRenderer.createSignalContainer(signal);\n      mouseAction.container.x = mouseX;\n      mouseAction.container.y = mouseY;\n   }\n\n   overlay_container.addChild(mouseAction.container);\n   stage.update();\n}\n\nfunction handleMouseMove(event) {\n   //console.log(\"handleMouseMove\", event);\n   if (!event.primary) return;\n   if (mouseAction == null) {\n      stage.removeEventListener(\"stagemousemove\", handleMouseMove);\n      return;\n   }\n   //falls mouseMove noch läuft, obwohl der User keinen button mehr drückt\n   //tritt vor allem beim debugging auf\n   if (event.nativeEvent.buttons == 0) {\n      console.log(\"debug mouse error\");\n      return handleStageMouseUp(event);\n   }\n\n   let local_point = stage.globalToLocal(stage.mouseX, stage.mouseY);\n   //console.log(local_point, { x: stage.mouseX, y: stage.mouseY });\n\n   if (mouseAction.action === MOUSE_DOWN_ACTION.NONE) {\n      determineMouseAction(event, local_point);\n   } else if (mouseAction.action === MOUSE_DOWN_ACTION.CUSTOM) {\n      if (custom_mouse_mode == CUSTOM_MOUSE_ACTION.DRAWING) {\n         mouseAction.shape.graphics.mt(mouseAction.startPoint.x, mouseAction.startPoint.y).lt(local_point.x, local_point.y);\n         mouseAction.startPoint.x = local_point.x;\n         mouseAction.startPoint.y = local_point.y;\n      } else if (custom_mouse_mode == CUSTOM_MOUSE_ACTION.PLATTFORM) {\n         overlay_container.removeAllChildren();\n         overlay_container.addChild((mouseAction.shape = new createjs.Shape()));\n         mouseAction.shape.graphics\n            .beginStroke(\"#111111\")\n            .drawRect(\n               mouseAction.startPoint.x,\n               mouseAction.startPoint.y,\n               local_point.x - mouseAction.startPoint.x,\n               local_point.y - mouseAction.startPoint.y\n            );\n         stage.update();\n      }\n   } else if (mouseAction.action === MOUSE_DOWN_ACTION.MOVE_OBJECT) {\n      const o = mouseAction.container.data;\n      o.pos(local_point);\n      if (mouseAction.offset) {\n         let p = mouseAction.container.localToLocal(mouseAction.offset.x, mouseAction.offset.y, stage);\n         local_point.x -= p.x - mouseAction.container.x;\n         local_point.y -= p.y - mouseAction.container.y;\n      }\n      mouseAction.container.x = local_point.x;\n      mouseAction.container.y = local_point.y;\n      renderer.updateSelection();\n   } else if (mouseAction.action === MOUSE_DOWN_ACTION.DND_SIGNAL) {\n      dragnDropSignal(local_point, event.nativeEvent.altKey);\n      renderer.updateSelection();\n   } else if (mouseAction.action === MOUSE_DOWN_ACTION.BUILD_TRACK) {\n      const grid_snap_point = getSnapPoint(local_point);\n\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry.distance(local_point, grid_snap_point) <= SNAP_2_GRID) {\n         if (_track_js__WEBPACK_IMPORTED_MODULE_4__.Track.isValidTrackNodePoint(local_point)) {\n            addTrackAnchorPoint(grid_snap_point);\n         }\n      }\n      drawBluePrintTrack();\n   } else if (mouseAction.action === MOUSE_DOWN_ACTION.SCROLL) {\n      stage.x += event.nativeEvent.movementX;\n      stage.y += event.nativeEvent.movementY;\n      RENDERING.drawGrid(false);\n      renderer.reDrawEverything();\n   } else if (mouseAction.action === MOUSE_DOWN_ACTION.MOVE_TRAIN) {\n      _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.moveTrain(mouseAction.container.data, event.nativeEvent.movementX);\n      renderer.reDrawEverything();\n   } else if (mouseAction.action === MOUSE_DOWN_ACTION.ADD_TRAIN) {\n      mouseAction.container.x = local_point.x;\n      mouseAction.container.y = local_point.y;\n   } else if (mouseAction.action === MOUSE_DOWN_ACTION.DND_TRACK) {\n      const grid_snap_point = getSnapPoint(local_point);\n\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry.distance(local_point, grid_snap_point) <= SNAP_2_GRID) {\n         if (_track_js__WEBPACK_IMPORTED_MODULE_4__.Track.isValidTrackNodePoint(grid_snap_point)) {\n            if (mouseAction.endpoint === \"start\") {\n               mouseAction.track.setNewStart(grid_snap_point);\n            } else {\n               mouseAction.track.setNewEnd(grid_snap_point);\n            }\n            _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.createRailNetwork();\n            renderer.reDrawEverything(true);\n         }\n      }\n   }\n\n   stage.update();\n}\n\nfunction getSnapPoint(local_point) {\n   return new _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point(Math.round(local_point.x / GRID_SIZE) * GRID_SIZE, Math.round(local_point.y / GRID_SIZE) * GRID_SIZE);\n}\n\nfunction determineMouseAction(event, local_point) {\n   //wie weit wurde die maus seit mousedown bewegt\n   if (mouseAction.distance() > 4) {\n      if (event.nativeEvent.buttons == 1) {\n         if (edit_mode) {\n            if (mouseAction.container?.name == \"signal\") {\n               myCanvas.style.cursor = \"move\";\n               mouseAction.action = MOUSE_DOWN_ACTION.DND_SIGNAL;\n               mouseAction.container.data._positioning.track.removeSignal(mouseAction.container.data);\n               startDragAndDropSignal();\n            } else if (mouseAction.container?.name == \"GenericObject\") {\n               myCanvas.style.cursor = \"move\";\n\n               mouseAction.action = MOUSE_DOWN_ACTION.MOVE_OBJECT;\n            } else if (\n               mouseAction.container?.name == \"track\" ||\n               mouseAction.container?.name == \"switch\" ||\n               mouseAction.container == null\n            ) {\n               mouseAction.action = MOUSE_DOWN_ACTION.BUILD_TRACK;\n               addTrackAnchorPoint(getSnapPoint(local_point));\n               overlay_container.addChild((mouseAction.lineShape = new createjs.Shape()));\n            }\n         }\n         if (mouseAction.container?.name == \"train\") {\n            mouseAction.action = MOUSE_DOWN_ACTION.MOVE_TRAIN;\n         }\n      } else if (event.nativeEvent.buttons == 2) {\n         //stage.addEventListener(\"stagemousemove\", handleMouseMove);\n         mouseAction.action = MOUSE_DOWN_ACTION.SCROLL;\n      }\n   }\n}\n\nfunction dragnDropSignal(local_point, flipped) {\n   let hitInformation = getHitInfoForSignalPositioning(local_point);\n   if (hitInformation) {\n      hitInformation.flipped = flipped;\n      mouseAction.hit_track = hitInformation;\n      console.log(hitInformation);\n      alignSignalContainerWithTrack(mouseAction.container, hitInformation);\n   } else {\n      mouseAction.hit_track = null;\n      mouseAction.container.rotation = 0;\n      if (mouseAction.offset) {\n         let p = mouseAction.container.localToLocal(mouseAction.offset.x, mouseAction.offset.y, stage);\n         local_point.x -= p.x - mouseAction.container.x;\n         local_point.y -= p.y - mouseAction.container.y;\n      }\n      mouseAction.container.x = local_point.x;\n      mouseAction.container.y = local_point.y;\n   }\n   draw_SignalPositionLine();\n}\n\nfunction draw_SignalPositionLine() {\n   let shape = overlay_container.getChildByName(\"SignalPositionLine\");\n   if (shape) overlay_container.removeChild(shape);\n\n   if (mouseAction.hit_track) {\n      const point = mouseAction.hit_track.point;\n      shape = new createjs.Shape();\n      shape.name = \"SignalPositionLine\";\n      shape.graphics\n         .setStrokeStyle(1)\n         .beginStroke(\"#e00\")\n         .mt(mouseAction.container.x, mouseAction.container.y)\n         .lt(point.x, point.y)\n         .es();\n      overlay_container.addChild(shape);\n   }\n}\n\nfunction drawBluePrintTrack() {\n   if (mouseAction.nodes == null) return;\n   const g = mouseAction.lineShape.graphics;\n   g.c().setStrokeStyle(_trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__.trackRendering_basic.STROKE).beginStroke(\"blue\").moveTo(mouseAction.nodes[0].x, mouseAction.nodes[0].y);\n\n   for (let index = 1; index < mouseAction.nodes.length; index++) {\n      const point = mouseAction.nodes[index];\n      g.lt(point.x, point.y);\n   }\n\n   const last = _utils_js__WEBPACK_IMPORTED_MODULE_11__.ArrayUtils.last(mouseAction.nodes);\n   const p = stage.globalToLocal(stage.mouseX, stage.mouseY);\n   g.beginStroke(\"red\").moveTo(last.x, last.y).lt(p.x, p.y).endStroke();\n}\n\nfunction addTrackAnchorPoint(p) {\n   if (mouseAction.nodes == null) {\n      mouseAction.nodes = [];\n   }\n\n   //wenn der letzte Punkt gleich dem aktuellen ist, dann nichts tun\n   if (_utils_js__WEBPACK_IMPORTED_MODULE_11__.ArrayUtils.last(mouseAction.nodes)?.equals(p)) return;\n   //wenn der Startpunkt gleich dem aktuellen ist, dann Track zurücksetzen\n   if (_utils_js__WEBPACK_IMPORTED_MODULE_11__.ArrayUtils.first(mouseAction.nodes)?.equals(p)) {\n      mouseAction.nodes = [mouseAction.nodes[0]];\n      return;\n   }\n\n   mouseAction.nodes.push(p);\n   return;\n\n   // removed by dead control flow\n{}\n}\n\nfunction handleStageMouseUp(e) {\n   //console.log(\"handleStageMouseUp\", e);\n   try {\n      stage.removeEventListener(\"stagemousemove\", handleMouseMove);\n      myCanvas.style.cursor = \"auto\";\n      if (mouseAction == null) return;\n\n      let local_point = _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point.fromPoint(stage.globalToLocal(stage.mouseX, stage.mouseY));\n      //left button\n      if (e.nativeEvent.which == 1) {\n         if (mouseAction.action === MOUSE_DOWN_ACTION.DND_SIGNAL) {\n            overlay_container.removeChild(mouseAction.container);\n\n            if (mouseAction.hit_track) {\n               signal_container.addChild(mouseAction.container);\n               const signal = mouseAction.container.data;\n               mouseAction.hit_track.track.AddSignal(\n                  signal,\n                  mouseAction.hit_track.km,\n                  mouseAction.hit_track.above,\n                  mouseAction.hit_track.flipped\n               );\n            }\n            else{\n               _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal.removeSignal(mouseAction.container.data);\n            }\n            renderer.reDrawEverything(true);\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n         } else if (mouseAction.action === MOUSE_DOWN_ACTION.BUILD_TRACK) {\n            if (mouseAction.nodes.length > 0) {\n               _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.checkNodesAndCreateTracks(mouseAction.nodes);\n               _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.createRailNetwork();\n               renderer.reDrawEverything(true);\n               _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.allTrains.forEach((t) => t.restore());\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            }\n         } else if (mouseAction.action === MOUSE_DOWN_ACTION.ADD_TRAIN) {\n            overlay_container.removeChild(mouseAction.container);\n            const hit = getHitTest(track_container);\n            if (hit?.name == \"track\") {\n               const color = _utils_js__WEBPACK_IMPORTED_MODULE_11__.ArrayUtils.random([\"#ff0000\", \"#ffff00\", \"#00ff00\", \"#0000ff\"]);\n               const track = hit.data;\n               const hitInfo = getHitInfoForSignalPositioning(local_point);\n               let train, car, car2;\n               const km = hitInfo.km;\n\n               // Create locomotive as the first car\n               car = train = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.addTrain(track, km, color, _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.CAR_TYPES.LOCOMOTIVE, \"\");\n\n               // Add passenger cars\n               car2 = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.addTrain(track, km, color, _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.CAR_TYPES.PASSENGER, \"\");\n               car.coupleBack(car2);\n               car = car2;\n\n               // Add another passenger car\n               car2 = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.addTrain(track, km, color, _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.CAR_TYPES.PASSENGER, \"\");\n               car.coupleBack(car2);\n               car = car2;\n\n               // Add a third passenger car\n               car2 = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.addTrain(track, km, color, _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.CAR_TYPES.PASSENGER, \"\");\n               car.coupleBack(car2);\n\n               // Update train positions\n               _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.moveTrain(train, 0);\n               renderer.renderAllTrains();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            }\n         } else if (_utils_js__WEBPACK_IMPORTED_MODULE_11__.NumberUtils.is(mouseAction.action, MOUSE_DOWN_ACTION.MOVE_TRAIN, MOUSE_DOWN_ACTION.MOVE_OBJECT)) {\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n         } else if (mouseAction.action === MOUSE_DOWN_ACTION.CUSTOM) {\n            if (custom_mouse_mode == CUSTOM_MOUSE_ACTION.TEXT) {\n               const o = new _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject(_generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.OBJECT_TYPE.text).pos(local_point).content(\"Text\");\n               _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.all_objects.push(o);\n               selectObject(o);\n               renderer.renderAllGenericObjects();\n               custom_mouse_mode = CUSTOM_MOUSE_ACTION.NONE;\n               window.custom_mouse_mode = custom_mouse_mode; // Update global reference\n               UI.activate_custom_mouse_mode();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            } else if (custom_mouse_mode == CUSTOM_MOUSE_ACTION.PLATTFORM) {\n               overlay_container.removeAllChildren();\n               const o = new _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject(_generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.OBJECT_TYPE.plattform)\n                  .content(\"Bahnsteig\")\n                  .pos(mouseAction.startPoint)\n                  .size(local_point.x - mouseAction.startPoint.x, local_point.y - mouseAction.startPoint.y);\n               _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.all_objects.push(o);\n               renderer.renderAllGenericObjects();\n               selectObject(o);\n               custom_mouse_mode = CUSTOM_MOUSE_ACTION.NONE;\n               window.custom_mouse_mode = custom_mouse_mode; // Update global reference\n               UI.activate_custom_mouse_mode();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            } else if (custom_mouse_mode === CUSTOM_MOUSE_ACTION.TRAIN_DECOUPLE) {\n               if (mouseAction.container?.name == \"decouplingPoint\") {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.handleDecouplingClick(mouseAction.container.data);\n               } else {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.exitDecouplingMode();\n               }\n            } else if (custom_mouse_mode === CUSTOM_MOUSE_ACTION.TRAIN_COUPLE) {\n               if (mouseAction.container?.name == \"couplingPoint\") {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.handleCouplingClick(mouseAction.container.data);\n               } else {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.exitCouplingMode();\n               }\n            }\n         } else if (mouseAction.action === MOUSE_DOWN_ACTION.NONE && mouseAction.distance() < 4) {\n            if (mouseAction.container?.name == \"signal\") {\n               selectObject(mouseAction.container.data, e);\n            } else if (mouseAction.container?.name == \"couplingPoint\" && custom_mouse_mode === CUSTOM_MOUSE_ACTION.TRAIN_COUPLE) {\n               // Handle coupling at this point\n               _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.handleCouplingClick(mouseAction.container.data);\n            } else if (mouseAction.container?.name == \"train\") {\n               selectObject(mouseAction.container.data, e);\n            } else if (mouseAction.container?.name == \"track\") {\n               selectObject(mouseAction.container.data, e);\n            } else if (mouseAction.container?.name == \"GenericObject\") {\n               selectObject(mouseAction.container.data, e);\n            } else if (mouseAction.container?.name == \"switch\") {\n               _switch_js__WEBPACK_IMPORTED_MODULE_3__.Switch.switch_A_Switch(mouseAction.container.data, local_point.x);\n               renderer.renderSwitchUI(mouseAction.container.data);\n            } else {\n               selectObject();\n            }\n         }\n      } else if (mouseAction.action === MOUSE_DOWN_ACTION.SCROLL) {\n         _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n      }\n   } catch (error) {\n      _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showErrorToast(error);\n   } finally {\n      mouseAction = null;\n      overlay_container.removeAllChildren();\n      stage.update();\n   }\n}\n\nfunction drawPoint(point, displayObject, label = \"\", color = \"#000\", size = 0.5) {\n   const s = new createjs.Shape();\n   s.graphics.setStrokeStyle(1).beginStroke(color).beginFill(color).drawCircle(0, 0, size);\n   s.x = point.x;\n   s.y = point.y;\n\n   debug_container.addChild(s);\n\n   if (label) {\n      const text = new createjs.Text(label, \"Italic 6px Arial\", color);\n      text.x = s.x;\n      text.y = s.y - 5;\n      text.textBaseline = \"alphabetic\";\n      debug_container.addChild(text);\n   }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGtDQUFrQzs7QUFFbEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxVQUFVLGdEQUFRO0FBQ2xCLGFBQWEsNENBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSw0Q0FBSztBQUNYO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsVUFBVSxnREFBUTtBQUNsQixhQUFhLDRDQUFLO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVksNENBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsNkNBQUs7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEVBQW9COztBQUU1Qyx1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0RBQVU7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyxrREFBVTtBQUNqQjtBQUNBLE9BQU8sa0RBQVU7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUFBLEVBc0NDO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qiw2Q0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBTTtBQUNyQjtBQUNBO0FBQ0EsWUFBWSxnREFBTztBQUNuQixZQUFZLGdEQUFPO0FBQ25CLFdBQVc7QUFDWDtBQUNBLGVBQWUsNENBQUs7QUFDcEIsZUFBZSw0Q0FBSztBQUNwQjtBQUNBLGVBQWUsNENBQUs7QUFDcEIsZUFBZSxnREFBTztBQUN0QixlQUFlLGdEQUFPO0FBQ3RCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qiw0Q0FBSyw0QkFBNEIsNENBQUs7O0FBRW5FO0FBQ0Esc0JBQXNCLDRDQUFLLDRCQUE0Qiw0Q0FBSztBQUM1RDtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDRDQUFLLDRCQUE0Qiw0Q0FBSztBQUM1RDtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDRDQUFLLDRCQUE0Qiw0Q0FBSztBQUM1RDs7QUFFQTtBQUNBLGVBQWUsNENBQUs7QUFDcEI7QUFDQSxlQUFlLGdEQUFPO0FBQ3RCO0FBQ0EsV0FBVyxTQUFTLG1EQUFXO0FBQy9CLFlBQVksZ0RBQU87QUFDbkIsWUFBWSxnREFBTztBQUNuQixXQUFXO0FBQ1g7QUFDQSw2QkFBNkIsNkRBQWEsQ0FBQyw2REFBYTtBQUN4RCxlQUFlLDZEQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLGVBQWUsZ0RBQU87QUFDdEIsZUFBZSxnREFBTztBQUN0QixjQUFjO0FBQ2Q7QUFDQSw2QkFBNkIsNkRBQWEsQ0FBQyw2REFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZEQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLGVBQWUsZ0RBQU87QUFDdEIsZUFBZSxnREFBTztBQUN0QixjQUFjO0FBQ2Q7QUFDQSxrQkFBa0IsNENBQUs7QUFDdkIsaUJBQWlCO0FBQ2pCLGtCQUFrQiw0Q0FBSztBQUN2QjtBQUNBLGNBQWM7QUFDZDtBQUNBLGtCQUFrQiw0Q0FBSztBQUN2QixpQkFBaUI7QUFDakIsa0JBQWtCLDRDQUFLO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWUsNENBQUs7QUFDcEIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkLGVBQWUsOENBQU07QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLFNBQVMsZ0RBQU87QUFDaEI7QUFDQSxLQUFLO0FBQ0wsTUFBTSx1Q0FBRTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3N0YXJ0LmpzPzk3OGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgcHJlTG9hZGVyIH0gZnJvbSAnLi9wcmVMb2FkZXIuanMnO1xuaW1wb3J0IHsgU2lnbmFsUmVuZGVyZXIsIFNpZ25hbCwgU2lnX1VJIH0gZnJvbSAnLi9zaWduYWwuanMnO1xuaW1wb3J0IHsgVHJhaW4gfSBmcm9tICcuL3RyYWluLmpzJztcbmltcG9ydCB7IFN3aXRjaCB9IGZyb20gJy4vc3dpdGNoLmpzJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay5qcyc7XG5pbXBvcnQgeyBHZW5lcmljT2JqZWN0IH0gZnJvbSAnLi9nZW5lcmljX29iamVjdC5qcyc7XG5pbXBvcnQgeyBTVE9SQUdFIH0gZnJvbSAnLi9zdG9yYWdlLmpzJztcbmltcG9ydCB7IHRyYWNrUmVuZGVyaW5nX2Jhc2ljIH0gZnJvbSAnLi90cmFja1JlbmRlcmluZ19iYXNpYy5qcyc7XG5pbXBvcnQgeyB0cmFja1JlbmRlcmluZ190ZXh0dXJlZCB9IGZyb20gJy4vdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuanMnO1xuaW1wb3J0IHsgaW5pdFNpZ25hbHMgfSBmcm9tICcuL3NpZ25hbF9saWJyYXJ5LmpzJztcbmltcG9ydCB7IFxuICAgdHlwZSwgXG4gICBUT09MUywgXG4gICBnZW9tZXRyeSwgXG4gICBQb2ludCwgXG59IGZyb20gJy4vdG9vbHMuanMnO1xuaW1wb3J0IHsgTnVtYmVyVXRpbHMsIEFycmF5VXRpbHMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHVpIH0gZnJvbSAnLi91aS5qcyc7XG5cbmNvbnN0IFZFUlNJT04gPSBcIjAuNVwiO1xuXG5jb25zdCBERUZBVUxUX1NJTVBMSUZJRURfVklFVyA9IHRydWU7IC8vIFNldCB0byBmYWxzZSBmb3IgdGV4dHVyZWQgdmlldyBieSBkZWZhdWx0XG5cbmNvbnN0IEdSSURfU0laRSA9IDEwMDtcbmNvbnN0IEdSSURfU0laRV8yID0gR1JJRF9TSVpFIC8gMjtcblxuY29uc3QgU05BUF8yX0dSSUQgPSAxMDtcbmNvbnN0IE1BWF9TQ0FMRSA9IDg7XG5jb25zdCBNSU5fU0NBTEUgPSAwLjI7XG5cbmNvbnN0IE1PU1RfVU5ETyA9IDIwO1xuXG5jb25zdCBESVJFQ1RJT04gPSB7XG4gICBMRUZUXzJfUklHVEg6IDEsXG4gICBSSUdIVF8yX0xFRlQ6IC0xLFxufTtcblxuY29uc3QgTU9VU0VfRE9XTl9BQ1RJT04gPSB7XG4gICBOT05FOiAwLFxuICAgU0NST0xMOiAxLFxuICAgQlVJTERfVFJBQ0s6IDIsXG4gICBNT1ZFX0lURU06IDMsXG4gICBETkRfU0lHTkFMOiA0LFxuICAgQUREX1RSQUlOOiA1LFxuICAgTU9WRV9UUkFJTjogNixcbiAgIE1PVkVfT0JKRUNUOiA3LFxuICAgRE5EX1RSQUNLOiA4LFxuICAgQ1VTVE9NOiA5LFxufTtcblxuY29uc3QgQ1VTVE9NX01PVVNFX0FDVElPTiA9IHtcbiAgIE5PTkU6IDAsXG4gICBEUkFXSU5HOiAxLFxuICAgVEVYVDogMixcbiAgIFBMQVRURk9STTogMyxcbiAgIFRSQUlOX0NPVVBMRTogNCxcbiAgIFRSQUlOX0RFQ09VUExFOiA1LFxufTtcblxuY29uc3QgTUVOVSA9IHtcbiAgIEVESVRfU0lHTkFMOiAwLFxuICAgTkVXX1NJR05BTDogMSxcbiAgIEVESVRfVFJBSU46IDIsXG4gICBORVdfVFJBSU46IDMsXG4gICBORVdfT0JKRUNUOiA0LFxuICAgRURJVF9PQkpFQ1Q6IDUsXG59O1xuXG52YXIgc3RhZ2UsXG4gICBkZWJ1Z19jb250YWluZXIsXG4gICBtYWluX2NvbnRhaW5lcixcbiAgIG92ZXJsYXlfY29udGFpbmVyLFxuICAgdWlfY29udGFpbmVyLFxuICAgc2VsZWN0aW9uX2NvbnRhaW5lcixcbiAgIHNpZ25hbF9jb250YWluZXIsXG4gICB0cmFja19jb250YWluZXIsXG4gICB0cmFpbl9jb250YWluZXIsXG4gICBkcmF3aW5nX2NvbnRhaW5lcixcbiAgIG9iamVjdF9jb250YWluZXIsXG4gICBncmlkO1xuXG52YXIgcHJldmlvdXNUb3VjaDtcbnZhciBzaG93R3JpZCA9IHRydWU7XG52YXIgZWRpdF9tb2RlID0gdHJ1ZTtcbnZhciBjdXN0b21fbW91c2VfbW9kZSA9IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORTtcbnZhciBwbDtcbnZhciBtb3VzZUFjdGlvbiA9IG51bGw7XG5cbnZhciByZW5kZXJlcjtcblxudmFyIHVuZG9IaXN0b3J5ID0gW107XG5cbmV4cG9ydCB2YXIgc2lnbmFsVGVtcGxhdGVzID0ge307XG5cbnZhciBzZWxlY3Rpb24gPSB7XG4gICB0eXBlOiBcIlwiLFxuICAgb2JqZWN0OiBudWxsLFxuICAgaXNTZWxlY3RlZE9iamVjdDogZnVuY3Rpb24gKHRlc3QpIHtcbiAgICAgIGlmICghdGVzdCB8fCAhdGhpcy5vYmplY3QgfHwgdGhpcy50eXBlICE9IHR5cGUodGVzdCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub2JqZWN0KSkgcmV0dXJuIHRoaXMub2JqZWN0LmluY2x1ZGVzKHRlc3QpO1xuICAgICAgZWxzZSByZXR1cm4gdGhpcy5vYmplY3QgPT09IHRlc3Q7XG4gICB9LFxufTtcblxuLy8gTWFrZSB2YXJpYWJsZXMgZ2xvYmFsbHkgYWNjZXNzaWJsZSBmb3Igb3RoZXIgbW9kdWxlcyBkdXJpbmcgdHJhbnNpdGlvblxud2luZG93LlZFUlNJT04gPSBWRVJTSU9OO1xud2luZG93LkdSSURfU0laRSA9IEdSSURfU0laRTtcbndpbmRvdy5HUklEX1NJWkVfMiA9IEdSSURfU0laRV8yO1xud2luZG93LkRJUkVDVElPTiA9IERJUkVDVElPTjtcbndpbmRvdy5DVVNUT01fTU9VU0VfQUNUSU9OID0gQ1VTVE9NX01PVVNFX0FDVElPTjtcbndpbmRvdy5NT1NUX1VORE8gPSBNT1NUX1VORE87XG53aW5kb3cuc2lnbmFsVGVtcGxhdGVzID0gc2lnbmFsVGVtcGxhdGVzO1xud2luZG93LnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbndpbmRvdy5jdXN0b21fbW91c2VfbW9kZSA9IGN1c3RvbV9tb3VzZV9tb2RlO1xud2luZG93LnVuZG9IaXN0b3J5ID0gdW5kb0hpc3Rvcnk7XG53aW5kb3cudXBkYXRlVW5kb0J1dHRvblN0YXRlID0gdXBkYXRlVW5kb0J1dHRvblN0YXRlO1xud2luZG93LnNlbGVjdE9iamVjdCA9IHNlbGVjdE9iamVjdDtcbndpbmRvdy5zZWxlY3RSZW5kZXJlciA9IHNlbGVjdFJlbmRlcmVyO1xud2luZG93LmRlbGV0ZVNlbGVjdGVkT2JqZWN0ID0gZGVsZXRlU2VsZWN0ZWRPYmplY3Q7XG53aW5kb3cuYWxpZ25TaWduYWxDb250YWluZXJXaXRoVHJhY2sgPSBhbGlnblNpZ25hbENvbnRhaW5lcldpdGhUcmFjaztcblxuJCgoKSA9PiB7XG4gICBpbml0KCk7XG59KTtcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgIHRyeSB7XG4gICAgICBwbCA9IG5ldyBwcmVMb2FkZXIoXCJpbWFnZXNcIik7XG4gICAgICB3aW5kb3cucGwgPSBwbDsgLy8gTWFrZSBwbCBpbW1lZGlhdGVseSBhdmFpbGFibGUgZ2xvYmFsbHlcbiAgICAgIGluaXRTaWduYWxzKHNpZ25hbFRlbXBsYXRlcyk7XG5cbiAgICAgIHBsLmFkZEltYWdlKFwic2Nod2VsbGVuLnBuZ1wiLCBcInNjaHdlbGxlblwiKTsgICAgICBcbiAgICAgIHBsLmFkZEltYWdlKFwiYnVtcGVyMS5zdmdcIiwgXCJidW1wZXJcIik7XG4gICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdWkuc2hvd0Vycm9yVG9hc3QoZXJyb3IpO1xuICAgfVxuXG4gICBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShteUNhbnZhcyk7XG4gICBzdGFnZS5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgc3RhZ2UuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuICAgLyogY29uc29sZS5sb2coY3JlYXRlanMuVG91Y2guaXNTdXBwb3J0ZWQoKSk7XG4gICAgaWYgKGNyZWF0ZWpzLlRvdWNoLmlzU3VwcG9ydGVkKCkpXG4gICAgICAgIGNyZWF0ZWpzLlRvdWNoLmVuYWJsZShzdGFnZSk7ICovXG4gICBjcmVhdGVqcy5UaWNrZXIuZnJhbWVyYXRlID0gMTtcblxuICAgY29uc3QgY3JlYXRlX2NvbnRhaW5lciA9IChuKSA9PiB7XG4gICAgICBsZXQgYyA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgIGMubmFtZSA9IG47XG4gICAgICBjLm1vdXNlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgcmV0dXJuIGM7XG4gICB9O1xuXG4gICBzdGFnZS5hZGRDaGlsZCgobWFpbl9jb250YWluZXIgPSBjcmVhdGVfY29udGFpbmVyKFwibWFpblwiKSkpO1xuICAgc3RhZ2UuYWRkQ2hpbGQoKGRlYnVnX2NvbnRhaW5lciA9IGNyZWF0ZV9jb250YWluZXIoXCJkZWJ1Z1wiKSkpO1xuICAgbWFpbl9jb250YWluZXIuYWRkQ2hpbGQoKHRyYWNrX2NvbnRhaW5lciA9IGNyZWF0ZV9jb250YWluZXIoXCJ0cmFja3NcIikpKTtcbiAgIG1haW5fY29udGFpbmVyLmFkZENoaWxkKChvYmplY3RfY29udGFpbmVyID0gY3JlYXRlX2NvbnRhaW5lcihcIm9iamVjdHNcIikpKTtcbiAgIG1haW5fY29udGFpbmVyLmFkZENoaWxkKCh0cmFpbl9jb250YWluZXIgPSBjcmVhdGVfY29udGFpbmVyKFwidHJhaW5zXCIpKSk7XG4gICBtYWluX2NvbnRhaW5lci5hZGRDaGlsZCgoc2lnbmFsX2NvbnRhaW5lciA9IGNyZWF0ZV9jb250YWluZXIoXCJzaWduYWxzXCIpKSk7XG4gICBzdGFnZS5hZGRDaGlsZCgodWlfY29udGFpbmVyID0gY3JlYXRlX2NvbnRhaW5lcihcInVpXCIpKSk7XG4gICBzdGFnZS5hZGRDaGlsZCgoc2VsZWN0aW9uX2NvbnRhaW5lciA9IGNyZWF0ZV9jb250YWluZXIoXCJzZWxlY3Rpb25cIikpKTtcbiAgIHN0YWdlLmFkZENoaWxkKChvdmVybGF5X2NvbnRhaW5lciA9IGNyZWF0ZV9jb250YWluZXIoXCJvdmVybGF5XCIpKSk7XG4gICBzdGFnZS5hZGRDaGlsZCgoZHJhd2luZ19jb250YWluZXIgPSBjcmVhdGVfY29udGFpbmVyKFwiZHJhd2luZ19jb250YWluZXJcIikpKTtcblxuICAgLy8gTWFrZSBjb250YWluZXJzIGFuZCBvdGhlciB2YXJpYWJsZXMgZ2xvYmFsbHkgYWNjZXNzaWJsZVxuICAgd2luZG93LnN0YWdlID0gc3RhZ2U7XG4gICB3aW5kb3cuZGVidWdfY29udGFpbmVyID0gZGVidWdfY29udGFpbmVyO1xuICAgd2luZG93Lm1haW5fY29udGFpbmVyID0gbWFpbl9jb250YWluZXI7XG4gICB3aW5kb3cub3ZlcmxheV9jb250YWluZXIgPSBvdmVybGF5X2NvbnRhaW5lcjtcbiAgIHdpbmRvdy51aV9jb250YWluZXIgPSB1aV9jb250YWluZXI7XG4gICB3aW5kb3cuc2VsZWN0aW9uX2NvbnRhaW5lciA9IHNlbGVjdGlvbl9jb250YWluZXI7XG4gICB3aW5kb3cuc2lnbmFsX2NvbnRhaW5lciA9IHNpZ25hbF9jb250YWluZXI7XG4gICB3aW5kb3cudHJhY2tfY29udGFpbmVyID0gdHJhY2tfY29udGFpbmVyO1xuICAgd2luZG93LnRyYWluX2NvbnRhaW5lciA9IHRyYWluX2NvbnRhaW5lcjtcbiAgIHdpbmRvdy5kcmF3aW5nX2NvbnRhaW5lciA9IGRyYXdpbmdfY29udGFpbmVyO1xuICAgd2luZG93Lm9iamVjdF9jb250YWluZXIgPSBvYmplY3RfY29udGFpbmVyO1xuICAgd2luZG93LnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICB3aW5kb3cubW91c2VBY3Rpb24gPSBtb3VzZUFjdGlvbjtcbiAgIHdpbmRvdy50cmFja1JlbmRlcmluZ19iYXNpYyA9IHRyYWNrUmVuZGVyaW5nX2Jhc2ljO1xuICAgd2luZG93LnRyYWNrUmVuZGVyaW5nX3RleHR1cmVkID0gdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQ7XG5cbiAgIFVJLnNob3dQcmVCdWlsZFNjcmVlbigpO1xuXG4gICBwbC5zdGFydCgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coYFByZWxvYWRlcjogJHtwbC5fbG9hZGVkSXRlbXN9LyR7cGwuX3RvdGFsSXRlbXN9YCk7XG4gICAgICBjb25zdCBpZCA9IFwiI25ld0l0ZW1NZW51QWNjb3JkaW5hdGlvblwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgICQoaWQpLmFwcGVuZChbXG4gICAgICAgICAgICB1aS5jcmVhdGVBY2NvcmRpb25JdGVtKFxuICAgICAgICAgICAgICAgXCJIYXVwdHNpZ25hbGVcIixcbiAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgVUkubmV3SXRlbUJ1dHRvbnMoc2lnbmFsVGVtcGxhdGVzLmh2X2hwLCBzaWduYWxUZW1wbGF0ZXMua3MsIHNpZ25hbFRlbXBsYXRlcy5scywgc2lnbmFsVGVtcGxhdGVzLnp1c2F0elNpZ25hbCksXG4gICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICB1aS5jcmVhdGVBY2NvcmRpb25JdGVtKFwiVm9yc2lnbmFsZVwiLCBpZCwgVUkubmV3SXRlbUJ1dHRvbnMoc2lnbmFsVGVtcGxhdGVzLmh2X3ZyLCBzaWduYWxUZW1wbGF0ZXMua3NfdnIpKSxcbiAgICAgICAgICAgIHVpLmNyZWF0ZUFjY29yZGlvbkl0ZW0oXCJMZi1TaWduYWxlXCIsIGlkLCBVSS5uZXdJdGVtQnV0dG9ucyhzaWduYWxUZW1wbGF0ZXMubGY2LCBzaWduYWxUZW1wbGF0ZXMubGY3KSksXG4gICAgICAgICAgICB1aS5jcmVhdGVBY2NvcmRpb25JdGVtKFxuICAgICAgICAgICAgICAgXCJOZS1TaWduYWxlXCIsXG4gICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgIFVJLm5ld0l0ZW1CdXR0b25zKHNpZ25hbFRlbXBsYXRlcy5uZTQsIHNpZ25hbFRlbXBsYXRlcy5uZTEsIHNpZ25hbFRlbXBsYXRlcy5uZTIpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdWkuY3JlYXRlQWNjb3JkaW9uSXRlbShcbiAgICAgICAgICAgICAgIFwiV2VpdGVyZVwiLFxuICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICBVSS5uZXdJdGVtQnV0dG9ucyhzaWduYWxUZW1wbGF0ZXMuenMzLCBzaWduYWxUZW1wbGF0ZXMuenM2LCBzaWduYWxUZW1wbGF0ZXMuenMxMCwgc2lnbmFsVGVtcGxhdGVzLnJhMTApXG4gICAgICAgICAgICApLFxuICAgICAgICAgXSk7XG5cbiAgICAgICAgIC8vU1RPUkFHRS5sb2FkUmVjZW50KCk7XG4gICAgICAgICBzZWxlY3RSZW5kZXJlcighREVGQVVMVF9TSU1QTElGSUVEX1ZJRVcpO1xuICAgICAgICAgdXBkYXRlVW5kb0J1dHRvblN0YXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgdWkuc2hvd0Vycm9yVG9hc3QoZXJyb3IpO1xuICAgICAgfVxuICAgfSk7XG5cbiAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBzdGFnZSk7XG5cbiAgIHN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGFnZW1vdXNlZG93blwiLCBoYW5kbGVTdGFnZU1vdXNlRG93bik7XG4gICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZXVwXCIsIGhhbmRsZVN0YWdlTW91c2VVcCk7XG5cbiAgIG15Q2FudmFzLm9uY29udGV4dG1lbnUgPSAoKSA9PiBmYWxzZTtcbiAgIG15Q2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIW15Q2FudmFzLnByZXZlbnRfaW5wdXQpIHtcbiAgICAgICAgIG15Q2FudmFzLnByZXZlbnRfaW5wdXQgPSB0cnVlO1xuICAgICAgICAgbGV0IHBvaW50ID0gbmV3IGNyZWF0ZWpzLlBvaW50KHN0YWdlLm1vdXNlWCwgc3RhZ2UubW91c2VZKTtcbiAgICAgICAgIGxldCBsb2NhbFBvaW50ID0gc3RhZ2UuZ2xvYmFsVG9Mb2NhbChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgIGxldCBvbGRfc2NhbGUgPSBzdGFnZS5zY2FsZTtcbiAgICAgICAgIGxldCBzdGVwID0gZXZlbnQuZGVsdGFZIC8gKDEwMDAgLyBzdGFnZS5zY2FsZSk7XG4gICAgICAgICBzdGFnZS5zY2FsZSAtPSBzdGVwO1xuICAgICAgICAgc3RhZ2Uuc2NhbGUgPSBNYXRoLm1pbihNYXRoLm1heChNSU5fU0NBTEUsIHN0YWdlLnNjYWxlKSwgTUFYX1NDQUxFKTtcblxuICAgICAgICAgaWYgKHN0YWdlLnNjYWxlICE9IG9sZF9zY2FsZSkge1xuICAgICAgICAgICAgLy9pZiB3ZSByZWFjaGVkIE1JTiBvciBNQVgsIHRoZSBzY2FsZSB2YWx1ZSBkb2VzbnQgY2hhbmdlIGFueW1vcmVcbiAgICAgICAgICAgIC8vIEZpbmQgd2hlcmUgdGhlIG9yaWdpbmFsIHBvaW50IGlzIG5vd1xuICAgICAgICAgICAgbGV0IGdsb2JhbFBvaW50ID0gc3RhZ2UubG9jYWxUb0dsb2JhbChsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBtYXAgYnkgdGhlIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIHN0YWdlLnggLT0gZ2xvYmFsUG9pbnQueCAtIHBvaW50Lng7XG4gICAgICAgICAgICBzdGFnZS55IC09IGdsb2JhbFBvaW50LnkgLSBwb2ludC55O1xuICAgICAgICAgICAgUkVOREVSSU5HLmRyYXdHcmlkKCk7XG4gICAgICAgICAgICByZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKCk7XG4gICAgICAgICAgICBzdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgfVxuICAgICAgICAgbXlDYW52YXMucHJldmVudF9pbnB1dCA9IGZhbHNlO1xuICAgICAgfVxuICAgfSk7XG4gICBpZiAoY3JlYXRlanMuVG91Y2guaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgbXlDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICAgICAgICAvL3N0YXJ0VHJhY2tEcmF3aW5nKHN0YWdlLmdsb2JhbFRvTG9jYWwodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSkpO1xuICAgICAgICAgfVxuXG4gICAgICAgICAvKiBjb25zb2xlLmxvZyhcInRvdWNoOlwiICsgZXZlbnQudG91Y2hlcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGV2ZW50LnRvdWNoZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwieDpcIiArIGl0ZW0uY2xpZW50WCArIFwiOlwiICsgaXRlbS5jbGllbnRZKTtcbiAgICAgICAgICAgIH0gKi9cbiAgICAgIH0pO1xuXG4gICAgICBteUNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNUb3VjaCkge1xuICAgICAgICAgICAgICAgLy8gYmUgYXdhcmUgdGhhdCB0aGVzZSBvbmx5IHN0b3JlIHRoZSBtb3ZlbWVudCBvZiB0aGUgZmlyc3QgdG91Y2ggaW4gdGhlIHRvdWNoZXMgYXJyYXlcbiAgICAgICAgICAgICAgIHN0YWdlLnggKz0gdG91Y2guY2xpZW50WCAtIHByZXZpb3VzVG91Y2guY2xpZW50WDtcbiAgICAgICAgICAgICAgIHN0YWdlLnkgKz0gdG91Y2guY2xpZW50WSAtIHByZXZpb3VzVG91Y2guY2xpZW50WTtcblxuICAgICAgICAgICAgICAgUkVOREVSSU5HLmRyYXdHcmlkKGZhbHNlKTtcbiAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldmlvdXNUb3VjaCA9IHRvdWNoO1xuICAgICAgICAgfVxuICAgICAgfSk7XG4gICB9XG5cbiAgICQoXCIjYnRuRHJhd1RyYWNrcywjYnRuUGxheVwiKS5jbGljaygoKSA9PiB0b2dnbGVFZGl0TW9kZSgpKTtcblxuICAgJChcIiNzd2l0Y2hfcmVuZGVyZXJcIikub24oXCJjaGFuZ2VcIiwgKGUpID0+IHtcbiAgICAgIHNlbGVjdFJlbmRlcmVyKCEkKFwiI3N3aXRjaF9yZW5kZXJlclwiKS5pcyhcIjpjaGVja2VkXCIpKTtcbiAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgfSk7XG5cbiAgICQoXCIjYnRuQWRkU2lnbmFsc1wiKS5jbGljaygoKSA9PiBVSS5zaG93TWVudShNRU5VLk5FV19TSUdOQUwpKTtcbiAgICQoXCIjYnRuQWRkVHJhaW5cIikuY2xpY2soKCkgPT4gVUkuc2hvd01lbnUoTUVOVS5ORVdfVFJBSU4pKTtcbiAgICQoXCIjYnRuQWRkT2JqZWN0XCIpLmNsaWNrKCgpID0+IFVJLnNob3dNZW51KE1FTlUuTkVXX09CSkVDVCkpO1xuXG4gICAkKFwiI2J0bkNsZWFyXCIpLmNsaWNrKCgpID0+IHtcbiAgICAgIFJFTkRFUklORy5jbGVhcigpO1xuICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICBTVE9SQUdFLnNhdmVVbmRvSGlzdG9yeSgpO1xuICAgfSk7XG5cbiAgICQoXCIjYnRuQ2VudGVyXCIpLmNsaWNrKCgpID0+IHtcbiAgICAgIFJFTkRFUklORy5jZW50ZXIoKTtcbiAgIH0pO1xuXG4gICAkKFwiI2J0blJlZHJhd1wiKS5jbGljaygoKSA9PiB7XG4gICAgICAvL3Rlc3RQZXJmb3JtYW5jZSgoKSA9PiByZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpLCBcIlRvdGFsIHJlZHJhdyB0aW1lXCIpO1xuICAgICAgcmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlKTtcbiAgIH0pO1xuXG4gICAkKFwiI2J0bkltYWdlXCIpLmNsaWNrKChlKSA9PiB7XG4gICAgICBsZXQgYmFja3VwID0geyB4OiBzdGFnZS54LCB5OiBzdGFnZS55LCBzY2FsZTogc3RhZ2Uuc2NhbGUgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgIGNvbnN0IGN1c3RvbV9zY2FsZSA9IDI7XG4gICAgICAgICBzdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXG4gICAgICAgICBzdGFnZS5zY2FsZSA9IGN1c3RvbV9zY2FsZTtcblxuICAgICAgICAgcmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlLCB0cnVlKTtcblxuICAgICAgICAgbGV0IGJvdW5kcyA9IG1haW5fY29udGFpbmVyLmdldEJvdW5kcygpO1xuICAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICAgIHVpLnNob3dJbmZvVG9hc3QoXCJOaXggenUgc2VoZW5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG4gICAgICAgICBjb25zdCBhbm90aGVyQ2FudmFzID0gJChcIjxjYW52YXM+XCIsIHsgaWQ6IFwidGVzdFwiIH0pXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGJvdW5kcy53aWR0aCAqIGN1c3RvbV9zY2FsZSlcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGJvdW5kcy5oZWlnaHQgKiBjdXN0b21fc2NhbGUpO1xuICAgICAgICAgc3RhZ2UuY2FudmFzID0gYW5vdGhlckNhbnZhc1swXTtcbiAgICAgICAgIHN0YWdlLnggPSBib3VuZHMueCAqIC1jdXN0b21fc2NhbGU7XG4gICAgICAgICBzdGFnZS55ID0gYm91bmRzLnkgKiAtY3VzdG9tX3NjYWxlO1xuICAgICAgICAgZ3JpZC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICBkcmF3aW5nX2NvbnRhaW5lci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICB1aV9jb250YWluZXIudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG5cbiAgICAgICAgIGxldCBpbWdfZGF0YSA9IHN0YWdlLnRvRGF0YVVSTChcIiMwMDAwMDAwMFwiLCBcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgIGNvbnN0IGltZyA9ICQoXCI8aW1nPlwiLCB7IHNyYzogaW1nX2RhdGEsIHdpZHRoOiBcIjEwMCVcIiB9KS5jc3MoXCJvYmplY3QtZml0XCIsIFwic2NhbGUtZG93blwiKS5jc3MoXCJtYXgtaGVpZ2h0XCIsIFwiNTB2aFwiKTtcbiAgICAgICAgIHVpLnNob3dNb2RhbERpYWxvZyhpbWcsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gJChcIjxhPlwiLCB7IGRvd25sb2FkOiBcImdsZWlzcGxhbi5wbmdcIiwgaHJlZjogaW1nX2RhdGEgfSk7XG4gICAgICAgICAgICBhWzBdLmNsaWNrKCk7XG4gICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICB1aS5zaG93RXJyb3JUb2FzdChlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgc3RhZ2UueCA9IGJhY2t1cC54O1xuICAgICAgICAgc3RhZ2UueSA9IGJhY2t1cC55O1xuICAgICAgICAgc3RhZ2Uuc2NhbGUgPSBiYWNrdXAuc2NhbGU7XG4gICAgICAgICBzdGFnZS5jYW52YXMgPSBteUNhbnZhcztcbiAgICAgICAgIGdyaWQudmlzaWJsZSA9IHNob3dHcmlkO1xuICAgICAgICAgZHJhd2luZ19jb250YWluZXIudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICB1aV9jb250YWluZXIudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICByZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgICAgc3RhZ2UuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG4gICAgICB9XG4gICB9KTtcblxuICAgJChcIiNidG5EcmF3XCIpLmNsaWNrKChlKSA9PiB7XG4gICAgICBjdXN0b21fbW91c2VfbW9kZSA9ICQoXCIjYnRuRHJhd1wiKS5oYXNDbGFzcyhcImFjdGl2ZVwiKSA/IENVU1RPTV9NT1VTRV9BQ1RJT04uRFJBV0lORyA6IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORTtcbiAgICAgIHdpbmRvdy5jdXN0b21fbW91c2VfbW9kZSA9IGN1c3RvbV9tb3VzZV9tb2RlOyAvLyBVcGRhdGUgZ2xvYmFsIHJlZmVyZW5jZVxuICAgICAgY29uc3QgYnNPZmZjYW52YXMgPSBib290c3RyYXAuT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkcmF3aW5nUGFuZWxcIikpO1xuICAgICAgaWYgKGN1c3RvbV9tb3VzZV9tb2RlID09PSBDVVNUT01fTU9VU0VfQUNUSU9OLkRSQVdJTkcpIHtcbiAgICAgICAgIGJzT2ZmY2FudmFzLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBic09mZmNhbnZhcy5oaWRlKCk7XG4gICAgICB9XG4gICB9KTtcblxuICAgJChcIiNidG5EcmF3aW5nQ2xlYXJcIikuY2xpY2soKGUpID0+IHtcbiAgICAgIGRyYXdpbmdfY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICBzdGFnZS51cGRhdGUoKTtcbiAgIH0pO1xuXG4gICAkKFwiI2J0bkdydW5kc3RlbGx1bmdcIikuY2xpY2soKGUpID0+IHtcbiAgICAgIGlmIChzZWxlY3Rpb24udHlwZSA9PSBcIlNpZ25hbFwiKSB7XG4gICAgICAgICBbXS5jb25jYXQoc2VsZWN0aW9uLm9iamVjdCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgcy5fc2lnbmFsU3RlbGx1bmcgPSB7fTtcbiAgICAgICAgICAgIGlmIChzLl90ZW1wbGF0ZS5pbml0aWFsU2lnbmFsU3RlbGx1bmcpXG4gICAgICAgICAgICAgICBzLl90ZW1wbGF0ZS5pbml0aWFsU2lnbmFsU3RlbGx1bmcuZm9yRWFjaCgoaSkgPT4gcy5zZXRfc3RlbGx1bmcoaSwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICAgICAgICByZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgIH0pO1xuXG4gICAkKFwiI2J0blVuZG9cIikuY2xpY2soKGUpID0+IHtcbiAgICAgIHVuZG8oKTtcbiAgIH0pO1xuXG4gICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgIT0gXCJJTlBVVFwiICYmIChlLmNvZGUgPT0gXCJEZWxldGVcIiB8fCBlLmNvZGUgPT0gXCJCYWNrc3BhY2VcIikpIHtcbiAgICAgICAgIGRlbGV0ZVNlbGVjdGVkT2JqZWN0KCk7XG4gICAgICB9XG4gICB9KTtcblxuICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciBhXCIpLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciAuY2FyZC10ZXh0XCIpLmhpZGUoKTtcbiAgICAgICQoXCIjc2lnbmFsRWRpdE1lbnVIZWFkZXIgaW5wdXRcIilcbiAgICAgICAgIC52YWwoc2VsZWN0aW9uLm9iamVjdC5nZXQoXCJiZXpcIikpXG4gICAgICAgICAuc2hvdygpXG4gICAgICAgICAuZm9jdXMoKVxuICAgICAgICAgLm9uKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vYmplY3Quc2V0X3N0ZWxsdW5nKFwiYmV6XCIsICQodGhpcykudmFsKCkpO1xuICAgICAgICAgICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciAuY2FyZC10ZXh0XCIpLnNob3coKTtcbiAgICAgICAgICAgICAgICQoXCIjc2lnbmFsRWRpdE1lbnVIZWFkZXIgaW5wdXRcIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgU2lnX1VJLnN5bmNTaWduYWxNZW51KHNlbGVjdGlvbi5vYmplY3QpO1xuICAgICAgICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICAgICAgICAgICByZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9KVxuICAgICAgICAgLm9uKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICAkKFwiI3NpZ25hbEVkaXRNZW51SGVhZGVyIC5jYXJkLXRleHRcIikuc2hvdygpO1xuICAgICAgICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciBpbnB1dFwiKS5oaWRlKCk7XG4gICAgICAgICB9KTtcbiAgIH0pO1xuXG4gICBvblJlc2l6ZVdpbmRvdygpO1xuICAgdG9nZ2xlRWRpdE1vZGUoZWRpdF9tb2RlKTtcblxuICAgJCh3aW5kb3cpLnJlc2l6ZShvblJlc2l6ZVdpbmRvdyk7XG4gICBteUNhbnZhcy5mb2N1cygpO1xufVxuXG5mdW5jdGlvbiBkZWxldGVTZWxlY3RlZE9iamVjdCgpIHtcbiAgIGlmIChzZWxlY3Rpb24ub2JqZWN0KSB7XG4gICAgICBpZiAoc2VsZWN0aW9uLnR5cGUgPT0gXCJUcmFja1wiKSB7XG4gICAgICAgICBjb25zdCByZW1vdmVkVHJhY2tzID0gW10uY29uY2F0KHNlbGVjdGlvbi5vYmplY3QpO1xuICAgICAgICAgcmVtb3ZlZFRyYWNrcy5mb3JFYWNoKCh0KSA9PiBUcmFjay5yZW1vdmVUcmFjayh0KSk7XG4gICAgICAgICAvLyBDaGVjayBhbmQgcmVtb3ZlIGFueSB0cmFpbnMgdGhhdCB3ZXJlIG9uIHRoZSBkZWxldGVkIHRyYWNrc1xuICAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiByZW1vdmVkVHJhY2tzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFpbnNPblRyYWNrID0gVHJhaW4uYWxsVHJhaW5zLmZpbHRlcigodHJhaW4pID0+IHRyYWluLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWluIG9mIHRyYWluc09uVHJhY2spIHtcbiAgICAgICAgICAgICAgIFRyYWluLmRlbGV0ZVRyYWluKHRyYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIFRyYWNrLmNyZWF0ZVJhaWxOZXR3b3JrKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uLnR5cGUgPT0gXCJTaWduYWxcIikgW10uY29uY2F0KHNlbGVjdGlvbi5vYmplY3QpLmZvckVhY2goKHMpID0+IFNpZ25hbC5yZW1vdmVTaWduYWwocywgbnVsbCkpO1xuICAgICAgU1RPUkFHRS5zYXZlVW5kb0hpc3RvcnkoKTtcbiAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgcmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlKTtcbiAgICAgIHN0YWdlLnVwZGF0ZSgpO1xuICAgICAgc2VsZWN0T2JqZWN0KCk7XG4gICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVVuZG9CdXR0b25TdGF0ZSgpIHtcbiAgICQoXCIjYnRuVW5kb1wiKS5wcm9wKFwiZGlzYWJsZWRcIiwgdW5kb0hpc3RvcnkubGVuZ3RoIDw9IDEpO1xufVxuXG5mdW5jdGlvbiB1bmRvKCkge1xuICAgU1RPUkFHRS5yZXN0b3JlTGFzdFVuZG9TdGVwKCk7XG4gICBTVE9SQUdFLnNhdmUoKTtcbiAgIHJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICBzdGFnZS51cGRhdGUoKTtcbiAgIHVwZGF0ZVVuZG9CdXR0b25TdGF0ZSgpO1xufVxuXG5jb25zdCBSRU5ERVJJTkcgPSB7XG4gICBjbGVhcigpIHtcbiAgICAgIHNlbGVjdE9iamVjdCgpO1xuICAgICAgLy8gU3RvcCBhbnkgbW92aW5nIHRyYWlucyBmaXJzdFxuICAgICAgVHJhaW4uc3RvcEFsbFRyYWlucygpO1xuXG4gICAgICBUcmFjay5hbGxUcmFja3MgPSBbXTtcbiAgICAgIFN3aXRjaC5hbGxTd2l0Y2hlcyA9IFtdO1xuICAgICAgU2lnbmFsLmFsbFNpZ25hbHMgPSBuZXcgU2V0KCk7XG4gICAgICBUcmFpbi5hbGxUcmFpbnMgPSBbXTtcbiAgICAgIEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMgPSBbXTtcblxuICAgICAgcmVuZGVyZXI/LnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICB9LFxuICAgY2VudGVyKCkge1xuICAgICAgc3RhZ2Uuc2NhbGUgPSAxO1xuICAgICAgc3RhZ2UueCA9IDA7XG4gICAgICBzdGFnZS55ID0gMDtcbiAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgUkVOREVSSU5HLmRyYXdHcmlkKCk7XG4gICAgICByZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKCk7XG4gICAgICBzdGFnZS51cGRhdGUoKTtcbiAgIH0sXG4gICBkcmF3R3JpZChyZXBhaW50ID0gdHJ1ZSkge1xuICAgICAgaWYgKCFncmlkKSB7XG4gICAgICAgICBncmlkID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICAgICBncmlkLm5hbWUgPSBcImdyaWRcIjtcbiAgICAgICAgIGdyaWQubW91c2VFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICBzdGFnZS5hZGRDaGlsZEF0KGdyaWQsIDApO1xuICAgICAgICAgZ3JpZC5ncmFwaGljcy5zZXRTdHJva2VTdHlsZSgxLCBcInJvdW5kXCIpO1xuICAgICAgfVxuXG4gICAgICBncmlkLnZpc2libGUgPSBzaG93R3JpZDtcbiAgICAgIGlmICghc2hvd0dyaWQpIHJldHVybjtcblxuICAgICAgaWYgKHJlcGFpbnQpIHtcbiAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHN0YWdlLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgIGNvbnN0IHNjYWxlID0gc3RhZ2Uuc2NhbGU7XG5cbiAgICAgICAgIC8vIENhbGN1bGF0ZSB2aXNpYmxlIGFyZWEgaW4gZ3JpZCBjb29yZGluYXRlc1xuICAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLmNlaWwoYm91bmRzLndpZHRoIC8gc2NhbGUgLyBHUklEX1NJWkUpICogR1JJRF9TSVpFLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLmNlaWwoYm91bmRzLmhlaWdodCAvIHNjYWxlIC8gR1JJRF9TSVpFKSAqIEdSSURfU0laRSxcbiAgICAgICAgIH07XG5cbiAgICAgICAgIC8vIEFkZCBwYWRkaW5nIHRvIHByZXZlbnQgZ2FwcyBkdXJpbmcgcGFubmluZ1xuICAgICAgICAgY29uc3QgcGFkZGluZyA9IEdSSURfU0laRSAqIDI7XG5cbiAgICAgICAgIGdyaWQuZ3JhcGhpY3MuY2xlYXIoKS5zZXRTdHJva2VTdHlsZSgxLCBcInJvdW5kXCIpLnNldFN0cm9rZURhc2goWzUsIDVdLCAyKS5iZWdpblN0cm9rZShcIiNjY2NcIik7XG5cbiAgICAgICAgIC8vIERyYXcgdmVydGljYWwgbGluZXNcbiAgICAgICAgIGZvciAobGV0IHggPSAtcGFkZGluZzsgeCA8PSBzaXplLndpZHRoICsgcGFkZGluZzsgeCArPSBHUklEX1NJWkUpIHtcbiAgICAgICAgICAgIGdyaWQuZ3JhcGhpY3MubW92ZVRvKHgsIC1wYWRkaW5nKS5saW5lVG8oeCwgc2l6ZS5oZWlnaHQgKyBwYWRkaW5nKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgLy8gRHJhdyBob3Jpem9udGFsIGxpbmVzXG4gICAgICAgICBmb3IgKGxldCB5ID0gLXBhZGRpbmc7IHkgPD0gc2l6ZS5oZWlnaHQgKyBwYWRkaW5nOyB5ICs9IEdSSURfU0laRSkge1xuICAgICAgICAgICAgZ3JpZC5ncmFwaGljcy5tb3ZlVG8oLXBhZGRpbmcsIHkpLmxpbmVUbyhzaXplLndpZHRoICsgcGFkZGluZywgeSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIENhY2hlIHdpdGggcGFkZGluZyB0byBwcmV2ZW50IGFydGlmYWN0c1xuICAgICAgICAgZ3JpZC5jYWNoZSgtcGFkZGluZywgLXBhZGRpbmcsIHNpemUud2lkdGggKyBwYWRkaW5nICogMiwgc2l6ZS5oZWlnaHQgKyBwYWRkaW5nICogMiwgc2NhbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGlnbiBncmlkIHRvIG5lYXJlc3QgZ3JpZCBsaW5lIHRvIHByZXZlbnQgZmxvYXRpbmcgcG9pbnQgYXJ0aWZhY3RzXG4gICAgICBjb25zdCBzY2FsZWRfZ3JpZF9zaXplID0gR1JJRF9TSVpFICogc3RhZ2Uuc2NhbGU7XG4gICAgICBncmlkLnggPSBNYXRoLmZsb29yKHN0YWdlLnggLyBzY2FsZWRfZ3JpZF9zaXplKSAqIC1HUklEX1NJWkU7XG4gICAgICBncmlkLnkgPSBNYXRoLmZsb29yKHN0YWdlLnkgLyBzY2FsZWRfZ3JpZF9zaXplKSAqIC1HUklEX1NJWkU7XG4gICB9LFxufTtcblxud2luZG93LlJFTkRFUklORyA9IFJFTkRFUklORztcblxuY29uc3QgVUkgPSB7XG4gICAvLy9TaG93cyB0aGUgbWVudSBvbiB0aGUgcmlnaHQuXG4gICAvLy8gbWVudT09bnVsbCBqdXN0IGhpZGVzIGl0LlxuICAgc2hvd01lbnUobWVudSkge1xuICAgICAgdmFyIGJzT2ZmY2FudmFzID0gYm9vdHN0cmFwLk9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKCQoXCIjc2lkZWJhclwiKSk7XG4gICAgICAkKFwiaW5wdXQsYnV0dG9uXCIsIGJzT2ZmY2FudmFzLl9lbGVtZW50KS5vZmYoKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcblxuICAgICAgaWYgKG1lbnUgPT0gbnVsbCkge1xuICAgICAgICAgYnNPZmZjYW52YXMuaGlkZSgpO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudF9pZCA9ICQoJyNzaWRlYmFyPmRpdjpub3QoW3N0eWxlKj1cImRpc3BsYXk6IG5vbmVcIl0pJyk7XG4gICAgICBsZXQgZGl2X2lkO1xuICAgICAgc3dpdGNoIChtZW51KSB7XG4gICAgICAgICBjYXNlIE1FTlUuRURJVF9TSUdOQUw6XG4gICAgICAgICAgICBkaXZfaWQgPSBcInNpZ25hbEVkaXRNZW51XCI7XG4gICAgICAgICAgICBsZXQgYm9keSA9ICQoXCIjbmF2LWhvbWVcIik7XG4gICAgICAgICAgICBib2R5LmVtcHR5KCk7XG4gICAgICAgICAgICBib2R5LmFwcGVuZChTaWdfVUkuZ2V0SFRNTChzZWxlY3Rpb24ub2JqZWN0KSk7XG4gICAgICAgICAgICBTaWdfVUkuaW5pdFNpZ25hbE1lbnUoKTtcbiAgICAgICAgICAgIFNpZ19VSS5zeW5jU2lnbmFsTWVudShzZWxlY3Rpb24ub2JqZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgY2FzZSBNRU5VLk5FV19TSUdOQUw6XG4gICAgICAgICAgICBkaXZfaWQgPSBcIm5ld0l0ZW1NZW51XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGNhc2UgTUVOVS5FRElUX1RSQUlOOlxuICAgICAgICAgICAgZGl2X2lkID0gXCJlZGl0VHJhaW5NZW51XCI7XG4gICAgICAgICAgICBUcmFpbi5pbml0RWRpdFRyYWluTWVudShzZWxlY3Rpb24ub2JqZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgY2FzZSBNRU5VLk5FV19UUkFJTjpcbiAgICAgICAgICAgIGRpdl9pZCA9IFwibmV3VHJhaW5NZW51XCI7XG4gICAgICAgICAgICAkKFwiI25ld1RyYWluXCIpLm9uKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogTU9VU0VfRE9XTl9BQ1RJT04uQUREX1RSQUlOLFxuICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgLy9tb3VzZXVwIGJlaW0gZG9jdW1lbnQgYW5tZWxkZW4sIHdlaWwgbW91c2V1cCBpbSBzdGFnZSBuaWNodCBhdXNnZWzDtnN0IHdpcmQsIHdlbm4gbW91c2Vkb3duIG5pY2h0IGF1Y2ggYXVmIGRlciBzdGFnZSB3YXJcbiAgICAgICAgICAgICAgIC8vbGl0dGxlIGhhY2ssIHdlaWwgaGFuZGxlU3RhZ2VNb3VzZVVwIGVpbiBldmVudCB2b24gY3JlYXRlanMgZXJ3YXJ0ZXRcbiAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIChlKSA9PiBoYW5kbGVTdGFnZU1vdXNlVXAoeyBuYXRpdmVFdmVudDogZSB9KSwge1xuICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcblxuICAgICAgICAgICAgICAgbGV0IGxvY2FsX3BvaW50ID0gc3RhZ2UuZ2xvYmFsVG9Mb2NhbChzdGFnZS5tb3VzZVgsIHN0YWdlLm1vdXNlWSk7XG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbi5jb250YWluZXIgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwienVnLnBuZ1wiKS5zZXQoe1xuICAgICAgICAgICAgICAgICAgeDogbG9jYWxfcG9pbnQueCxcbiAgICAgICAgICAgICAgICAgIHk6IGxvY2FsX3BvaW50LnksXG4gICAgICAgICAgICAgICAgICBzY2FsZTogMC41LFxuICAgICAgICAgICAgICAgICAgcmVnWTogOTYgLyAyLFxuICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgIG92ZXJsYXlfY29udGFpbmVyLmFkZENoaWxkKG1vdXNlQWN0aW9uLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgY2FzZSBNRU5VLk5FV19PQkpFQ1Q6XG4gICAgICAgICAgICBkaXZfaWQgPSBcIm5ld09iamVjdE1lbnVcIjtcbiAgICAgICAgICAgICQoXCIjYnRuQWRkVGV4dFwiKS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICBjdXN0b21fbW91c2VfbW9kZSA9ICQoXCIjYnRuQWRkVGV4dFwiKS5oYXNDbGFzcyhcImFjdGl2ZVwiKSA/IENVU1RPTV9NT1VTRV9BQ1RJT04uVEVYVCA6IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORTtcbiAgICAgICAgICAgICAgIHdpbmRvdy5jdXN0b21fbW91c2VfbW9kZSA9IGN1c3RvbV9tb3VzZV9tb2RlOyAvLyBVcGRhdGUgZ2xvYmFsIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgVUkuYWN0aXZhdGVfY3VzdG9tX21vdXNlX21vZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJChcIiNidG5BZGRQbGF0Zm9ybVwiKS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICBjdXN0b21fbW91c2VfbW9kZSA9ICQoXCIjYnRuQWRkUGxhdGZvcm1cIikuaGFzQ2xhc3MoXCJhY3RpdmVcIilcbiAgICAgICAgICAgICAgICAgID8gQ1VTVE9NX01PVVNFX0FDVElPTi5QTEFUVEZPUk1cbiAgICAgICAgICAgICAgICAgIDogQ1VTVE9NX01PVVNFX0FDVElPTi5OT05FO1xuICAgICAgICAgICAgICAgd2luZG93LmN1c3RvbV9tb3VzZV9tb2RlID0gY3VzdG9tX21vdXNlX21vZGU7IC8vIFVwZGF0ZSBnbG9iYWwgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICBVSS5hY3RpdmF0ZV9jdXN0b21fbW91c2VfbW9kZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGNhc2UgTUVOVS5FRElUX09CSkVDVDpcbiAgICAgICAgICAgIGRpdl9pZCA9IFwiZWRpdE9iamVjdE1lbnVcIjtcbiAgICAgICAgICAgIEdlbmVyaWNPYmplY3QuaW5pdEVkaXRNZW51KHNlbGVjdGlvbi5vYmplY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBNZW51XCIpO1xuICAgICAgfVxuXG4gICAgICAkKFwiI3NpZGViYXIgPiBkaXZcIilcbiAgICAgICAgIC5ub3QoXCIjXCIgKyBkaXZfaWQpXG4gICAgICAgICAuaGlkZSgpO1xuICAgICAgJChcIiNzaWRlYmFyID4gI1wiICsgZGl2X2lkKS5zaG93KCk7XG5cbiAgICAgIGJzT2ZmY2FudmFzLnNob3coKTtcbiAgICAgIGlmIChic09mZmNhbnZhcy5faXNTaG93bikge1xuICAgICAgICAgLy9ic09mZmNhbnZhcy5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgLy9ic09mZmNhbnZhcy5oaWRlKCk7XG4gICAgICB9XG4gICB9LFxuXG4gICBhY3RpdmF0ZV9jdXN0b21fbW91c2VfbW9kZSgpIHtcbiAgICAgIHN3aXRjaCAoY3VzdG9tX21vdXNlX21vZGUpIHtcbiAgICAgICAgIGNhc2UgQ1VTVE9NX01PVVNFX0FDVElPTi5URVhUOlxuICAgICAgICAgICAgbXlDYW52YXMuc3R5bGUuY3Vyc29yID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBteUNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcImF1dG9cIjtcbiAgICAgIH1cbiAgIH0sXG5cbiAgIHNob3dQcmVCdWlsZFNjcmVlbigpIHtcbiAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImJhaG5ob2ZfbGFzdDFcIikgPT0gbnVsbCkgJChidG5Mb2FkUmVjZW50KS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICQoYnRuU3RhcnRGcm9tWmVybykuY2xpY2soVUkuaGlkZVN0YXJ0U2NyZWVuKTtcbiAgICAgICQoYnRuTG9hZFJlY2VudCkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgU1RPUkFHRS5sb2FkUmVjZW50KCk7XG4gICAgICAgICBVSS5oaWRlU3RhcnRTY3JlZW4oKTtcbiAgICAgICAgIFJFTkRFUklORy5kcmF3R3JpZCgpO1xuICAgICAgICAgcmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgJChcIiNidG5Mb2FkMkdsZWlzaWcsI2J0bkxvYWQxR2xlaXNpZ1wiKS5vbihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgICBjb25zdCBuYW1lID0gJChlLnRhcmdldCkuYXR0cihcImRhdGFcIik7XG4gICAgICAgICBTVE9SQUdFLmxvYWRQcmVidWlsZGJ5TmFtZShuYW1lKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIFVJLmhpZGVTdGFydFNjcmVlbigpO1xuICAgICAgICAgICAgUkVOREVSSU5HLmRyYXdHcmlkKCk7XG4gICAgICAgICAgICByZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgICAgICAgU1RPUkFHRS5zYXZlVW5kb0hpc3RvcnkoKTtcbiAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvKiQoYnRuTG9hZEZyb21GaWxlKS5jbGljaygoKSA9PiB7IGxvYWRTaWduYWxzRnJvbUZpbGUoKTsgaGlkZVN0YXJ0U2NyZWVuKCk7IH0pO1xuICAgICAgIGxvYWRQcmVidWlsZHMoKTsgKi9cbiAgICAgIGxldCBtID0gYm9vdHN0cmFwLk1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UobG9hZE1vZGFsKTtcbiAgICAgIG0uX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgIFwiaGlkZGVuLmJzLm1vZGFsXCIsXG4gICAgICAgICAoeCkgPT4ge1xuICAgICAgICAgICAgYm9vdHN0cmFwLk1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UoeC50YXJnZXQpLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICQoYnRuU3RhcnRGcm9tWmVybykub2ZmKFwiY2xpY2tcIik7XG4gICAgICAgICAgICAkKGJ0bkxvYWRSZWNlbnQpLm9mZihcImNsaWNrXCIpO1xuICAgICAgICAgICAgJChidG5Mb2FkRnJvbUZpbGUpLm9mZihcImNsaWNrXCIpO1xuICAgICAgICAgfSxcbiAgICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICApO1xuICAgICAgbS5zaG93KCk7XG4gICB9LFxuXG4gICBoaWRlU3RhcnRTY3JlZW4oKSB7XG4gICAgICAkKFwibXlDYW52YXNcIikuZm9jdXMoKTtcbiAgICAgIGJvb3RzdHJhcC5Nb2RhbC5nZXRJbnN0YW5jZShsb2FkTW9kYWwpLmhpZGUoKTtcbiAgIH0sXG5cbiAgIG5ld0l0ZW1CdXR0b25zKC4uLnRlbXBsYXRlcykge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlcy5tYXAoKHQpID0+XG4gICAgICAgICB1aVxuICAgICAgICAgICAgLmRpdihcImQtZmxleCBuZXdTaWduYWxJdGVtIGFsaWduLWl0ZW1zLWNlbnRlciB1c2VyLXNlbGVjdC1ub25lXCIsIFtcbiAgICAgICAgICAgICAgIHVpXG4gICAgICAgICAgICAgICAgICAuZGl2KFwiZmxleC1zaHJpbmstMCBuZXdJdGVtX2ltYWdlXCIpXG4gICAgICAgICAgICAgICAgICAuY3NzKFwiYmFja2dyb3VuZC1pbWFnZVwiLCBcInVybChcIiArIFVJLkdldERhdGFVUkxfRnJvbVRlbXBsYXRlKHQpICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgICAuY3NzKFwiYmFja2dyb3VuZC1zaXplXCIsIHQucHJldmlld3NpemUgPz8gNDUpLFxuICAgICAgICAgICAgICAgdWkuZGl2KFwiZmxleC1ncm93LTUgbXMtMlwiLCB0LnRpdGxlKSxcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAub24oXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgIG1vdXNlQWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBNT1VTRV9ET1dOX0FDVElPTi5ETkRfU0lHTkFMLFxuICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHQsXG4gICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAvL21vdXNldXAgYmVpbSBkb2N1bWVudCBhbm1lbGRlbiwgd2VpbCBtb3VzZXVwIGltIHN0YWdlIG5pY2h0IGF1c2dlbMO2c3Qgd2lyZCwgd2VubiBtb3VzZWRvd24gbmljaHQgYXVjaCBhdWYgZGVyIHN0YWdlIHdhclxuICAgICAgICAgICAgICAgLy9saXR0bGUgaGFjaywgd2VpbCBoYW5kbGVTdGFnZU1vdXNlVXAgZWluIGV2ZW50IHZvbiBjcmVhdGVqcyBlcndhcnRldFxuICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgKGUpID0+IGhhbmRsZVN0YWdlTW91c2VVcCh7IG5hdGl2ZUV2ZW50OiBlIH0pLCB7XG4gICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgICAgIHN0YXJ0RHJhZ0FuZERyb3BTaWduYWwoZS5vZmZzZXRYLCBlLm9mZnNldFkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICk7XG4gICB9LFxuXG4gICBHZXREYXRhVVJMX0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgY29uc3QgdG1wU3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoJChcIjxjYW52YXM+XCIpLmF0dHIoeyB3aWR0aDogNDUwLCBoZWlnaHQ6IDQ1MCB9KVswXSk7XG4gICAgICB0bXBTdGFnZS5zY2FsZSA9IHRlbXBsYXRlLnNjYWxlO1xuXG4gICAgICAvLyBVc2UgZGVkaWNhdGVkIHByZXZpZXcgcmVuZGVyaW5nIG1ldGhvZFxuICAgICAgU2lnbmFsUmVuZGVyZXIuZHJhd1ByZXZpZXcodGVtcGxhdGUsIHRtcFN0YWdlKTtcbiAgICAgIHRtcFN0YWdlLnVwZGF0ZSgpO1xuXG4gICAgICBjb25zdCBzaWdfYm91bmRzID0gdG1wU3RhZ2UuZ2V0Qm91bmRzKCk7XG4gICAgICBpZiAoc2lnX2JvdW5kcyA9PSBudWxsKSB0aHJvdyBFcnJvcih0ZW1wbGF0ZS50aXRsZSArIFwiIGhhcyBubyB2aXN1YWwgRWxlbWVudCB2aXNpYmxlXCIpO1xuICAgICAgdG1wU3RhZ2UuY2FjaGUoc2lnX2JvdW5kcy54LCBzaWdfYm91bmRzLnksIHNpZ19ib3VuZHMud2lkdGgsIHNpZ19ib3VuZHMuaGVpZ2h0LCAwLjUpO1xuICAgICAgcmV0dXJuIHRtcFN0YWdlLmJpdG1hcENhY2hlLmdldENhY2hlRGF0YVVSTCgpO1xuICAgfSxcbn07XG5cbmZ1bmN0aW9uIHRvZ2dsZUVkaXRNb2RlKG1vZGUpIHtcbiAgIGVkaXRfbW9kZSA9IG1vZGUgIT0gdW5kZWZpbmVkID8gbW9kZSA6ICQoYnRuRHJhd1RyYWNrcykuaXMoXCI6Y2hlY2tlZFwiKTtcbiAgIHNob3dHcmlkID0gZWRpdF9tb2RlO1xuICAgUkVOREVSSU5HLmRyYXdHcmlkKCk7XG4gICBzdGFnZS51cGRhdGUoKTtcbiAgIGlmIChtb2RlICE9IHVuZGVmaW5lZCkgJChidG5EcmF3VHJhY2tzKS5wcm9wKFwiOmNoZWNrZWRcIiwgZWRpdF9tb2RlKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0UmVuZGVyZXIodGV4dHVyZWQpIHtcbiAgIGlmICh0ZXh0dXJlZCkge1xuICAgICAgcmVuZGVyZXIgPSBuZXcgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQoKTtcbiAgICAgICQoXCIjc3dpdGNoX3JlbmRlcmVyXCIpLnByb3AoXCJjaGVja2VkXCIsIGZhbHNlKTtcbiAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlciA9IG5ldyB0cmFja1JlbmRlcmluZ19iYXNpYygpO1xuICAgICAgJChcIiNzd2l0Y2hfcmVuZGVyZXJcIikucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICB9XG4gICB3aW5kb3cucmVuZGVyZXIgPSByZW5kZXJlcjsgLy8gVXBkYXRlIGdsb2JhbCByZWZlcmVuY2VcbiAgIHJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICBzdGFnZS51cGRhdGUoKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0T2JqZWN0KG9iamVjdCwgZSkge1xuICAgaWYgKCFvYmplY3QpIHtcbiAgICAgIHNlbGVjdGlvbi5vYmplY3QgPSBudWxsO1xuICAgICAgc2VsZWN0aW9uLnR5cGUgPSBcIlwiO1xuICAgICAgcmVuZGVyZXI/LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgVUkuc2hvd01lbnUoKTtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIGNvbnN0IHQgPSB0eXBlKG9iamVjdCk7XG4gICBpZiAob2JqZWN0KSBjb25zb2xlLmxvZyhvYmplY3QpO1xuXG4gICBpZiAodCAhPSBzZWxlY3Rpb24udHlwZSkge1xuICAgICAgc2VsZWN0aW9uLm9iamVjdCA9IG9iamVjdDtcbiAgICAgIHNlbGVjdGlvbi50eXBlID0gdDtcbiAgIH0gZWxzZSB7XG4gICAgICBpZiAoZT8ubmF0aXZlRXZlbnQ/LmN0cmxLZXkpXG4gICAgICAgICBzZWxlY3Rpb24ub2JqZWN0ID0gQXJyYXkuaXNBcnJheShzZWxlY3Rpb24ub2JqZWN0KSA/IFsuLi5zZWxlY3Rpb24ub2JqZWN0LCBvYmplY3RdIDogW3NlbGVjdGlvbi5vYmplY3QsIG9iamVjdF07XG4gICAgICBlbHNlIHNlbGVjdGlvbi5vYmplY3QgPSBvYmplY3Q7XG4gICB9XG4gICByZW5kZXJlcj8udXBkYXRlU2VsZWN0aW9uKCk7XG5cbiAgIGxldCBtZW51O1xuICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFwiU2lnbmFsXCI6XG4gICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZWN0aW9uLm9iamVjdCkpIG1lbnUgPSBNRU5VLkVESVRfU0lHTkFMO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVHJhaW5cIjpcbiAgICAgICAgIG1lbnUgPSBNRU5VLkVESVRfVFJBSU47XG4gICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJHZW5lcmljT2JqZWN0XCI6XG4gICAgICAgICBtZW51ID0gTUVOVS5FRElUX09CSkVDVDtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgIG1lbnUgPSBudWxsO1xuICAgICAgICAgYnJlYWs7XG4gICB9XG5cbiAgIFVJLnNob3dNZW51KG1lbnUpO1xufVxuXG5mdW5jdGlvbiBvblJlc2l6ZVdpbmRvdygpIHtcbiAgICQobXlDYW52YXMpLmF0dHIoXCJoZWlnaHRcIiwgJChDYW52YXNDb250YWluZXIpLmhlaWdodCgpIC0gNSk7XG4gICAkKG15Q2FudmFzKS5hdHRyKFwid2lkdGhcIiwgJChDYW52YXNDb250YWluZXIpLndpZHRoKCkpO1xuICAgUkVOREVSSU5HLmRyYXdHcmlkKCk7XG4gICBzdGFnZS51cGRhdGUoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RhZ2VNb3VzZURvd24oZXZlbnQpIHtcbiAgIC8vY29uc29sZS5sb2coXCJoYW5kbGVTdGFnZU1vdXNlRG93blwiLCBldmVudCk7XG5cbiAgIGxldCBoaXR0ZXN0ID0gZ2V0SGl0VGVzdCgpO1xuXG4gICBjb25zb2xlLmxvZyhoaXR0ZXN0ID8gaGl0dGVzdCA6IFwibm90aGluZyBoaXRcIik7XG5cbiAgIG1vdXNlQWN0aW9uID0ge1xuICAgICAgYWN0aW9uOiBjdXN0b21fbW91c2VfbW9kZSAhPSBDVVNUT01fTU9VU0VfQUNUSU9OLk5PTkUgPyBNT1VTRV9ET1dOX0FDVElPTi5DVVNUT00gOiBNT1VTRV9ET1dOX0FDVElPTi5OT05FLFxuICAgICAgY29udGFpbmVyOiBoaXR0ZXN0LFxuICAgICAgc3RhcnRQb2ludDogc3RhZ2UuZ2xvYmFsVG9Mb2NhbChzdGFnZS5tb3VzZVgsIHN0YWdlLm1vdXNlWSksXG4gICAgICBfZGlzdGFuY2VQb2ludDogbmV3IFBvaW50KGV2ZW50LnN0YWdlWCwgZXZlbnQuc3RhZ2VZKSxcbiAgICAgIG9mZnNldDogaGl0dGVzdD8uZ2xvYmFsVG9Mb2NhbChzdGFnZS5tb3VzZVgsIHN0YWdlLm1vdXNlWSksIC8vS29vcmRpbmF0ZSBhdWYgZGVtIGFuZ2VrbGlja3RlbiBPYmplY3QgKHpiIFNpZ25hbCksIGRhbWl0IGRlciBDb250YWluZXIgYW0gTWF1c3plaWdlciBcImtsZWJ0XCJcbiAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICByZXR1cm4gZ2VvbWV0cnkuZGlzdGFuY2UodGhpcy5fZGlzdGFuY2VQb2ludCwgbmV3IFBvaW50KHN0YWdlLm1vdXNlWCwgc3RhZ2UubW91c2VZKSk7XG4gICAgICB9LFxuICAgfTtcblxuICAgLy8gQ2hlY2sgaWYgd2UgY2xpY2tlZCBvbiBhIHRyYWNrIGVuZHBvaW50XG4gICBpZiAobW91c2VBY3Rpb24uY29udGFpbmVyPy5uYW1lID09PSBcInRyYWNrX2VuZHBvaW50XCIpIHtcbiAgICAgIG1vdXNlQWN0aW9uLmFjdGlvbiA9IE1PVVNFX0RPV05fQUNUSU9OLkRORF9UUkFDSztcbiAgICAgIG1vdXNlQWN0aW9uLnRyYWNrID0gbW91c2VBY3Rpb24uY29udGFpbmVyLnRyYWNrO1xuICAgICAgbW91c2VBY3Rpb24uZW5kcG9pbnQgPSBtb3VzZUFjdGlvbi5jb250YWluZXIuZW5kcG9pbnQ7XG4gICB9XG5cbiAgIGlmIChjdXN0b21fbW91c2VfbW9kZSA9PSBDVVNUT01fTU9VU0VfQUNUSU9OLkRSQVdJTkcpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cIkRyYXdpbmdDb2xvclwiXTpjaGVja2VkJykudmFsdWU7XG4gICAgICBjb25zdCB3aWR0aCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W25hbWU9XCJEcmF3aW5nV2lkdGhcIl06Y2hlY2tlZCcpLnZhbHVlO1xuXG4gICAgICBkcmF3aW5nX2NvbnRhaW5lci5hZGRDaGlsZCgobW91c2VBY3Rpb24uc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKSkpO1xuICAgICAgbW91c2VBY3Rpb24uc2hhcGUuZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUod2lkdGgsIFwicm91bmRcIiwgXCJyb3VuZFwiKS5iZWdpblN0cm9rZShjb2xvcik7XG4gICAgICBtb3VzZUFjdGlvbi5vbGRfcG9pbnQgPSBuZXcgUG9pbnQoZXZlbnQuc3RhZ2VYLCBldmVudC5zdGFnZVkpO1xuICAgfVxuICAgLy9jb25zb2xlLmxvZyhtb3VzZUFjdGlvbik7XG4gICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SGl0VGVzdChjb250YWluZXIpIHtcbiAgIGxldCBsb2NhbF9wb2ludCA9IHN0YWdlLmdsb2JhbFRvTG9jYWwoc3RhZ2UubW91c2VYLCBzdGFnZS5tb3VzZVkpO1xuXG4gICByZXR1cm4gKGNvbnRhaW5lciA/IGNvbnRhaW5lciA6IHN0YWdlKS5nZXRPYmplY3RVbmRlclBvaW50KGxvY2FsX3BvaW50LngsIGxvY2FsX3BvaW50LnksIDEpO1xufVxuXG5mdW5jdGlvbiBnZXRIaXRJbmZvRm9yU2lnbmFsUG9zaXRpb25pbmcodGVzdFBvaW50KSB7XG4gICBmb3IgKGNvbnN0IHRyYWNrIG9mIFRyYWNrLmFsbFRyYWNrcykge1xuICAgICAgaWYgKE51bWJlclV0aWxzLmJldHdlZW4odGVzdFBvaW50LngsIHRyYWNrLnN0YXJ0LngsIHRyYWNrLmVuZC54KSkge1xuICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBnZW9tZXRyeS5wb2ludFRvU2VnbWVudERpc3RhbmNlKHRlc3RQb2ludCwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCk7XG4gICAgICAgICBpZiAoZGlzdGFuY2UgPD0gR1JJRF9TSVpFXzIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gVE9PTFMubmVhcmVzdFBvaW50T25MaW5lKHRyYWNrLnN0YXJ0LCB0cmFjay5lbmQsIHRlc3RQb2ludCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICBrbTogdHJhY2suZ2V0S21mcm9tUG9pbnQocG9pbnQpLFxuICAgICAgICAgICAgICAgYWJvdmU6IHRlc3RQb2ludC55IDwgcG9pbnQueSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG59XG5cbmZ1bmN0aW9uIGFsaWduU2lnbmFsQ29udGFpbmVyV2l0aFRyYWNrKGMsIHBvcykge1xuICAgLy9rb29yZGluYXRlbiBhbmhhbmQgZGVzIFN0cmVja2VuIEtNIHN1Y2hlbiwgd2VubiBzaWUgbmljaHQgw7xiZXJnZWJlbiB3b3JkZW4gc2luZFxuXG4gICBjb25zdCBwb2ludCA9IHBvcy50cmFjay5nZXRQb2ludEZyb21LbShwb3Mua20pO1xuXG4gICBsZXQgcDtcbiAgIGlmIChwb3MuYWJvdmUpIHtcbiAgICAgIGMucm90YXRpb24gPSAyNzAgKyBwb3MudHJhY2suZGVnO1xuICAgICAgcCA9IHBvaW50LmFkZChcbiAgICAgICAgIGdlb21ldHJ5XG4gICAgICAgICAgICAucGVycGVuZGljdWxhcihwb3MudHJhY2sudW5pdClcbiAgICAgICAgICAgIC5tdWx0aXBseSgtcmVuZGVyZXIuU0lHTkFMX0RJU1RBTkNFX0ZST01fVFJBQ0sgLSBjLmRhdGEuX3RlbXBsYXRlLmRpc3RhbmNlX2Zyb21fdHJhY2spXG4gICAgICApO1xuICAgfSBlbHNlIHtcbiAgICAgIGMucm90YXRpb24gPSA5MCArIHBvcy50cmFjay5kZWc7XG4gICAgICBwID0gcG9pbnQuYWRkKFxuICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgIC5wZXJwZW5kaWN1bGFyKHBvcy50cmFjay51bml0KVxuICAgICAgICAgICAgLm11bHRpcGx5KHJlbmRlcmVyLlNJR05BTF9ESVNUQU5DRV9GUk9NX1RSQUNLICsgYy5kYXRhLl90ZW1wbGF0ZS5kaXN0YW5jZV9mcm9tX3RyYWNrKVxuICAgICAgKTtcbiAgIH1cbiAgIGlmIChwb3MuZmxpcHBlZCkgYy5yb3RhdGlvbiArPSAxODA7XG5cbiAgIGMueCA9IHAueDtcbiAgIGMueSA9IHAueTtcbn1cblxuZnVuY3Rpb24gc3RhcnREcmFnQW5kRHJvcFNpZ25hbChtb3VzZVgsIG1vdXNlWSkge1xuICAgaWYgKG1vdXNlQWN0aW9uLmNvbnRhaW5lcikge1xuICAgICAgbW91c2VBY3Rpb24uY29udGFpbmVyLnBhcmVudC5yZW1vdmVDaGlsZChtb3VzZUFjdGlvbi5jb250YWluZXIpO1xuICAgfSBlbHNlIHtcbiAgICAgIGxldCBzaWduYWwgPSBuZXcgU2lnbmFsKG1vdXNlQWN0aW9uLnRlbXBsYXRlKTtcbiAgICAgIG1vdXNlQWN0aW9uLmNvbnRhaW5lciA9IFNpZ25hbFJlbmRlcmVyLmNyZWF0ZVNpZ25hbENvbnRhaW5lcihzaWduYWwpO1xuICAgICAgbW91c2VBY3Rpb24uY29udGFpbmVyLnggPSBtb3VzZVg7XG4gICAgICBtb3VzZUFjdGlvbi5jb250YWluZXIueSA9IG1vdXNlWTtcbiAgIH1cblxuICAgb3ZlcmxheV9jb250YWluZXIuYWRkQ2hpbGQobW91c2VBY3Rpb24uY29udGFpbmVyKTtcbiAgIHN0YWdlLnVwZGF0ZSgpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgIC8vY29uc29sZS5sb2coXCJoYW5kbGVNb3VzZU1vdmVcIiwgZXZlbnQpO1xuICAgaWYgKCFldmVudC5wcmltYXJ5KSByZXR1cm47XG4gICBpZiAobW91c2VBY3Rpb24gPT0gbnVsbCkge1xuICAgICAgc3RhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YWdlbW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICByZXR1cm47XG4gICB9XG4gICAvL2ZhbGxzIG1vdXNlTW92ZSBub2NoIGzDpHVmdCwgb2J3b2hsIGRlciBVc2VyIGtlaW5lbiBidXR0b24gbWVociBkcsO8Y2t0XG4gICAvL3RyaXR0IHZvciBhbGxlbSBiZWltIGRlYnVnZ2luZyBhdWZcbiAgIGlmIChldmVudC5uYXRpdmVFdmVudC5idXR0b25zID09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZGVidWcgbW91c2UgZXJyb3JcIik7XG4gICAgICByZXR1cm4gaGFuZGxlU3RhZ2VNb3VzZVVwKGV2ZW50KTtcbiAgIH1cblxuICAgbGV0IGxvY2FsX3BvaW50ID0gc3RhZ2UuZ2xvYmFsVG9Mb2NhbChzdGFnZS5tb3VzZVgsIHN0YWdlLm1vdXNlWSk7XG4gICAvL2NvbnNvbGUubG9nKGxvY2FsX3BvaW50LCB7IHg6IHN0YWdlLm1vdXNlWCwgeTogc3RhZ2UubW91c2VZIH0pO1xuXG4gICBpZiAobW91c2VBY3Rpb24uYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5OT05FKSB7XG4gICAgICBkZXRlcm1pbmVNb3VzZUFjdGlvbihldmVudCwgbG9jYWxfcG9pbnQpO1xuICAgfSBlbHNlIGlmIChtb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLkNVU1RPTSkge1xuICAgICAgaWYgKGN1c3RvbV9tb3VzZV9tb2RlID09IENVU1RPTV9NT1VTRV9BQ1RJT04uRFJBV0lORykge1xuICAgICAgICAgbW91c2VBY3Rpb24uc2hhcGUuZ3JhcGhpY3MubXQobW91c2VBY3Rpb24uc3RhcnRQb2ludC54LCBtb3VzZUFjdGlvbi5zdGFydFBvaW50LnkpLmx0KGxvY2FsX3BvaW50LngsIGxvY2FsX3BvaW50LnkpO1xuICAgICAgICAgbW91c2VBY3Rpb24uc3RhcnRQb2ludC54ID0gbG9jYWxfcG9pbnQueDtcbiAgICAgICAgIG1vdXNlQWN0aW9uLnN0YXJ0UG9pbnQueSA9IGxvY2FsX3BvaW50Lnk7XG4gICAgICB9IGVsc2UgaWYgKGN1c3RvbV9tb3VzZV9tb2RlID09IENVU1RPTV9NT1VTRV9BQ1RJT04uUExBVFRGT1JNKSB7XG4gICAgICAgICBvdmVybGF5X2NvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICAgb3ZlcmxheV9jb250YWluZXIuYWRkQ2hpbGQoKG1vdXNlQWN0aW9uLnNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkpKTtcbiAgICAgICAgIG1vdXNlQWN0aW9uLnNoYXBlLmdyYXBoaWNzXG4gICAgICAgICAgICAuYmVnaW5TdHJva2UoXCIjMTExMTExXCIpXG4gICAgICAgICAgICAuZHJhd1JlY3QoXG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbi5zdGFydFBvaW50LngsXG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbi5zdGFydFBvaW50LnksXG4gICAgICAgICAgICAgICBsb2NhbF9wb2ludC54IC0gbW91c2VBY3Rpb24uc3RhcnRQb2ludC54LFxuICAgICAgICAgICAgICAgbG9jYWxfcG9pbnQueSAtIG1vdXNlQWN0aW9uLnN0YXJ0UG9pbnQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgIHN0YWdlLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgfSBlbHNlIGlmIChtb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLk1PVkVfT0JKRUNUKSB7XG4gICAgICBjb25zdCBvID0gbW91c2VBY3Rpb24uY29udGFpbmVyLmRhdGE7XG4gICAgICBvLnBvcyhsb2NhbF9wb2ludCk7XG4gICAgICBpZiAobW91c2VBY3Rpb24ub2Zmc2V0KSB7XG4gICAgICAgICBsZXQgcCA9IG1vdXNlQWN0aW9uLmNvbnRhaW5lci5sb2NhbFRvTG9jYWwobW91c2VBY3Rpb24ub2Zmc2V0LngsIG1vdXNlQWN0aW9uLm9mZnNldC55LCBzdGFnZSk7XG4gICAgICAgICBsb2NhbF9wb2ludC54IC09IHAueCAtIG1vdXNlQWN0aW9uLmNvbnRhaW5lci54O1xuICAgICAgICAgbG9jYWxfcG9pbnQueSAtPSBwLnkgLSBtb3VzZUFjdGlvbi5jb250YWluZXIueTtcbiAgICAgIH1cbiAgICAgIG1vdXNlQWN0aW9uLmNvbnRhaW5lci54ID0gbG9jYWxfcG9pbnQueDtcbiAgICAgIG1vdXNlQWN0aW9uLmNvbnRhaW5lci55ID0gbG9jYWxfcG9pbnQueTtcbiAgICAgIHJlbmRlcmVyLnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgfSBlbHNlIGlmIChtb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLkRORF9TSUdOQUwpIHtcbiAgICAgIGRyYWduRHJvcFNpZ25hbChsb2NhbF9wb2ludCwgZXZlbnQubmF0aXZlRXZlbnQuYWx0S2V5KTtcbiAgICAgIHJlbmRlcmVyLnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgfSBlbHNlIGlmIChtb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLkJVSUxEX1RSQUNLKSB7XG4gICAgICBjb25zdCBncmlkX3NuYXBfcG9pbnQgPSBnZXRTbmFwUG9pbnQobG9jYWxfcG9pbnQpO1xuXG4gICAgICBpZiAoZ2VvbWV0cnkuZGlzdGFuY2UobG9jYWxfcG9pbnQsIGdyaWRfc25hcF9wb2ludCkgPD0gU05BUF8yX0dSSUQpIHtcbiAgICAgICAgIGlmIChUcmFjay5pc1ZhbGlkVHJhY2tOb2RlUG9pbnQobG9jYWxfcG9pbnQpKSB7XG4gICAgICAgICAgICBhZGRUcmFja0FuY2hvclBvaW50KGdyaWRfc25hcF9wb2ludCk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBkcmF3Qmx1ZVByaW50VHJhY2soKTtcbiAgIH0gZWxzZSBpZiAobW91c2VBY3Rpb24uYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5TQ1JPTEwpIHtcbiAgICAgIHN0YWdlLnggKz0gZXZlbnQubmF0aXZlRXZlbnQubW92ZW1lbnRYO1xuICAgICAgc3RhZ2UueSArPSBldmVudC5uYXRpdmVFdmVudC5tb3ZlbWVudFk7XG4gICAgICBSRU5ERVJJTkcuZHJhd0dyaWQoZmFsc2UpO1xuICAgICAgcmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZygpO1xuICAgfSBlbHNlIGlmIChtb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLk1PVkVfVFJBSU4pIHtcbiAgICAgIFRyYWluLm1vdmVUcmFpbihtb3VzZUFjdGlvbi5jb250YWluZXIuZGF0YSwgZXZlbnQubmF0aXZlRXZlbnQubW92ZW1lbnRYKTtcbiAgICAgIHJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcoKTtcbiAgIH0gZWxzZSBpZiAobW91c2VBY3Rpb24uYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5BRERfVFJBSU4pIHtcbiAgICAgIG1vdXNlQWN0aW9uLmNvbnRhaW5lci54ID0gbG9jYWxfcG9pbnQueDtcbiAgICAgIG1vdXNlQWN0aW9uLmNvbnRhaW5lci55ID0gbG9jYWxfcG9pbnQueTtcbiAgIH0gZWxzZSBpZiAobW91c2VBY3Rpb24uYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5ETkRfVFJBQ0spIHtcbiAgICAgIGNvbnN0IGdyaWRfc25hcF9wb2ludCA9IGdldFNuYXBQb2ludChsb2NhbF9wb2ludCk7XG5cbiAgICAgIGlmIChnZW9tZXRyeS5kaXN0YW5jZShsb2NhbF9wb2ludCwgZ3JpZF9zbmFwX3BvaW50KSA8PSBTTkFQXzJfR1JJRCkge1xuICAgICAgICAgaWYgKFRyYWNrLmlzVmFsaWRUcmFja05vZGVQb2ludChncmlkX3NuYXBfcG9pbnQpKSB7XG4gICAgICAgICAgICBpZiAobW91c2VBY3Rpb24uZW5kcG9pbnQgPT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgbW91c2VBY3Rpb24udHJhY2suc2V0TmV3U3RhcnQoZ3JpZF9zbmFwX3BvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbi50cmFjay5zZXROZXdFbmQoZ3JpZF9zbmFwX3BvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYWNrLmNyZWF0ZVJhaWxOZXR3b3JrKCk7XG4gICAgICAgICAgICByZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuXG4gICBzdGFnZS51cGRhdGUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0U25hcFBvaW50KGxvY2FsX3BvaW50KSB7XG4gICByZXR1cm4gbmV3IFBvaW50KE1hdGgucm91bmQobG9jYWxfcG9pbnQueCAvIEdSSURfU0laRSkgKiBHUklEX1NJWkUsIE1hdGgucm91bmQobG9jYWxfcG9pbnQueSAvIEdSSURfU0laRSkgKiBHUklEX1NJWkUpO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNb3VzZUFjdGlvbihldmVudCwgbG9jYWxfcG9pbnQpIHtcbiAgIC8vd2llIHdlaXQgd3VyZGUgZGllIG1hdXMgc2VpdCBtb3VzZWRvd24gYmV3ZWd0XG4gICBpZiAobW91c2VBY3Rpb24uZGlzdGFuY2UoKSA+IDQpIHtcbiAgICAgIGlmIChldmVudC5uYXRpdmVFdmVudC5idXR0b25zID09IDEpIHtcbiAgICAgICAgIGlmIChlZGl0X21vZGUpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZUFjdGlvbi5jb250YWluZXI/Lm5hbWUgPT0gXCJzaWduYWxcIikge1xuICAgICAgICAgICAgICAgbXlDYW52YXMuc3R5bGUuY3Vyc29yID0gXCJtb3ZlXCI7XG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbi5hY3Rpb24gPSBNT1VTRV9ET1dOX0FDVElPTi5ETkRfU0lHTkFMO1xuICAgICAgICAgICAgICAgbW91c2VBY3Rpb24uY29udGFpbmVyLmRhdGEuX3Bvc2l0aW9uaW5nLnRyYWNrLnJlbW92ZVNpZ25hbChtb3VzZUFjdGlvbi5jb250YWluZXIuZGF0YSk7XG4gICAgICAgICAgICAgICBzdGFydERyYWdBbmREcm9wU2lnbmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vdXNlQWN0aW9uLmNvbnRhaW5lcj8ubmFtZSA9PSBcIkdlbmVyaWNPYmplY3RcIikge1xuICAgICAgICAgICAgICAgbXlDYW52YXMuc3R5bGUuY3Vyc29yID0gXCJtb3ZlXCI7XG5cbiAgICAgICAgICAgICAgIG1vdXNlQWN0aW9uLmFjdGlvbiA9IE1PVVNFX0RPV05fQUNUSU9OLk1PVkVfT0JKRUNUO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIG1vdXNlQWN0aW9uLmNvbnRhaW5lcj8ubmFtZSA9PSBcInRyYWNrXCIgfHxcbiAgICAgICAgICAgICAgIG1vdXNlQWN0aW9uLmNvbnRhaW5lcj8ubmFtZSA9PSBcInN3aXRjaFwiIHx8XG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbi5jb250YWluZXIgPT0gbnVsbFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbi5hY3Rpb24gPSBNT1VTRV9ET1dOX0FDVElPTi5CVUlMRF9UUkFDSztcbiAgICAgICAgICAgICAgIGFkZFRyYWNrQW5jaG9yUG9pbnQoZ2V0U25hcFBvaW50KGxvY2FsX3BvaW50KSk7XG4gICAgICAgICAgICAgICBvdmVybGF5X2NvbnRhaW5lci5hZGRDaGlsZCgobW91c2VBY3Rpb24ubGluZVNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChtb3VzZUFjdGlvbi5jb250YWluZXI/Lm5hbWUgPT0gXCJ0cmFpblwiKSB7XG4gICAgICAgICAgICBtb3VzZUFjdGlvbi5hY3Rpb24gPSBNT1VTRV9ET1dOX0FDVElPTi5NT1ZFX1RSQUlOO1xuICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudC5uYXRpdmVFdmVudC5idXR0b25zID09IDIpIHtcbiAgICAgICAgIC8vc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWdlbW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgICBtb3VzZUFjdGlvbi5hY3Rpb24gPSBNT1VTRV9ET1dOX0FDVElPTi5TQ1JPTEw7XG4gICAgICB9XG4gICB9XG59XG5cbmZ1bmN0aW9uIGRyYWduRHJvcFNpZ25hbChsb2NhbF9wb2ludCwgZmxpcHBlZCkge1xuICAgbGV0IGhpdEluZm9ybWF0aW9uID0gZ2V0SGl0SW5mb0ZvclNpZ25hbFBvc2l0aW9uaW5nKGxvY2FsX3BvaW50KTtcbiAgIGlmIChoaXRJbmZvcm1hdGlvbikge1xuICAgICAgaGl0SW5mb3JtYXRpb24uZmxpcHBlZCA9IGZsaXBwZWQ7XG4gICAgICBtb3VzZUFjdGlvbi5oaXRfdHJhY2sgPSBoaXRJbmZvcm1hdGlvbjtcbiAgICAgIGNvbnNvbGUubG9nKGhpdEluZm9ybWF0aW9uKTtcbiAgICAgIGFsaWduU2lnbmFsQ29udGFpbmVyV2l0aFRyYWNrKG1vdXNlQWN0aW9uLmNvbnRhaW5lciwgaGl0SW5mb3JtYXRpb24pO1xuICAgfSBlbHNlIHtcbiAgICAgIG1vdXNlQWN0aW9uLmhpdF90cmFjayA9IG51bGw7XG4gICAgICBtb3VzZUFjdGlvbi5jb250YWluZXIucm90YXRpb24gPSAwO1xuICAgICAgaWYgKG1vdXNlQWN0aW9uLm9mZnNldCkge1xuICAgICAgICAgbGV0IHAgPSBtb3VzZUFjdGlvbi5jb250YWluZXIubG9jYWxUb0xvY2FsKG1vdXNlQWN0aW9uLm9mZnNldC54LCBtb3VzZUFjdGlvbi5vZmZzZXQueSwgc3RhZ2UpO1xuICAgICAgICAgbG9jYWxfcG9pbnQueCAtPSBwLnggLSBtb3VzZUFjdGlvbi5jb250YWluZXIueDtcbiAgICAgICAgIGxvY2FsX3BvaW50LnkgLT0gcC55IC0gbW91c2VBY3Rpb24uY29udGFpbmVyLnk7XG4gICAgICB9XG4gICAgICBtb3VzZUFjdGlvbi5jb250YWluZXIueCA9IGxvY2FsX3BvaW50Lng7XG4gICAgICBtb3VzZUFjdGlvbi5jb250YWluZXIueSA9IGxvY2FsX3BvaW50Lnk7XG4gICB9XG4gICBkcmF3X1NpZ25hbFBvc2l0aW9uTGluZSgpO1xufVxuXG5mdW5jdGlvbiBkcmF3X1NpZ25hbFBvc2l0aW9uTGluZSgpIHtcbiAgIGxldCBzaGFwZSA9IG92ZXJsYXlfY29udGFpbmVyLmdldENoaWxkQnlOYW1lKFwiU2lnbmFsUG9zaXRpb25MaW5lXCIpO1xuICAgaWYgKHNoYXBlKSBvdmVybGF5X2NvbnRhaW5lci5yZW1vdmVDaGlsZChzaGFwZSk7XG5cbiAgIGlmIChtb3VzZUFjdGlvbi5oaXRfdHJhY2spIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gbW91c2VBY3Rpb24uaGl0X3RyYWNrLnBvaW50O1xuICAgICAgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIHNoYXBlLm5hbWUgPSBcIlNpZ25hbFBvc2l0aW9uTGluZVwiO1xuICAgICAgc2hhcGUuZ3JhcGhpY3NcbiAgICAgICAgIC5zZXRTdHJva2VTdHlsZSgxKVxuICAgICAgICAgLmJlZ2luU3Ryb2tlKFwiI2UwMFwiKVxuICAgICAgICAgLm10KG1vdXNlQWN0aW9uLmNvbnRhaW5lci54LCBtb3VzZUFjdGlvbi5jb250YWluZXIueSlcbiAgICAgICAgIC5sdChwb2ludC54LCBwb2ludC55KVxuICAgICAgICAgLmVzKCk7XG4gICAgICBvdmVybGF5X2NvbnRhaW5lci5hZGRDaGlsZChzaGFwZSk7XG4gICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdCbHVlUHJpbnRUcmFjaygpIHtcbiAgIGlmIChtb3VzZUFjdGlvbi5ub2RlcyA9PSBudWxsKSByZXR1cm47XG4gICBjb25zdCBnID0gbW91c2VBY3Rpb24ubGluZVNoYXBlLmdyYXBoaWNzO1xuICAgZy5jKCkuc2V0U3Ryb2tlU3R5bGUodHJhY2tSZW5kZXJpbmdfYmFzaWMuU1RST0tFKS5iZWdpblN0cm9rZShcImJsdWVcIikubW92ZVRvKG1vdXNlQWN0aW9uLm5vZGVzWzBdLngsIG1vdXNlQWN0aW9uLm5vZGVzWzBdLnkpO1xuXG4gICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgbW91c2VBY3Rpb24ubm9kZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IG1vdXNlQWN0aW9uLm5vZGVzW2luZGV4XTtcbiAgICAgIGcubHQocG9pbnQueCwgcG9pbnQueSk7XG4gICB9XG5cbiAgIGNvbnN0IGxhc3QgPSBBcnJheVV0aWxzLmxhc3QobW91c2VBY3Rpb24ubm9kZXMpO1xuICAgY29uc3QgcCA9IHN0YWdlLmdsb2JhbFRvTG9jYWwoc3RhZ2UubW91c2VYLCBzdGFnZS5tb3VzZVkpO1xuICAgZy5iZWdpblN0cm9rZShcInJlZFwiKS5tb3ZlVG8obGFzdC54LCBsYXN0LnkpLmx0KHAueCwgcC55KS5lbmRTdHJva2UoKTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhY2tBbmNob3JQb2ludChwKSB7XG4gICBpZiAobW91c2VBY3Rpb24ubm9kZXMgPT0gbnVsbCkge1xuICAgICAgbW91c2VBY3Rpb24ubm9kZXMgPSBbXTtcbiAgIH1cblxuICAgLy93ZW5uIGRlciBsZXR6dGUgUHVua3QgZ2xlaWNoIGRlbSBha3R1ZWxsZW4gaXN0LCBkYW5uIG5pY2h0cyB0dW5cbiAgIGlmIChBcnJheVV0aWxzLmxhc3QobW91c2VBY3Rpb24ubm9kZXMpPy5lcXVhbHMocCkpIHJldHVybjtcbiAgIC8vd2VubiBkZXIgU3RhcnRwdW5rdCBnbGVpY2ggZGVtIGFrdHVlbGxlbiBpc3QsIGRhbm4gVHJhY2sgenVyw7xja3NldHplblxuICAgaWYgKEFycmF5VXRpbHMuZmlyc3QobW91c2VBY3Rpb24ubm9kZXMpPy5lcXVhbHMocCkpIHtcbiAgICAgIG1vdXNlQWN0aW9uLm5vZGVzID0gW21vdXNlQWN0aW9uLm5vZGVzWzBdXTtcbiAgICAgIHJldHVybjtcbiAgIH1cblxuICAgbW91c2VBY3Rpb24ubm9kZXMucHVzaChwKTtcbiAgIHJldHVybjtcblxuICAgaWYgKGFua2VyUG9pbnRzID09IG51bGwgfHwgYW5rZXJQb2ludHMubGVuZ3RoID09IDApIHtcbiAgICAgIG1vdXNlQWN0aW9uLmFua2VyUG9pbnRzID0gW3BdO1xuICAgfSBlbHNlIHtcbiAgICAgIGlmIChnZW9tZXRyeS5kaXN0YW5jZShsb2NhbF9wb2ludCwgcCkgPiBTTkFQXzJfR1JJRCkge1xuICAgICAgICAgLyogaWYgKGFua2VyUG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGFua2VyUG9pbnRzLnBvcCgpO1xuICAgICAgICAgfSAqL1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsYXN0ID0gYW5rZXJQb2ludHMubGFzdCgpO1xuICAgICAgLy9pZiAoIWxvY2FsX3BvaW50LnguY2xvc2VUb0J5KEdSSURfU0laRSwgU05BUF8yX0dSSUQpIHx8ICFsb2NhbF9wb2ludC55LmNsb3NlVG9CeShHUklEX1NJWkUsIFNOQVBfMl9HUklEKSkgcmV0dXJuO1xuICAgICAgaWYgKCFsYXN0LmVxdWFscyhwKSkge1xuICAgICAgICAgY29uc3Qgc2xvcGUgPSBnZW9tZXRyeS5zbG9wZShsYXN0LCBwKTtcbiAgICAgICAgIGlmIChhbmtlclBvaW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaWYgKHNsb3BlLmJldHdlZW4oMSwgLTEpKSBhbmtlclBvaW50cy5wdXNoKHApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBNYXRoLnNpZ24oYW5rZXJQb2ludHNbMV0ueCAtIGFua2VyUG9pbnRzWzBdLngpO1xuICAgICAgICAgICAgLy9oYWJlbiB3aXIgZGVuIFB1bmt0IHNjaG9uIGVpbmdldHJhZ2VuP1xuICAgICAgICAgICAgY29uc3QgeSA9IHAueCAtIEdSSURfU0laRSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBhbmtlclBvaW50cy5maW5kSW5kZXgoKHApID0+IE1hdGguc2lnbihwLnggLSB5KSA9PSBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAvL2JpcyB6dSBkaWVzZW0gUHVua3QgYWxsZSB2b3JoYW5kZW5lbiBQdW5rdGUgbMO2c2NoZW4gdW5kIGRlbiBha3R1ZWxsZW4gUHVua3QgdmVyc3VjaGVuIG5ldSBlaW56dXRyYWdlblxuICAgICAgICAgICAgICAgYW5rZXJQb2ludHMuc3BsaWNlKGkpO1xuICAgICAgICAgICAgICAgYWRkVHJhY2tBbmNob3JQb2ludChsb2NhbF9wb2ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgLy9jaGVja3MgZm9yIHRoZSByaWdodCBzbG9wZVxuICAgICAgICAgICAgICAgLy9ubyBvdGhlciBzdHJhaWdodCBvciA0NcKwIGFuZCB0aGUgcHJldmlvdXMgc2xvcGUgYW5kIGN1cnJlbnQgc2xvcGUgbXVzc3Qgbm90IGNyZWF0ZSBhIDkwwrAgYW5nbGVcbiAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNsb3BlLmJldHdlZW4oMSwgLTEpICYmXG4gICAgICAgICAgICAgICAgICAoc2xvcGUgPT0gMCB8fCBzbG9wZSArIGdlb21ldHJ5LnNsb3BlKGxhc3QsIGFua2VyUG9pbnRzW2Fua2VyUG9pbnRzLmxlbmd0aCAtIDJdKSAhPSAwKVxuICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBhbmtlclBvaW50cy5wdXNoKHApO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVTdGFnZU1vdXNlVXAoZSkge1xuICAgLy9jb25zb2xlLmxvZyhcImhhbmRsZVN0YWdlTW91c2VVcFwiLCBlKTtcbiAgIHRyeSB7XG4gICAgICBzdGFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgIG15Q2FudmFzLnN0eWxlLmN1cnNvciA9IFwiYXV0b1wiO1xuICAgICAgaWYgKG1vdXNlQWN0aW9uID09IG51bGwpIHJldHVybjtcblxuICAgICAgbGV0IGxvY2FsX3BvaW50ID0gUG9pbnQuZnJvbVBvaW50KHN0YWdlLmdsb2JhbFRvTG9jYWwoc3RhZ2UubW91c2VYLCBzdGFnZS5tb3VzZVkpKTtcbiAgICAgIC8vbGVmdCBidXR0b25cbiAgICAgIGlmIChlLm5hdGl2ZUV2ZW50LndoaWNoID09IDEpIHtcbiAgICAgICAgIGlmIChtb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLkRORF9TSUdOQUwpIHtcbiAgICAgICAgICAgIG92ZXJsYXlfY29udGFpbmVyLnJlbW92ZUNoaWxkKG1vdXNlQWN0aW9uLmNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChtb3VzZUFjdGlvbi5oaXRfdHJhY2spIHtcbiAgICAgICAgICAgICAgIHNpZ25hbF9jb250YWluZXIuYWRkQ2hpbGQobW91c2VBY3Rpb24uY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IG1vdXNlQWN0aW9uLmNvbnRhaW5lci5kYXRhO1xuICAgICAgICAgICAgICAgbW91c2VBY3Rpb24uaGl0X3RyYWNrLnRyYWNrLkFkZFNpZ25hbChcbiAgICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIG1vdXNlQWN0aW9uLmhpdF90cmFjay5rbSxcbiAgICAgICAgICAgICAgICAgIG1vdXNlQWN0aW9uLmhpdF90cmFjay5hYm92ZSxcbiAgICAgICAgICAgICAgICAgIG1vdXNlQWN0aW9uLmhpdF90cmFjay5mbGlwcGVkXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgIFNpZ25hbC5yZW1vdmVTaWduYWwobW91c2VBY3Rpb24uY29udGFpbmVyLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgICAgU1RPUkFHRS5zYXZlVW5kb0hpc3RvcnkoKTtcbiAgICAgICAgIH0gZWxzZSBpZiAobW91c2VBY3Rpb24uYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5CVUlMRF9UUkFDSykge1xuICAgICAgICAgICAgaWYgKG1vdXNlQWN0aW9uLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgIFRyYWNrLmNoZWNrTm9kZXNBbmRDcmVhdGVUcmFja3MobW91c2VBY3Rpb24ubm9kZXMpO1xuICAgICAgICAgICAgICAgVHJhY2suY3JlYXRlUmFpbE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICBUcmFpbi5hbGxUcmFpbnMuZm9yRWFjaCgodCkgPT4gdC5yZXN0b3JlKCkpO1xuICAgICAgICAgICAgICAgU1RPUkFHRS5zYXZlVW5kb0hpc3RvcnkoKTtcbiAgICAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIGlmIChtb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLkFERF9UUkFJTikge1xuICAgICAgICAgICAgb3ZlcmxheV9jb250YWluZXIucmVtb3ZlQ2hpbGQobW91c2VBY3Rpb24uY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGhpdCA9IGdldEhpdFRlc3QodHJhY2tfY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChoaXQ/Lm5hbWUgPT0gXCJ0cmFja1wiKSB7XG4gICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IEFycmF5VXRpbHMucmFuZG9tKFtcIiNmZjAwMDBcIiwgXCIjZmZmZjAwXCIsIFwiIzAwZmYwMFwiLCBcIiMwMDAwZmZcIl0pO1xuICAgICAgICAgICAgICAgY29uc3QgdHJhY2sgPSBoaXQuZGF0YTtcbiAgICAgICAgICAgICAgIGNvbnN0IGhpdEluZm8gPSBnZXRIaXRJbmZvRm9yU2lnbmFsUG9zaXRpb25pbmcobG9jYWxfcG9pbnQpO1xuICAgICAgICAgICAgICAgbGV0IHRyYWluLCBjYXIsIGNhcjI7XG4gICAgICAgICAgICAgICBjb25zdCBrbSA9IGhpdEluZm8ua207XG5cbiAgICAgICAgICAgICAgIC8vIENyZWF0ZSBsb2NvbW90aXZlIGFzIHRoZSBmaXJzdCBjYXJcbiAgICAgICAgICAgICAgIGNhciA9IHRyYWluID0gVHJhaW4uYWRkVHJhaW4odHJhY2ssIGttLCBjb2xvciwgVHJhaW4uQ0FSX1RZUEVTLkxPQ09NT1RJVkUsIFwiXCIpO1xuXG4gICAgICAgICAgICAgICAvLyBBZGQgcGFzc2VuZ2VyIGNhcnNcbiAgICAgICAgICAgICAgIGNhcjIgPSBUcmFpbi5hZGRUcmFpbih0cmFjaywga20sIGNvbG9yLCBUcmFpbi5DQVJfVFlQRVMuUEFTU0VOR0VSLCBcIlwiKTtcbiAgICAgICAgICAgICAgIGNhci5jb3VwbGVCYWNrKGNhcjIpO1xuICAgICAgICAgICAgICAgY2FyID0gY2FyMjtcblxuICAgICAgICAgICAgICAgLy8gQWRkIGFub3RoZXIgcGFzc2VuZ2VyIGNhclxuICAgICAgICAgICAgICAgY2FyMiA9IFRyYWluLmFkZFRyYWluKHRyYWNrLCBrbSwgY29sb3IsIFRyYWluLkNBUl9UWVBFUy5QQVNTRU5HRVIsIFwiXCIpO1xuICAgICAgICAgICAgICAgY2FyLmNvdXBsZUJhY2soY2FyMik7XG4gICAgICAgICAgICAgICBjYXIgPSBjYXIyO1xuXG4gICAgICAgICAgICAgICAvLyBBZGQgYSB0aGlyZCBwYXNzZW5nZXIgY2FyXG4gICAgICAgICAgICAgICBjYXIyID0gVHJhaW4uYWRkVHJhaW4odHJhY2ssIGttLCBjb2xvciwgVHJhaW4uQ0FSX1RZUEVTLlBBU1NFTkdFUiwgXCJcIik7XG4gICAgICAgICAgICAgICBjYXIuY291cGxlQmFjayhjYXIyKTtcblxuICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRyYWluIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgVHJhaW4ubW92ZVRyYWluKHRyYWluLCAwKTtcbiAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlckFsbFRyYWlucygpO1xuICAgICAgICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2UgaWYgKE51bWJlclV0aWxzLmlzKG1vdXNlQWN0aW9uLmFjdGlvbiwgTU9VU0VfRE9XTl9BQ1RJT04uTU9WRV9UUkFJTiwgTU9VU0VfRE9XTl9BQ1RJT04uTU9WRV9PQkpFQ1QpKSB7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICAgICAgICB9IGVsc2UgaWYgKG1vdXNlQWN0aW9uLmFjdGlvbiA9PT0gTU9VU0VfRE9XTl9BQ1RJT04uQ1VTVE9NKSB7XG4gICAgICAgICAgICBpZiAoY3VzdG9tX21vdXNlX21vZGUgPT0gQ1VTVE9NX01PVVNFX0FDVElPTi5URVhUKSB7XG4gICAgICAgICAgICAgICBjb25zdCBvID0gbmV3IEdlbmVyaWNPYmplY3QoR2VuZXJpY09iamVjdC5PQkpFQ1RfVFlQRS50ZXh0KS5wb3MobG9jYWxfcG9pbnQpLmNvbnRlbnQoXCJUZXh0XCIpO1xuICAgICAgICAgICAgICAgR2VuZXJpY09iamVjdC5hbGxfb2JqZWN0cy5wdXNoKG8pO1xuICAgICAgICAgICAgICAgc2VsZWN0T2JqZWN0KG8pO1xuICAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyQWxsR2VuZXJpY09iamVjdHMoKTtcbiAgICAgICAgICAgICAgIGN1c3RvbV9tb3VzZV9tb2RlID0gQ1VTVE9NX01PVVNFX0FDVElPTi5OT05FO1xuICAgICAgICAgICAgICAgd2luZG93LmN1c3RvbV9tb3VzZV9tb2RlID0gY3VzdG9tX21vdXNlX21vZGU7IC8vIFVwZGF0ZSBnbG9iYWwgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICBVSS5hY3RpdmF0ZV9jdXN0b21fbW91c2VfbW9kZSgpO1xuICAgICAgICAgICAgICAgU1RPUkFHRS5zYXZlVW5kb0hpc3RvcnkoKTtcbiAgICAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21fbW91c2VfbW9kZSA9PSBDVVNUT01fTU9VU0VfQUNUSU9OLlBMQVRURk9STSkge1xuICAgICAgICAgICAgICAgb3ZlcmxheV9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgIGNvbnN0IG8gPSBuZXcgR2VuZXJpY09iamVjdChHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLnBsYXR0Zm9ybSlcbiAgICAgICAgICAgICAgICAgIC5jb250ZW50KFwiQmFobnN0ZWlnXCIpXG4gICAgICAgICAgICAgICAgICAucG9zKG1vdXNlQWN0aW9uLnN0YXJ0UG9pbnQpXG4gICAgICAgICAgICAgICAgICAuc2l6ZShsb2NhbF9wb2ludC54IC0gbW91c2VBY3Rpb24uc3RhcnRQb2ludC54LCBsb2NhbF9wb2ludC55IC0gbW91c2VBY3Rpb24uc3RhcnRQb2ludC55KTtcbiAgICAgICAgICAgICAgIEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMucHVzaChvKTtcbiAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlckFsbEdlbmVyaWNPYmplY3RzKCk7XG4gICAgICAgICAgICAgICBzZWxlY3RPYmplY3Qobyk7XG4gICAgICAgICAgICAgICBjdXN0b21fbW91c2VfbW9kZSA9IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORTtcbiAgICAgICAgICAgICAgIHdpbmRvdy5jdXN0b21fbW91c2VfbW9kZSA9IGN1c3RvbV9tb3VzZV9tb2RlOyAvLyBVcGRhdGUgZ2xvYmFsIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgVUkuYWN0aXZhdGVfY3VzdG9tX21vdXNlX21vZGUoKTtcbiAgICAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICAgICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tX21vdXNlX21vZGUgPT09IENVU1RPTV9NT1VTRV9BQ1RJT04uVFJBSU5fREVDT1VQTEUpIHtcbiAgICAgICAgICAgICAgIGlmIChtb3VzZUFjdGlvbi5jb250YWluZXI/Lm5hbWUgPT0gXCJkZWNvdXBsaW5nUG9pbnRcIikge1xuICAgICAgICAgICAgICAgICAgVHJhaW4uaGFuZGxlRGVjb3VwbGluZ0NsaWNrKG1vdXNlQWN0aW9uLmNvbnRhaW5lci5kYXRhKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBUcmFpbi5leGl0RGVjb3VwbGluZ01vZGUoKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tX21vdXNlX21vZGUgPT09IENVU1RPTV9NT1VTRV9BQ1RJT04uVFJBSU5fQ09VUExFKSB7XG4gICAgICAgICAgICAgICBpZiAobW91c2VBY3Rpb24uY29udGFpbmVyPy5uYW1lID09IFwiY291cGxpbmdQb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgICBUcmFpbi5oYW5kbGVDb3VwbGluZ0NsaWNrKG1vdXNlQWN0aW9uLmNvbnRhaW5lci5kYXRhKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBUcmFpbi5leGl0Q291cGxpbmdNb2RlKCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2UgaWYgKG1vdXNlQWN0aW9uLmFjdGlvbiA9PT0gTU9VU0VfRE9XTl9BQ1RJT04uTk9ORSAmJiBtb3VzZUFjdGlvbi5kaXN0YW5jZSgpIDwgNCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlQWN0aW9uLmNvbnRhaW5lcj8ubmFtZSA9PSBcInNpZ25hbFwiKSB7XG4gICAgICAgICAgICAgICBzZWxlY3RPYmplY3QobW91c2VBY3Rpb24uY29udGFpbmVyLmRhdGEsIGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb3VzZUFjdGlvbi5jb250YWluZXI/Lm5hbWUgPT0gXCJjb3VwbGluZ1BvaW50XCIgJiYgY3VzdG9tX21vdXNlX21vZGUgPT09IENVU1RPTV9NT1VTRV9BQ1RJT04uVFJBSU5fQ09VUExFKSB7XG4gICAgICAgICAgICAgICAvLyBIYW5kbGUgY291cGxpbmcgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgVHJhaW4uaGFuZGxlQ291cGxpbmdDbGljayhtb3VzZUFjdGlvbi5jb250YWluZXIuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vdXNlQWN0aW9uLmNvbnRhaW5lcj8ubmFtZSA9PSBcInRyYWluXCIpIHtcbiAgICAgICAgICAgICAgIHNlbGVjdE9iamVjdChtb3VzZUFjdGlvbi5jb250YWluZXIuZGF0YSwgZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vdXNlQWN0aW9uLmNvbnRhaW5lcj8ubmFtZSA9PSBcInRyYWNrXCIpIHtcbiAgICAgICAgICAgICAgIHNlbGVjdE9iamVjdChtb3VzZUFjdGlvbi5jb250YWluZXIuZGF0YSwgZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vdXNlQWN0aW9uLmNvbnRhaW5lcj8ubmFtZSA9PSBcIkdlbmVyaWNPYmplY3RcIikge1xuICAgICAgICAgICAgICAgc2VsZWN0T2JqZWN0KG1vdXNlQWN0aW9uLmNvbnRhaW5lci5kYXRhLCBlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW91c2VBY3Rpb24uY29udGFpbmVyPy5uYW1lID09IFwic3dpdGNoXCIpIHtcbiAgICAgICAgICAgICAgIFN3aXRjaC5zd2l0Y2hfQV9Td2l0Y2gobW91c2VBY3Rpb24uY29udGFpbmVyLmRhdGEsIGxvY2FsX3BvaW50LngpO1xuICAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyU3dpdGNoVUkobW91c2VBY3Rpb24uY29udGFpbmVyLmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHNlbGVjdE9iamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLlNDUk9MTCkge1xuICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICB9XG4gICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdWkuc2hvd0Vycm9yVG9hc3QoZXJyb3IpO1xuICAgfSBmaW5hbGx5IHtcbiAgICAgIG1vdXNlQWN0aW9uID0gbnVsbDtcbiAgICAgIG92ZXJsYXlfY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICBzdGFnZS51cGRhdGUoKTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50KHBvaW50LCBkaXNwbGF5T2JqZWN0LCBsYWJlbCA9IFwiXCIsIGNvbG9yID0gXCIjMDAwXCIsIHNpemUgPSAwLjUpIHtcbiAgIGNvbnN0IHMgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgIHMuZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoMSkuYmVnaW5TdHJva2UoY29sb3IpLmJlZ2luRmlsbChjb2xvcikuZHJhd0NpcmNsZSgwLCAwLCBzaXplKTtcbiAgIHMueCA9IHBvaW50Lng7XG4gICBzLnkgPSBwb2ludC55O1xuXG4gICBkZWJ1Z19jb250YWluZXIuYWRkQ2hpbGQocyk7XG5cbiAgIGlmIChsYWJlbCkge1xuICAgICAgY29uc3QgdGV4dCA9IG5ldyBjcmVhdGVqcy5UZXh0KGxhYmVsLCBcIkl0YWxpYyA2cHggQXJpYWxcIiwgY29sb3IpO1xuICAgICAgdGV4dC54ID0gcy54O1xuICAgICAgdGV4dC55ID0gcy55IC0gNTtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgICBkZWJ1Z19jb250YWluZXIuYWRkQ2hpbGQodGV4dCk7XG4gICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/code/start.js\n\n}");

/***/ }),

/***/ "./www/code/storage.js":
/*!*****************************!*\
  !*** ./www/code/storage.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STORAGE: () => (/* binding */ STORAGE)\n/* harmony export */ });\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\nconst STORAGE = {\n   MIN_STORAGE_VERSION: 0.5,\n   STORAGE_IDENT: \"bahnhof_last1\",\n\n   getClassMap() {\n      return {\n         Track: _track_js__WEBPACK_IMPORTED_MODULE_0__.Track,\n         Switch: _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch,\n         Signal: _signal_js__WEBPACK_IMPORTED_MODULE_2__.Signal,\n         Train: _train_js__WEBPACK_IMPORTED_MODULE_3__.Train,\n         GenericObject: _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject,\n      };\n   },\n\n   receiver(key, value) {\n      if (value?._class && STORAGE.getClassMap()[value._class]) {\n         const MyClass = STORAGE.getClassMap()[value._class];\n         const instance = MyClass.FromObject(value);\n         if (instance == null) _ui_js__WEBPACK_IMPORTED_MODULE_6__.ui.showErrorToast(new Error(\"error loading \" + key));\n         return instance;\n      }\n      return value;\n   },\n\n   replacer(key, value) {\n      return typeof value?.stringify === \"function\" ? value.stringify() : value;\n   },\n\n   getSaveString() {\n      return (\n         VERSION +\n         \";\" +\n         JSON.stringify(\n            {\n               tracks: _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks,\n               trains: _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains,\n               switches: _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches,\n               objects: _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects,\n               settings: {\n                  zoom: window.stage.scale,\n                  scrollX: window.stage.x,\n                  scrollY: window.stage.y,\n                  renderer: window.renderer instanceof window.trackRendering_textured ? \"textured\" : \"basic\",\n               },\n            },\n            STORAGE.replacer\n         )\n      );\n   },\n\n   restoreLastUndoStep() {\n      if (window.undoHistory.length <= 1) return;\n      window.undoHistory.pop();\n      const last = _utils_js__WEBPACK_IMPORTED_MODULE_5__.ArrayUtils.last(window.undoHistory);\n      if (last) {\n         STORAGE.loadFromJson(last);\n      } else _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks = [];\n\n      window.updateUndoButtonState();\n   },\n\n   linkObjects() {\n      // Link switches to tracks\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.forEach((s) => {\n         if (s.tracks_id) {\n            s.tracks = s.tracks_id.map((id) => (id ? _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.find((t) => t.id === id) : null));\n         }\n         s.branch = s.branch_id ? _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.find((t) => t.id === s.branch_id) : null;\n         s.from = s.from_id ? _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.find((t) => t.id === s.from_id) : null;\n         s.calculateParameters();\n         delete s.tracks_id;\n         delete s.branch_id;\n         delete s.from_id;\n      });\n\n      // Link tracks to switches/other tracks\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.forEach((t) => {\n         t.switches = t.switches_data.map((sd) => {\n            if (!sd) return null;\n            if (sd.type === \"Switch\") {\n               return _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.find((s) => s.id === sd.id);\n            } else if (sd.type === \"Track\") {\n               return _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.find((tr) => tr.id === sd.id);\n            }\n            return null;\n         });\n         delete t.switches_data;\n      });\n   },\n\n   loadFromJson(json) {\n      RENDERING.clear();\n      let loaded = JSON.parse(json, STORAGE.receiver);\n      if (loaded.settings) {\n         window.stage.x = loaded.settings.scrollX;\n         window.stage.y = loaded.settings.scrollY;\n         window.stage.scale = loaded.settings.zoom;\n         if (loaded.settings.renderer) {\n            window.selectRenderer(loaded.settings.renderer === \"textured\");\n         }\n      }\n      if (loaded.objects) _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects = loaded.objects;\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks = loaded.tracks ? _utils_js__WEBPACK_IMPORTED_MODULE_5__.ArrayUtils.cleanUp(loaded.tracks) : []; //when something went wront while loading track, we filter all nulls\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches = loaded.switches ? _utils_js__WEBPACK_IMPORTED_MODULE_5__.ArrayUtils.cleanUp(loaded.switches) : []; //when something went wront while loading switch, we filter all nulls\n\n      // Reset counters\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.counter = _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.length ? Math.max(..._track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.map((t) => t.id)) + 1 : 0;\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.counter = _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.length ? Math.max(..._switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.map((s) => s.id)) + 1 : 0;\n\n      STORAGE.linkObjects();\n\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.createRailNetwork();\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains = loaded.trains ? _utils_js__WEBPACK_IMPORTED_MODULE_5__.ArrayUtils.cleanUp(loaded.trains) : []; ////when something went wront while loading trains, we filter all nulls\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains.forEach((t) => t.restore());\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains.forEach((t) => {\n         delete t.trainCoupledFrontId;\n         delete t.trainCoupledBackId;\n      });\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains = _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains.filter((t) => t.track != null);\n   },\n\n   saveUndoHistory() {\n      window.undoHistory.push(JSON.stringify({ tracks: _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks, objects: _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects }, STORAGE.replacer));\n      if (window.undoHistory.length > window.MOST_UNDO) window.undoHistory.shift();\n\n      window.updateUndoButtonState();\n   },\n\n   save() {\n      localStorage.setItem(STORAGE.STORAGE_IDENT, STORAGE.getSaveString());\n   },\n\n   loadRecent() {\n      try {\n         const x = localStorage.getItem(STORAGE.STORAGE_IDENT);\n         if (x != null) {\n            const indexOfFirst = x.indexOf(\";\");\n            if (indexOfFirst > -1) {\n               const loaded_version = parseFloat(x.substring(0, indexOfFirst));\n               if (loaded_version >= STORAGE.MIN_STORAGE_VERSION) STORAGE.loadFromJson(x.slice(indexOfFirst + 1));\n               else console.error(`stored version ${loaded_version} to old`);\n            } else throw new Error(\"Version Tag is missing\");\n            STORAGE.saveUndoHistory();\n         }\n      } catch (error) {\n         _ui_js__WEBPACK_IMPORTED_MODULE_6__.ui.showErrorToast(error);\n      }\n      window.updateUndoButtonState();\n   },\n\n   loadPrebuildbyName(name) {\n      return new Promise((resolve, reject) => {\n         let xmlhttp = new XMLHttpRequest();\n         xmlhttp.onreadystatechange = function () {\n            if (this.readyState == 4 && this.status == 200) {\n               let i;\n               let xmlDoc = this.responseXML;\n\n               let x = xmlDoc.getElementsByTagName(\"setup\");\n               for (i = 0; i < x.length; i++) {\n                  if (x[i].getElementsByTagName(\"title\")[0].textContent == name) {\n                     STORAGE.loadFromJson(x[i].getElementsByTagName(\"json\")[0].childNodes[0].wholeText.trim());\n                     resolve();\n                  }\n               }\n            }\n         };\n         xmlhttp.open(\"GET\", \"prebuilds.xml\" + \"?\" + Math.floor(Math.random() * 100), true);\n         xmlhttp.send();\n      });\n   },\n};\n\n //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7O0FBRWI7QUFDbUM7QUFDRTtBQUNBO0FBQ0Y7QUFDaUI7QUFDWjtBQUNYOztBQUV0QjtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBSztBQUNyQixpQkFBaUIsOENBQU07QUFDdkIsaUJBQWlCLDhDQUFNO0FBQ3ZCLGdCQUFnQiw0Q0FBSztBQUNyQix3QkFBd0IsNkRBQWE7QUFDckM7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNDQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx1QkFBdUIsNENBQUs7QUFDNUIsdUJBQXVCLDRDQUFLO0FBQzVCLHlCQUF5Qiw4Q0FBTTtBQUMvQix3QkFBd0IsNkRBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQVU7QUFDN0I7QUFDQTtBQUNBLFFBQVEsS0FBSyw0Q0FBSzs7QUFFbEI7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxNQUFNLDhDQUFNO0FBQ1o7QUFDQSxxREFBcUQsNENBQUs7QUFDMUQ7QUFDQSxrQ0FBa0MsNENBQUs7QUFDdkMsOEJBQThCLDRDQUFLO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLE1BQU0sNENBQUs7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOENBQU07QUFDNUIsY0FBYztBQUNkLHNCQUFzQiw0Q0FBSztBQUMzQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2REFBYTtBQUN2QyxNQUFNLDRDQUFLLDZCQUE2QixpREFBVSw4QkFBOEI7QUFDaEYsTUFBTSw4Q0FBTSxpQ0FBaUMsaURBQVUsZ0NBQWdDOztBQUV2RjtBQUNBLE1BQU0sNENBQUssV0FBVyw0Q0FBSyxnQ0FBZ0MsNENBQUs7QUFDaEUsTUFBTSw4Q0FBTSxXQUFXLDhDQUFNLGtDQUFrQyw4Q0FBTTs7QUFFckU7O0FBRUEsTUFBTSw0Q0FBSztBQUNYLE1BQU0sNENBQUssNkJBQTZCLGlEQUFVLDhCQUE4QjtBQUNoRixNQUFNLDRDQUFLO0FBQ1gsTUFBTSw0Q0FBSztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSw0Q0FBSyxhQUFhLDRDQUFLO0FBQzdCLElBQUk7O0FBRUo7QUFDQSwrQ0FBK0MsUUFBUSw0Q0FBSyxxQkFBcUIsNkRBQWEsY0FBYztBQUM1Rzs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFFBQVE7QUFDUixTQUFTLHNDQUFFO0FBQ1g7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSTtBQUNKOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2xlaXNwbGFuZWRpdG9yLy4vd3d3L2NvZGUvc3RvcmFnZS5qcz9kYjhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay5qcyc7XG5pbXBvcnQgeyBTd2l0Y2ggfSBmcm9tICcuL3N3aXRjaC5qcyc7XG5pbXBvcnQgeyBTaWduYWwgfSBmcm9tICcuL3NpZ25hbC5qcyc7XG5pbXBvcnQgeyBUcmFpbiB9IGZyb20gJy4vdHJhaW4uanMnO1xuaW1wb3J0IHsgR2VuZXJpY09iamVjdCB9IGZyb20gJy4vZ2VuZXJpY19vYmplY3QuanMnO1xuaW1wb3J0IHsgQXJyYXlVdGlscyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgdWkgfSBmcm9tICcuL3VpLmpzJztcblxuZXhwb3J0IGNvbnN0IFNUT1JBR0UgPSB7XG4gICBNSU5fU1RPUkFHRV9WRVJTSU9OOiAwLjUsXG4gICBTVE9SQUdFX0lERU5UOiBcImJhaG5ob2ZfbGFzdDFcIixcblxuICAgZ2V0Q2xhc3NNYXAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgVHJhY2s6IFRyYWNrLFxuICAgICAgICAgU3dpdGNoOiBTd2l0Y2gsXG4gICAgICAgICBTaWduYWw6IFNpZ25hbCxcbiAgICAgICAgIFRyYWluOiBUcmFpbixcbiAgICAgICAgIEdlbmVyaWNPYmplY3Q6IEdlbmVyaWNPYmplY3QsXG4gICAgICB9O1xuICAgfSxcblxuICAgcmVjZWl2ZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlPy5fY2xhc3MgJiYgU1RPUkFHRS5nZXRDbGFzc01hcCgpW3ZhbHVlLl9jbGFzc10pIHtcbiAgICAgICAgIGNvbnN0IE15Q2xhc3MgPSBTVE9SQUdFLmdldENsYXNzTWFwKClbdmFsdWUuX2NsYXNzXTtcbiAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gTXlDbGFzcy5Gcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgIGlmIChpbnN0YW5jZSA9PSBudWxsKSB1aS5zaG93RXJyb3JUb2FzdChuZXcgRXJyb3IoXCJlcnJvciBsb2FkaW5nIFwiICsga2V5KSk7XG4gICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICB9LFxuXG4gICByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlPy5zdHJpbmdpZnkgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlLnN0cmluZ2lmeSgpIDogdmFsdWU7XG4gICB9LFxuXG4gICBnZXRTYXZlU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgIFZFUlNJT04gK1xuICAgICAgICAgXCI7XCIgK1xuICAgICAgICAgSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICB0cmFja3M6IFRyYWNrLmFsbFRyYWNrcyxcbiAgICAgICAgICAgICAgIHRyYWluczogVHJhaW4uYWxsVHJhaW5zLFxuICAgICAgICAgICAgICAgc3dpdGNoZXM6IFN3aXRjaC5hbGxTd2l0Y2hlcyxcbiAgICAgICAgICAgICAgIG9iamVjdHM6IEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMsXG4gICAgICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICAgICAgem9vbTogd2luZG93LnN0YWdlLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgc2Nyb2xsWDogd2luZG93LnN0YWdlLngsXG4gICAgICAgICAgICAgICAgICBzY3JvbGxZOiB3aW5kb3cuc3RhZ2UueSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiB3aW5kb3cucmVuZGVyZXIgaW5zdGFuY2VvZiB3aW5kb3cudHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQgPyBcInRleHR1cmVkXCIgOiBcImJhc2ljXCIsXG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNUT1JBR0UucmVwbGFjZXJcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9LFxuXG4gICByZXN0b3JlTGFzdFVuZG9TdGVwKCkge1xuICAgICAgaWYgKHdpbmRvdy51bmRvSGlzdG9yeS5sZW5ndGggPD0gMSkgcmV0dXJuO1xuICAgICAgd2luZG93LnVuZG9IaXN0b3J5LnBvcCgpO1xuICAgICAgY29uc3QgbGFzdCA9IEFycmF5VXRpbHMubGFzdCh3aW5kb3cudW5kb0hpc3RvcnkpO1xuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgIFNUT1JBR0UubG9hZEZyb21Kc29uKGxhc3QpO1xuICAgICAgfSBlbHNlIFRyYWNrLmFsbFRyYWNrcyA9IFtdO1xuXG4gICAgICB3aW5kb3cudXBkYXRlVW5kb0J1dHRvblN0YXRlKCk7XG4gICB9LFxuXG4gICBsaW5rT2JqZWN0cygpIHtcbiAgICAgIC8vIExpbmsgc3dpdGNoZXMgdG8gdHJhY2tzXG4gICAgICBTd2l0Y2guYWxsU3dpdGNoZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgaWYgKHMudHJhY2tzX2lkKSB7XG4gICAgICAgICAgICBzLnRyYWNrcyA9IHMudHJhY2tzX2lkLm1hcCgoaWQpID0+IChpZCA/IFRyYWNrLmFsbFRyYWNrcy5maW5kKCh0KSA9PiB0LmlkID09PSBpZCkgOiBudWxsKSk7XG4gICAgICAgICB9XG4gICAgICAgICBzLmJyYW5jaCA9IHMuYnJhbmNoX2lkID8gVHJhY2suYWxsVHJhY2tzLmZpbmQoKHQpID0+IHQuaWQgPT09IHMuYnJhbmNoX2lkKSA6IG51bGw7XG4gICAgICAgICBzLmZyb20gPSBzLmZyb21faWQgPyBUcmFjay5hbGxUcmFja3MuZmluZCgodCkgPT4gdC5pZCA9PT0gcy5mcm9tX2lkKSA6IG51bGw7XG4gICAgICAgICBzLmNhbGN1bGF0ZVBhcmFtZXRlcnMoKTtcbiAgICAgICAgIGRlbGV0ZSBzLnRyYWNrc19pZDtcbiAgICAgICAgIGRlbGV0ZSBzLmJyYW5jaF9pZDtcbiAgICAgICAgIGRlbGV0ZSBzLmZyb21faWQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gTGluayB0cmFja3MgdG8gc3dpdGNoZXMvb3RoZXIgdHJhY2tzXG4gICAgICBUcmFjay5hbGxUcmFja3MuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgdC5zd2l0Y2hlcyA9IHQuc3dpdGNoZXNfZGF0YS5tYXAoKHNkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChzZC50eXBlID09PSBcIlN3aXRjaFwiKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gU3dpdGNoLmFsbFN3aXRjaGVzLmZpbmQoKHMpID0+IHMuaWQgPT09IHNkLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gXCJUcmFja1wiKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gVHJhY2suYWxsVHJhY2tzLmZpbmQoKHRyKSA9PiB0ci5pZCA9PT0gc2QuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICB9KTtcbiAgICAgICAgIGRlbGV0ZSB0LnN3aXRjaGVzX2RhdGE7XG4gICAgICB9KTtcbiAgIH0sXG5cbiAgIGxvYWRGcm9tSnNvbihqc29uKSB7XG4gICAgICBSRU5ERVJJTkcuY2xlYXIoKTtcbiAgICAgIGxldCBsb2FkZWQgPSBKU09OLnBhcnNlKGpzb24sIFNUT1JBR0UucmVjZWl2ZXIpO1xuICAgICAgaWYgKGxvYWRlZC5zZXR0aW5ncykge1xuICAgICAgICAgd2luZG93LnN0YWdlLnggPSBsb2FkZWQuc2V0dGluZ3Muc2Nyb2xsWDtcbiAgICAgICAgIHdpbmRvdy5zdGFnZS55ID0gbG9hZGVkLnNldHRpbmdzLnNjcm9sbFk7XG4gICAgICAgICB3aW5kb3cuc3RhZ2Uuc2NhbGUgPSBsb2FkZWQuc2V0dGluZ3Muem9vbTtcbiAgICAgICAgIGlmIChsb2FkZWQuc2V0dGluZ3MucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZWxlY3RSZW5kZXJlcihsb2FkZWQuc2V0dGluZ3MucmVuZGVyZXIgPT09IFwidGV4dHVyZWRcIik7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG9hZGVkLm9iamVjdHMpIEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMgPSBsb2FkZWQub2JqZWN0cztcbiAgICAgIFRyYWNrLmFsbFRyYWNrcyA9IGxvYWRlZC50cmFja3MgPyBBcnJheVV0aWxzLmNsZWFuVXAobG9hZGVkLnRyYWNrcykgOiBbXTsgLy93aGVuIHNvbWV0aGluZyB3ZW50IHdyb250IHdoaWxlIGxvYWRpbmcgdHJhY2ssIHdlIGZpbHRlciBhbGwgbnVsbHNcbiAgICAgIFN3aXRjaC5hbGxTd2l0Y2hlcyA9IGxvYWRlZC5zd2l0Y2hlcyA/IEFycmF5VXRpbHMuY2xlYW5VcChsb2FkZWQuc3dpdGNoZXMpIDogW107IC8vd2hlbiBzb21ldGhpbmcgd2VudCB3cm9udCB3aGlsZSBsb2FkaW5nIHN3aXRjaCwgd2UgZmlsdGVyIGFsbCBudWxsc1xuXG4gICAgICAvLyBSZXNldCBjb3VudGVyc1xuICAgICAgVHJhY2suY291bnRlciA9IFRyYWNrLmFsbFRyYWNrcy5sZW5ndGggPyBNYXRoLm1heCguLi5UcmFjay5hbGxUcmFja3MubWFwKCh0KSA9PiB0LmlkKSkgKyAxIDogMDtcbiAgICAgIFN3aXRjaC5jb3VudGVyID0gU3dpdGNoLmFsbFN3aXRjaGVzLmxlbmd0aCA/IE1hdGgubWF4KC4uLlN3aXRjaC5hbGxTd2l0Y2hlcy5tYXAoKHMpID0+IHMuaWQpKSArIDEgOiAwO1xuXG4gICAgICBTVE9SQUdFLmxpbmtPYmplY3RzKCk7XG5cbiAgICAgIFRyYWNrLmNyZWF0ZVJhaWxOZXR3b3JrKCk7XG4gICAgICBUcmFpbi5hbGxUcmFpbnMgPSBsb2FkZWQudHJhaW5zID8gQXJyYXlVdGlscy5jbGVhblVwKGxvYWRlZC50cmFpbnMpIDogW107IC8vLy93aGVuIHNvbWV0aGluZyB3ZW50IHdyb250IHdoaWxlIGxvYWRpbmcgdHJhaW5zLCB3ZSBmaWx0ZXIgYWxsIG51bGxzXG4gICAgICBUcmFpbi5hbGxUcmFpbnMuZm9yRWFjaCgodCkgPT4gdC5yZXN0b3JlKCkpO1xuICAgICAgVHJhaW4uYWxsVHJhaW5zLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgIGRlbGV0ZSB0LnRyYWluQ291cGxlZEZyb250SWQ7XG4gICAgICAgICBkZWxldGUgdC50cmFpbkNvdXBsZWRCYWNrSWQ7XG4gICAgICB9KTtcbiAgICAgIFRyYWluLmFsbFRyYWlucyA9IFRyYWluLmFsbFRyYWlucy5maWx0ZXIoKHQpID0+IHQudHJhY2sgIT0gbnVsbCk7XG4gICB9LFxuXG4gICBzYXZlVW5kb0hpc3RvcnkoKSB7XG4gICAgICB3aW5kb3cudW5kb0hpc3RvcnkucHVzaChKU09OLnN0cmluZ2lmeSh7IHRyYWNrczogVHJhY2suYWxsVHJhY2tzLCBvYmplY3RzOiBHZW5lcmljT2JqZWN0LmFsbF9vYmplY3RzIH0sIFNUT1JBR0UucmVwbGFjZXIpKTtcbiAgICAgIGlmICh3aW5kb3cudW5kb0hpc3RvcnkubGVuZ3RoID4gd2luZG93Lk1PU1RfVU5ETykgd2luZG93LnVuZG9IaXN0b3J5LnNoaWZ0KCk7XG5cbiAgICAgIHdpbmRvdy51cGRhdGVVbmRvQnV0dG9uU3RhdGUoKTtcbiAgIH0sXG5cbiAgIHNhdmUoKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFLlNUT1JBR0VfSURFTlQsIFNUT1JBR0UuZ2V0U2F2ZVN0cmluZygpKTtcbiAgIH0sXG5cbiAgIGxvYWRSZWNlbnQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgY29uc3QgeCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0UuU1RPUkFHRV9JREVOVCk7XG4gICAgICAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleE9mRmlyc3QgPSB4LmluZGV4T2YoXCI7XCIpO1xuICAgICAgICAgICAgaWYgKGluZGV4T2ZGaXJzdCA+IC0xKSB7XG4gICAgICAgICAgICAgICBjb25zdCBsb2FkZWRfdmVyc2lvbiA9IHBhcnNlRmxvYXQoeC5zdWJzdHJpbmcoMCwgaW5kZXhPZkZpcnN0KSk7XG4gICAgICAgICAgICAgICBpZiAobG9hZGVkX3ZlcnNpb24gPj0gU1RPUkFHRS5NSU5fU1RPUkFHRV9WRVJTSU9OKSBTVE9SQUdFLmxvYWRGcm9tSnNvbih4LnNsaWNlKGluZGV4T2ZGaXJzdCArIDEpKTtcbiAgICAgICAgICAgICAgIGVsc2UgY29uc29sZS5lcnJvcihgc3RvcmVkIHZlcnNpb24gJHtsb2FkZWRfdmVyc2lvbn0gdG8gb2xkYCk7XG4gICAgICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBUYWcgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgdWkuc2hvd0Vycm9yVG9hc3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgd2luZG93LnVwZGF0ZVVuZG9CdXR0b25TdGF0ZSgpO1xuICAgfSxcblxuICAgbG9hZFByZWJ1aWxkYnlOYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICBsZXQgeG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgeG1saHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgIGxldCB4bWxEb2MgPSB0aGlzLnJlc3BvbnNlWE1MO1xuXG4gICAgICAgICAgICAgICBsZXQgeCA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNldHVwXCIpO1xuICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICh4W2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGl0bGVcIilbMF0udGV4dENvbnRlbnQgPT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgU1RPUkFHRS5sb2FkRnJvbUpzb24oeFtpXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImpzb25cIilbMF0uY2hpbGROb2Rlc1swXS53aG9sZVRleHQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH07XG4gICAgICAgICB4bWxodHRwLm9wZW4oXCJHRVRcIiwgXCJwcmVidWlsZHMueG1sXCIgKyBcIj9cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCksIHRydWUpO1xuICAgICAgICAgeG1saHR0cC5zZW5kKCk7XG4gICAgICB9KTtcbiAgIH0sXG59O1xuXG4gIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/storage.js\n\n}");

/***/ }),

/***/ "./www/code/switch.js":
/*!****************************!*\
  !*** ./www/code/switch.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Switch: () => (/* binding */ Switch)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n\n\n// ES6 Module imports\n\n\n\n\nclass Switch {\n   static allSwitches = [];\n   static counter = 0;\n\n   static _getID() {\n      return Switch.counter++;\n   }\n\n   static SWITCH_TYPE = {\n      NONE: 0,\n      TO_RIGHT: 1, //45°\n      FROM_RIGHT: 2, //135°\n      FROM_LEFT: 3, //225°\n      TO_LEFT: 4, //315°\n      DKW: 9,\n      CROSSING: 10,\n   };\n\n   //sw=switch location\n   //rad= angle of track_1 in rad\n   //c= end of the track_2 to find angle\n   static findAngle(sw, c, rad = 0) {\n      let atan = Math.atan2(c.y - sw.y, c.x - sw.x) - rad;\n      if (atan < 0) atan += 2 * Math.PI; //macht aus neg Winkeln durch addition von 360° positive winkel\n\n      let val = (atan * 180) / Math.PI;\n      return val;\n   }\n\n   /**\n    * Validates if a switch at a given location is valid based on the provided tracks.\n    *\n    * @param {Object} location - The location to check for a valid switch.\n    * @param {Array} tracks - An array of track objects, each containing nodes with start and end points.\n    * @returns {boolean} - Returns true if the switch is valid, otherwise false.\n    */\n   static isValidSwitch(location, tracks) {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.between(tracks.length, 3, 4)) {\n         console.log(`too many nodes ${tracks.length}`);\n         return false;\n      }\n      const slopes = tracks.map((t) => t.slope);\n      const equal_slopes = _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.countNonUnique(slopes);\n      if (!((tracks.length == 3 && equal_slopes == 1) || (tracks.length == 4 && equal_slopes == 2))) {\n         console.log(`2 tracks with the same slope are necessary`);\n         return false;\n      }\n\n      for (let i = 1; i < slopes.length; i++) {\n         if (Math.abs(slopes[i - 1] - slopes[i]) > 1) {\n            console.log(`slope between 2 tracks must be lower than 45°`);\n            return false;\n         }\n      }\n      return true;\n   }\n   /**\n    * Creates a switch object based on the provided location and tracks.\n    *\n    * @param {Object} location - The location of the switch.\n    * @param {Array} tracks - An array of track objects.\n    * @returns {Object} The created switch object.\n    * @throws {Error} If the tracks do not have 2 different angles.\n    */\n   static createSwitch(location, tracks) {\n      const sw = new Switch(location);\n\n      const left_tracks = tracks.filter((t) => t.end.equals(location)).sort((a, b) => b.slope - a.slope);\n      const right_tracks = tracks.filter((t) => t.start.equals(location)).sort((a, b) => b.slope - a.slope);\n      let rad = 0;\n\n      if (left_tracks.length == 1) {\n         sw.track1 = left_tracks[0];\n         rad = sw.track1.rad;\n         sw.track2 = right_tracks.find((t) => t.rad == rad);\n      } else {\n         sw.track1 = right_tracks[0];\n         rad = sw.track1.rad;\n         sw.track2 = left_tracks.find((t) => t.rad == rad);\n      }\n\n      if (sw.track2 == null) throw new Error(\"couldnt find 2 tracks with the same slope\");\n\n      //find the other two tracks and sort them by their start point\n      [sw.track3, sw.track4] = tracks\n         .filter((t) => t != sw.track1 && t != sw.track2)\n         .sort((a, b) => a.start.x - b.start.x);\n\n      // Calculate direction vectors for each track branch\n      sw.calculateParameters();\n\n      //TODO calculate connection points and shorten the tracks\n\n      sw.branch = sw.track2;\n      sw.from = sw.track1;\n\n      return sw;\n   }\n\n   /**\n    * Checks for and creates/updates a switch at a specific point in the track network.\n    * This function encapsulates the logic for determining if a point is a simple connection,\n    * a valid switch, or an invalid connection, and performs the necessary updates.\n    * @param {Point} point - The connection point to check.\n    * @param {Switch} [existingSwitch=null] - An optional, pre-existing switch to re-evaluate.\n    */\n   static updateSwitchAtPoint(point, existingSwitch = null) {\n      const tracksAtPoint = _track_js__WEBPACK_IMPORTED_MODULE_1__.Track.allTracks.filter(\n         (t) => t.start.equals(point) || t.end.equals(point)\n      );\n\n      if (!existingSwitch) {\n         existingSwitch = Switch.allSwitches.find(sw => sw.location.equals(point));\n      }else{\n         if(!existingSwitch.location.equals(point)) throw new Error(\"existing switch at wrong point\");\n      }\n\n      if (tracksAtPoint.length === 2) {\n         // Simple connection, not a switch.\n         const track1 = tracksAtPoint[0];\n         const track2 = tracksAtPoint[1];\n\n         if (track1.start.equals(point)) track1.switchAtTheStart = track2;\n         else track1.switchAtTheEnd = track2;\n         \n         if (track2.start.equals(point)) track2.switchAtTheStart = track1;\n         else track2.switchAtTheEnd = track1;\n\n         if (existingSwitch) {\n            Switch.removeSwitch(existingSwitch);\n         }\n      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.between(tracksAtPoint.length, 3, 4)) {\n         // Potential switch.\n         if (Switch.isValidSwitch(point, tracksAtPoint)) {\n            if (existingSwitch) {\n               const existingTracks = [\n                  existingSwitch.track1,\n                  existingSwitch.track2,\n                  existingSwitch.track3,\n                  existingSwitch.track4,\n               ].filter((t) => t);\n               const tracksMatch =\n                  existingTracks.length === tracksAtPoint.length &&\n                  existingTracks.every((existingTrack) =>\n                     tracksAtPoint.some((currentTrack) => currentTrack === existingTrack)\n                  );\n\n               if (!tracksMatch) {\n                  Switch.removeSwitch(existingSwitch);\n                  const sw = Switch.createSwitch(point, tracksAtPoint);\n                  [sw.track1, sw.track2, sw.track3, sw.track4].forEach((track) => track && track.addSwitch(sw));\n                  Switch.allSwitches.push(sw);\n               }\n            } else {\n               const sw = Switch.createSwitch(point, tracksAtPoint);\n               [sw.track1, sw.track2, sw.track3, sw.track4].forEach((track) => track && track.addSwitch(sw));\n               Switch.allSwitches.push(sw);\n            }\n         } else if (existingSwitch) {\n            Switch.removeSwitch(existingSwitch);\n         }\n      } else if (existingSwitch) {\n         // Any other configuration is not a switch, so remove if one exists.\n         Switch.removeSwitch(existingSwitch);\n      }\n   }\n\n   /**\n    * Removes a switch and cleans up all references to it\n    * @param {Switch} switchToRemove - The switch to remove\n    */\n   static removeSwitch(switchToRemove) {\n      // Remove switch from all tracks that reference it\n      [switchToRemove.track1, switchToRemove.track2, switchToRemove.track3, switchToRemove.track4].forEach(\n         (track) => {\n            if (track) {\n               track.switches = track.switches.map((sw) => (sw === switchToRemove ? null : sw));\n            }\n         }\n      );\n\n      // Remove switch from the global switches array\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.remove(Switch.allSwitches, switchToRemove);\n   }\n\n   static switch_A_Switch(sw, mouseX) {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.is(sw.type, Switch.SWITCH_TYPE.DKW)) {\n         sw.branch = (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.swap)(sw.branch, sw.track2, sw.track3);\n      } else {\n         if (mouseX < sw.location.x) {\n            sw.branch = (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.swap)(sw.branch, sw.track2, sw.track3);\n         } else {\n            sw.from = (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.swap)(sw.from, sw.track1, sw.track4);\n         }\n      }\n   }\n\n   constructor(location) {\n      this.id = Switch._getID();\n      this.location = location;\n      this.type = Switch.SWITCH_TYPE.NONE;\n\n      this.size = window.GRID_SIZE;\n\n      this.tracks = new Array(4).fill(null);\n\n      this.branch = null;\n      this.from = null;\n\n      // Direction information for rendering - stores the direction vector for each track\n      this.track_directions = new Array(4);\n   }\n\n   get track1() {\n      return this.tracks[0];\n   }\n   set track1(track) {\n      this.tracks[0] = track;\n   }\n   get track2() {\n      return this.tracks[1];\n   }\n   set track2(track) {\n      this.tracks[1] = track;\n   }\n   get track3() {\n      return this.tracks[2];\n   }\n   set track3(track) {\n      this.tracks[2] = track;\n   }\n   get track4() {\n      return this.tracks[3];\n   }\n   set track4(track) {\n      this.tracks[3] = track;\n   }\n\n   /**\n    * Calculates the direction vectors for each track branch\n    * This eliminates the need for runtime direction calculations during rendering\n    */\n   calculateParameters() {\n      // For each track, determine if it connects to the switch at its start or end\n      // and use the appropriate direction (unit vector or its opposite)\n\n      this.track_directions = this.tracks.map((track) =>\n         track ? (track.end.equals(this.location) ? _tools_js__WEBPACK_IMPORTED_MODULE_2__.V2.fromV2(track.unit).invert() : _tools_js__WEBPACK_IMPORTED_MODULE_2__.V2.fromV2(track.unit)) : null\n      );\n\n      if (this.track4) this.type = Switch.SWITCH_TYPE.DKW;\n      else {\n         const angle = Switch.findAngle(this.location, this.track3.end.equals(this.location) ? this.track3.start : this.track3.end, this.track1.rad);\n         this.type = Math.ceil((angle % 360) / 90);\n      }\n\n   }\n\n   /**\n    * Replaces all references to an old track with a new track within this switch.\n    * @param {Track} oldTrack - The track to be replaced.\n    * @param {Track} newTrack - The new track to reference.\n    */\n   replaceTrackReference(oldTrack, newTrack) {\n      if (this.track1 === oldTrack) this.track1 = newTrack;\n      if (this.track2 === oldTrack) this.track2 = newTrack;\n      if (this.track3 === oldTrack) this.track3 = newTrack;\n      if (this.track4 === oldTrack) this.track4 = newTrack;\n\n      if (this.branch === oldTrack) this.branch = newTrack;\n      if (this.from === oldTrack) this.from = newTrack;\n\n      // After updating track references, it's crucial to recalculate the directions\n      // for rendering and other logic.\n      this.calculateParameters();\n   }\n\n   getBranchEndPoint(branch, size = this.size) {\n      return this.location.add(this.track_directions[branch].multiply(size));\n   }\n\n   stringify() {\n      return {\n         _class: \"Switch\",\n         id: this.id,\n         location: this.location,\n         tracks: this.tracks.map((t) => t?.id),\n         branch: this.branch?.id,\n         from: this.from?.id,\n      };\n   }\n\n   static FromObject(o) {\n      const s = new Switch(_tools_js__WEBPACK_IMPORTED_MODULE_2__.Point.fromPoint(o.location));\n      s.id = o.id;\n\n      // Store IDs for later linking\n      s.tracks_id = o.tracks;\n      s.branch_id = o.branch;\n      s.from_id = o.from;\n\n      return s;\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3N3aXRjaC5qcz82YjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IE51bWJlclV0aWxzLCBBcnJheVV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vdHJhY2suanMnO1xuaW1wb3J0IHsgVjIsIFBvaW50LCBnZW9tZXRyeSwgdHlwZSwgc3dhcCB9IGZyb20gJy4vdG9vbHMuanMnO1xuXG5leHBvcnQgY2xhc3MgU3dpdGNoIHtcbiAgIHN0YXRpYyBhbGxTd2l0Y2hlcyA9IFtdO1xuICAgc3RhdGljIGNvdW50ZXIgPSAwO1xuXG4gICBzdGF0aWMgX2dldElEKCkge1xuICAgICAgcmV0dXJuIFN3aXRjaC5jb3VudGVyKys7XG4gICB9XG5cbiAgIHN0YXRpYyBTV0lUQ0hfVFlQRSA9IHtcbiAgICAgIE5PTkU6IDAsXG4gICAgICBUT19SSUdIVDogMSwgLy80NcKwXG4gICAgICBGUk9NX1JJR0hUOiAyLCAvLzEzNcKwXG4gICAgICBGUk9NX0xFRlQ6IDMsIC8vMjI1wrBcbiAgICAgIFRPX0xFRlQ6IDQsIC8vMzE1wrBcbiAgICAgIERLVzogOSxcbiAgICAgIENST1NTSU5HOiAxMCxcbiAgIH07XG5cbiAgIC8vc3c9c3dpdGNoIGxvY2F0aW9uXG4gICAvL3JhZD0gYW5nbGUgb2YgdHJhY2tfMSBpbiByYWRcbiAgIC8vYz0gZW5kIG9mIHRoZSB0cmFja18yIHRvIGZpbmQgYW5nbGVcbiAgIHN0YXRpYyBmaW5kQW5nbGUoc3csIGMsIHJhZCA9IDApIHtcbiAgICAgIGxldCBhdGFuID0gTWF0aC5hdGFuMihjLnkgLSBzdy55LCBjLnggLSBzdy54KSAtIHJhZDtcbiAgICAgIGlmIChhdGFuIDwgMCkgYXRhbiArPSAyICogTWF0aC5QSTsgLy9tYWNodCBhdXMgbmVnIFdpbmtlbG4gZHVyY2ggYWRkaXRpb24gdm9uIDM2MMKwIHBvc2l0aXZlIHdpbmtlbFxuXG4gICAgICBsZXQgdmFsID0gKGF0YW4gKiAxODApIC8gTWF0aC5QSTtcbiAgICAgIHJldHVybiB2YWw7XG4gICB9XG5cbiAgIC8qKlxuICAgICogVmFsaWRhdGVzIGlmIGEgc3dpdGNoIGF0IGEgZ2l2ZW4gbG9jYXRpb24gaXMgdmFsaWQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRyYWNrcy5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gY2hlY2sgZm9yIGEgdmFsaWQgc3dpdGNoLlxuICAgICogQHBhcmFtIHtBcnJheX0gdHJhY2tzIC0gQW4gYXJyYXkgb2YgdHJhY2sgb2JqZWN0cywgZWFjaCBjb250YWluaW5nIG5vZGVzIHdpdGggc3RhcnQgYW5kIGVuZCBwb2ludHMuXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHN3aXRjaCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICovXG4gICBzdGF0aWMgaXNWYWxpZFN3aXRjaChsb2NhdGlvbiwgdHJhY2tzKSB7XG4gICAgICBpZiAoIU51bWJlclV0aWxzLmJldHdlZW4odHJhY2tzLmxlbmd0aCwgMywgNCkpIHtcbiAgICAgICAgIGNvbnNvbGUubG9nKGB0b28gbWFueSBub2RlcyAke3RyYWNrcy5sZW5ndGh9YCk7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzbG9wZXMgPSB0cmFja3MubWFwKCh0KSA9PiB0LnNsb3BlKTtcbiAgICAgIGNvbnN0IGVxdWFsX3Nsb3BlcyA9IEFycmF5VXRpbHMuY291bnROb25VbmlxdWUoc2xvcGVzKTtcbiAgICAgIGlmICghKCh0cmFja3MubGVuZ3RoID09IDMgJiYgZXF1YWxfc2xvcGVzID09IDEpIHx8ICh0cmFja3MubGVuZ3RoID09IDQgJiYgZXF1YWxfc2xvcGVzID09IDIpKSkge1xuICAgICAgICAgY29uc29sZS5sb2coYDIgdHJhY2tzIHdpdGggdGhlIHNhbWUgc2xvcGUgYXJlIG5lY2Vzc2FyeWApO1xuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNsb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgaWYgKE1hdGguYWJzKHNsb3Blc1tpIC0gMV0gLSBzbG9wZXNbaV0pID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHNsb3BlIGJldHdlZW4gMiB0cmFja3MgbXVzdCBiZSBsb3dlciB0aGFuIDQ1wrBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgc3dpdGNoIG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb24gYW5kIHRyYWNrcy5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gb2YgdGhlIHN3aXRjaC5cbiAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYWNrcyAtIEFuIGFycmF5IG9mIHRyYWNrIG9iamVjdHMuXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3JlYXRlZCBzd2l0Y2ggb2JqZWN0LlxuICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0cmFja3MgZG8gbm90IGhhdmUgMiBkaWZmZXJlbnQgYW5nbGVzLlxuICAgICovXG4gICBzdGF0aWMgY3JlYXRlU3dpdGNoKGxvY2F0aW9uLCB0cmFja3MpIHtcbiAgICAgIGNvbnN0IHN3ID0gbmV3IFN3aXRjaChsb2NhdGlvbik7XG5cbiAgICAgIGNvbnN0IGxlZnRfdHJhY2tzID0gdHJhY2tzLmZpbHRlcigodCkgPT4gdC5lbmQuZXF1YWxzKGxvY2F0aW9uKSkuc29ydCgoYSwgYikgPT4gYi5zbG9wZSAtIGEuc2xvcGUpO1xuICAgICAgY29uc3QgcmlnaHRfdHJhY2tzID0gdHJhY2tzLmZpbHRlcigodCkgPT4gdC5zdGFydC5lcXVhbHMobG9jYXRpb24pKS5zb3J0KChhLCBiKSA9PiBiLnNsb3BlIC0gYS5zbG9wZSk7XG4gICAgICBsZXQgcmFkID0gMDtcblxuICAgICAgaWYgKGxlZnRfdHJhY2tzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICBzdy50cmFjazEgPSBsZWZ0X3RyYWNrc1swXTtcbiAgICAgICAgIHJhZCA9IHN3LnRyYWNrMS5yYWQ7XG4gICAgICAgICBzdy50cmFjazIgPSByaWdodF90cmFja3MuZmluZCgodCkgPT4gdC5yYWQgPT0gcmFkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBzdy50cmFjazEgPSByaWdodF90cmFja3NbMF07XG4gICAgICAgICByYWQgPSBzdy50cmFjazEucmFkO1xuICAgICAgICAgc3cudHJhY2syID0gbGVmdF90cmFja3MuZmluZCgodCkgPT4gdC5yYWQgPT0gcmFkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN3LnRyYWNrMiA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG50IGZpbmQgMiB0cmFja3Mgd2l0aCB0aGUgc2FtZSBzbG9wZVwiKTtcblxuICAgICAgLy9maW5kIHRoZSBvdGhlciB0d28gdHJhY2tzIGFuZCBzb3J0IHRoZW0gYnkgdGhlaXIgc3RhcnQgcG9pbnRcbiAgICAgIFtzdy50cmFjazMsIHN3LnRyYWNrNF0gPSB0cmFja3NcbiAgICAgICAgIC5maWx0ZXIoKHQpID0+IHQgIT0gc3cudHJhY2sxICYmIHQgIT0gc3cudHJhY2syKVxuICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQueCAtIGIuc3RhcnQueCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBkaXJlY3Rpb24gdmVjdG9ycyBmb3IgZWFjaCB0cmFjayBicmFuY2hcbiAgICAgIHN3LmNhbGN1bGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgLy9UT0RPIGNhbGN1bGF0ZSBjb25uZWN0aW9uIHBvaW50cyBhbmQgc2hvcnRlbiB0aGUgdHJhY2tzXG5cbiAgICAgIHN3LmJyYW5jaCA9IHN3LnRyYWNrMjtcbiAgICAgIHN3LmZyb20gPSBzdy50cmFjazE7XG5cbiAgICAgIHJldHVybiBzdztcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGVja3MgZm9yIGFuZCBjcmVhdGVzL3VwZGF0ZXMgYSBzd2l0Y2ggYXQgYSBzcGVjaWZpYyBwb2ludCBpbiB0aGUgdHJhY2sgbmV0d29yay5cbiAgICAqIFRoaXMgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIHRoZSBsb2dpYyBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBwb2ludCBpcyBhIHNpbXBsZSBjb25uZWN0aW9uLFxuICAgICogYSB2YWxpZCBzd2l0Y2gsIG9yIGFuIGludmFsaWQgY29ubmVjdGlvbiwgYW5kIHBlcmZvcm1zIHRoZSBuZWNlc3NhcnkgdXBkYXRlcy5cbiAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIGNvbm5lY3Rpb24gcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0ge1N3aXRjaH0gW2V4aXN0aW5nU3dpdGNoPW51bGxdIC0gQW4gb3B0aW9uYWwsIHByZS1leGlzdGluZyBzd2l0Y2ggdG8gcmUtZXZhbHVhdGUuXG4gICAgKi9cbiAgIHN0YXRpYyB1cGRhdGVTd2l0Y2hBdFBvaW50KHBvaW50LCBleGlzdGluZ1N3aXRjaCA9IG51bGwpIHtcbiAgICAgIGNvbnN0IHRyYWNrc0F0UG9pbnQgPSBUcmFjay5hbGxUcmFja3MuZmlsdGVyKFxuICAgICAgICAgKHQpID0+IHQuc3RhcnQuZXF1YWxzKHBvaW50KSB8fCB0LmVuZC5lcXVhbHMocG9pbnQpXG4gICAgICApO1xuXG4gICAgICBpZiAoIWV4aXN0aW5nU3dpdGNoKSB7XG4gICAgICAgICBleGlzdGluZ1N3aXRjaCA9IFN3aXRjaC5hbGxTd2l0Y2hlcy5maW5kKHN3ID0+IHN3LmxvY2F0aW9uLmVxdWFscyhwb2ludCkpO1xuICAgICAgfWVsc2V7XG4gICAgICAgICBpZighZXhpc3RpbmdTd2l0Y2gubG9jYXRpb24uZXF1YWxzKHBvaW50KSkgdGhyb3cgbmV3IEVycm9yKFwiZXhpc3Rpbmcgc3dpdGNoIGF0IHdyb25nIHBvaW50XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2tzQXRQb2ludC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgIC8vIFNpbXBsZSBjb25uZWN0aW9uLCBub3QgYSBzd2l0Y2guXG4gICAgICAgICBjb25zdCB0cmFjazEgPSB0cmFja3NBdFBvaW50WzBdO1xuICAgICAgICAgY29uc3QgdHJhY2syID0gdHJhY2tzQXRQb2ludFsxXTtcblxuICAgICAgICAgaWYgKHRyYWNrMS5zdGFydC5lcXVhbHMocG9pbnQpKSB0cmFjazEuc3dpdGNoQXRUaGVTdGFydCA9IHRyYWNrMjtcbiAgICAgICAgIGVsc2UgdHJhY2sxLnN3aXRjaEF0VGhlRW5kID0gdHJhY2syO1xuICAgICAgICAgXG4gICAgICAgICBpZiAodHJhY2syLnN0YXJ0LmVxdWFscyhwb2ludCkpIHRyYWNrMi5zd2l0Y2hBdFRoZVN0YXJ0ID0gdHJhY2sxO1xuICAgICAgICAgZWxzZSB0cmFjazIuc3dpdGNoQXRUaGVFbmQgPSB0cmFjazE7XG5cbiAgICAgICAgIGlmIChleGlzdGluZ1N3aXRjaCkge1xuICAgICAgICAgICAgU3dpdGNoLnJlbW92ZVN3aXRjaChleGlzdGluZ1N3aXRjaCk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE51bWJlclV0aWxzLmJldHdlZW4odHJhY2tzQXRQb2ludC5sZW5ndGgsIDMsIDQpKSB7XG4gICAgICAgICAvLyBQb3RlbnRpYWwgc3dpdGNoLlxuICAgICAgICAgaWYgKFN3aXRjaC5pc1ZhbGlkU3dpdGNoKHBvaW50LCB0cmFja3NBdFBvaW50KSkge1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3dpdGNoKSB7XG4gICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RyYWNrcyA9IFtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3dpdGNoLnRyYWNrMSxcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3dpdGNoLnRyYWNrMixcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3dpdGNoLnRyYWNrMyxcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3dpdGNoLnRyYWNrNCxcbiAgICAgICAgICAgICAgIF0uZmlsdGVyKCh0KSA9PiB0KTtcbiAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrc01hdGNoID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVHJhY2tzLmxlbmd0aCA9PT0gdHJhY2tzQXRQb2ludC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVHJhY2tzLmV2ZXJ5KChleGlzdGluZ1RyYWNrKSA9PlxuICAgICAgICAgICAgICAgICAgICAgdHJhY2tzQXRQb2ludC5zb21lKChjdXJyZW50VHJhY2spID0+IGN1cnJlbnRUcmFjayA9PT0gZXhpc3RpbmdUcmFjaylcbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgIGlmICghdHJhY2tzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIFN3aXRjaC5yZW1vdmVTd2l0Y2goZXhpc3RpbmdTd2l0Y2gpO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3cgPSBTd2l0Y2guY3JlYXRlU3dpdGNoKHBvaW50LCB0cmFja3NBdFBvaW50KTtcbiAgICAgICAgICAgICAgICAgIFtzdy50cmFjazEsIHN3LnRyYWNrMiwgc3cudHJhY2szLCBzdy50cmFjazRdLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjayAmJiB0cmFjay5hZGRTd2l0Y2goc3cpKTtcbiAgICAgICAgICAgICAgICAgIFN3aXRjaC5hbGxTd2l0Y2hlcy5wdXNoKHN3KTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBjb25zdCBzdyA9IFN3aXRjaC5jcmVhdGVTd2l0Y2gocG9pbnQsIHRyYWNrc0F0UG9pbnQpO1xuICAgICAgICAgICAgICAgW3N3LnRyYWNrMSwgc3cudHJhY2syLCBzdy50cmFjazMsIHN3LnRyYWNrNF0uZm9yRWFjaCgodHJhY2spID0+IHRyYWNrICYmIHRyYWNrLmFkZFN3aXRjaChzdykpO1xuICAgICAgICAgICAgICAgU3dpdGNoLmFsbFN3aXRjaGVzLnB1c2goc3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1N3aXRjaCkge1xuICAgICAgICAgICAgU3dpdGNoLnJlbW92ZVN3aXRjaChleGlzdGluZ1N3aXRjaCk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU3dpdGNoKSB7XG4gICAgICAgICAvLyBBbnkgb3RoZXIgY29uZmlndXJhdGlvbiBpcyBub3QgYSBzd2l0Y2gsIHNvIHJlbW92ZSBpZiBvbmUgZXhpc3RzLlxuICAgICAgICAgU3dpdGNoLnJlbW92ZVN3aXRjaChleGlzdGluZ1N3aXRjaCk7XG4gICAgICB9XG4gICB9XG5cbiAgIC8qKlxuICAgICogUmVtb3ZlcyBhIHN3aXRjaCBhbmQgY2xlYW5zIHVwIGFsbCByZWZlcmVuY2VzIHRvIGl0XG4gICAgKiBAcGFyYW0ge1N3aXRjaH0gc3dpdGNoVG9SZW1vdmUgLSBUaGUgc3dpdGNoIHRvIHJlbW92ZVxuICAgICovXG4gICBzdGF0aWMgcmVtb3ZlU3dpdGNoKHN3aXRjaFRvUmVtb3ZlKSB7XG4gICAgICAvLyBSZW1vdmUgc3dpdGNoIGZyb20gYWxsIHRyYWNrcyB0aGF0IHJlZmVyZW5jZSBpdFxuICAgICAgW3N3aXRjaFRvUmVtb3ZlLnRyYWNrMSwgc3dpdGNoVG9SZW1vdmUudHJhY2syLCBzd2l0Y2hUb1JlbW92ZS50cmFjazMsIHN3aXRjaFRvUmVtb3ZlLnRyYWNrNF0uZm9yRWFjaChcbiAgICAgICAgICh0cmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICB0cmFjay5zd2l0Y2hlcyA9IHRyYWNrLnN3aXRjaGVzLm1hcCgoc3cpID0+IChzdyA9PT0gc3dpdGNoVG9SZW1vdmUgPyBudWxsIDogc3cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIFJlbW92ZSBzd2l0Y2ggZnJvbSB0aGUgZ2xvYmFsIHN3aXRjaGVzIGFycmF5XG4gICAgICBBcnJheVV0aWxzLnJlbW92ZShTd2l0Y2guYWxsU3dpdGNoZXMsIHN3aXRjaFRvUmVtb3ZlKTtcbiAgIH1cblxuICAgc3RhdGljIHN3aXRjaF9BX1N3aXRjaChzdywgbW91c2VYKSB7XG4gICAgICBpZiAoIU51bWJlclV0aWxzLmlzKHN3LnR5cGUsIFN3aXRjaC5TV0lUQ0hfVFlQRS5ES1cpKSB7XG4gICAgICAgICBzdy5icmFuY2ggPSBzd2FwKHN3LmJyYW5jaCwgc3cudHJhY2syLCBzdy50cmFjazMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGlmIChtb3VzZVggPCBzdy5sb2NhdGlvbi54KSB7XG4gICAgICAgICAgICBzdy5icmFuY2ggPSBzd2FwKHN3LmJyYW5jaCwgc3cudHJhY2syLCBzdy50cmFjazMpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3LmZyb20gPSBzd2FwKHN3LmZyb20sIHN3LnRyYWNrMSwgc3cudHJhY2s0KTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgY29uc3RydWN0b3IobG9jYXRpb24pIHtcbiAgICAgIHRoaXMuaWQgPSBTd2l0Y2guX2dldElEKCk7XG4gICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICB0aGlzLnR5cGUgPSBTd2l0Y2guU1dJVENIX1RZUEUuTk9ORTtcblxuICAgICAgdGhpcy5zaXplID0gd2luZG93LkdSSURfU0laRTtcblxuICAgICAgdGhpcy50cmFja3MgPSBuZXcgQXJyYXkoNCkuZmlsbChudWxsKTtcblxuICAgICAgdGhpcy5icmFuY2ggPSBudWxsO1xuICAgICAgdGhpcy5mcm9tID0gbnVsbDtcblxuICAgICAgLy8gRGlyZWN0aW9uIGluZm9ybWF0aW9uIGZvciByZW5kZXJpbmcgLSBzdG9yZXMgdGhlIGRpcmVjdGlvbiB2ZWN0b3IgZm9yIGVhY2ggdHJhY2tcbiAgICAgIHRoaXMudHJhY2tfZGlyZWN0aW9ucyA9IG5ldyBBcnJheSg0KTtcbiAgIH1cblxuICAgZ2V0IHRyYWNrMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc1swXTtcbiAgIH1cbiAgIHNldCB0cmFjazEodHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2tzWzBdID0gdHJhY2s7XG4gICB9XG4gICBnZXQgdHJhY2syKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzWzFdO1xuICAgfVxuICAgc2V0IHRyYWNrMih0cmFjaykge1xuICAgICAgdGhpcy50cmFja3NbMV0gPSB0cmFjaztcbiAgIH1cbiAgIGdldCB0cmFjazMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja3NbMl07XG4gICB9XG4gICBzZXQgdHJhY2szKHRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrc1syXSA9IHRyYWNrO1xuICAgfVxuICAgZ2V0IHRyYWNrNCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc1szXTtcbiAgIH1cbiAgIHNldCB0cmFjazQodHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2tzWzNdID0gdHJhY2s7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2FsY3VsYXRlcyB0aGUgZGlyZWN0aW9uIHZlY3RvcnMgZm9yIGVhY2ggdHJhY2sgYnJhbmNoXG4gICAgKiBUaGlzIGVsaW1pbmF0ZXMgdGhlIG5lZWQgZm9yIHJ1bnRpbWUgZGlyZWN0aW9uIGNhbGN1bGF0aW9ucyBkdXJpbmcgcmVuZGVyaW5nXG4gICAgKi9cbiAgIGNhbGN1bGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgICAvLyBGb3IgZWFjaCB0cmFjaywgZGV0ZXJtaW5lIGlmIGl0IGNvbm5lY3RzIHRvIHRoZSBzd2l0Y2ggYXQgaXRzIHN0YXJ0IG9yIGVuZFxuICAgICAgLy8gYW5kIHVzZSB0aGUgYXBwcm9wcmlhdGUgZGlyZWN0aW9uICh1bml0IHZlY3RvciBvciBpdHMgb3Bwb3NpdGUpXG5cbiAgICAgIHRoaXMudHJhY2tfZGlyZWN0aW9ucyA9IHRoaXMudHJhY2tzLm1hcCgodHJhY2spID0+XG4gICAgICAgICB0cmFjayA/ICh0cmFjay5lbmQuZXF1YWxzKHRoaXMubG9jYXRpb24pID8gVjIuZnJvbVYyKHRyYWNrLnVuaXQpLmludmVydCgpIDogVjIuZnJvbVYyKHRyYWNrLnVuaXQpKSA6IG51bGxcbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLnRyYWNrNCkgdGhpcy50eXBlID0gU3dpdGNoLlNXSVRDSF9UWVBFLkRLVztcbiAgICAgIGVsc2Uge1xuICAgICAgICAgY29uc3QgYW5nbGUgPSBTd2l0Y2guZmluZEFuZ2xlKHRoaXMubG9jYXRpb24sIHRoaXMudHJhY2szLmVuZC5lcXVhbHModGhpcy5sb2NhdGlvbikgPyB0aGlzLnRyYWNrMy5zdGFydCA6IHRoaXMudHJhY2szLmVuZCwgdGhpcy50cmFjazEucmFkKTtcbiAgICAgICAgIHRoaXMudHlwZSA9IE1hdGguY2VpbCgoYW5nbGUgJSAzNjApIC8gOTApO1xuICAgICAgfVxuXG4gICB9XG5cbiAgIC8qKlxuICAgICogUmVwbGFjZXMgYWxsIHJlZmVyZW5jZXMgdG8gYW4gb2xkIHRyYWNrIHdpdGggYSBuZXcgdHJhY2sgd2l0aGluIHRoaXMgc3dpdGNoLlxuICAgICogQHBhcmFtIHtUcmFja30gb2xkVHJhY2sgLSBUaGUgdHJhY2sgdG8gYmUgcmVwbGFjZWQuXG4gICAgKiBAcGFyYW0ge1RyYWNrfSBuZXdUcmFjayAtIFRoZSBuZXcgdHJhY2sgdG8gcmVmZXJlbmNlLlxuICAgICovXG4gICByZXBsYWNlVHJhY2tSZWZlcmVuY2Uob2xkVHJhY2ssIG5ld1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy50cmFjazEgPT09IG9sZFRyYWNrKSB0aGlzLnRyYWNrMSA9IG5ld1RyYWNrO1xuICAgICAgaWYgKHRoaXMudHJhY2syID09PSBvbGRUcmFjaykgdGhpcy50cmFjazIgPSBuZXdUcmFjaztcbiAgICAgIGlmICh0aGlzLnRyYWNrMyA9PT0gb2xkVHJhY2spIHRoaXMudHJhY2szID0gbmV3VHJhY2s7XG4gICAgICBpZiAodGhpcy50cmFjazQgPT09IG9sZFRyYWNrKSB0aGlzLnRyYWNrNCA9IG5ld1RyYWNrO1xuXG4gICAgICBpZiAodGhpcy5icmFuY2ggPT09IG9sZFRyYWNrKSB0aGlzLmJyYW5jaCA9IG5ld1RyYWNrO1xuICAgICAgaWYgKHRoaXMuZnJvbSA9PT0gb2xkVHJhY2spIHRoaXMuZnJvbSA9IG5ld1RyYWNrO1xuXG4gICAgICAvLyBBZnRlciB1cGRhdGluZyB0cmFjayByZWZlcmVuY2VzLCBpdCdzIGNydWNpYWwgdG8gcmVjYWxjdWxhdGUgdGhlIGRpcmVjdGlvbnNcbiAgICAgIC8vIGZvciByZW5kZXJpbmcgYW5kIG90aGVyIGxvZ2ljLlxuICAgICAgdGhpcy5jYWxjdWxhdGVQYXJhbWV0ZXJzKCk7XG4gICB9XG5cbiAgIGdldEJyYW5jaEVuZFBvaW50KGJyYW5jaCwgc2l6ZSA9IHRoaXMuc2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYWRkKHRoaXMudHJhY2tfZGlyZWN0aW9uc1ticmFuY2hdLm11bHRpcGx5KHNpemUpKTtcbiAgIH1cblxuICAgc3RyaW5naWZ5KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIF9jbGFzczogXCJTd2l0Y2hcIixcbiAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgbG9jYXRpb246IHRoaXMubG9jYXRpb24sXG4gICAgICAgICB0cmFja3M6IHRoaXMudHJhY2tzLm1hcCgodCkgPT4gdD8uaWQpLFxuICAgICAgICAgYnJhbmNoOiB0aGlzLmJyYW5jaD8uaWQsXG4gICAgICAgICBmcm9tOiB0aGlzLmZyb20/LmlkLFxuICAgICAgfTtcbiAgIH1cblxuICAgc3RhdGljIEZyb21PYmplY3Qobykge1xuICAgICAgY29uc3QgcyA9IG5ldyBTd2l0Y2goUG9pbnQuZnJvbVBvaW50KG8ubG9jYXRpb24pKTtcbiAgICAgIHMuaWQgPSBvLmlkO1xuXG4gICAgICAvLyBTdG9yZSBJRHMgZm9yIGxhdGVyIGxpbmtpbmdcbiAgICAgIHMudHJhY2tzX2lkID0gby50cmFja3M7XG4gICAgICBzLmJyYW5jaF9pZCA9IG8uYnJhbmNoO1xuICAgICAgcy5mcm9tX2lkID0gby5mcm9tO1xuXG4gICAgICByZXR1cm4gcztcbiAgIH1cbn1cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/code/switch.js\n\n}");

/***/ }),

/***/ "./www/code/tools.js":
/*!***************************!*\
  !*** ./www/code/tools.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   TOOLS: () => (/* binding */ TOOLS),\n/* harmony export */   V2: () => (/* binding */ V2),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   findFieldNameForObject: () => (/* binding */ findFieldNameForObject),\n/* harmony export */   geometry: () => (/* binding */ geometry),\n/* harmony export */   isPointInsideBox: () => (/* binding */ isPointInsideBox),\n/* harmony export */   rotatePointAroundPivot: () => (/* binding */ rotatePointAroundPivot),\n/* harmony export */   swap: () => (/* binding */ swap),\n/* harmony export */   testPerformance: () => (/* binding */ testPerformance),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n\n\n\n\n// Utility functions\nfunction findFieldNameForObject(container, ref) {\n   for (let key of Object.keys(container)) {\n      if (container[key] === ref) {\n         return key;\n      }\n   }\n   return null;\n}\n\nfunction type(value) {\n   if (value === null) {\n      return \"null\";\n   }\n   const baseType = typeof value;\n   // Primitive types\n   if (![\"object\", \"function\"].includes(baseType)) {\n      return baseType;\n   }\n\n   // Symbol.toStringTag often specifies the \"display name\" of the\n   // object's class. It's used in Object.prototype.toString().\n   const tag = value[Symbol.toStringTag];\n   if (typeof tag === \"string\") {\n      return tag;\n   }\n\n   // If it's a function whose source code starts with the \"class\" keyword\n   if (baseType === \"function\" && Function.prototype.toString.call(value).startsWith(\"class\")) {\n      return \"class\";\n   }\n\n   // The name of the constructor; for example `Array`, `GeneratorFunction`,\n   // `Number`, `String`, `Boolean` or `MyCustomClass`\n   const className = value.constructor.name;\n   if (typeof className === \"string\" && className !== \"\") {\n      return className;\n   }\n\n   // At this point there's no robust way to get the type of value,\n   // so we use the base implementation.\n   return baseType;\n}\n\nfunction swap(current, value1, value2) {\n   return current === value1 ? value2 : value1;\n}\n\nfunction deepEqual(x, y) {\n   const ok = Object.keys,\n      tx = typeof x,\n      ty = typeof y;\n   return x && y && tx === \"object\" && tx === ty\n      ? ok(x).length === ok(y).length && ok(x).every((key) => deepEqual(x[key], y[key]))\n      : x === y;\n}\n\nfunction clone(obj) {\n   var copy;\n\n   // Handle the 3 simple types, and null or undefined\n   if (null == obj || \"object\" != typeof obj) return obj;\n\n   // Handle Date\n   if (obj instanceof Date) {\n      copy = new Date();\n      copy.setTime(obj.getTime());\n      return copy;\n   }\n\n   // Handle Array\n   if (obj instanceof Array) {\n      copy = [];\n      for (var i = 0, len = obj.length; i < len; i++) {\n         copy[i] = clone(obj[i]);\n      }\n      return copy;\n   }\n\n   // Handle Object\n   if (obj instanceof Object) {\n      copy = {};\n      for (var attr in obj) {\n         if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\n      }\n      return copy;\n   }\n\n   throw new Error(\"Unable to copy obj! Its type isn't supported.\");\n}\n\nfunction uuidv4() {\n   return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>\n      (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n   );\n}\n\nfunction isPointInsideBox(point, box, rotationAngle) {\n   const { topLeft, topRight, bottomRight, bottomLeft } = box;\n\n   // Translate the point to align with the box's axes based on the given rotation angle\n   const translatedPoint = {\n      x: (point.x - topLeft.x) * Math.cos(-rotationAngle) - (point.y - topLeft.y) * Math.sin(-rotationAngle),\n      y: (point.x - topLeft.x) * Math.sin(-rotationAngle) + (point.y - topLeft.y) * Math.cos(-rotationAngle),\n   };\n\n   // Check if the translated point is inside the aligned box\n   const isInsideX = translatedPoint.x > 0 && translatedPoint.x < Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\n   const isInsideY = translatedPoint.y > 0 && translatedPoint.y < Math.hypot(bottomLeft.x - topLeft.x, bottomLeft.y - topLeft.y);\n\n   return isInsideX && isInsideY;\n}\n\nfunction rotatePointAroundPivot(angle, pivot, point) {\n   var cos = Math.cos(angle);\n   var sin = Math.sin(angle);\n   var dx = point.x - pivot.x;\n   var dy = point.y - pivot.y;\n   var x = dx * cos - dy * sin + pivot.x;\n   var y = dy * cos + dx * sin + pivot.y;\n   return { x: x, y: y };\n}\n\nconst TOOLS = {\n   /**\n    * Finds the nearest point on a line segment to a given point\n    * @param {Point|{x: number, y: number}} start - Start point of the line segment\n    * @param {Point|{x: number, y: number}} end - End point of the line segment\n    * @param {Point|{x: number, y: number}} point - Point to find nearest position to\n    * @returns {Point} The nearest point on the line segment\n    */\n   nearestPointOnLine(start, end, point) {\n      const lineDeltaX = end.x - start.x;\n      const lineDeltaY = end.y - start.y;\n      \n      // Handle degenerate case where start and end are the same point\n      if (lineDeltaX === 0 && lineDeltaY === 0) {\n         return new Point(start.x, start.y);\n      }\n\n      // Find the closest point on the line to the point\n      // We can avoid the sqrt in lineLength by using squared values\n      const lengthSquared = lineDeltaX * lineDeltaX + lineDeltaY * lineDeltaY;\n      let u = ((point.x - start.x) * lineDeltaX + (point.y - start.y) * lineDeltaY) / lengthSquared;\n\n      // Clamp u to the range [0, 1]\n      u = Math.max(0, Math.min(1, u));\n\n      // Calculate the closest point on the line segment\n      return new Point(\n         start.x + u * lineDeltaX,\n         start.y + u * lineDeltaY\n      );\n   },\n};\n\nconst geometry = {\n   PRECISION: 3,\n   distance: function (p1, p2) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round(Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)), this.PRECISION);\n   },\n   length: function (v) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round(Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2)), this.PRECISION);\n   },\n   slope: function (p1, p2) {\n      return (p1.y - p2.y) / (p1.x - p2.x);\n   },\n   \n   getIntersectionPoint: function (line1, line2) {\n      const denominator =\n         (line2.end.y - line2.start.y) * (line1.end.x - line1.start.x) -\n         (line2.end.x - line2.start.x) * (line1.end.y - line1.start.y);\n\n      // If the denominator is 0, the lines are parallel and don't intersect\n      if (denominator === 0) {\n         return null;\n      }\n\n      const ua =\n         ((line2.end.x - line2.start.x) * (line1.start.y - line2.start.y) -\n            (line2.end.y - line2.start.y) * (line1.start.x - line2.start.x)) /\n         denominator;\n      const ub =\n         ((line1.end.x - line1.start.x) * (line1.start.y - line2.start.y) -\n            (line1.end.y - line1.start.y) * (line1.start.x - line2.start.x)) /\n         denominator;\n\n      // If ua or ub is less than 0 or greater than 1, the intersection point is outside of the segments\n      if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n         return null;\n      }\n\n      // Calculate the intersection point\n      const intersectionX = line1.start.x + ua * (line1.end.x - line1.start.x);\n      const intersectionY = line1.start.y + ua * (line1.end.y - line1.start.y);\n\n      return new Point(intersectionX, intersectionY);\n   },\n\n   //returns the intersection point of 2 lines, regardless of their length\n   getIntersectionPointX: function (p1, d1, p2, d2) {\n      // Solve for t and s using the equations:\n      const denominator = d1.x * d2.y - d1.y * d2.x;\n      if (denominator === 0) return null; // Vectors are parallel or collinear\n      // Compute parameters t and s\n      const t = ((p2.x - p1.x) * d2.y - (p2.y - p1.y) * d2.x) / denominator;\n      // Compute the intersection point using either vector\n      return new Point(p1.x + t * d1.x, p1.y + t * d1.y);\n   },\n\n   /**\n    * Checks if a target point lies on the line segment defined by two points.\n    * @param {Object} point1 - The first point of the line segment.\n    * @param {number} point1.x - The x-coordinate of the first point.\n    * @param {number} point1.y - The y-coordinate of the first point.\n    * @param {Object} point2 - The second point of the line segment.\n    * @param {number} point2.x - The x-coordinate of the second point.\n    * @param {number} point2.y - The y-coordinate of the second point.\n    * @param {Object} targetPoint - The point to check.\n    * @param {number} targetPoint.x - The x-coordinate of the target point.\n    * @param {number} targetPoint.y - The y-coordinate of the target point.\n    * @returns {boolean} True if the target point lies on the line segment, false otherwise.\n    */\n   pointOnLine: function (point1, point2, targetPoint) {\n      // Extract coordinates from the objects\n      let x1 = point1.x,\n         y1 = point1.y;\n      let x2 = point2.x,\n         y2 = point2.y;\n      let px = targetPoint.x,\n         py = targetPoint.y;\n\n      //if(x1==px && y1==py || x2==px && y2 == py) return false;\n\n      // Calculate parameters for the parametric equations\n      let tX = px == x1 && x1 == x2 ? 0 : (px - x1) / (x2 - x1);\n      let tY = py == y1 && y1 == y2 ? 0 : (py - y1) / (y2 - y1);\n\n      // Check if the point is on the line (within the segment boundaries)\n      if (tX >= 0 && tX <= 1 && tY >= 0 && tY <= 1) {\n         return true; // Point lies on the line segment\n      } else {\n         return false; // Point is outside the line segment\n      }\n   },\n   areSegmentsOverlapping2D: function (p1, p2, p3, p4) {\n\n      if (p1.x === p3.x && p1.y === p3.y && p2.x === p4.x && p2.y === p4.y) return true;\n\n      if ((p2.x === p3.x && p2.y === p3.y) || (p1.x === p4.x && p1.y === p4.y)) return false;\n\n      // Check if the segments are parallel\n      const slopeCheck = (p2.y - p1.y) * (p4.x - p3.x) === (p4.y - p3.y) * (p2.x - p1.x);\n\n      // Check if they lie on the same line\n      const colinearCheck = (p3.y - p1.y) * (p2.x - p1.x) === (p3.x - p1.x) * (p2.y - p1.y);\n\n      if (!slopeCheck || !colinearCheck) {\n         return false; // Not parallel or not colinear\n      }\n\n      // Check for overlap in projections (dominant axis)\n      const overlapX = Math.max(p1.x, p2.x) >= Math.min(p3.x, p4.x) && Math.max(p3.x, p4.x) >= Math.min(p1.x, p2.x);\n      const overlapY = Math.max(p1.y, p2.y) >= Math.min(p3.y, p4.y) && Math.max(p3.y, p4.y) >= Math.min(p1.y, p2.y);\n\n      return overlapX && overlapY;\n   },\n   //returns true if 2 line, described by 4 points intersect, each other\n   doLineSegmentsIntersect: function (p1, q1, p2, q2) {\n      const orientation = (p, q, r) => {\n         const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n         return val === 0 ? 0 : val > 0 ? 1 : 2;\n      };\n\n      const onSegment = (p, q, r) => {\n         return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n      };\n\n      const o1 = orientation(p1, q1, p2);\n      const o2 = orientation(p1, q1, q2);\n      const o3 = orientation(p2, q2, p1);\n      const o4 = orientation(p2, q2, q1);\n\n      if (o1 !== o2 && o3 !== o4) {\n         return true; // Segments intersect\n      }\n\n      if (o1 === 0 && onSegment(p1, p2, q1)) return true;\n      if (o2 === 0 && onSegment(p1, q2, q1)) return true;\n      if (o3 === 0 && onSegment(p2, p1, q2)) return true;\n      if (o4 === 0 && onSegment(p2, q1, q2)) return true;\n\n      return false; // No intersection\n   },\n   pointOnArc: function (radius, rad, centerpoint) {\n      const v = {\n         x: radius * Math.cos(rad) + centerpoint?.x,\n         y: radius * Math.sin(rad) + centerpoint?.y,\n      };\n\n      return v;\n   },\n\n   //returns the distance between a point and a line\n   pointToSegmentDistance: function(point, start, end) {\n      const dx = end.x - start.x;\n      const dy = end.y - start.y;\n      \n      // Handle degenerate case where start and end are the same point\n      if (dx === 0 && dy === 0) {\n          return Math.hypot(point.x - start.x, point.y - start.y);\n      }\n      \n      // Compute the projection of the point onto the line defined by start and end\n      const t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / (dx * dx + dy * dy);\n      \n      // Clamp t to the range [0,1] to restrict to the segment\n      const tClamped = Math.max(0, Math.min(1, t));\n      \n      // Find the closest point on the segment\n      const closestX = start.x + tClamped * dx;\n      const closestY = start.y + tClamped * dy;\n      \n      // Return the Euclidean distance\n      return Math.hypot(point.x - closestX, point.y - closestY);\n  },\n\n   \n   //calculates a point which is perpendicular to the given vector\n   perpendicular: function (v) {\n      return new V2({\n         y: v.x,\n         x: -v.y,\n      });\n   },\n\n   //returns the unit vector of the given vector\n   unit: function (v, l) {\n      const length = l ? l : this.length(v);\n      return this.multiply(v, 1 / length);\n   },\n\n   multiply: function (v, s) {\n      return {\n         x: _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round(v.x * s, this.PRECISION),\n         y: _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round(v.y * s, this.PRECISION),\n      };\n   },\n\n   add: function (v1, v2) {\n      return new Point(v1.x + v2.x, v1.y + v2.y);\n   },\n\n   sub: function (v1, v2) {\n      return new Point(v1.x - v2.x, v1.y - v2.y);\n   },\n\n   calculateAngle: function (reference, point1, point2) {\n      // Calculate vectors\n      const v1 = { x: point1.x - reference.x, y: point1.y - reference.y };\n      const v2 = { x: point2.x - reference.x, y: point2.y - reference.y };\n\n      // Dot product\n      const dotProduct = v1.x * v2.x + v1.y * v2.y;\n\n      // Magnitudes\n      const magnitudeV1 = Math.sqrt(v1.x ** 2 + v1.y ** 2);\n      const magnitudeV2 = Math.sqrt(v2.x ** 2 + v2.y ** 2);\n\n      // Cosine of the angle\n      const cosTheta = dotProduct / (magnitudeV1 * magnitudeV2);\n\n      // Angle in radians\n      const theta = Math.acos(cosTheta);\n\n      // Convert to degrees (optional)\n      return theta * (180 / Math.PI); // Return the angle in degrees\n   },\n\n   /**\n    * Returns the midpoint between two points\n    * @param {Object} p1 - First point\n    * @param {number} p1.x - X coordinate of first point\n    * @param {number} p1.y - Y coordinate of first point\n    * @param {Object} p2 - Second point\n    * @param {number} p2.x - X coordinate of second point\n    * @param {number} p2.y - Y coordinate of second point\n    * @returns {Point} The midpoint between p1 and p2\n    */\n   midpoint: function(p1, p2) {\n      return new Point(\n         _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round((p1.x + p2.x) / 2, this.PRECISION),\n         _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round((p1.y + p2.y) / 2, this.PRECISION)\n      );\n   },\n\n   /**\n    * Returns the angle bisector of two normalized vectors\n    * @param {Object} v1 - First normalized vector\n    * @param {number} v1.x - X component of first vector\n    * @param {number} v1.y - Y component of first vector\n    * @param {Object} v2 - Second normalized vector\n    * @param {number} v2.x - X component of second vector\n    * @param {number} v2.y - Y component of second vector\n    * @returns {Point} The angle bisector vector (normalized)\n    */\n   angleBisector: function(v1, v2) {\n      // Add the two vectors to get the bisector\n      const bisector = this.add(v1, v2);    \n      \n      \n      // Normalize the bisector using the existing normalize function\n      return this.unit(bisector);\n   },\n\n   /**\n    * Returns a point along the angle bisector of two unit vectors at a given distance\n    * @param {Object} v1 - First normalized vector\n    * @param {number} v1.x - X component of first vector\n    * @param {number} v1.y - Y component of first vector\n    * @param {Object} v2 - Second normalized vector\n    * @param {number} v2.x - X component of second vector\n    * @param {number} v2.y - Y component of second vector\n    * @param {number} distance - Distance to move along the bisector\n    * @returns {Point} The point at the specified distance along the angle bisector\n    */\n   pointAlongBisector: function(v1, v2, distance) {\n      // Get the angle bisector vector\n      const bisector = this.angleBisector(v1, v2);\n      \n      // Scale the bisector by the desired distance\n      const scaledBisector = this.multiply(bisector, distance);\n      \n      return scaledBisector;\n   },\n\n   /**\n    * Inverts a given vector by negating both x and y components\n    * @param {Object} v - Vector to invert\n    * @param {number} v.x - X component of vector\n    * @param {number} v.y - Y component of vector\n    * @returns {Point} The inverted vector\n    */\n   invert: function(v) {\n      return new Point(-v.x, -v.y);\n   },\n};\n\nclass V2 {\n   static fromV2(v) {\n      return new V2(v);\n   }\n\n   #_length = null;\n\n   get length() {\n      if (this.#_length == null) this.#_length = geometry.length(this);\n      return this.#_length;\n   }\n\n   get x() {\n      return this._p.x;\n   }\n\n   get y() {\n      return this._p.y;\n   }\n\n   constructor(p) {\n      this._p = p;\n   }\n\n   add(v) {\n      return new V2(geometry.add(this, v));\n   }\n\n   sub(v) {\n      return new V2(geometry.sub(this, v));\n   }\n\n   multiply(s) {\n      return new V2(geometry.multiply(this, s));\n   }\n\n   unit() {\n      return new V2(geometry.unit(this));\n   }\n   invert() {\n      return new V2(geometry.invert(this));\n   }\n}\n\nclass Point {\n   static fromPoint(p) {\n      return new Point(p.x, p.y);\n   }\n\n   constructor(x, y) {\n      this.x = x;\n      this.y = y;\n   }\n\n   add(v) {\n      return new Point(this.x + v.x, this.y + v.y);\n   }\n\n   sub(v) {\n      return new Point(this.x - v.x, this.y - v.y);\n   }\n\n   equals(p) {\n      return p.x == this.x && p.y == this.y;\n   }\n}\n\nfunction testPerformance(f, txt) {\n   const start = performance.now();\n   f();\n   const end = performance.now();\n   console.info(`${txt}: ${(end - start).toFixed(3)}ms`);\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSSxJQUFJLHlCQUF5QjtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3Rvb2xzLmpzP2U1YTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE51bWJlclV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpZWxkTmFtZUZvck9iamVjdChjb250YWluZXIsIHJlZikge1xuICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbnRhaW5lcikpIHtcbiAgICAgIGlmIChjb250YWluZXJba2V5XSA9PT0gcmVmKSB7XG4gICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfVxuICAgfVxuICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlKHZhbHVlKSB7XG4gICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgIH1cbiAgIGNvbnN0IGJhc2VUeXBlID0gdHlwZW9mIHZhbHVlO1xuICAgLy8gUHJpbWl0aXZlIHR5cGVzXG4gICBpZiAoIVtcIm9iamVjdFwiLCBcImZ1bmN0aW9uXCJdLmluY2x1ZGVzKGJhc2VUeXBlKSkge1xuICAgICAgcmV0dXJuIGJhc2VUeXBlO1xuICAgfVxuXG4gICAvLyBTeW1ib2wudG9TdHJpbmdUYWcgb2Z0ZW4gc3BlY2lmaWVzIHRoZSBcImRpc3BsYXkgbmFtZVwiIG9mIHRoZVxuICAgLy8gb2JqZWN0J3MgY2xhc3MuIEl0J3MgdXNlZCBpbiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKCkuXG4gICBjb25zdCB0YWcgPSB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddO1xuICAgaWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0YWc7XG4gICB9XG5cbiAgIC8vIElmIGl0J3MgYSBmdW5jdGlvbiB3aG9zZSBzb3VyY2UgY29kZSBzdGFydHMgd2l0aCB0aGUgXCJjbGFzc1wiIGtleXdvcmRcbiAgIGlmIChiYXNlVHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zdGFydHNXaXRoKFwiY2xhc3NcIikpIHtcbiAgICAgIHJldHVybiBcImNsYXNzXCI7XG4gICB9XG5cbiAgIC8vIFRoZSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvcjsgZm9yIGV4YW1wbGUgYEFycmF5YCwgYEdlbmVyYXRvckZ1bmN0aW9uYCxcbiAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYEJvb2xlYW5gIG9yIGBNeUN1c3RvbUNsYXNzYFxuICAgY29uc3QgY2xhc3NOYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGNsYXNzTmFtZSAhPT0gXCJcIikge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgIH1cblxuICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSdzIG5vIHJvYnVzdCB3YXkgdG8gZ2V0IHRoZSB0eXBlIG9mIHZhbHVlLFxuICAgLy8gc28gd2UgdXNlIHRoZSBiYXNlIGltcGxlbWVudGF0aW9uLlxuICAgcmV0dXJuIGJhc2VUeXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3dhcChjdXJyZW50LCB2YWx1ZTEsIHZhbHVlMikge1xuICAgcmV0dXJuIGN1cnJlbnQgPT09IHZhbHVlMSA/IHZhbHVlMiA6IHZhbHVlMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBFcXVhbCh4LCB5KSB7XG4gICBjb25zdCBvayA9IE9iamVjdC5rZXlzLFxuICAgICAgdHggPSB0eXBlb2YgeCxcbiAgICAgIHR5ID0gdHlwZW9mIHk7XG4gICByZXR1cm4geCAmJiB5ICYmIHR4ID09PSBcIm9iamVjdFwiICYmIHR4ID09PSB0eVxuICAgICAgPyBvayh4KS5sZW5ndGggPT09IG9rKHkpLmxlbmd0aCAmJiBvayh4KS5ldmVyeSgoa2V5KSA9PiBkZWVwRXF1YWwoeFtrZXldLCB5W2tleV0pKVxuICAgICAgOiB4ID09PSB5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICB2YXIgY29weTtcblxuICAgLy8gSGFuZGxlIHRoZSAzIHNpbXBsZSB0eXBlcywgYW5kIG51bGwgb3IgdW5kZWZpbmVkXG4gICBpZiAobnVsbCA9PSBvYmogfHwgXCJvYmplY3RcIiAhPSB0eXBlb2Ygb2JqKSByZXR1cm4gb2JqO1xuXG4gICAvLyBIYW5kbGUgRGF0ZVxuICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGNvcHkgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29weS5zZXRUaW1lKG9iai5nZXRUaW1lKCkpO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICB9XG5cbiAgIC8vIEhhbmRsZSBBcnJheVxuICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjb3B5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICBjb3B5W2ldID0gY2xvbmUob2JqW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3B5O1xuICAgfVxuXG4gICAvLyBIYW5kbGUgT2JqZWN0XG4gICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBjb3B5ID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIG9iaikge1xuICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShhdHRyKSkgY29weVthdHRyXSA9IGNsb25lKG9ialthdHRyXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29weTtcbiAgIH1cblxuICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgb2JqISBJdHMgdHlwZSBpc24ndCBzdXBwb3J0ZWQuXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXVpZHY0KCkge1xuICAgcmV0dXJuIChbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExKS5yZXBsYWNlKC9bMDE4XS9nLCAoYykgPT5cbiAgICAgIChjIF4gKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMSkpWzBdICYgKDE1ID4+IChjIC8gNCkpKSkudG9TdHJpbmcoMTYpXG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQb2ludEluc2lkZUJveChwb2ludCwgYm94LCByb3RhdGlvbkFuZ2xlKSB7XG4gICBjb25zdCB7IHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCB9ID0gYm94O1xuXG4gICAvLyBUcmFuc2xhdGUgdGhlIHBvaW50IHRvIGFsaWduIHdpdGggdGhlIGJveCdzIGF4ZXMgYmFzZWQgb24gdGhlIGdpdmVuIHJvdGF0aW9uIGFuZ2xlXG4gICBjb25zdCB0cmFuc2xhdGVkUG9pbnQgPSB7XG4gICAgICB4OiAocG9pbnQueCAtIHRvcExlZnQueCkgKiBNYXRoLmNvcygtcm90YXRpb25BbmdsZSkgLSAocG9pbnQueSAtIHRvcExlZnQueSkgKiBNYXRoLnNpbigtcm90YXRpb25BbmdsZSksXG4gICAgICB5OiAocG9pbnQueCAtIHRvcExlZnQueCkgKiBNYXRoLnNpbigtcm90YXRpb25BbmdsZSkgKyAocG9pbnQueSAtIHRvcExlZnQueSkgKiBNYXRoLmNvcygtcm90YXRpb25BbmdsZSksXG4gICB9O1xuXG4gICAvLyBDaGVjayBpZiB0aGUgdHJhbnNsYXRlZCBwb2ludCBpcyBpbnNpZGUgdGhlIGFsaWduZWQgYm94XG4gICBjb25zdCBpc0luc2lkZVggPSB0cmFuc2xhdGVkUG9pbnQueCA+IDAgJiYgdHJhbnNsYXRlZFBvaW50LnggPCBNYXRoLmh5cG90KHRvcFJpZ2h0LnggLSB0b3BMZWZ0LngsIHRvcFJpZ2h0LnkgLSB0b3BMZWZ0LnkpO1xuICAgY29uc3QgaXNJbnNpZGVZID0gdHJhbnNsYXRlZFBvaW50LnkgPiAwICYmIHRyYW5zbGF0ZWRQb2ludC55IDwgTWF0aC5oeXBvdChib3R0b21MZWZ0LnggLSB0b3BMZWZ0LngsIGJvdHRvbUxlZnQueSAtIHRvcExlZnQueSk7XG5cbiAgIHJldHVybiBpc0luc2lkZVggJiYgaXNJbnNpZGVZO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlUG9pbnRBcm91bmRQaXZvdChhbmdsZSwgcGl2b3QsIHBvaW50KSB7XG4gICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgIHZhciBkeCA9IHBvaW50LnggLSBwaXZvdC54O1xuICAgdmFyIGR5ID0gcG9pbnQueSAtIHBpdm90Lnk7XG4gICB2YXIgeCA9IGR4ICogY29zIC0gZHkgKiBzaW4gKyBwaXZvdC54O1xuICAgdmFyIHkgPSBkeSAqIGNvcyArIGR4ICogc2luICsgcGl2b3QueTtcbiAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFRPT0xTID0ge1xuICAgLyoqXG4gICAgKiBGaW5kcyB0aGUgbmVhcmVzdCBwb2ludCBvbiBhIGxpbmUgc2VnbWVudCB0byBhIGdpdmVuIHBvaW50XG4gICAgKiBAcGFyYW0ge1BvaW50fHt4OiBudW1iZXIsIHk6IG51bWJlcn19IHN0YXJ0IC0gU3RhcnQgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICogQHBhcmFtIHtQb2ludHx7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBlbmQgLSBFbmQgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICogQHBhcmFtIHtQb2ludHx7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludCAtIFBvaW50IHRvIGZpbmQgbmVhcmVzdCBwb3NpdGlvbiB0b1xuICAgICogQHJldHVybnMge1BvaW50fSBUaGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgbGluZSBzZWdtZW50XG4gICAgKi9cbiAgIG5lYXJlc3RQb2ludE9uTGluZShzdGFydCwgZW5kLCBwb2ludCkge1xuICAgICAgY29uc3QgbGluZURlbHRhWCA9IGVuZC54IC0gc3RhcnQueDtcbiAgICAgIGNvbnN0IGxpbmVEZWx0YVkgPSBlbmQueSAtIHN0YXJ0Lnk7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBkZWdlbmVyYXRlIGNhc2Ugd2hlcmUgc3RhcnQgYW5kIGVuZCBhcmUgdGhlIHNhbWUgcG9pbnRcbiAgICAgIGlmIChsaW5lRGVsdGFYID09PSAwICYmIGxpbmVEZWx0YVkgPT09IDApIHtcbiAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmUgdG8gdGhlIHBvaW50XG4gICAgICAvLyBXZSBjYW4gYXZvaWQgdGhlIHNxcnQgaW4gbGluZUxlbmd0aCBieSB1c2luZyBzcXVhcmVkIHZhbHVlc1xuICAgICAgY29uc3QgbGVuZ3RoU3F1YXJlZCA9IGxpbmVEZWx0YVggKiBsaW5lRGVsdGFYICsgbGluZURlbHRhWSAqIGxpbmVEZWx0YVk7XG4gICAgICBsZXQgdSA9ICgocG9pbnQueCAtIHN0YXJ0LngpICogbGluZURlbHRhWCArIChwb2ludC55IC0gc3RhcnQueSkgKiBsaW5lRGVsdGFZKSAvIGxlbmd0aFNxdWFyZWQ7XG5cbiAgICAgIC8vIENsYW1wIHUgdG8gdGhlIHJhbmdlIFswLCAxXVxuICAgICAgdSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHUpKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICBzdGFydC54ICsgdSAqIGxpbmVEZWx0YVgsXG4gICAgICAgICBzdGFydC55ICsgdSAqIGxpbmVEZWx0YVlcbiAgICAgICk7XG4gICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IGdlb21ldHJ5ID0ge1xuICAgUFJFQ0lTSU9OOiAzLFxuICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgIHJldHVybiBOdW1iZXJVdGlscy5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKSwgdGhpcy5QUkVDSVNJT04pO1xuICAgfSxcbiAgIGxlbmd0aDogZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBOdW1iZXJVdGlscy5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3codi54LCAyKSArIE1hdGgucG93KHYueSwgMikpLCB0aGlzLlBSRUNJU0lPTik7XG4gICB9LFxuICAgc2xvcGU6IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgIHJldHVybiAocDEueSAtIHAyLnkpIC8gKHAxLnggLSBwMi54KTtcbiAgIH0sXG4gICBcbiAgIGdldEludGVyc2VjdGlvblBvaW50OiBmdW5jdGlvbiAobGluZTEsIGxpbmUyKSB7XG4gICAgICBjb25zdCBkZW5vbWluYXRvciA9XG4gICAgICAgICAobGluZTIuZW5kLnkgLSBsaW5lMi5zdGFydC55KSAqIChsaW5lMS5lbmQueCAtIGxpbmUxLnN0YXJ0LngpIC1cbiAgICAgICAgIChsaW5lMi5lbmQueCAtIGxpbmUyLnN0YXJ0LngpICogKGxpbmUxLmVuZC55IC0gbGluZTEuc3RhcnQueSk7XG5cbiAgICAgIC8vIElmIHRoZSBkZW5vbWluYXRvciBpcyAwLCB0aGUgbGluZXMgYXJlIHBhcmFsbGVsIGFuZCBkb24ndCBpbnRlcnNlY3RcbiAgICAgIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVhID1cbiAgICAgICAgICgobGluZTIuZW5kLnggLSBsaW5lMi5zdGFydC54KSAqIChsaW5lMS5zdGFydC55IC0gbGluZTIuc3RhcnQueSkgLVxuICAgICAgICAgICAgKGxpbmUyLmVuZC55IC0gbGluZTIuc3RhcnQueSkgKiAobGluZTEuc3RhcnQueCAtIGxpbmUyLnN0YXJ0LngpKSAvXG4gICAgICAgICBkZW5vbWluYXRvcjtcbiAgICAgIGNvbnN0IHViID1cbiAgICAgICAgICgobGluZTEuZW5kLnggLSBsaW5lMS5zdGFydC54KSAqIChsaW5lMS5zdGFydC55IC0gbGluZTIuc3RhcnQueSkgLVxuICAgICAgICAgICAgKGxpbmUxLmVuZC55IC0gbGluZTEuc3RhcnQueSkgKiAobGluZTEuc3RhcnQueCAtIGxpbmUyLnN0YXJ0LngpKSAvXG4gICAgICAgICBkZW5vbWluYXRvcjtcblxuICAgICAgLy8gSWYgdWEgb3IgdWIgaXMgbGVzcyB0aGFuIDAgb3IgZ3JlYXRlciB0aGFuIDEsIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgb3V0c2lkZSBvZiB0aGUgc2VnbWVudHNcbiAgICAgIGlmICh1YSA8IDAgfHwgdWEgPiAxIHx8IHViIDwgMCB8fCB1YiA+IDEpIHtcbiAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgY29uc3QgaW50ZXJzZWN0aW9uWCA9IGxpbmUxLnN0YXJ0LnggKyB1YSAqIChsaW5lMS5lbmQueCAtIGxpbmUxLnN0YXJ0LngpO1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW9uWSA9IGxpbmUxLnN0YXJ0LnkgKyB1YSAqIChsaW5lMS5lbmQueSAtIGxpbmUxLnN0YXJ0LnkpO1xuXG4gICAgICByZXR1cm4gbmV3IFBvaW50KGludGVyc2VjdGlvblgsIGludGVyc2VjdGlvblkpO1xuICAgfSxcblxuICAgLy9yZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgMiBsaW5lcywgcmVnYXJkbGVzcyBvZiB0aGVpciBsZW5ndGhcbiAgIGdldEludGVyc2VjdGlvblBvaW50WDogZnVuY3Rpb24gKHAxLCBkMSwgcDIsIGQyKSB7XG4gICAgICAvLyBTb2x2ZSBmb3IgdCBhbmQgcyB1c2luZyB0aGUgZXF1YXRpb25zOlxuICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBkMS54ICogZDIueSAtIGQxLnkgKiBkMi54O1xuICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwKSByZXR1cm4gbnVsbDsgLy8gVmVjdG9ycyBhcmUgcGFyYWxsZWwgb3IgY29sbGluZWFyXG4gICAgICAvLyBDb21wdXRlIHBhcmFtZXRlcnMgdCBhbmQgc1xuICAgICAgY29uc3QgdCA9ICgocDIueCAtIHAxLngpICogZDIueSAtIChwMi55IC0gcDEueSkgKiBkMi54KSAvIGRlbm9taW5hdG9yO1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IHVzaW5nIGVpdGhlciB2ZWN0b3JcbiAgICAgIHJldHVybiBuZXcgUG9pbnQocDEueCArIHQgKiBkMS54LCBwMS55ICsgdCAqIGQxLnkpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBDaGVja3MgaWYgYSB0YXJnZXQgcG9pbnQgbGllcyBvbiB0aGUgbGluZSBzZWdtZW50IGRlZmluZWQgYnkgdHdvIHBvaW50cy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludDEgLSBUaGUgZmlyc3QgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudC5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludDEueCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50MS55IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnQyIC0gVGhlIHNlY29uZCBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50Mi54IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50Mi55IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFBvaW50LnggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB0YXJnZXQgcG9pbnQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UG9pbnQueSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRhcmdldCBwb2ludC5cbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0YXJnZXQgcG9pbnQgbGllcyBvbiB0aGUgbGluZSBzZWdtZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgKi9cbiAgIHBvaW50T25MaW5lOiBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIsIHRhcmdldFBvaW50KSB7XG4gICAgICAvLyBFeHRyYWN0IGNvb3JkaW5hdGVzIGZyb20gdGhlIG9iamVjdHNcbiAgICAgIGxldCB4MSA9IHBvaW50MS54LFxuICAgICAgICAgeTEgPSBwb2ludDEueTtcbiAgICAgIGxldCB4MiA9IHBvaW50Mi54LFxuICAgICAgICAgeTIgPSBwb2ludDIueTtcbiAgICAgIGxldCBweCA9IHRhcmdldFBvaW50LngsXG4gICAgICAgICBweSA9IHRhcmdldFBvaW50Lnk7XG5cbiAgICAgIC8vaWYoeDE9PXB4ICYmIHkxPT1weSB8fCB4Mj09cHggJiYgeTIgPT0gcHkpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHBhcmFtZXRlcnMgZm9yIHRoZSBwYXJhbWV0cmljIGVxdWF0aW9uc1xuICAgICAgbGV0IHRYID0gcHggPT0geDEgJiYgeDEgPT0geDIgPyAwIDogKHB4IC0geDEpIC8gKHgyIC0geDEpO1xuICAgICAgbGV0IHRZID0gcHkgPT0geTEgJiYgeTEgPT0geTIgPyAwIDogKHB5IC0geTEpIC8gKHkyIC0geTEpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgaXMgb24gdGhlIGxpbmUgKHdpdGhpbiB0aGUgc2VnbWVudCBib3VuZGFyaWVzKVxuICAgICAgaWYgKHRYID49IDAgJiYgdFggPD0gMSAmJiB0WSA+PSAwICYmIHRZIDw9IDEpIHtcbiAgICAgICAgIHJldHVybiB0cnVlOyAvLyBQb2ludCBsaWVzIG9uIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFBvaW50IGlzIG91dHNpZGUgdGhlIGxpbmUgc2VnbWVudFxuICAgICAgfVxuICAgfSxcbiAgIGFyZVNlZ21lbnRzT3ZlcmxhcHBpbmcyRDogZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG5cbiAgICAgIGlmIChwMS54ID09PSBwMy54ICYmIHAxLnkgPT09IHAzLnkgJiYgcDIueCA9PT0gcDQueCAmJiBwMi55ID09PSBwNC55KSByZXR1cm4gdHJ1ZTtcblxuICAgICAgaWYgKChwMi54ID09PSBwMy54ICYmIHAyLnkgPT09IHAzLnkpIHx8IChwMS54ID09PSBwNC54ICYmIHAxLnkgPT09IHA0LnkpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWdtZW50cyBhcmUgcGFyYWxsZWxcbiAgICAgIGNvbnN0IHNsb3BlQ2hlY2sgPSAocDIueSAtIHAxLnkpICogKHA0LnggLSBwMy54KSA9PT0gKHA0LnkgLSBwMy55KSAqIChwMi54IC0gcDEueCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZXkgbGllIG9uIHRoZSBzYW1lIGxpbmVcbiAgICAgIGNvbnN0IGNvbGluZWFyQ2hlY2sgPSAocDMueSAtIHAxLnkpICogKHAyLnggLSBwMS54KSA9PT0gKHAzLnggLSBwMS54KSAqIChwMi55IC0gcDEueSk7XG5cbiAgICAgIGlmICghc2xvcGVDaGVjayB8fCAhY29saW5lYXJDaGVjaykge1xuICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBOb3QgcGFyYWxsZWwgb3Igbm90IGNvbGluZWFyXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBvdmVybGFwIGluIHByb2plY3Rpb25zIChkb21pbmFudCBheGlzKVxuICAgICAgY29uc3Qgb3ZlcmxhcFggPSBNYXRoLm1heChwMS54LCBwMi54KSA+PSBNYXRoLm1pbihwMy54LCBwNC54KSAmJiBNYXRoLm1heChwMy54LCBwNC54KSA+PSBNYXRoLm1pbihwMS54LCBwMi54KTtcbiAgICAgIGNvbnN0IG92ZXJsYXBZID0gTWF0aC5tYXgocDEueSwgcDIueSkgPj0gTWF0aC5taW4ocDMueSwgcDQueSkgJiYgTWF0aC5tYXgocDMueSwgcDQueSkgPj0gTWF0aC5taW4ocDEueSwgcDIueSk7XG5cbiAgICAgIHJldHVybiBvdmVybGFwWCAmJiBvdmVybGFwWTtcbiAgIH0sXG4gICAvL3JldHVybnMgdHJ1ZSBpZiAyIGxpbmUsIGRlc2NyaWJlZCBieSA0IHBvaW50cyBpbnRlcnNlY3QsIGVhY2ggb3RoZXJcbiAgIGRvTGluZVNlZ21lbnRzSW50ZXJzZWN0OiBmdW5jdGlvbiAocDEsIHExLCBwMiwgcTIpIHtcbiAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gKHAsIHEsIHIpID0+IHtcbiAgICAgICAgIGNvbnN0IHZhbCA9IChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xuICAgICAgICAgcmV0dXJuIHZhbCA9PT0gMCA/IDAgOiB2YWwgPiAwID8gMSA6IDI7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvblNlZ21lbnQgPSAocCwgcSwgcikgPT4ge1xuICAgICAgICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvMSA9IG9yaWVudGF0aW9uKHAxLCBxMSwgcDIpO1xuICAgICAgY29uc3QgbzIgPSBvcmllbnRhdGlvbihwMSwgcTEsIHEyKTtcbiAgICAgIGNvbnN0IG8zID0gb3JpZW50YXRpb24ocDIsIHEyLCBwMSk7XG4gICAgICBjb25zdCBvNCA9IG9yaWVudGF0aW9uKHAyLCBxMiwgcTEpO1xuXG4gICAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkge1xuICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFNlZ21lbnRzIGludGVyc2VjdFxuICAgICAgfVxuXG4gICAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvMiA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHEyLCBxMSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBpbnRlcnNlY3Rpb25cbiAgIH0sXG4gICBwb2ludE9uQXJjOiBmdW5jdGlvbiAocmFkaXVzLCByYWQsIGNlbnRlcnBvaW50KSB7XG4gICAgICBjb25zdCB2ID0ge1xuICAgICAgICAgeDogcmFkaXVzICogTWF0aC5jb3MocmFkKSArIGNlbnRlcnBvaW50Py54LFxuICAgICAgICAgeTogcmFkaXVzICogTWF0aC5zaW4ocmFkKSArIGNlbnRlcnBvaW50Py55LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHY7XG4gICB9LFxuXG4gICAvL3JldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCBhbmQgYSBsaW5lXG4gICBwb2ludFRvU2VnbWVudERpc3RhbmNlOiBmdW5jdGlvbihwb2ludCwgc3RhcnQsIGVuZCkge1xuICAgICAgY29uc3QgZHggPSBlbmQueCAtIHN0YXJ0Lng7XG4gICAgICBjb25zdCBkeSA9IGVuZC55IC0gc3RhcnQueTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIGRlZ2VuZXJhdGUgY2FzZSB3aGVyZSBzdGFydCBhbmQgZW5kIGFyZSB0aGUgc2FtZSBwb2ludFxuICAgICAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguaHlwb3QocG9pbnQueCAtIHN0YXJ0LngsIHBvaW50LnkgLSBzdGFydC55KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgb250byB0aGUgbGluZSBkZWZpbmVkIGJ5IHN0YXJ0IGFuZCBlbmRcbiAgICAgIGNvbnN0IHQgPSAoKHBvaW50LnggLSBzdGFydC54KSAqIGR4ICsgKHBvaW50LnkgLSBzdGFydC55KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBcbiAgICAgIC8vIENsYW1wIHQgdG8gdGhlIHJhbmdlIFswLDFdIHRvIHJlc3RyaWN0IHRvIHRoZSBzZWdtZW50XG4gICAgICBjb25zdCB0Q2xhbXBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcbiAgICAgIFxuICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxuICAgICAgY29uc3QgY2xvc2VzdFggPSBzdGFydC54ICsgdENsYW1wZWQgKiBkeDtcbiAgICAgIGNvbnN0IGNsb3Nlc3RZID0gc3RhcnQueSArIHRDbGFtcGVkICogZHk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiB0aGUgRXVjbGlkZWFuIGRpc3RhbmNlXG4gICAgICByZXR1cm4gTWF0aC5oeXBvdChwb2ludC54IC0gY2xvc2VzdFgsIHBvaW50LnkgLSBjbG9zZXN0WSk7XG4gIH0sXG5cbiAgIFxuICAgLy9jYWxjdWxhdGVzIGEgcG9pbnQgd2hpY2ggaXMgcGVycGVuZGljdWxhciB0byB0aGUgZ2l2ZW4gdmVjdG9yXG4gICBwZXJwZW5kaWN1bGFyOiBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIG5ldyBWMih7XG4gICAgICAgICB5OiB2LngsXG4gICAgICAgICB4OiAtdi55LFxuICAgICAgfSk7XG4gICB9LFxuXG4gICAvL3JldHVybnMgdGhlIHVuaXQgdmVjdG9yIG9mIHRoZSBnaXZlbiB2ZWN0b3JcbiAgIHVuaXQ6IGZ1bmN0aW9uICh2LCBsKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBsID8gbCA6IHRoaXMubGVuZ3RoKHYpO1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkodiwgMSAvIGxlbmd0aCk7XG4gICB9LFxuXG4gICBtdWx0aXBseTogZnVuY3Rpb24gKHYsIHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICB4OiBOdW1iZXJVdGlscy5yb3VuZCh2LnggKiBzLCB0aGlzLlBSRUNJU0lPTiksXG4gICAgICAgICB5OiBOdW1iZXJVdGlscy5yb3VuZCh2LnkgKiBzLCB0aGlzLlBSRUNJU0lPTiksXG4gICAgICB9O1xuICAgfSxcblxuICAgYWRkOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHYxLnggKyB2Mi54LCB2MS55ICsgdjIueSk7XG4gICB9LFxuXG4gICBzdWI6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodjEueCAtIHYyLngsIHYxLnkgLSB2Mi55KTtcbiAgIH0sXG5cbiAgIGNhbGN1bGF0ZUFuZ2xlOiBmdW5jdGlvbiAocmVmZXJlbmNlLCBwb2ludDEsIHBvaW50Mikge1xuICAgICAgLy8gQ2FsY3VsYXRlIHZlY3RvcnNcbiAgICAgIGNvbnN0IHYxID0geyB4OiBwb2ludDEueCAtIHJlZmVyZW5jZS54LCB5OiBwb2ludDEueSAtIHJlZmVyZW5jZS55IH07XG4gICAgICBjb25zdCB2MiA9IHsgeDogcG9pbnQyLnggLSByZWZlcmVuY2UueCwgeTogcG9pbnQyLnkgLSByZWZlcmVuY2UueSB9O1xuXG4gICAgICAvLyBEb3QgcHJvZHVjdFxuICAgICAgY29uc3QgZG90UHJvZHVjdCA9IHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnk7XG5cbiAgICAgIC8vIE1hZ25pdHVkZXNcbiAgICAgIGNvbnN0IG1hZ25pdHVkZVYxID0gTWF0aC5zcXJ0KHYxLnggKiogMiArIHYxLnkgKiogMik7XG4gICAgICBjb25zdCBtYWduaXR1ZGVWMiA9IE1hdGguc3FydCh2Mi54ICoqIDIgKyB2Mi55ICoqIDIpO1xuXG4gICAgICAvLyBDb3NpbmUgb2YgdGhlIGFuZ2xlXG4gICAgICBjb25zdCBjb3NUaGV0YSA9IGRvdFByb2R1Y3QgLyAobWFnbml0dWRlVjEgKiBtYWduaXR1ZGVWMik7XG5cbiAgICAgIC8vIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKGNvc1RoZXRhKTtcblxuICAgICAgLy8gQ29udmVydCB0byBkZWdyZWVzIChvcHRpb25hbClcbiAgICAgIHJldHVybiB0aGV0YSAqICgxODAgLyBNYXRoLlBJKTsgLy8gUmV0dXJuIHRoZSBhbmdsZSBpbiBkZWdyZWVzXG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJldHVybnMgdGhlIG1pZHBvaW50IGJldHdlZW4gdHdvIHBvaW50c1xuICAgICogQHBhcmFtIHtPYmplY3R9IHAxIC0gRmlyc3QgcG9pbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwMS54IC0gWCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gcDEueSAtIFkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICAgICogQHBhcmFtIHtPYmplY3R9IHAyIC0gU2Vjb25kIHBvaW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gcDIueCAtIFggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwMi55IC0gWSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICAgICogQHJldHVybnMge1BvaW50fSBUaGUgbWlkcG9pbnQgYmV0d2VlbiBwMSBhbmQgcDJcbiAgICAqL1xuICAgbWlkcG9pbnQ6IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgIE51bWJlclV0aWxzLnJvdW5kKChwMS54ICsgcDIueCkgLyAyLCB0aGlzLlBSRUNJU0lPTiksXG4gICAgICAgICBOdW1iZXJVdGlscy5yb3VuZCgocDEueSArIHAyLnkpIC8gMiwgdGhpcy5QUkVDSVNJT04pXG4gICAgICApO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBiaXNlY3RvciBvZiB0d28gbm9ybWFsaXplZCB2ZWN0b3JzXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdjEgLSBGaXJzdCBub3JtYWxpemVkIHZlY3RvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHYxLnggLSBYIGNvbXBvbmVudCBvZiBmaXJzdCB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2MS55IC0gWSBjb21wb25lbnQgb2YgZmlyc3QgdmVjdG9yXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdjIgLSBTZWNvbmQgbm9ybWFsaXplZCB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2Mi54IC0gWCBjb21wb25lbnQgb2Ygc2Vjb25kIHZlY3RvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHYyLnkgLSBZIGNvbXBvbmVudCBvZiBzZWNvbmQgdmVjdG9yXG4gICAgKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBhbmdsZSBiaXNlY3RvciB2ZWN0b3IgKG5vcm1hbGl6ZWQpXG4gICAgKi9cbiAgIGFuZ2xlQmlzZWN0b3I6IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgLy8gQWRkIHRoZSB0d28gdmVjdG9ycyB0byBnZXQgdGhlIGJpc2VjdG9yXG4gICAgICBjb25zdCBiaXNlY3RvciA9IHRoaXMuYWRkKHYxLCB2Mik7ICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYmlzZWN0b3IgdXNpbmcgdGhlIGV4aXN0aW5nIG5vcm1hbGl6ZSBmdW5jdGlvblxuICAgICAgcmV0dXJuIHRoaXMudW5pdChiaXNlY3Rvcik7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJldHVybnMgYSBwb2ludCBhbG9uZyB0aGUgYW5nbGUgYmlzZWN0b3Igb2YgdHdvIHVuaXQgdmVjdG9ycyBhdCBhIGdpdmVuIGRpc3RhbmNlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdjEgLSBGaXJzdCBub3JtYWxpemVkIHZlY3RvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHYxLnggLSBYIGNvbXBvbmVudCBvZiBmaXJzdCB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2MS55IC0gWSBjb21wb25lbnQgb2YgZmlyc3QgdmVjdG9yXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdjIgLSBTZWNvbmQgbm9ybWFsaXplZCB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2Mi54IC0gWCBjb21wb25lbnQgb2Ygc2Vjb25kIHZlY3RvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHYyLnkgLSBZIGNvbXBvbmVudCBvZiBzZWNvbmQgdmVjdG9yXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgLSBEaXN0YW5jZSB0byBtb3ZlIGFsb25nIHRoZSBiaXNlY3RvclxuICAgICogQHJldHVybnMge1BvaW50fSBUaGUgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBkaXN0YW5jZSBhbG9uZyB0aGUgYW5nbGUgYmlzZWN0b3JcbiAgICAqL1xuICAgcG9pbnRBbG9uZ0Jpc2VjdG9yOiBmdW5jdGlvbih2MSwgdjIsIGRpc3RhbmNlKSB7XG4gICAgICAvLyBHZXQgdGhlIGFuZ2xlIGJpc2VjdG9yIHZlY3RvclxuICAgICAgY29uc3QgYmlzZWN0b3IgPSB0aGlzLmFuZ2xlQmlzZWN0b3IodjEsIHYyKTtcbiAgICAgIFxuICAgICAgLy8gU2NhbGUgdGhlIGJpc2VjdG9yIGJ5IHRoZSBkZXNpcmVkIGRpc3RhbmNlXG4gICAgICBjb25zdCBzY2FsZWRCaXNlY3RvciA9IHRoaXMubXVsdGlwbHkoYmlzZWN0b3IsIGRpc3RhbmNlKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHNjYWxlZEJpc2VjdG9yO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBJbnZlcnRzIGEgZ2l2ZW4gdmVjdG9yIGJ5IG5lZ2F0aW5nIGJvdGggeCBhbmQgeSBjb21wb25lbnRzXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdiAtIFZlY3RvciB0byBpbnZlcnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2LnggLSBYIGNvbXBvbmVudCBvZiB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2LnkgLSBZIGNvbXBvbmVudCBvZiB2ZWN0b3JcbiAgICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIGludmVydGVkIHZlY3RvclxuICAgICovXG4gICBpbnZlcnQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoLXYueCwgLXYueSk7XG4gICB9LFxufTtcblxuZXhwb3J0IGNsYXNzIFYyIHtcbiAgIHN0YXRpYyBmcm9tVjIodikge1xuICAgICAgcmV0dXJuIG5ldyBWMih2KTtcbiAgIH1cblxuICAgI19sZW5ndGggPSBudWxsO1xuXG4gICBnZXQgbGVuZ3RoKCkge1xuICAgICAgaWYgKHRoaXMuI19sZW5ndGggPT0gbnVsbCkgdGhpcy4jX2xlbmd0aCA9IGdlb21ldHJ5Lmxlbmd0aCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLiNfbGVuZ3RoO1xuICAgfVxuXG4gICBnZXQgeCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wLng7XG4gICB9XG5cbiAgIGdldCB5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3AueTtcbiAgIH1cblxuICAgY29uc3RydWN0b3IocCkge1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICB9XG5cbiAgIGFkZCh2KSB7XG4gICAgICByZXR1cm4gbmV3IFYyKGdlb21ldHJ5LmFkZCh0aGlzLCB2KSk7XG4gICB9XG5cbiAgIHN1Yih2KSB7XG4gICAgICByZXR1cm4gbmV3IFYyKGdlb21ldHJ5LnN1Yih0aGlzLCB2KSk7XG4gICB9XG5cbiAgIG11bHRpcGx5KHMpIHtcbiAgICAgIHJldHVybiBuZXcgVjIoZ2VvbWV0cnkubXVsdGlwbHkodGhpcywgcykpO1xuICAgfVxuXG4gICB1bml0KCkge1xuICAgICAgcmV0dXJuIG5ldyBWMihnZW9tZXRyeS51bml0KHRoaXMpKTtcbiAgIH1cbiAgIGludmVydCgpIHtcbiAgICAgIHJldHVybiBuZXcgVjIoZ2VvbWV0cnkuaW52ZXJ0KHRoaXMpKTtcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBvaW50IHtcbiAgIHN0YXRpYyBmcm9tUG9pbnQocCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngsIHAueSk7XG4gICB9XG5cbiAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgfVxuXG4gICBhZGQodikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB2LngsIHRoaXMueSArIHYueSk7XG4gICB9XG5cbiAgIHN1Yih2KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcbiAgIH1cblxuICAgZXF1YWxzKHApIHtcbiAgICAgIHJldHVybiBwLnggPT0gdGhpcy54ICYmIHAueSA9PSB0aGlzLnk7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UGVyZm9ybWFuY2UoZiwgdHh0KSB7XG4gICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgZigpO1xuICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICBjb25zb2xlLmluZm8oYCR7dHh0fTogJHsoZW5kIC0gc3RhcnQpLnRvRml4ZWQoMyl9bXNgKTtcbn1cblxuXG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/tools.js\n\n}");

/***/ }),

/***/ "./www/code/track.js":
/*!***************************!*\
  !*** ./www/code/track.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Track: () => (/* binding */ Track)\n/* harmony export */ });\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\nclass Track {\n   static allTracks = [];\n\n   //track drawing\n   static isValidTrackNodePoint(p) {\n      return true;\n   }\n\n   static findTrackbySignal(s) {\n      return Track.allTracks.find((t) => t.signals.find((o) => o.data == s) != undefined);\n   }\n   static findTrackByPoint(p) {\n      return Track.allTracks.find((track) => {\n         return _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.pointOnLine(track.start, track.end, p);\n      });\n   }\n\n   static counter = 0;\n\n   static _getID() {\n      return Track.counter++;\n   }\n\n   static splitTrackAtPoint(track, point) {\n      const t1 = new Track(track.start, point);\n      const t2 = new Track(point, track.end);\n      const cut_km = track.getKmfromPoint(point);\n\n      track.signals.forEach((s) => {\n         if (s._positioning.km < cut_km) {\n            s._positioning.track = t1;\n            t1.AddSignal(s);\n         } else {\n            s._positioning.track = t2;\n            s._positioning.km -= cut_km;\n            t2.AddSignal(s);\n         }\n      });\n\n      return [t1, t2];\n   }\n\n   static joinTrack(track1, track2) {\n      let cut_km = track1.length;\n      track1.setNewEnd(track2.end);\n\n      // Remove any existing switch between the two tracks\n      if (track2.switchAtTheStart) {\n         _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.removeSwitch(track2.switchAtTheStart);\n      }\n\n      if (track1.switchAtTheEnd) {\n         _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.removeSwitch(track1.switchAtTheEnd);\n      }\n\n      track2.signals.forEach((s) => {\n         s._positioning.track = track1;\n         s._positioning.km += cut_km;\n         track1.AddSignal(s);\n      });\n   }\n\n   static checkNodesAndCreateTracks(points) {\n      if (points == null || points.length <= 1) return;\n\n      const new_tracks = [];\n\n      //reverse the points array if the user drew it from right to left, or if the user drew straight from bottom to top\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.first(points).x > _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.last(points).x || (_utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.first(points).x == _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.last(points).x && _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.first(points).y > _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.last(points).y)) {\n         points.reverse();\n      }\n\n      let current_point = points.shift();\n      let tmp_points = [current_point];\n\n      //iterate over all points and create tracks\n      while (points.length > 0) {\n         const next_point = points.shift();\n\n         // Check if the new segment would overlap with any existing track\n         const overlapping_tracks = Track.allTracks.filter((track) => {\n            return _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.areSegmentsOverlapping2D(current_point, next_point, track.start, track.end);\n         });\n\n         if (overlapping_tracks.length === 0) {\n            // No overlap, create a new track\n            tmp_points.push(next_point);\n            if (tmp_points.length >= 2) {\n               new_tracks.push(new Track(tmp_points[0], tmp_points[1]));\n               tmp_points = [next_point];\n            }\n         } else {\n            // Handle overlapping tracks\n            const overlapping_track = overlapping_tracks[0];\n\n            // If we have a partial track before the overlap, create it\n            if (tmp_points.length >= 2) {\n               new_tracks.push(new Track(tmp_points[0], tmp_points[1]));\n            }\n\n            // Check if we need to create a track from the last point to the overlap point\n            if (!current_point.equals(overlapping_track.start) && !current_point.equals(overlapping_track.end)) {\n               // Find the overlap point\n               const overlap_point = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.getIntersectionPoint(\n                  current_point,\n                  next_point,\n                  overlapping_track.start,\n                  overlapping_track.end\n               );\n\n               if (overlap_point) {\n                  new_tracks.push(new Track(current_point, overlap_point));\n                  tmp_points = [overlap_point];\n               }\n            }\n         }\n\n         current_point = next_point;\n      }\n\n      // Create final track if we have remaining points\n      if (tmp_points.length >= 2) {\n         new_tracks.push(new Track(tmp_points[0], tmp_points[1]));\n      }\n\n      Track.allTracks.push(...new_tracks);\n\n      return new_tracks;\n   }\n\n   static splitTracksAtIntersections() {\n      let intersection,\n         skip = false, // true if the track was already split\n         new_tracks = [],\n         remainingTracks = [...Track.allTracks]; //copy of the tracks, will be modified during the loop\n\n      //iterate over all tracks and search for intersections\n      while (remainingTracks.length > 0) {\n         skip = false;\n         const track1 = remainingTracks.shift();\n\n         //iterate over all remaining tracks\n         for (let k = 0; k < remainingTracks.length && !skip; k++) {\n            const track2 = remainingTracks[k];\n\n            // Get intersection point of the two tracks\n            intersection = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.getIntersectionPoint(track1, track2);\n\n            //check if the intersection point is on the grid\n            if (intersection && intersection.x % window.GRID_SIZE == 0 && intersection.y % window.GRID_SIZE == 0) {\n               // Split track1 if intersection is not at start or end\n               if (!intersection.equals(track1.start) && !intersection.equals(track1.end)) {\n                  const km = track1.getKmfromPoint(intersection);\n                  const signals_on_track = [...track1.signals];\n\n                  // Create two new tracks\n                  const t1 = new Track(track1.start, intersection);\n                  const t2 = new Track(intersection, track1.end);\n\n                  const startSwitch = track1.switchAtTheStart;\n                  if (startSwitch) {\n                     if (startSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch) {\n                        startSwitch.replaceTrackReference(track1, t1);\n                        t1.switchAtTheStart = startSwitch;\n                     } else if (startSwitch instanceof Track) {\n                        // If it's a track, update the track reference\n                        if (startSwitch.switchAtTheEnd === track1) {\n                           startSwitch.switchAtTheEnd = t1;\n                        } else if (startSwitch.switchAtTheStart === track1) {\n                           startSwitch.switchAtTheStart = t1; //Ich glaube das ist nicht nötig\n                        }\n                        t1.switchAtTheStart = startSwitch;\n                     }\n\n                     \n                  }\n\n                  const endSwitch = track1.switchAtTheEnd;\n                  if (endSwitch) {\n                     if (endSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch) {\n                        endSwitch.replaceTrackReference(track1, t2);\n                        t2.switchAtTheEnd = endSwitch;\n                     } else if (endSwitch instanceof Track) {\n                        // If it's a track, update the track reference\n                        if (endSwitch.switchAtTheEnd === track1) {\n                           endSwitch.switchAtTheEnd = t2;\n                        } else if (endSwitch.switchAtTheStart === track1) {\n                           endSwitch.switchAtTheStart = t2; //Ich glaube das ist nicht nötig\n                        }\n                        t2.switchAtTheEnd = endSwitch;\n                     }\n                  }\n\n                  // Remove the original track\n                  _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(Track.allTracks, track1);\n                  _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(remainingTracks, track1);\n\n                  // Add new tracks\n                  new_tracks.push(t1, t2);\n\n                  // Reassign signals to the appropriate new track\n                  signals_on_track.forEach((signal) => {\n                     if (signal._positioning.km < km) {\n                        signal.setTrack(t1, signal._positioning.km);\n                     } else {\n                        signal.setTrack(t2, signal._positioning.km - km);\n                     }\n                  });\n\n                  remainingTracks.push(t1, t2);\n                  skip = true;\n               }\n\n               // Split track2 if intersection is not at start or end\n               if (!intersection.equals(track2.start) && !intersection.equals(track2.end)) {\n                  const km = track2.getKmfromPoint(intersection);\n                  const signals_on_track = [...track2.signals];\n\n                  // Create two new tracks\n                  const t1 = new Track(track2.start, intersection);\n                  const t2 = new Track(intersection, track2.end);\n\n                  const startSwitch = track2.switchAtTheStart;\n                  if (startSwitch) {\n                     if (startSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch) {\n                        startSwitch.replaceTrackReference(track2, t1);\n                        t1.switchAtTheStart = startSwitch;\n                     } else if (startSwitch instanceof Track) {\n                        // If it's a track, update the track reference\n                        if (startSwitch.switchAtTheEnd === track2) {\n                           startSwitch.switchAtTheEnd = t1;\n                        } else if (startSwitch.switchAtTheStart === track2) {\n                           startSwitch.switchAtTheStart = t1; //Ich glaube das ist nicht nötig\n                        }\n                        t1.switchAtTheStart = startSwitch;\n                     }\n                  }\n\n                  const endSwitch = track2.switchAtTheEnd;\n                  if (endSwitch) {\n                     if (endSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch) {\n                        endSwitch.replaceTrackReference(track2, t2);\n                        t2.switchAtTheEnd = endSwitch;\n                     } else if (endSwitch instanceof Track) {\n                        // If it's a track, update the track reference\n                        if (endSwitch.switchAtTheEnd === track2) {\n                           endSwitch.switchAtTheEnd = t2;\n                        } else if (endSwitch.switchAtTheStart === track2) {\n                           endSwitch.switchAtTheStart = t2; //Ich glaube das ist nicht nötig\n                        }\n                        t2.switchAtTheEnd = endSwitch;\n                     }\n                  }\n\n                  // Remove the original track\n                  _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(Track.allTracks, track2);\n                  _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(remainingTracks, track2);\n\n                  // Add new tracks\n                  new_tracks.push(t1, t2);\n\n                  // Reassign signals to the appropriate new track\n                  signals_on_track.forEach((signal) => {\n                     if (signal._positioning.km < km) {\n                        signal.setTrack(t1, signal._positioning.km);\n                     } else {\n                        signal.setTrack(t2, signal._positioning.km - km);\n                     }\n                  });\n\n                  remainingTracks.push(t1, t2);\n                  skip = true;\n               }\n            }\n         }\n      }\n\n      // Add all new tracks to the global tracks array\n      Track.allTracks.push(...new_tracks);\n   }\n\n   static cleanUpTracks() {\n      let i = 0;\n      while (i < Track.allTracks.length) {\n         const track = Track.allTracks[i];\n\n         //searches for every track wich starts or end at that point, filters tracks wich would combine to a 90° angle\n         const connected_tracks = Track.allTracks.filter(\n            (t) => t != track && (t.start.equals(track.end) || t.end.equals(track.end))\n         );\n\n         if (connected_tracks.length == 1 && connected_tracks[0].rad == track.rad) {\n            Track.joinTrack(track, connected_tracks[0]);\n            _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(Track.allTracks, connected_tracks[0]);\n         } else i++;\n      }\n   }\n\n   static createSwitches() {\n      const processedPoints = new Set();\n\n      Track.allTracks.forEach((track) => {\n         const end_point = track.end;\n         if (!processedPoints.has(end_point)) {\n            _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.updateSwitchAtPoint(end_point);\n            processedPoints.add(end_point);\n         }\n\n         const start_point = track.start;\n         if (!processedPoints.has(start_point)) {\n            _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.updateSwitchAtPoint(start_point);\n            processedPoints.add(start_point);\n         }\n      });\n   }\n\n   static removeTrack(track) {\n      // Get switches before removing the track\n      const startSwitch = track.switchAtTheStart;\n      const endSwitch = track.switchAtTheEnd;\n\n      // Remove track from allTracks array\n      _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(Track.allTracks, track);\n\n      if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_0__.type)(track.switchAtTheStart) == \"Track\") track.switchAtTheStart.switchAtTheEnd = null;\n      if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_0__.type)(track.switchAtTheEnd) == \"Track\") track.switchAtTheEnd.switchAtTheStart = null;\n      \n      // Update switches at the former track's endpoints\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.updateSwitchAtPoint(track.start, startSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch ? startSwitch : null);\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.updateSwitchAtPoint(track.end, endSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch ? endSwitch : null);\n\n      // Remove any signals on the track\n      track.signals.forEach((signal) => {\n         _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(_signal_js__WEBPACK_IMPORTED_MODULE_2__.Signal.allSignals, signal);\n      });\n   }\n\n   static createRailNetwork() {\n      Track.splitTracksAtIntersections();\n      Track.cleanUpTracks();\n      Track.createSwitches();\n   }\n\n   #_start = null;\n   #_end = null;\n   signals = [];\n\n   switches = [null, null];\n   id = 0;\n\n   // Vector calculations (moved from TrackNode)\n   #_vector = null;\n   #_rad = null;\n   #_deg = null;\n   #_length = null;\n   #_unit = null;\n   #_slope = null;\n   #_sin = null;\n   #_cos = null;\n\n   get id() {\n      return this.id;\n   }\n\n   get start() {\n      return this.#_start;\n   }\n\n   get end() {\n      return this.#_end;\n   }\n\n   get vector() {\n      if (!this.#_vector) {\n         this.#_vector = {\n            x: this.#_end.x - this.#_start.x,\n            y: this.#_end.y - this.#_start.y,\n         };\n      }\n      return this.#_vector;\n   }\n\n   get rad() {\n      if (!this.#_rad) this.#_rad = Math.atan2(this.vector.y, this.vector.x);\n      return this.#_rad;\n   }\n\n   get deg() {\n      if (!this.#_deg) this.#_deg = this.rad * (180 / Math.PI);\n      return this.#_deg;\n   }\n\n   get length() {\n      if (!this.#_length) this.#_length = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.length(this.vector);\n      return this.#_length;\n   }\n\n   get unit() {\n      if (!this.#_unit) this.#_unit = new _tools_js__WEBPACK_IMPORTED_MODULE_0__.V2(_tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.unit(this.vector, this.length));\n      return this.#_unit;\n   }\n\n   get slope() {\n      return this.#_slope ? this.#_slope : (this.#_slope = this.vector.y / this.vector.x);\n   }\n\n   get sin() {\n      if (!this.#_sin) this.#_sin = Math.sin(this.rad);\n      return this.#_sin;\n   }\n\n   get cos() {\n      if (!this.#_cos) this.#_cos = Math.cos(this.rad);\n      return this.#_cos;\n   }\n\n   #resetCache() {\n      this.#_vector = null;\n      this.#_rad = null;\n      this.#_deg = null;\n      this.#_length = null;\n      this.#_unit = null;\n      this.#_slope = null;\n      this.#_sin = null;\n      this.#_cos = null;\n   }\n\n   get switches() {\n      return this.switches;\n   }\n\n   get switchAtTheEnd() {\n      return this.switches[1];\n   }\n\n   set switchAtTheEnd(value) {\n      this.switches[1] = value;\n   }\n\n   get switchAtTheStart() {\n      return this.switches[0];\n   }\n\n   set switchAtTheStart(value) {\n      this.switches[0] = value;\n   }\n\n   constructor(start, end) {\n      if (!start || !end) throw new Error(\"Track must have start and end points\");\n      this.id = Track._getID();\n\n      if (start instanceof _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point) this.#_start = start;\n      else this.#_start = new _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point(start.x, start.y);\n\n      if (end instanceof _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point) this.#_end = end;\n      else this.#_end = new _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point(end.x, end.y);\n   }\n\n   //returns the Point\n   getPointFromKm(km) {\n      if (km < 0 || km > this.length) {\n         throw new Error(\"Km exceeds track length\");\n      }\n      const point = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.add(this.start, _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.multiply(this.unit, km));\n      return point;\n   }\n\n   getKmfromPoint(p) {\n      if (p.equals(this.start)) {\n         return 0;\n      }\n\n      if (!_tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.pointOnLine(this.start, this.end, p)) {\n         throw new Error(\"Point is not on the track.\");\n      }\n\n      const distanceOnTrack = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.distance(this.start, p);\n      return distanceOnTrack;\n   }\n\n   //returns the point, if u go x km from point along the track, so point must be track.start or track.end\n   //the direction is automaticly optained\n   along(point, x) {\n      return _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.add(point, _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.multiply(this.unit, x));\n   }\n\n   AddSignal(signal, km, above, flipped) {\n      signal._positioning.km = km;\n      signal._positioning.track = this;\n      signal._positioning.above = above;\n      signal._positioning.flipped = flipped;\n      let i = this.signals.findIndex((s) => km < s._positioning.km);\n      if (i != -1) this.signals.splice(i, 0, signal);\n      else this.signals.push(signal);\n   }\n\n   removeSignal(s) {\n      let i = this.signals.indexOf(s);\n      if (i != -1) {\n         this.signals.splice(i, 1);\n      }\n   }\n\n   addSwitch(sw) {\n      // Store switch at index 0 for start position, 1 for end position\n      const isAtEnd = this.end.equals(sw.location);\n      this.switches[isAtEnd ? 1 : 0] = sw;\n   }\n\n   stringify() {\n      const switchData = this.switches.map((s) => {\n         if (!s) return null;\n         return { type: s.constructor.name, id: s.id };\n      });\n      return {\n         _class: \"Track\",\n         id: this.id,\n         start: this.start,\n         end: this.end,\n         signals: this.signals,\n         switches: switchData,\n      };\n   }\n\n   static FromObject(o) {\n      let t = new Track(_tools_js__WEBPACK_IMPORTED_MODULE_0__.Point.fromPoint(o.start), _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point.fromPoint(o.end));\n      t.id = o.id;\n      t.signals = o.signals;\n      t.switches_data = o.switches;\n      t.signals.forEach(function (s) {\n         s._positioning.track = t;\n      });\n      return t;\n   }\n\n   /**\n    * Changes the start point of the track to the new point\n    * @param {Point} newStart - The new start point\n    */\n   setNewStart(newStart) {\n      if (!newStart) return;\n      this.#_start = newStart;\n      this.#resetCache();\n   }\n\n   /**\n    * Changes the end point of the track to the new point\n    * @param {Point} newEnd - The new end point\n    */\n   setNewEnd(newEnd) {\n      if (!newEnd) return;\n      this.#_end = newEnd;\n      this.#resetCache();\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS90cmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFhOztBQUViO0FBQ3VEO0FBQ2xCO0FBQ0E7QUFDRzs7QUFFakM7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFRO0FBQ3hCLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLDhDQUFNO0FBQ2Y7O0FBRUE7QUFDQSxTQUFTLDhDQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsaURBQVUsbUJBQW1CLGlEQUFVLG9CQUFvQixpREFBVSxvQkFBb0IsaURBQVUsbUJBQW1CLGlEQUFVLG1CQUFtQixpREFBVTtBQUN2SztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQVE7QUFDM0IsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrQ0FBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDs7QUFFQTtBQUNBLDJCQUEyQiwrQ0FBUTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELDhDQUFNO0FBQ3REO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDhDQUFNO0FBQ3BEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpREFBVTtBQUM1QixrQkFBa0IsaURBQVU7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELDhDQUFNO0FBQ3REO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDhDQUFNO0FBQ3BEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpREFBVTtBQUM1QixrQkFBa0IsaURBQVU7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxpREFBVTtBQUN0QixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBTTtBQUNsQjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxpREFBVTs7QUFFaEIsVUFBVSwrQ0FBSTtBQUNkLFVBQVUsK0NBQUk7QUFDZDtBQUNBO0FBQ0EsTUFBTSw4Q0FBTSx5REFBeUQsOENBQU07QUFDM0UsTUFBTSw4Q0FBTSxxREFBcUQsOENBQU07O0FBRXZFO0FBQ0E7QUFDQSxTQUFTLGlEQUFVLFFBQVEsOENBQU07QUFDakMsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQywrQ0FBUTtBQUNsRDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLHlDQUFFLENBQUMsK0NBQVE7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDRDQUFLO0FBQ2hDLDhCQUE4Qiw0Q0FBSzs7QUFFbkMseUJBQXlCLDRDQUFLO0FBQzlCLDRCQUE0Qiw0Q0FBSztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFRLGlCQUFpQiwrQ0FBUTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTs7QUFFQSw4QkFBOEIsK0NBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtDQUFRLFlBQVksK0NBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDRDQUFLLHFCQUFxQiw0Q0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3RyYWNrLmpzPzZiNzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgZ2VvbWV0cnksIFYyLCBQb2ludCwgdHlwZSB9IGZyb20gJy4vdG9vbHMuanMnO1xuaW1wb3J0IHsgU3dpdGNoIH0gZnJvbSAnLi9zd2l0Y2guanMnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnLi9zaWduYWwuanMnO1xuaW1wb3J0IHsgQXJyYXlVdGlscyB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5leHBvcnQgY2xhc3MgVHJhY2sge1xuICAgc3RhdGljIGFsbFRyYWNrcyA9IFtdO1xuXG4gICAvL3RyYWNrIGRyYXdpbmdcbiAgIHN0YXRpYyBpc1ZhbGlkVHJhY2tOb2RlUG9pbnQocCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG5cbiAgIHN0YXRpYyBmaW5kVHJhY2tieVNpZ25hbChzKSB7XG4gICAgICByZXR1cm4gVHJhY2suYWxsVHJhY2tzLmZpbmQoKHQpID0+IHQuc2lnbmFscy5maW5kKChvKSA9PiBvLmRhdGEgPT0gcykgIT0gdW5kZWZpbmVkKTtcbiAgIH1cbiAgIHN0YXRpYyBmaW5kVHJhY2tCeVBvaW50KHApIHtcbiAgICAgIHJldHVybiBUcmFjay5hbGxUcmFja3MuZmluZCgodHJhY2spID0+IHtcbiAgICAgICAgIHJldHVybiBnZW9tZXRyeS5wb2ludE9uTGluZSh0cmFjay5zdGFydCwgdHJhY2suZW5kLCBwKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBzdGF0aWMgY291bnRlciA9IDA7XG5cbiAgIHN0YXRpYyBfZ2V0SUQoKSB7XG4gICAgICByZXR1cm4gVHJhY2suY291bnRlcisrO1xuICAgfVxuXG4gICBzdGF0aWMgc3BsaXRUcmFja0F0UG9pbnQodHJhY2ssIHBvaW50KSB7XG4gICAgICBjb25zdCB0MSA9IG5ldyBUcmFjayh0cmFjay5zdGFydCwgcG9pbnQpO1xuICAgICAgY29uc3QgdDIgPSBuZXcgVHJhY2socG9pbnQsIHRyYWNrLmVuZCk7XG4gICAgICBjb25zdCBjdXRfa20gPSB0cmFjay5nZXRLbWZyb21Qb2ludChwb2ludCk7XG5cbiAgICAgIHRyYWNrLnNpZ25hbHMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgaWYgKHMuX3Bvc2l0aW9uaW5nLmttIDwgY3V0X2ttKSB7XG4gICAgICAgICAgICBzLl9wb3NpdGlvbmluZy50cmFjayA9IHQxO1xuICAgICAgICAgICAgdDEuQWRkU2lnbmFsKHMpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMuX3Bvc2l0aW9uaW5nLnRyYWNrID0gdDI7XG4gICAgICAgICAgICBzLl9wb3NpdGlvbmluZy5rbSAtPSBjdXRfa207XG4gICAgICAgICAgICB0Mi5BZGRTaWduYWwocyk7XG4gICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFt0MSwgdDJdO1xuICAgfVxuXG4gICBzdGF0aWMgam9pblRyYWNrKHRyYWNrMSwgdHJhY2syKSB7XG4gICAgICBsZXQgY3V0X2ttID0gdHJhY2sxLmxlbmd0aDtcbiAgICAgIHRyYWNrMS5zZXROZXdFbmQodHJhY2syLmVuZCk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3Rpbmcgc3dpdGNoIGJldHdlZW4gdGhlIHR3byB0cmFja3NcbiAgICAgIGlmICh0cmFjazIuc3dpdGNoQXRUaGVTdGFydCkge1xuICAgICAgICAgU3dpdGNoLnJlbW92ZVN3aXRjaCh0cmFjazIuc3dpdGNoQXRUaGVTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFjazEuc3dpdGNoQXRUaGVFbmQpIHtcbiAgICAgICAgIFN3aXRjaC5yZW1vdmVTd2l0Y2godHJhY2sxLnN3aXRjaEF0VGhlRW5kKTtcbiAgICAgIH1cblxuICAgICAgdHJhY2syLnNpZ25hbHMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgcy5fcG9zaXRpb25pbmcudHJhY2sgPSB0cmFjazE7XG4gICAgICAgICBzLl9wb3NpdGlvbmluZy5rbSArPSBjdXRfa207XG4gICAgICAgICB0cmFjazEuQWRkU2lnbmFsKHMpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHN0YXRpYyBjaGVja05vZGVzQW5kQ3JlYXRlVHJhY2tzKHBvaW50cykge1xuICAgICAgaWYgKHBvaW50cyA9PSBudWxsIHx8IHBvaW50cy5sZW5ndGggPD0gMSkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBuZXdfdHJhY2tzID0gW107XG5cbiAgICAgIC8vcmV2ZXJzZSB0aGUgcG9pbnRzIGFycmF5IGlmIHRoZSB1c2VyIGRyZXcgaXQgZnJvbSByaWdodCB0byBsZWZ0LCBvciBpZiB0aGUgdXNlciBkcmV3IHN0cmFpZ2h0IGZyb20gYm90dG9tIHRvIHRvcFxuICAgICAgaWYgKEFycmF5VXRpbHMuZmlyc3QocG9pbnRzKS54ID4gQXJyYXlVdGlscy5sYXN0KHBvaW50cykueCB8fCAoQXJyYXlVdGlscy5maXJzdChwb2ludHMpLnggPT0gQXJyYXlVdGlscy5sYXN0KHBvaW50cykueCAmJiBBcnJheVV0aWxzLmZpcnN0KHBvaW50cykueSA+IEFycmF5VXRpbHMubGFzdChwb2ludHMpLnkpKSB7XG4gICAgICAgICBwb2ludHMucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY3VycmVudF9wb2ludCA9IHBvaW50cy5zaGlmdCgpO1xuICAgICAgbGV0IHRtcF9wb2ludHMgPSBbY3VycmVudF9wb2ludF07XG5cbiAgICAgIC8vaXRlcmF0ZSBvdmVyIGFsbCBwb2ludHMgYW5kIGNyZWF0ZSB0cmFja3NcbiAgICAgIHdoaWxlIChwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgY29uc3QgbmV4dF9wb2ludCA9IHBvaW50cy5zaGlmdCgpO1xuXG4gICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmV3IHNlZ21lbnQgd291bGQgb3ZlcmxhcCB3aXRoIGFueSBleGlzdGluZyB0cmFja1xuICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdfdHJhY2tzID0gVHJhY2suYWxsVHJhY2tzLmZpbHRlcigodHJhY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZW9tZXRyeS5hcmVTZWdtZW50c092ZXJsYXBwaW5nMkQoY3VycmVudF9wb2ludCwgbmV4dF9wb2ludCwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCk7XG4gICAgICAgICB9KTtcblxuICAgICAgICAgaWYgKG92ZXJsYXBwaW5nX3RyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIG92ZXJsYXAsIGNyZWF0ZSBhIG5ldyB0cmFja1xuICAgICAgICAgICAgdG1wX3BvaW50cy5wdXNoKG5leHRfcG9pbnQpO1xuICAgICAgICAgICAgaWYgKHRtcF9wb2ludHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgIG5ld190cmFja3MucHVzaChuZXcgVHJhY2sodG1wX3BvaW50c1swXSwgdG1wX3BvaW50c1sxXSkpO1xuICAgICAgICAgICAgICAgdG1wX3BvaW50cyA9IFtuZXh0X3BvaW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgb3ZlcmxhcHBpbmcgdHJhY2tzXG4gICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ190cmFjayA9IG92ZXJsYXBwaW5nX3RyYWNrc1swXTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBhcnRpYWwgdHJhY2sgYmVmb3JlIHRoZSBvdmVybGFwLCBjcmVhdGUgaXRcbiAgICAgICAgICAgIGlmICh0bXBfcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICBuZXdfdHJhY2tzLnB1c2gobmV3IFRyYWNrKHRtcF9wb2ludHNbMF0sIHRtcF9wb2ludHNbMV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBjcmVhdGUgYSB0cmFjayBmcm9tIHRoZSBsYXN0IHBvaW50IHRvIHRoZSBvdmVybGFwIHBvaW50XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRfcG9pbnQuZXF1YWxzKG92ZXJsYXBwaW5nX3RyYWNrLnN0YXJ0KSAmJiAhY3VycmVudF9wb2ludC5lcXVhbHMob3ZlcmxhcHBpbmdfdHJhY2suZW5kKSkge1xuICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgb3ZlcmxhcCBwb2ludFxuICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcF9wb2ludCA9IGdlb21ldHJ5LmdldEludGVyc2VjdGlvblBvaW50KFxuICAgICAgICAgICAgICAgICAgY3VycmVudF9wb2ludCxcbiAgICAgICAgICAgICAgICAgIG5leHRfcG9pbnQsXG4gICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ190cmFjay5zdGFydCxcbiAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nX3RyYWNrLmVuZFxuICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBfcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgIG5ld190cmFja3MucHVzaChuZXcgVHJhY2soY3VycmVudF9wb2ludCwgb3ZlcmxhcF9wb2ludCkpO1xuICAgICAgICAgICAgICAgICAgdG1wX3BvaW50cyA9IFtvdmVybGFwX3BvaW50XTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgY3VycmVudF9wb2ludCA9IG5leHRfcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBmaW5hbCB0cmFjayBpZiB3ZSBoYXZlIHJlbWFpbmluZyBwb2ludHNcbiAgICAgIGlmICh0bXBfcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICBuZXdfdHJhY2tzLnB1c2gobmV3IFRyYWNrKHRtcF9wb2ludHNbMF0sIHRtcF9wb2ludHNbMV0pKTtcbiAgICAgIH1cblxuICAgICAgVHJhY2suYWxsVHJhY2tzLnB1c2goLi4ubmV3X3RyYWNrcyk7XG5cbiAgICAgIHJldHVybiBuZXdfdHJhY2tzO1xuICAgfVxuXG4gICBzdGF0aWMgc3BsaXRUcmFja3NBdEludGVyc2VjdGlvbnMoKSB7XG4gICAgICBsZXQgaW50ZXJzZWN0aW9uLFxuICAgICAgICAgc2tpcCA9IGZhbHNlLCAvLyB0cnVlIGlmIHRoZSB0cmFjayB3YXMgYWxyZWFkeSBzcGxpdFxuICAgICAgICAgbmV3X3RyYWNrcyA9IFtdLFxuICAgICAgICAgcmVtYWluaW5nVHJhY2tzID0gWy4uLlRyYWNrLmFsbFRyYWNrc107IC8vY29weSBvZiB0aGUgdHJhY2tzLCB3aWxsIGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgbG9vcFxuXG4gICAgICAvL2l0ZXJhdGUgb3ZlciBhbGwgdHJhY2tzIGFuZCBzZWFyY2ggZm9yIGludGVyc2VjdGlvbnNcbiAgICAgIHdoaWxlIChyZW1haW5pbmdUcmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgY29uc3QgdHJhY2sxID0gcmVtYWluaW5nVHJhY2tzLnNoaWZ0KCk7XG5cbiAgICAgICAgIC8vaXRlcmF0ZSBvdmVyIGFsbCByZW1haW5pbmcgdHJhY2tzXG4gICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlbWFpbmluZ1RyYWNrcy5sZW5ndGggJiYgIXNraXA7IGsrKykge1xuICAgICAgICAgICAgY29uc3QgdHJhY2syID0gcmVtYWluaW5nVHJhY2tzW2tdO1xuXG4gICAgICAgICAgICAvLyBHZXQgaW50ZXJzZWN0aW9uIHBvaW50IG9mIHRoZSB0d28gdHJhY2tzXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludCh0cmFjazEsIHRyYWNrMik7XG5cbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGludGVyc2VjdGlvbiBwb2ludCBpcyBvbiB0aGUgZ3JpZFxuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3Rpb24ueCAlIHdpbmRvdy5HUklEX1NJWkUgPT0gMCAmJiBpbnRlcnNlY3Rpb24ueSAlIHdpbmRvdy5HUklEX1NJWkUgPT0gMCkge1xuICAgICAgICAgICAgICAgLy8gU3BsaXQgdHJhY2sxIGlmIGludGVyc2VjdGlvbiBpcyBub3QgYXQgc3RhcnQgb3IgZW5kXG4gICAgICAgICAgICAgICBpZiAoIWludGVyc2VjdGlvbi5lcXVhbHModHJhY2sxLnN0YXJ0KSAmJiAhaW50ZXJzZWN0aW9uLmVxdWFscyh0cmFjazEuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qga20gPSB0cmFjazEuZ2V0S21mcm9tUG9pbnQoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbHNfb25fdHJhY2sgPSBbLi4udHJhY2sxLnNpZ25hbHNdO1xuXG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdHdvIG5ldyB0cmFja3NcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQxID0gbmV3IFRyYWNrKHRyYWNrMS5zdGFydCwgaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQyID0gbmV3IFRyYWNrKGludGVyc2VjdGlvbiwgdHJhY2sxLmVuZCk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3dpdGNoID0gdHJhY2sxLnN3aXRjaEF0VGhlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhcnRTd2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFN3aXRjaCBpbnN0YW5jZW9mIFN3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTd2l0Y2gucmVwbGFjZVRyYWNrUmVmZXJlbmNlKHRyYWNrMSwgdDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdDEuc3dpdGNoQXRUaGVTdGFydCA9IHN0YXJ0U3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydFN3aXRjaCBpbnN0YW5jZW9mIFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgdHJhY2ssIHVwZGF0ZSB0aGUgdHJhY2sgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPT09IHRyYWNrMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVTdGFydCA9PT0gdHJhY2sxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFN3aXRjaC5zd2l0Y2hBdFRoZVN0YXJ0ID0gdDE7IC8vSWNoIGdsYXViZSBkYXMgaXN0IG5pY2h0IG7DtnRpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdDEuc3dpdGNoQXRUaGVTdGFydCA9IHN0YXJ0U3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY29uc3QgZW5kU3dpdGNoID0gdHJhY2sxLnN3aXRjaEF0VGhlRW5kO1xuICAgICAgICAgICAgICAgICAgaWYgKGVuZFN3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFN3aXRjaCBpbnN0YW5jZW9mIFN3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3dpdGNoLnJlcGxhY2VUcmFja1JlZmVyZW5jZSh0cmFjazEsIHQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQyLnN3aXRjaEF0VGhlRW5kID0gZW5kU3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRTd2l0Y2ggaW5zdGFuY2VvZiBUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIHRyYWNrLCB1cGRhdGUgdGhlIHRyYWNrIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFN3aXRjaC5zd2l0Y2hBdFRoZUVuZCA9PT0gdHJhY2sxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPSB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kU3dpdGNoLnN3aXRjaEF0VGhlU3RhcnQgPT09IHRyYWNrMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3dpdGNoLnN3aXRjaEF0VGhlU3RhcnQgPSB0MjsgLy9JY2ggZ2xhdWJlIGRhcyBpc3QgbmljaHQgbsO2dGlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0Mi5zd2l0Y2hBdFRoZUVuZCA9IGVuZFN3aXRjaDtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcmlnaW5hbCB0cmFja1xuICAgICAgICAgICAgICAgICAgQXJyYXlVdGlscy5yZW1vdmUoVHJhY2suYWxsVHJhY2tzLCB0cmFjazEpO1xuICAgICAgICAgICAgICAgICAgQXJyYXlVdGlscy5yZW1vdmUocmVtYWluaW5nVHJhY2tzLCB0cmFjazEpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IHRyYWNrc1xuICAgICAgICAgICAgICAgICAgbmV3X3RyYWNrcy5wdXNoKHQxLCB0Mik7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFJlYXNzaWduIHNpZ25hbHMgdG8gdGhlIGFwcHJvcHJpYXRlIG5ldyB0cmFja1xuICAgICAgICAgICAgICAgICAgc2lnbmFsc19vbl90cmFjay5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWwuX3Bvc2l0aW9uaW5nLmttIDwga20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5zZXRUcmFjayh0MSwgc2lnbmFsLl9wb3NpdGlvbmluZy5rbSk7XG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldFRyYWNrKHQyLCBzaWduYWwuX3Bvc2l0aW9uaW5nLmttIC0ga20pO1xuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ1RyYWNrcy5wdXNoKHQxLCB0Mik7XG4gICAgICAgICAgICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgLy8gU3BsaXQgdHJhY2syIGlmIGludGVyc2VjdGlvbiBpcyBub3QgYXQgc3RhcnQgb3IgZW5kXG4gICAgICAgICAgICAgICBpZiAoIWludGVyc2VjdGlvbi5lcXVhbHModHJhY2syLnN0YXJ0KSAmJiAhaW50ZXJzZWN0aW9uLmVxdWFscyh0cmFjazIuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qga20gPSB0cmFjazIuZ2V0S21mcm9tUG9pbnQoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbHNfb25fdHJhY2sgPSBbLi4udHJhY2syLnNpZ25hbHNdO1xuXG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdHdvIG5ldyB0cmFja3NcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQxID0gbmV3IFRyYWNrKHRyYWNrMi5zdGFydCwgaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQyID0gbmV3IFRyYWNrKGludGVyc2VjdGlvbiwgdHJhY2syLmVuZCk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3dpdGNoID0gdHJhY2syLnN3aXRjaEF0VGhlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhcnRTd2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFN3aXRjaCBpbnN0YW5jZW9mIFN3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTd2l0Y2gucmVwbGFjZVRyYWNrUmVmZXJlbmNlKHRyYWNrMiwgdDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdDEuc3dpdGNoQXRUaGVTdGFydCA9IHN0YXJ0U3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydFN3aXRjaCBpbnN0YW5jZW9mIFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgdHJhY2ssIHVwZGF0ZSB0aGUgdHJhY2sgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPT09IHRyYWNrMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVTdGFydCA9PT0gdHJhY2syKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFN3aXRjaC5zd2l0Y2hBdFRoZVN0YXJ0ID0gdDE7IC8vSWNoIGdsYXViZSBkYXMgaXN0IG5pY2h0IG7DtnRpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdDEuc3dpdGNoQXRUaGVTdGFydCA9IHN0YXJ0U3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBjb25zdCBlbmRTd2l0Y2ggPSB0cmFjazIuc3dpdGNoQXRUaGVFbmQ7XG4gICAgICAgICAgICAgICAgICBpZiAoZW5kU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICBpZiAoZW5kU3dpdGNoIGluc3RhbmNlb2YgU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRTd2l0Y2gucmVwbGFjZVRyYWNrUmVmZXJlbmNlKHRyYWNrMiwgdDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdDIuc3dpdGNoQXRUaGVFbmQgPSBlbmRTd2l0Y2g7XG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZFN3aXRjaCBpbnN0YW5jZW9mIFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgdHJhY2ssIHVwZGF0ZSB0aGUgdHJhY2sgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kU3dpdGNoLnN3aXRjaEF0VGhlRW5kID09PSB0cmFjazIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFN3aXRjaC5zd2l0Y2hBdFRoZUVuZCA9IHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRTd2l0Y2guc3dpdGNoQXRUaGVTdGFydCA9PT0gdHJhY2syKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRTd2l0Y2guc3dpdGNoQXRUaGVTdGFydCA9IHQyOyAvL0ljaCBnbGF1YmUgZGFzIGlzdCBuaWNodCBuw7Z0aWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHQyLnN3aXRjaEF0VGhlRW5kID0gZW5kU3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9yaWdpbmFsIHRyYWNrXG4gICAgICAgICAgICAgICAgICBBcnJheVV0aWxzLnJlbW92ZShUcmFjay5hbGxUcmFja3MsIHRyYWNrMik7XG4gICAgICAgICAgICAgICAgICBBcnJheVV0aWxzLnJlbW92ZShyZW1haW5pbmdUcmFja3MsIHRyYWNrMik7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgdHJhY2tzXG4gICAgICAgICAgICAgICAgICBuZXdfdHJhY2tzLnB1c2godDEsIHQyKTtcblxuICAgICAgICAgICAgICAgICAgLy8gUmVhc3NpZ24gc2lnbmFscyB0byB0aGUgYXBwcm9wcmlhdGUgbmV3IHRyYWNrXG4gICAgICAgICAgICAgICAgICBzaWduYWxzX29uX3RyYWNrLmZvckVhY2goKHNpZ25hbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5fcG9zaXRpb25pbmcua20gPCBrbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldFRyYWNrKHQxLCBzaWduYWwuX3Bvc2l0aW9uaW5nLmttKTtcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuc2V0VHJhY2sodDIsIHNpZ25hbC5fcG9zaXRpb25pbmcua20gLSBrbSk7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgcmVtYWluaW5nVHJhY2tzLnB1c2godDEsIHQyKTtcbiAgICAgICAgICAgICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYWxsIG5ldyB0cmFja3MgdG8gdGhlIGdsb2JhbCB0cmFja3MgYXJyYXlcbiAgICAgIFRyYWNrLmFsbFRyYWNrcy5wdXNoKC4uLm5ld190cmFja3MpO1xuICAgfVxuXG4gICBzdGF0aWMgY2xlYW5VcFRyYWNrcygpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgVHJhY2suYWxsVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgY29uc3QgdHJhY2sgPSBUcmFjay5hbGxUcmFja3NbaV07XG5cbiAgICAgICAgIC8vc2VhcmNoZXMgZm9yIGV2ZXJ5IHRyYWNrIHdpY2ggc3RhcnRzIG9yIGVuZCBhdCB0aGF0IHBvaW50LCBmaWx0ZXJzIHRyYWNrcyB3aWNoIHdvdWxkIGNvbWJpbmUgdG8gYSA5MMKwIGFuZ2xlXG4gICAgICAgICBjb25zdCBjb25uZWN0ZWRfdHJhY2tzID0gVHJhY2suYWxsVHJhY2tzLmZpbHRlcihcbiAgICAgICAgICAgICh0KSA9PiB0ICE9IHRyYWNrICYmICh0LnN0YXJ0LmVxdWFscyh0cmFjay5lbmQpIHx8IHQuZW5kLmVxdWFscyh0cmFjay5lbmQpKVxuICAgICAgICAgKTtcblxuICAgICAgICAgaWYgKGNvbm5lY3RlZF90cmFja3MubGVuZ3RoID09IDEgJiYgY29ubmVjdGVkX3RyYWNrc1swXS5yYWQgPT0gdHJhY2sucmFkKSB7XG4gICAgICAgICAgICBUcmFjay5qb2luVHJhY2sodHJhY2ssIGNvbm5lY3RlZF90cmFja3NbMF0pO1xuICAgICAgICAgICAgQXJyYXlVdGlscy5yZW1vdmUoVHJhY2suYWxsVHJhY2tzLCBjb25uZWN0ZWRfdHJhY2tzWzBdKTtcbiAgICAgICAgIH0gZWxzZSBpKys7XG4gICAgICB9XG4gICB9XG5cbiAgIHN0YXRpYyBjcmVhdGVTd2l0Y2hlcygpIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZFBvaW50cyA9IG5ldyBTZXQoKTtcblxuICAgICAgVHJhY2suYWxsVHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICBjb25zdCBlbmRfcG9pbnQgPSB0cmFjay5lbmQ7XG4gICAgICAgICBpZiAoIXByb2Nlc3NlZFBvaW50cy5oYXMoZW5kX3BvaW50KSkge1xuICAgICAgICAgICAgU3dpdGNoLnVwZGF0ZVN3aXRjaEF0UG9pbnQoZW5kX3BvaW50KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZFBvaW50cy5hZGQoZW5kX3BvaW50KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgY29uc3Qgc3RhcnRfcG9pbnQgPSB0cmFjay5zdGFydDtcbiAgICAgICAgIGlmICghcHJvY2Vzc2VkUG9pbnRzLmhhcyhzdGFydF9wb2ludCkpIHtcbiAgICAgICAgICAgIFN3aXRjaC51cGRhdGVTd2l0Y2hBdFBvaW50KHN0YXJ0X3BvaW50KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZFBvaW50cy5hZGQoc3RhcnRfcG9pbnQpO1xuICAgICAgICAgfVxuICAgICAgfSk7XG4gICB9XG5cbiAgIHN0YXRpYyByZW1vdmVUcmFjayh0cmFjaykge1xuICAgICAgLy8gR2V0IHN3aXRjaGVzIGJlZm9yZSByZW1vdmluZyB0aGUgdHJhY2tcbiAgICAgIGNvbnN0IHN0YXJ0U3dpdGNoID0gdHJhY2suc3dpdGNoQXRUaGVTdGFydDtcbiAgICAgIGNvbnN0IGVuZFN3aXRjaCA9IHRyYWNrLnN3aXRjaEF0VGhlRW5kO1xuXG4gICAgICAvLyBSZW1vdmUgdHJhY2sgZnJvbSBhbGxUcmFja3MgYXJyYXlcbiAgICAgIEFycmF5VXRpbHMucmVtb3ZlKFRyYWNrLmFsbFRyYWNrcywgdHJhY2spO1xuXG4gICAgICBpZiAodHlwZSh0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0KSA9PSBcIlRyYWNrXCIpIHRyYWNrLnN3aXRjaEF0VGhlU3RhcnQuc3dpdGNoQXRUaGVFbmQgPSBudWxsO1xuICAgICAgaWYgKHR5cGUodHJhY2suc3dpdGNoQXRUaGVFbmQpID09IFwiVHJhY2tcIikgdHJhY2suc3dpdGNoQXRUaGVFbmQuc3dpdGNoQXRUaGVTdGFydCA9IG51bGw7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzd2l0Y2hlcyBhdCB0aGUgZm9ybWVyIHRyYWNrJ3MgZW5kcG9pbnRzXG4gICAgICBTd2l0Y2gudXBkYXRlU3dpdGNoQXRQb2ludCh0cmFjay5zdGFydCwgc3RhcnRTd2l0Y2ggaW5zdGFuY2VvZiBTd2l0Y2ggPyBzdGFydFN3aXRjaCA6IG51bGwpO1xuICAgICAgU3dpdGNoLnVwZGF0ZVN3aXRjaEF0UG9pbnQodHJhY2suZW5kLCBlbmRTd2l0Y2ggaW5zdGFuY2VvZiBTd2l0Y2ggPyBlbmRTd2l0Y2ggOiBudWxsKTtcblxuICAgICAgLy8gUmVtb3ZlIGFueSBzaWduYWxzIG9uIHRoZSB0cmFja1xuICAgICAgdHJhY2suc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgIEFycmF5VXRpbHMucmVtb3ZlKFNpZ25hbC5hbGxTaWduYWxzLCBzaWduYWwpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHN0YXRpYyBjcmVhdGVSYWlsTmV0d29yaygpIHtcbiAgICAgIFRyYWNrLnNwbGl0VHJhY2tzQXRJbnRlcnNlY3Rpb25zKCk7XG4gICAgICBUcmFjay5jbGVhblVwVHJhY2tzKCk7XG4gICAgICBUcmFjay5jcmVhdGVTd2l0Y2hlcygpO1xuICAgfVxuXG4gICAjX3N0YXJ0ID0gbnVsbDtcbiAgICNfZW5kID0gbnVsbDtcbiAgIHNpZ25hbHMgPSBbXTtcblxuICAgc3dpdGNoZXMgPSBbbnVsbCwgbnVsbF07XG4gICBpZCA9IDA7XG5cbiAgIC8vIFZlY3RvciBjYWxjdWxhdGlvbnMgKG1vdmVkIGZyb20gVHJhY2tOb2RlKVxuICAgI192ZWN0b3IgPSBudWxsO1xuICAgI19yYWQgPSBudWxsO1xuICAgI19kZWcgPSBudWxsO1xuICAgI19sZW5ndGggPSBudWxsO1xuICAgI191bml0ID0gbnVsbDtcbiAgICNfc2xvcGUgPSBudWxsO1xuICAgI19zaW4gPSBudWxsO1xuICAgI19jb3MgPSBudWxsO1xuXG4gICBnZXQgaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZDtcbiAgIH1cblxuICAgZ2V0IHN0YXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19zdGFydDtcbiAgIH1cblxuICAgZ2V0IGVuZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfZW5kO1xuICAgfVxuXG4gICBnZXQgdmVjdG9yKCkge1xuICAgICAgaWYgKCF0aGlzLiNfdmVjdG9yKSB7XG4gICAgICAgICB0aGlzLiNfdmVjdG9yID0ge1xuICAgICAgICAgICAgeDogdGhpcy4jX2VuZC54IC0gdGhpcy4jX3N0YXJ0LngsXG4gICAgICAgICAgICB5OiB0aGlzLiNfZW5kLnkgLSB0aGlzLiNfc3RhcnQueSxcbiAgICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jX3ZlY3RvcjtcbiAgIH1cblxuICAgZ2V0IHJhZCgpIHtcbiAgICAgIGlmICghdGhpcy4jX3JhZCkgdGhpcy4jX3JhZCA9IE1hdGguYXRhbjIodGhpcy52ZWN0b3IueSwgdGhpcy52ZWN0b3IueCk7XG4gICAgICByZXR1cm4gdGhpcy4jX3JhZDtcbiAgIH1cblxuICAgZ2V0IGRlZygpIHtcbiAgICAgIGlmICghdGhpcy4jX2RlZykgdGhpcy4jX2RlZyA9IHRoaXMucmFkICogKDE4MCAvIE1hdGguUEkpO1xuICAgICAgcmV0dXJuIHRoaXMuI19kZWc7XG4gICB9XG5cbiAgIGdldCBsZW5ndGgoKSB7XG4gICAgICBpZiAoIXRoaXMuI19sZW5ndGgpIHRoaXMuI19sZW5ndGggPSBnZW9tZXRyeS5sZW5ndGgodGhpcy52ZWN0b3IpO1xuICAgICAgcmV0dXJuIHRoaXMuI19sZW5ndGg7XG4gICB9XG5cbiAgIGdldCB1bml0KCkge1xuICAgICAgaWYgKCF0aGlzLiNfdW5pdCkgdGhpcy4jX3VuaXQgPSBuZXcgVjIoZ2VvbWV0cnkudW5pdCh0aGlzLnZlY3RvciwgdGhpcy5sZW5ndGgpKTtcbiAgICAgIHJldHVybiB0aGlzLiNfdW5pdDtcbiAgIH1cblxuICAgZ2V0IHNsb3BlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19zbG9wZSA/IHRoaXMuI19zbG9wZSA6ICh0aGlzLiNfc2xvcGUgPSB0aGlzLnZlY3Rvci55IC8gdGhpcy52ZWN0b3IueCk7XG4gICB9XG5cbiAgIGdldCBzaW4oKSB7XG4gICAgICBpZiAoIXRoaXMuI19zaW4pIHRoaXMuI19zaW4gPSBNYXRoLnNpbih0aGlzLnJhZCk7XG4gICAgICByZXR1cm4gdGhpcy4jX3NpbjtcbiAgIH1cblxuICAgZ2V0IGNvcygpIHtcbiAgICAgIGlmICghdGhpcy4jX2NvcykgdGhpcy4jX2NvcyA9IE1hdGguY29zKHRoaXMucmFkKTtcbiAgICAgIHJldHVybiB0aGlzLiNfY29zO1xuICAgfVxuXG4gICAjcmVzZXRDYWNoZSgpIHtcbiAgICAgIHRoaXMuI192ZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy4jX3JhZCA9IG51bGw7XG4gICAgICB0aGlzLiNfZGVnID0gbnVsbDtcbiAgICAgIHRoaXMuI19sZW5ndGggPSBudWxsO1xuICAgICAgdGhpcy4jX3VuaXQgPSBudWxsO1xuICAgICAgdGhpcy4jX3Nsb3BlID0gbnVsbDtcbiAgICAgIHRoaXMuI19zaW4gPSBudWxsO1xuICAgICAgdGhpcy4jX2NvcyA9IG51bGw7XG4gICB9XG5cbiAgIGdldCBzd2l0Y2hlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN3aXRjaGVzO1xuICAgfVxuXG4gICBnZXQgc3dpdGNoQXRUaGVFbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zd2l0Y2hlc1sxXTtcbiAgIH1cblxuICAgc2V0IHN3aXRjaEF0VGhlRW5kKHZhbHVlKSB7XG4gICAgICB0aGlzLnN3aXRjaGVzWzFdID0gdmFsdWU7XG4gICB9XG5cbiAgIGdldCBzd2l0Y2hBdFRoZVN0YXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3dpdGNoZXNbMF07XG4gICB9XG5cbiAgIHNldCBzd2l0Y2hBdFRoZVN0YXJ0KHZhbHVlKSB7XG4gICAgICB0aGlzLnN3aXRjaGVzWzBdID0gdmFsdWU7XG4gICB9XG5cbiAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghc3RhcnQgfHwgIWVuZCkgdGhyb3cgbmV3IEVycm9yKFwiVHJhY2sgbXVzdCBoYXZlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXCIpO1xuICAgICAgdGhpcy5pZCA9IFRyYWNrLl9nZXRJRCgpO1xuXG4gICAgICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBQb2ludCkgdGhpcy4jX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICBlbHNlIHRoaXMuI19zdGFydCA9IG5ldyBQb2ludChzdGFydC54LCBzdGFydC55KTtcblxuICAgICAgaWYgKGVuZCBpbnN0YW5jZW9mIFBvaW50KSB0aGlzLiNfZW5kID0gZW5kO1xuICAgICAgZWxzZSB0aGlzLiNfZW5kID0gbmV3IFBvaW50KGVuZC54LCBlbmQueSk7XG4gICB9XG5cbiAgIC8vcmV0dXJucyB0aGUgUG9pbnRcbiAgIGdldFBvaW50RnJvbUttKGttKSB7XG4gICAgICBpZiAoa20gPCAwIHx8IGttID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkttIGV4Y2VlZHMgdHJhY2sgbGVuZ3RoXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnQgPSBnZW9tZXRyeS5hZGQodGhpcy5zdGFydCwgZ2VvbWV0cnkubXVsdGlwbHkodGhpcy51bml0LCBrbSkpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgfVxuXG4gICBnZXRLbWZyb21Qb2ludChwKSB7XG4gICAgICBpZiAocC5lcXVhbHModGhpcy5zdGFydCkpIHtcbiAgICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdlb21ldHJ5LnBvaW50T25MaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCBwKSkge1xuICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9pbnQgaXMgbm90IG9uIHRoZSB0cmFjay5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpc3RhbmNlT25UcmFjayA9IGdlb21ldHJ5LmRpc3RhbmNlKHRoaXMuc3RhcnQsIHApO1xuICAgICAgcmV0dXJuIGRpc3RhbmNlT25UcmFjaztcbiAgIH1cblxuICAgLy9yZXR1cm5zIHRoZSBwb2ludCwgaWYgdSBnbyB4IGttIGZyb20gcG9pbnQgYWxvbmcgdGhlIHRyYWNrLCBzbyBwb2ludCBtdXN0IGJlIHRyYWNrLnN0YXJ0IG9yIHRyYWNrLmVuZFxuICAgLy90aGUgZGlyZWN0aW9uIGlzIGF1dG9tYXRpY2x5IG9wdGFpbmVkXG4gICBhbG9uZyhwb2ludCwgeCkge1xuICAgICAgcmV0dXJuIGdlb21ldHJ5LmFkZChwb2ludCwgZ2VvbWV0cnkubXVsdGlwbHkodGhpcy51bml0LCB4KSk7XG4gICB9XG5cbiAgIEFkZFNpZ25hbChzaWduYWwsIGttLCBhYm92ZSwgZmxpcHBlZCkge1xuICAgICAgc2lnbmFsLl9wb3NpdGlvbmluZy5rbSA9IGttO1xuICAgICAgc2lnbmFsLl9wb3NpdGlvbmluZy50cmFjayA9IHRoaXM7XG4gICAgICBzaWduYWwuX3Bvc2l0aW9uaW5nLmFib3ZlID0gYWJvdmU7XG4gICAgICBzaWduYWwuX3Bvc2l0aW9uaW5nLmZsaXBwZWQgPSBmbGlwcGVkO1xuICAgICAgbGV0IGkgPSB0aGlzLnNpZ25hbHMuZmluZEluZGV4KChzKSA9PiBrbSA8IHMuX3Bvc2l0aW9uaW5nLmttKTtcbiAgICAgIGlmIChpICE9IC0xKSB0aGlzLnNpZ25hbHMuc3BsaWNlKGksIDAsIHNpZ25hbCk7XG4gICAgICBlbHNlIHRoaXMuc2lnbmFscy5wdXNoKHNpZ25hbCk7XG4gICB9XG5cbiAgIHJlbW92ZVNpZ25hbChzKSB7XG4gICAgICBsZXQgaSA9IHRoaXMuc2lnbmFscy5pbmRleE9mKHMpO1xuICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgIHRoaXMuc2lnbmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICB9XG5cbiAgIGFkZFN3aXRjaChzdykge1xuICAgICAgLy8gU3RvcmUgc3dpdGNoIGF0IGluZGV4IDAgZm9yIHN0YXJ0IHBvc2l0aW9uLCAxIGZvciBlbmQgcG9zaXRpb25cbiAgICAgIGNvbnN0IGlzQXRFbmQgPSB0aGlzLmVuZC5lcXVhbHMoc3cubG9jYXRpb24pO1xuICAgICAgdGhpcy5zd2l0Y2hlc1tpc0F0RW5kID8gMSA6IDBdID0gc3c7XG4gICB9XG5cbiAgIHN0cmluZ2lmeSgpIHtcbiAgICAgIGNvbnN0IHN3aXRjaERhdGEgPSB0aGlzLnN3aXRjaGVzLm1hcCgocykgPT4ge1xuICAgICAgICAgaWYgKCFzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgIHJldHVybiB7IHR5cGU6IHMuY29uc3RydWN0b3IubmFtZSwgaWQ6IHMuaWQgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIF9jbGFzczogXCJUcmFja1wiLFxuICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgICAgIGVuZDogdGhpcy5lbmQsXG4gICAgICAgICBzaWduYWxzOiB0aGlzLnNpZ25hbHMsXG4gICAgICAgICBzd2l0Y2hlczogc3dpdGNoRGF0YSxcbiAgICAgIH07XG4gICB9XG5cbiAgIHN0YXRpYyBGcm9tT2JqZWN0KG8pIHtcbiAgICAgIGxldCB0ID0gbmV3IFRyYWNrKFBvaW50LmZyb21Qb2ludChvLnN0YXJ0KSwgUG9pbnQuZnJvbVBvaW50KG8uZW5kKSk7XG4gICAgICB0LmlkID0gby5pZDtcbiAgICAgIHQuc2lnbmFscyA9IG8uc2lnbmFscztcbiAgICAgIHQuc3dpdGNoZXNfZGF0YSA9IG8uc3dpdGNoZXM7XG4gICAgICB0LnNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgcy5fcG9zaXRpb25pbmcudHJhY2sgPSB0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdDtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGFuZ2VzIHRoZSBzdGFydCBwb2ludCBvZiB0aGUgdHJhY2sgdG8gdGhlIG5ldyBwb2ludFxuICAgICogQHBhcmFtIHtQb2ludH0gbmV3U3RhcnQgLSBUaGUgbmV3IHN0YXJ0IHBvaW50XG4gICAgKi9cbiAgIHNldE5ld1N0YXJ0KG5ld1N0YXJ0KSB7XG4gICAgICBpZiAoIW5ld1N0YXJ0KSByZXR1cm47XG4gICAgICB0aGlzLiNfc3RhcnQgPSBuZXdTdGFydDtcbiAgICAgIHRoaXMuI3Jlc2V0Q2FjaGUoKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGFuZ2VzIHRoZSBlbmQgcG9pbnQgb2YgdGhlIHRyYWNrIHRvIHRoZSBuZXcgcG9pbnRcbiAgICAqIEBwYXJhbSB7UG9pbnR9IG5ld0VuZCAtIFRoZSBuZXcgZW5kIHBvaW50XG4gICAgKi9cbiAgIHNldE5ld0VuZChuZXdFbmQpIHtcbiAgICAgIGlmICghbmV3RW5kKSByZXR1cm47XG4gICAgICB0aGlzLiNfZW5kID0gbmV3RW5kO1xuICAgICAgdGhpcy4jcmVzZXRDYWNoZSgpO1xuICAgfVxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/track.js\n\n}");

/***/ }),

/***/ "./www/code/trackRendering_basic.js":
/*!******************************************!*\
  !*** ./www/code/trackRendering_basic.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trackRendering_basic: () => (/* binding */ trackRendering_basic)\n/* harmony export */ });\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\nclass trackRendering_basic {\n   static TRACK_COLOR = \"#111111\";\n   static SWITCH_UI_COLOR = \"gray\";\n   static SWITCH_UI_COLOR_SELECTED = \"#eee\";\n   static STROKE = 6;\n   static HIT_TEST_DISTANCE = 10;\n   static BUMPER_SIZE = 8;\n   static SWITCH_SIZE = 30;\n\n   constructor() {\n      this.SIGNAL_DISTANCE_FROM_TRACK = 18;\n   }\n\n   reDrawEverything() {\n      window.track_container.removeAllChildren();\n      window.signal_container.removeAllChildren();\n      window.train_container.removeAllChildren();\n      window.ui_container.removeAllChildren();\n      window.debug_container.removeAllChildren();\n      window.object_container.removeAllChildren();\n\n      this.renderAllTracks();\n      this.renderAllSwitches();\n      this.renderAllGenericObjects();\n      this.renderAllSignals();\n      window.stage.update();\n   }\n\n   renderAllSignals() {\n      window.signal_container.removeAllChildren();\n      _signal_js__WEBPACK_IMPORTED_MODULE_2__.Signal.allSignals.forEach((signal) => {\n         let container = window.signal_container.addChild(_signal_js__WEBPACK_IMPORTED_MODULE_2__.SignalRenderer.createSignalContainer(signal));\n         window.alignSignalContainerWithTrack(container, signal._positioning);\n         if (window.selection.isSelectedObject(signal)) {\n            container.shadow = new createjs.Shadow(\"#ff0000\", 0, 0, 3);\n         }\n      });\n   }\n\n   renderAllTracks() {\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.forEach((t) => {\n         this.renderTrack(window.track_container, t);\n      });\n   }\n\n   isSelected(c) {\n      c.color.style = \"#ff0000\";\n   }\n\n   updateSelection() {\n      window.track_container.children.forEach((c) => {\n         if (c.data) {\n            if (window.selection.isSelectedObject(c.data)) this.isSelected(c);\n            else c.color.style = trackRendering_basic.TRACK_COLOR;\n         }\n      });\n      window.signal_container.children.forEach(function (c) {\n         if (c.data) {\n            if (window.selection.isSelectedObject(c.data)) c.shadow = new createjs.Shadow(\"#ff0000\", 0, 0, 3);\n            else c.shadow = null;\n         }\n      });\n      window.stage.update();\n   }\n\n   renderAllGenericObjects() {\n      window.object_container.removeAllChildren();\n      _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects.forEach((o) => {\n         const c = new createjs.Container();\n         c.name = \"object\";\n         c.object = o;\n         c.mouseChildren = false;\n         c.x = o.pos().x;\n         c.y = o.pos().y;\n\n         if (o.type() === _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.OBJECT_TYPE.text) this.renderTextObject(o, c);\n         else if (o.type() === _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.OBJECT_TYPE.plattform) this.renderPlattformObject(o, c);\n         else throw new Error(\"Unknown Object\");\n\n         window.object_container.addChild(c);\n      });\n   }\n\n   renderTextObject(text_object, container) {\n      var text = new createjs.Text(text_object.content(), \"20px Arial\", \"#000000\");\n      text.textBaseline = \"alphabetic\";\n      const height = text.getMeasuredHeight();\n      const width = text.getMeasuredWidth();\n\n      const hit = new createjs.Shape();\n      hit.graphics.beginFill(\"#000\").mt(0, 0).lt(width, 0).lt(width, -height).lt(0, -height).lt(0, 0);\n\n      text.hitArea = hit;\n\n      container.addChild(text);\n   }\n\n   renderPlattformObject(plattform, container) {\n      const shape = new createjs.Shape();\n      container.addChild(shape);\n      shape.graphics.beginStroke(\"#111111\").beginFill(\"#444\").drawRect(0, 0, plattform.size().width, plattform.size().height);\n\n      var text = new createjs.Text(plattform.content(), \"20px Arial\", \"#eee\");\n      text.textBaseline = \"middle\";\n      text.textAlign = \"center\";\n      text.x = plattform.size().width / 2;\n      text.y = plattform.size().height / 2;\n\n      container.addChild(text);\n   }\n\n   calculateTrackDrawingParameters(track) {\n      let corr_start = track.start,\n         corr_end = track.end;\n      let bumper_start, bumper_end;\n\n      if (!track.switchAtTheStart) {\n         //prellbock beim start\n         const B1 = track.start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(-trackRendering_basic.BUMPER_SIZE));\n         const B2 = track.start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(trackRendering_basic.BUMPER_SIZE));\n         bumper_start = [B1, B2];\n      } else if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_5__.type)(track.switchAtTheStart) == \"Switch\") {\n         corr_start = track.along(track.switchAtTheStart.location, track.switchAtTheStart.size);\n      }\n\n      if (!track.switchAtTheEnd) {\n         //prellbock beim ende\n         const B1 = track.end.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(-trackRendering_basic.BUMPER_SIZE));\n         const B2 = track.end.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(trackRendering_basic.BUMPER_SIZE));\n         bumper_end = [B1, B2];\n      } else if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_5__.type)(track.switchAtTheEnd) == \"Switch\") {\n         corr_end = track.along(track.switchAtTheEnd.location, -track.switchAtTheEnd.size);\n      }\n\n      const p1 = corr_start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(-trackRendering_basic.HIT_TEST_DISTANCE));\n      const p2 = corr_start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(trackRendering_basic.HIT_TEST_DISTANCE));\n      const p3 = corr_end.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(trackRendering_basic.HIT_TEST_DISTANCE));\n      const p4 = corr_end.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(-trackRendering_basic.HIT_TEST_DISTANCE));\n      return {\n         hit_area: [p1, p2, p3, p4],\n         bumper: [bumper_start, bumper_end],\n         start: corr_start,\n         end: corr_end,\n      };\n   }\n\n   renderTrack(container, track) {\n      let params = this.calculateTrackDrawingParameters(track);\n      let shape = new createjs.Shape();\n      shape.name = \"track\";\n      shape.data = track;\n\n      let hit = new createjs.Shape();\n\n      hit.graphics\n         .beginFill(\"#000\")\n         .mt(params.hit_area[0].x, params.hit_area[0].y)\n         .lt(params.hit_area[1].x, params.hit_area[1].y)\n         .lt(params.hit_area[2].x, params.hit_area[2].y)\n         .lt(params.hit_area[3].x, params.hit_area[3].y)\n         .lt(params.hit_area[0].x, params.hit_area[0].y);\n      shape.hitArea = hit;\n\n      //container.addChild(hit);\n      container.addChild(shape);\n\n      shape.graphics.setStrokeStyle(trackRendering_basic.STROKE, \"round\").beginStroke(trackRendering_basic.TRACK_COLOR);\n      shape.color = shape.graphics.command;\n      shape.graphics.moveTo(params.start.x, params.start.y).lineTo(params.end.x, params.end.y);\n      if (params.bumper[0]) {\n         //prellbock beim start\n         shape.graphics.moveTo(params.bumper[0][0].x, params.bumper[0][0].y).lineTo(params.bumper[0][1].x, params.bumper[0][1].y);\n      }\n\n      if (params.bumper[1]) {\n         //prellbock beim ende\n         shape.graphics.moveTo(params.bumper[1][0].x, params.bumper[1][0].y).lineTo(params.bumper[1][1].x, params.bumper[1][1].y);\n      }\n      if (window.selection.isSelectedObject(track)) this.isSelected(shape);\n\n      const text = new createjs.Text(track.id, \"Italic 10px Arial\", \"black\");\n      const p = track.along(track.start, track.length / 2).add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(15));\n\n      text.x = p.x;\n      text.y = p.y;\n      text.textBaseline = \"alphabetic\";\n      window.ui_container.addChild(text);\n\n      shape.setBounds(\n         params.start.x - trackRendering_basic.HIT_TEST_DISTANCE,\n         params.start.y - trackRendering_basic.HIT_TEST_DISTANCE,\n         params.end.x - params.start.x + trackRendering_basic.HIT_TEST_DISTANCE * 2,\n         params.end.y - params.start.y + trackRendering_basic.HIT_TEST_DISTANCE * 2\n      );\n\n      return shape;\n   }\n\n   static drawTriangle(graphics, color, p1, p2, p3) {\n      graphics.beginFill(color)\n         .mt(p1.x, p1.y)\n         .lt(p2.x, p2.y)\n         .lt(p3.x, p3.y)\n         .lt(p1.x, p1.y);\n   }\n\n   renderAllSwitches() {\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.forEach((sw) => {\n         if (!sw.track1 || !sw.track2 || !sw.track3 || (sw.type == _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.DKW && !sw.track4)) {\n            console.log(sw);\n            throw new Error(\"switch is falty\");\n         }\n         let switch_shape = new createjs.Shape();\n         switch_shape.name = \"switch\";\n         switch_shape.data = sw;\n         window.track_container.addChild(switch_shape);\n\n         // Draw the switch branch tracks\n         switch_shape.graphics.setStrokeStyle(trackRendering_basic.STROKE, \"round\").beginStroke(trackRendering_basic.TRACK_COLOR);\n\n         // Draw all track branches using a loop\n         const maxTracks = sw.type == _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.DKW ? 4 : 3;\n         for (let i = 0; i < maxTracks; i++) {\n            if (sw.track_directions[i]) {\n               let end_point = sw.getBranchEndPoint(i);\n               switch_shape.graphics.moveTo(sw.location.x, sw.location.y).lineTo(end_point.x, end_point.y);\n            }\n         }\n\n         let p1, p2;\n\n         p1 = sw.getBranchEndPoint(1, trackRendering_basic.SWITCH_SIZE);\n         p2 = sw.getBranchEndPoint(2, trackRendering_basic.SWITCH_SIZE);\n         if (p1 && p2) {\n            trackRendering_basic.drawTriangle(switch_shape.graphics, \"black\", sw.location, p1, p2);\n         }\n\n         if (sw.type == _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.DKW) {\n            p1 = sw.getBranchEndPoint(0, trackRendering_basic.SWITCH_SIZE);\n            p2 = sw.getBranchEndPoint(3, trackRendering_basic.SWITCH_SIZE);\n            if (p1 && p2) {\n               trackRendering_basic.drawTriangle(switch_shape.graphics, \"black\", sw.location, p1, p2);\n            }\n         }\n\n         this.renderSwitchUI(sw);\n      });\n   }\n\n   renderSwitchUI(sw) {\n      // Check if a container already exists for this switch\n      let container = window.ui_container.children.find((c) => c.data === sw);\n\n      if (container) {\n         // If container exists, clear it but keep it\n         container.removeAllChildren();\n      } else {\n         // Create a new container if none exists\n         container = new createjs.Container();\n         container.mouseChildren = false;\n         container.name = \"switch\";\n         container.data = sw;\n         window.ui_container.addChild(container);\n      }\n\n      const ui_shape = new createjs.Shape();\n      ui_shape.graphics.setStrokeStyle(trackRendering_basic.STROKE / 2, \"round\");\n      container.addChild(ui_shape);\n\n      const draw_line = function (t, color) {\n         ui_shape.graphics.beginStroke(color);\n         let p1 = sw.getBranchEndPoint(t, trackRendering_basic.SWITCH_SIZE);\n         let p0 = sw.getBranchEndPoint(t, trackRendering_basic.SWITCH_SIZE / 2);\n         ui_shape.graphics.moveTo(p0.x, p0.y).lineTo(p1.x, p1.y);\n      };\n\n      sw.tracks.forEach((t, i) => {\n         if (t)\n            draw_line(\n               i,\n               t === sw.from || t === sw.branch\n                  ? trackRendering_basic.SWITCH_UI_COLOR_SELECTED\n                  : trackRendering_basic.SWITCH_UI_COLOR\n            );\n      });\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c2ljLmpzPzI2ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL3RyYWNrLmpzJztcbmltcG9ydCB7IFN3aXRjaCB9IGZyb20gJy4vc3dpdGNoLmpzJztcbmltcG9ydCB7IFNpZ25hbCwgU2lnbmFsUmVuZGVyZXIgfSBmcm9tICcuL3NpZ25hbC5qcyc7XG5pbXBvcnQgeyBUcmFpbiB9IGZyb20gJy4vdHJhaW4uanMnO1xuaW1wb3J0IHsgR2VuZXJpY09iamVjdCB9IGZyb20gJy4vZ2VuZXJpY19vYmplY3QuanMnO1xuaW1wb3J0IHsgZ2VvbWV0cnksIHR5cGUgfSBmcm9tICcuL3Rvb2xzLmpzJztcbmltcG9ydCB7IE51bWJlclV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmV4cG9ydCBjbGFzcyB0cmFja1JlbmRlcmluZ19iYXNpYyB7XG4gICBzdGF0aWMgVFJBQ0tfQ09MT1IgPSBcIiMxMTExMTFcIjtcbiAgIHN0YXRpYyBTV0lUQ0hfVUlfQ09MT1IgPSBcImdyYXlcIjtcbiAgIHN0YXRpYyBTV0lUQ0hfVUlfQ09MT1JfU0VMRUNURUQgPSBcIiNlZWVcIjtcbiAgIHN0YXRpYyBTVFJPS0UgPSA2O1xuICAgc3RhdGljIEhJVF9URVNUX0RJU1RBTkNFID0gMTA7XG4gICBzdGF0aWMgQlVNUEVSX1NJWkUgPSA4O1xuICAgc3RhdGljIFNXSVRDSF9TSVpFID0gMzA7XG5cbiAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5TSUdOQUxfRElTVEFOQ0VfRlJPTV9UUkFDSyA9IDE4O1xuICAgfVxuXG4gICByZURyYXdFdmVyeXRoaW5nKCkge1xuICAgICAgd2luZG93LnRyYWNrX2NvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgd2luZG93LnNpZ25hbF9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIHdpbmRvdy50cmFpbl9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIHdpbmRvdy51aV9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIHdpbmRvdy5kZWJ1Z19jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIHdpbmRvdy5vYmplY3RfY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG5cbiAgICAgIHRoaXMucmVuZGVyQWxsVHJhY2tzKCk7XG4gICAgICB0aGlzLnJlbmRlckFsbFN3aXRjaGVzKCk7XG4gICAgICB0aGlzLnJlbmRlckFsbEdlbmVyaWNPYmplY3RzKCk7XG4gICAgICB0aGlzLnJlbmRlckFsbFNpZ25hbHMoKTtcbiAgICAgIHdpbmRvdy5zdGFnZS51cGRhdGUoKTtcbiAgIH1cblxuICAgcmVuZGVyQWxsU2lnbmFscygpIHtcbiAgICAgIHdpbmRvdy5zaWduYWxfY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICBTaWduYWwuYWxsU2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgIGxldCBjb250YWluZXIgPSB3aW5kb3cuc2lnbmFsX2NvbnRhaW5lci5hZGRDaGlsZChTaWduYWxSZW5kZXJlci5jcmVhdGVTaWduYWxDb250YWluZXIoc2lnbmFsKSk7XG4gICAgICAgICB3aW5kb3cuYWxpZ25TaWduYWxDb250YWluZXJXaXRoVHJhY2soY29udGFpbmVyLCBzaWduYWwuX3Bvc2l0aW9uaW5nKTtcbiAgICAgICAgIGlmICh3aW5kb3cuc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3Qoc2lnbmFsKSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnNoYWRvdyA9IG5ldyBjcmVhdGVqcy5TaGFkb3coXCIjZmYwMDAwXCIsIDAsIDAsIDMpO1xuICAgICAgICAgfVxuICAgICAgfSk7XG4gICB9XG5cbiAgIHJlbmRlckFsbFRyYWNrcygpIHtcbiAgICAgIFRyYWNrLmFsbFRyYWNrcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICB0aGlzLnJlbmRlclRyYWNrKHdpbmRvdy50cmFja19jb250YWluZXIsIHQpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIGlzU2VsZWN0ZWQoYykge1xuICAgICAgYy5jb2xvci5zdHlsZSA9IFwiI2ZmMDAwMFwiO1xuICAgfVxuXG4gICB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICB3aW5kb3cudHJhY2tfY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgIGlmIChjLmRhdGEpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3QoYy5kYXRhKSkgdGhpcy5pc1NlbGVjdGVkKGMpO1xuICAgICAgICAgICAgZWxzZSBjLmNvbG9yLnN0eWxlID0gdHJhY2tSZW5kZXJpbmdfYmFzaWMuVFJBQ0tfQ09MT1I7XG4gICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5zaWduYWxfY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgIGlmIChjLmRhdGEpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3QoYy5kYXRhKSkgYy5zaGFkb3cgPSBuZXcgY3JlYXRlanMuU2hhZG93KFwiI2ZmMDAwMFwiLCAwLCAwLCAzKTtcbiAgICAgICAgICAgIGVsc2UgYy5zaGFkb3cgPSBudWxsO1xuICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuc3RhZ2UudXBkYXRlKCk7XG4gICB9XG5cbiAgIHJlbmRlckFsbEdlbmVyaWNPYmplY3RzKCkge1xuICAgICAgd2luZG93Lm9iamVjdF9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgY29uc3QgYyA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgIGMubmFtZSA9IFwib2JqZWN0XCI7XG4gICAgICAgICBjLm9iamVjdCA9IG87XG4gICAgICAgICBjLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgIGMueCA9IG8ucG9zKCkueDtcbiAgICAgICAgIGMueSA9IG8ucG9zKCkueTtcblxuICAgICAgICAgaWYgKG8udHlwZSgpID09PSBHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLnRleHQpIHRoaXMucmVuZGVyVGV4dE9iamVjdChvLCBjKTtcbiAgICAgICAgIGVsc2UgaWYgKG8udHlwZSgpID09PSBHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLnBsYXR0Zm9ybSkgdGhpcy5yZW5kZXJQbGF0dGZvcm1PYmplY3QobywgYyk7XG4gICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gT2JqZWN0XCIpO1xuXG4gICAgICAgICB3aW5kb3cub2JqZWN0X2NvbnRhaW5lci5hZGRDaGlsZChjKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICByZW5kZXJUZXh0T2JqZWN0KHRleHRfb2JqZWN0LCBjb250YWluZXIpIHtcbiAgICAgIHZhciB0ZXh0ID0gbmV3IGNyZWF0ZWpzLlRleHQodGV4dF9vYmplY3QuY29udGVudCgpLCBcIjIwcHggQXJpYWxcIiwgXCIjMDAwMDAwXCIpO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRleHQuZ2V0TWVhc3VyZWRIZWlnaHQoKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5nZXRNZWFzdXJlZFdpZHRoKCk7XG5cbiAgICAgIGNvbnN0IGhpdCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgaGl0LmdyYXBoaWNzLmJlZ2luRmlsbChcIiMwMDBcIikubXQoMCwgMCkubHQod2lkdGgsIDApLmx0KHdpZHRoLCAtaGVpZ2h0KS5sdCgwLCAtaGVpZ2h0KS5sdCgwLCAwKTtcblxuICAgICAgdGV4dC5oaXRBcmVhID0gaGl0O1xuXG4gICAgICBjb250YWluZXIuYWRkQ2hpbGQodGV4dCk7XG4gICB9XG5cbiAgIHJlbmRlclBsYXR0Zm9ybU9iamVjdChwbGF0dGZvcm0sIGNvbnRhaW5lcikge1xuICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzaGFwZSk7XG4gICAgICBzaGFwZS5ncmFwaGljcy5iZWdpblN0cm9rZShcIiMxMTExMTFcIikuYmVnaW5GaWxsKFwiIzQ0NFwiKS5kcmF3UmVjdCgwLCAwLCBwbGF0dGZvcm0uc2l6ZSgpLndpZHRoLCBwbGF0dGZvcm0uc2l6ZSgpLmhlaWdodCk7XG5cbiAgICAgIHZhciB0ZXh0ID0gbmV3IGNyZWF0ZWpzLlRleHQocGxhdHRmb3JtLmNvbnRlbnQoKSwgXCIyMHB4IEFyaWFsXCIsIFwiI2VlZVwiKTtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgIHRleHQueCA9IHBsYXR0Zm9ybS5zaXplKCkud2lkdGggLyAyO1xuICAgICAgdGV4dC55ID0gcGxhdHRmb3JtLnNpemUoKS5oZWlnaHQgLyAyO1xuXG4gICAgICBjb250YWluZXIuYWRkQ2hpbGQodGV4dCk7XG4gICB9XG5cbiAgIGNhbGN1bGF0ZVRyYWNrRHJhd2luZ1BhcmFtZXRlcnModHJhY2spIHtcbiAgICAgIGxldCBjb3JyX3N0YXJ0ID0gdHJhY2suc3RhcnQsXG4gICAgICAgICBjb3JyX2VuZCA9IHRyYWNrLmVuZDtcbiAgICAgIGxldCBidW1wZXJfc3RhcnQsIGJ1bXBlcl9lbmQ7XG5cbiAgICAgIGlmICghdHJhY2suc3dpdGNoQXRUaGVTdGFydCkge1xuICAgICAgICAgLy9wcmVsbGJvY2sgYmVpbSBzdGFydFxuICAgICAgICAgY29uc3QgQjEgPSB0cmFjay5zdGFydC5hZGQoZ2VvbWV0cnkucGVycGVuZGljdWxhcih0cmFjay51bml0KS5tdWx0aXBseSgtdHJhY2tSZW5kZXJpbmdfYmFzaWMuQlVNUEVSX1NJWkUpKTtcbiAgICAgICAgIGNvbnN0IEIyID0gdHJhY2suc3RhcnQuYWRkKGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdCkubXVsdGlwbHkodHJhY2tSZW5kZXJpbmdfYmFzaWMuQlVNUEVSX1NJWkUpKTtcbiAgICAgICAgIGJ1bXBlcl9zdGFydCA9IFtCMSwgQjJdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlKHRyYWNrLnN3aXRjaEF0VGhlU3RhcnQpID09IFwiU3dpdGNoXCIpIHtcbiAgICAgICAgIGNvcnJfc3RhcnQgPSB0cmFjay5hbG9uZyh0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0LmxvY2F0aW9uLCB0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0LnNpemUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYWNrLnN3aXRjaEF0VGhlRW5kKSB7XG4gICAgICAgICAvL3ByZWxsYm9jayBiZWltIGVuZGVcbiAgICAgICAgIGNvbnN0IEIxID0gdHJhY2suZW5kLmFkZChnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKHRyYWNrLnVuaXQpLm11bHRpcGx5KC10cmFja1JlbmRlcmluZ19iYXNpYy5CVU1QRVJfU0laRSkpO1xuICAgICAgICAgY29uc3QgQjIgPSB0cmFjay5lbmQuYWRkKGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdCkubXVsdGlwbHkodHJhY2tSZW5kZXJpbmdfYmFzaWMuQlVNUEVSX1NJWkUpKTtcbiAgICAgICAgIGJ1bXBlcl9lbmQgPSBbQjEsIEIyXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSh0cmFjay5zd2l0Y2hBdFRoZUVuZCkgPT0gXCJTd2l0Y2hcIikge1xuICAgICAgICAgY29ycl9lbmQgPSB0cmFjay5hbG9uZyh0cmFjay5zd2l0Y2hBdFRoZUVuZC5sb2NhdGlvbiwgLXRyYWNrLnN3aXRjaEF0VGhlRW5kLnNpemUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwMSA9IGNvcnJfc3RhcnQuYWRkKGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdCkubXVsdGlwbHkoLXRyYWNrUmVuZGVyaW5nX2Jhc2ljLkhJVF9URVNUX0RJU1RBTkNFKSk7XG4gICAgICBjb25zdCBwMiA9IGNvcnJfc3RhcnQuYWRkKGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdCkubXVsdGlwbHkodHJhY2tSZW5kZXJpbmdfYmFzaWMuSElUX1RFU1RfRElTVEFOQ0UpKTtcbiAgICAgIGNvbnN0IHAzID0gY29ycl9lbmQuYWRkKGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdCkubXVsdGlwbHkodHJhY2tSZW5kZXJpbmdfYmFzaWMuSElUX1RFU1RfRElTVEFOQ0UpKTtcbiAgICAgIGNvbnN0IHA0ID0gY29ycl9lbmQuYWRkKGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdCkubXVsdGlwbHkoLXRyYWNrUmVuZGVyaW5nX2Jhc2ljLkhJVF9URVNUX0RJU1RBTkNFKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgaGl0X2FyZWE6IFtwMSwgcDIsIHAzLCBwNF0sXG4gICAgICAgICBidW1wZXI6IFtidW1wZXJfc3RhcnQsIGJ1bXBlcl9lbmRdLFxuICAgICAgICAgc3RhcnQ6IGNvcnJfc3RhcnQsXG4gICAgICAgICBlbmQ6IGNvcnJfZW5kLFxuICAgICAgfTtcbiAgIH1cblxuICAgcmVuZGVyVHJhY2soY29udGFpbmVyLCB0cmFjaykge1xuICAgICAgbGV0IHBhcmFtcyA9IHRoaXMuY2FsY3VsYXRlVHJhY2tEcmF3aW5nUGFyYW1ldGVycyh0cmFjayk7XG4gICAgICBsZXQgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIHNoYXBlLm5hbWUgPSBcInRyYWNrXCI7XG4gICAgICBzaGFwZS5kYXRhID0gdHJhY2s7XG5cbiAgICAgIGxldCBoaXQgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcblxuICAgICAgaGl0LmdyYXBoaWNzXG4gICAgICAgICAuYmVnaW5GaWxsKFwiIzAwMFwiKVxuICAgICAgICAgLm10KHBhcmFtcy5oaXRfYXJlYVswXS54LCBwYXJhbXMuaGl0X2FyZWFbMF0ueSlcbiAgICAgICAgIC5sdChwYXJhbXMuaGl0X2FyZWFbMV0ueCwgcGFyYW1zLmhpdF9hcmVhWzFdLnkpXG4gICAgICAgICAubHQocGFyYW1zLmhpdF9hcmVhWzJdLngsIHBhcmFtcy5oaXRfYXJlYVsyXS55KVxuICAgICAgICAgLmx0KHBhcmFtcy5oaXRfYXJlYVszXS54LCBwYXJhbXMuaGl0X2FyZWFbM10ueSlcbiAgICAgICAgIC5sdChwYXJhbXMuaGl0X2FyZWFbMF0ueCwgcGFyYW1zLmhpdF9hcmVhWzBdLnkpO1xuICAgICAgc2hhcGUuaGl0QXJlYSA9IGhpdDtcblxuICAgICAgLy9jb250YWluZXIuYWRkQ2hpbGQoaGl0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzaGFwZSk7XG5cbiAgICAgIHNoYXBlLmdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKHRyYWNrUmVuZGVyaW5nX2Jhc2ljLlNUUk9LRSwgXCJyb3VuZFwiKS5iZWdpblN0cm9rZSh0cmFja1JlbmRlcmluZ19iYXNpYy5UUkFDS19DT0xPUik7XG4gICAgICBzaGFwZS5jb2xvciA9IHNoYXBlLmdyYXBoaWNzLmNvbW1hbmQ7XG4gICAgICBzaGFwZS5ncmFwaGljcy5tb3ZlVG8ocGFyYW1zLnN0YXJ0LngsIHBhcmFtcy5zdGFydC55KS5saW5lVG8ocGFyYW1zLmVuZC54LCBwYXJhbXMuZW5kLnkpO1xuICAgICAgaWYgKHBhcmFtcy5idW1wZXJbMF0pIHtcbiAgICAgICAgIC8vcHJlbGxib2NrIGJlaW0gc3RhcnRcbiAgICAgICAgIHNoYXBlLmdyYXBoaWNzLm1vdmVUbyhwYXJhbXMuYnVtcGVyWzBdWzBdLngsIHBhcmFtcy5idW1wZXJbMF1bMF0ueSkubGluZVRvKHBhcmFtcy5idW1wZXJbMF1bMV0ueCwgcGFyYW1zLmJ1bXBlclswXVsxXS55KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5idW1wZXJbMV0pIHtcbiAgICAgICAgIC8vcHJlbGxib2NrIGJlaW0gZW5kZVxuICAgICAgICAgc2hhcGUuZ3JhcGhpY3MubW92ZVRvKHBhcmFtcy5idW1wZXJbMV1bMF0ueCwgcGFyYW1zLmJ1bXBlclsxXVswXS55KS5saW5lVG8ocGFyYW1zLmJ1bXBlclsxXVsxXS54LCBwYXJhbXMuYnVtcGVyWzFdWzFdLnkpO1xuICAgICAgfVxuICAgICAgaWYgKHdpbmRvdy5zZWxlY3Rpb24uaXNTZWxlY3RlZE9iamVjdCh0cmFjaykpIHRoaXMuaXNTZWxlY3RlZChzaGFwZSk7XG5cbiAgICAgIGNvbnN0IHRleHQgPSBuZXcgY3JlYXRlanMuVGV4dCh0cmFjay5pZCwgXCJJdGFsaWMgMTBweCBBcmlhbFwiLCBcImJsYWNrXCIpO1xuICAgICAgY29uc3QgcCA9IHRyYWNrLmFsb25nKHRyYWNrLnN0YXJ0LCB0cmFjay5sZW5ndGggLyAyKS5hZGQoZ2VvbWV0cnkucGVycGVuZGljdWxhcih0cmFjay51bml0KS5tdWx0aXBseSgxNSkpO1xuXG4gICAgICB0ZXh0LnggPSBwLng7XG4gICAgICB0ZXh0LnkgPSBwLnk7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuICAgICAgd2luZG93LnVpX2NvbnRhaW5lci5hZGRDaGlsZCh0ZXh0KTtcblxuICAgICAgc2hhcGUuc2V0Qm91bmRzKFxuICAgICAgICAgcGFyYW1zLnN0YXJ0LnggLSB0cmFja1JlbmRlcmluZ19iYXNpYy5ISVRfVEVTVF9ESVNUQU5DRSxcbiAgICAgICAgIHBhcmFtcy5zdGFydC55IC0gdHJhY2tSZW5kZXJpbmdfYmFzaWMuSElUX1RFU1RfRElTVEFOQ0UsXG4gICAgICAgICBwYXJhbXMuZW5kLnggLSBwYXJhbXMuc3RhcnQueCArIHRyYWNrUmVuZGVyaW5nX2Jhc2ljLkhJVF9URVNUX0RJU1RBTkNFICogMixcbiAgICAgICAgIHBhcmFtcy5lbmQueSAtIHBhcmFtcy5zdGFydC55ICsgdHJhY2tSZW5kZXJpbmdfYmFzaWMuSElUX1RFU1RfRElTVEFOQ0UgKiAyXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gc2hhcGU7XG4gICB9XG5cbiAgIHN0YXRpYyBkcmF3VHJpYW5nbGUoZ3JhcGhpY3MsIGNvbG9yLCBwMSwgcDIsIHAzKSB7XG4gICAgICBncmFwaGljcy5iZWdpbkZpbGwoY29sb3IpXG4gICAgICAgICAubXQocDEueCwgcDEueSlcbiAgICAgICAgIC5sdChwMi54LCBwMi55KVxuICAgICAgICAgLmx0KHAzLngsIHAzLnkpXG4gICAgICAgICAubHQocDEueCwgcDEueSk7XG4gICB9XG5cbiAgIHJlbmRlckFsbFN3aXRjaGVzKCkge1xuICAgICAgU3dpdGNoLmFsbFN3aXRjaGVzLmZvckVhY2goKHN3KSA9PiB7XG4gICAgICAgICBpZiAoIXN3LnRyYWNrMSB8fCAhc3cudHJhY2syIHx8ICFzdy50cmFjazMgfHwgKHN3LnR5cGUgPT0gU3dpdGNoLlNXSVRDSF9UWVBFLkRLVyAmJiAhc3cudHJhY2s0KSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coc3cpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3dpdGNoIGlzIGZhbHR5XCIpO1xuICAgICAgICAgfVxuICAgICAgICAgbGV0IHN3aXRjaF9zaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICAgc3dpdGNoX3NoYXBlLm5hbWUgPSBcInN3aXRjaFwiO1xuICAgICAgICAgc3dpdGNoX3NoYXBlLmRhdGEgPSBzdztcbiAgICAgICAgIHdpbmRvdy50cmFja19jb250YWluZXIuYWRkQ2hpbGQoc3dpdGNoX3NoYXBlKTtcblxuICAgICAgICAgLy8gRHJhdyB0aGUgc3dpdGNoIGJyYW5jaCB0cmFja3NcbiAgICAgICAgIHN3aXRjaF9zaGFwZS5ncmFwaGljcy5zZXRTdHJva2VTdHlsZSh0cmFja1JlbmRlcmluZ19iYXNpYy5TVFJPS0UsIFwicm91bmRcIikuYmVnaW5TdHJva2UodHJhY2tSZW5kZXJpbmdfYmFzaWMuVFJBQ0tfQ09MT1IpO1xuXG4gICAgICAgICAvLyBEcmF3IGFsbCB0cmFjayBicmFuY2hlcyB1c2luZyBhIGxvb3BcbiAgICAgICAgIGNvbnN0IG1heFRyYWNrcyA9IHN3LnR5cGUgPT0gU3dpdGNoLlNXSVRDSF9UWVBFLkRLVyA/IDQgOiAzO1xuICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUcmFja3M7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN3LnRyYWNrX2RpcmVjdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgIGxldCBlbmRfcG9pbnQgPSBzdy5nZXRCcmFuY2hFbmRQb2ludChpKTtcbiAgICAgICAgICAgICAgIHN3aXRjaF9zaGFwZS5ncmFwaGljcy5tb3ZlVG8oc3cubG9jYXRpb24ueCwgc3cubG9jYXRpb24ueSkubGluZVRvKGVuZF9wb2ludC54LCBlbmRfcG9pbnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGxldCBwMSwgcDI7XG5cbiAgICAgICAgIHAxID0gc3cuZ2V0QnJhbmNoRW5kUG9pbnQoMSwgdHJhY2tSZW5kZXJpbmdfYmFzaWMuU1dJVENIX1NJWkUpO1xuICAgICAgICAgcDIgPSBzdy5nZXRCcmFuY2hFbmRQb2ludCgyLCB0cmFja1JlbmRlcmluZ19iYXNpYy5TV0lUQ0hfU0laRSk7XG4gICAgICAgICBpZiAocDEgJiYgcDIpIHtcbiAgICAgICAgICAgIHRyYWNrUmVuZGVyaW5nX2Jhc2ljLmRyYXdUcmlhbmdsZShzd2l0Y2hfc2hhcGUuZ3JhcGhpY3MsIFwiYmxhY2tcIiwgc3cubG9jYXRpb24sIHAxLCBwMik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChzdy50eXBlID09IFN3aXRjaC5TV0lUQ0hfVFlQRS5ES1cpIHtcbiAgICAgICAgICAgIHAxID0gc3cuZ2V0QnJhbmNoRW5kUG9pbnQoMCwgdHJhY2tSZW5kZXJpbmdfYmFzaWMuU1dJVENIX1NJWkUpO1xuICAgICAgICAgICAgcDIgPSBzdy5nZXRCcmFuY2hFbmRQb2ludCgzLCB0cmFja1JlbmRlcmluZ19iYXNpYy5TV0lUQ0hfU0laRSk7XG4gICAgICAgICAgICBpZiAocDEgJiYgcDIpIHtcbiAgICAgICAgICAgICAgIHRyYWNrUmVuZGVyaW5nX2Jhc2ljLmRyYXdUcmlhbmdsZShzd2l0Y2hfc2hhcGUuZ3JhcGhpY3MsIFwiYmxhY2tcIiwgc3cubG9jYXRpb24sIHAxLCBwMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMucmVuZGVyU3dpdGNoVUkoc3cpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHJlbmRlclN3aXRjaFVJKHN3KSB7XG4gICAgICAvLyBDaGVjayBpZiBhIGNvbnRhaW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBzd2l0Y2hcbiAgICAgIGxldCBjb250YWluZXIgPSB3aW5kb3cudWlfY29udGFpbmVyLmNoaWxkcmVuLmZpbmQoKGMpID0+IGMuZGF0YSA9PT0gc3cpO1xuXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAvLyBJZiBjb250YWluZXIgZXhpc3RzLCBjbGVhciBpdCBidXQga2VlcCBpdFxuICAgICAgICAgY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbnRhaW5lciBpZiBub25lIGV4aXN0c1xuICAgICAgICAgY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgY29udGFpbmVyLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgIGNvbnRhaW5lci5uYW1lID0gXCJzd2l0Y2hcIjtcbiAgICAgICAgIGNvbnRhaW5lci5kYXRhID0gc3c7XG4gICAgICAgICB3aW5kb3cudWlfY29udGFpbmVyLmFkZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVpX3NoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICB1aV9zaGFwZS5ncmFwaGljcy5zZXRTdHJva2VTdHlsZSh0cmFja1JlbmRlcmluZ19iYXNpYy5TVFJPS0UgLyAyLCBcInJvdW5kXCIpO1xuICAgICAgY29udGFpbmVyLmFkZENoaWxkKHVpX3NoYXBlKTtcblxuICAgICAgY29uc3QgZHJhd19saW5lID0gZnVuY3Rpb24gKHQsIGNvbG9yKSB7XG4gICAgICAgICB1aV9zaGFwZS5ncmFwaGljcy5iZWdpblN0cm9rZShjb2xvcik7XG4gICAgICAgICBsZXQgcDEgPSBzdy5nZXRCcmFuY2hFbmRQb2ludCh0LCB0cmFja1JlbmRlcmluZ19iYXNpYy5TV0lUQ0hfU0laRSk7XG4gICAgICAgICBsZXQgcDAgPSBzdy5nZXRCcmFuY2hFbmRQb2ludCh0LCB0cmFja1JlbmRlcmluZ19iYXNpYy5TV0lUQ0hfU0laRSAvIDIpO1xuICAgICAgICAgdWlfc2hhcGUuZ3JhcGhpY3MubW92ZVRvKHAwLngsIHAwLnkpLmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgIH07XG5cbiAgICAgIHN3LnRyYWNrcy5mb3JFYWNoKCh0LCBpKSA9PiB7XG4gICAgICAgICBpZiAodClcbiAgICAgICAgICAgIGRyYXdfbGluZShcbiAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICB0ID09PSBzdy5mcm9tIHx8IHQgPT09IHN3LmJyYW5jaFxuICAgICAgICAgICAgICAgICAgPyB0cmFja1JlbmRlcmluZ19iYXNpYy5TV0lUQ0hfVUlfQ09MT1JfU0VMRUNURURcbiAgICAgICAgICAgICAgICAgIDogdHJhY2tSZW5kZXJpbmdfYmFzaWMuU1dJVENIX1VJX0NPTE9SXG4gICAgICAgICAgICApO1xuICAgICAgfSk7XG4gICB9XG59XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/trackRendering_basic.js\n\n}");

/***/ }),

/***/ "./www/code/trackRendering_textured.js":
/*!*********************************************!*\
  !*** ./www/code/trackRendering_textured.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trackRendering_textured: () => (/* binding */ trackRendering_textured)\n/* harmony export */ });\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\n\nclass trackRendering_textured {\n   static SWITCH_UI_STROKE = 3;\n   static TRACK_SCALE = 0.3;\n   static signale_scale = 0.5;\n   static SCHWELLEN_VARIANTEN = 24;\n   static CURVATURE_4WAY_SWITCH = 70;\n   static RAILS = [\n      [3.2, \"#222\"],\n      [2.8, \"#999\"],\n      [1.4, \"#eee\"],\n   ];\n\n   // Define sleeper pattern for 4-way switch\n   static FOUR_WAY_SLEEPER_PATTERN = [\n      { offset: 1, length: 1.0 }, // Start straight\n      { offset: 1, length: 1.4 }, // Start straight\n      { offset: 1.1, length: 1.7 }, // Begin transition\n      { offset: 1.2, length: 1.9 }, // Peak of curve\n      { offset: 1.4, length: 1.8 }, // Peak of curve\n      { offset: 1.5, length: 1.7 }, // Curve\n      { offset: 1.7, length: 1.65 }, // Curve\n   ];\n\n   constructor() {\n      //cause the class is been loaded before start.js, we have to hack and calculate this constant here\n      trackRendering_textured.CURVE_RADIUS = window.GRID_SIZE * 1.21;\n\n      this.SIGNAL_DISTANCE_FROM_TRACK = 35;\n\n      this.LOD = 5;\n      this._lastRenderScale = 0;\n\n      // Cache for sleeper shapes and bitmaps\n      this._sleeperCache = {};\n      this._bitmapCache = new Array(trackRendering_textured.SCHWELLEN_VARIANTEN);\n   }\n\n   cleanUp() {\n      if (this._idleCallback) {\n         if (window.requestIdleCallback) cancelIdleCallback(this._idleCallback);\n         else clearTimeout(this._idleCallback);\n      }\n\n      const myIdleCallback =\n         window.requestIdleCallback ||\n         function (callback) {\n            return setTimeout(callback, 1);\n         };\n\n      this._idleCallback = myIdleCallback(\n         function (r) {\n            if (track_container.renderedTracks.size == 0 || this._rendering != null) return;\n            const bounds = this.calcCanvasSize();\n\n            // Find tracks that are no longer visible\n            const toBeRemoved = [];\n            track_container.renderedTracks.forEach((track) => {\n               if (!this.TrackVisible(track, bounds)) {\n                  toBeRemoved.push(track);\n               }\n            });\n\n            // Remove tracks and their associated signals\n            toBeRemoved.forEach((track) => {\n               // Remove associated signals\n               const signalsToBeRemoved = signal_container.children.filter((cs) => cs.data._positioning.track === track);\n               signalsToBeRemoved.forEach((cs) => {\n                  signal_container.removeChild(cs);\n               });\n               // Remove track from rendered set\n               track_container.renderedTracks.delete(track);\n\n               // Remove track elements from both containers\n               const sleepersToRemove = track_container.children[0].children.filter((c) => c.data === track);\n               const railsToRemove = track_container.children[1].children.filter((c) => c.data === track);\n\n               sleepersToRemove.forEach((c) => {\n                  delete c.track;\n                  track_container.children[0].removeChild(c);\n               });\n\n               railsToRemove.forEach((c) => {\n                  delete c.track;\n                  track_container.children[1].removeChild(c);\n               });\n            });\n\n            // Clean up sleeper cache if it's getting too large (more than 200 entries)\n            if (Object.keys(this._sleeperCache).length > 200) {\n               this._sleeperCache = {};\n            }\n\n            this._idleCallback = null;\n         }.bind(this)\n      );\n   }\n\n   calcCanvasSize() {\n      const width = (stage.canvas.width + GRID_SIZE * 2) / stage.scaleX,\n         height = (stage.canvas.height + GRID_SIZE * 2) / stage.scaleY,\n         x = (-stage.x - GRID_SIZE) / stage.scaleX,\n         y = (-stage.y - GRID_SIZE) / stage.scaleY;\n      return { left: x, top: y, right: x + width, bottom: y + height };\n   }\n\n   ///force=false means, each element decides if it needs to be redrawn. If something global changed,\n   ///like the scale, force needs to be true.\n   /// dont_optimize parameter disables the optimasation to only handle and draw elements inside the viewport\n   /// and disables caching. its used by the export to image functionality\n   reDrawEverything(force = false, dont_optimize = false) {\n      if (!pl.loaded)\n         //stupid code that should prevent drawing, before the preloader is ready\n         setTimeout(() => {\n            this.reDrawEverything(force, dont_optimize);\n         }, 500);\n      else {\n         if (this._rendering == undefined) {\n            try {\n               this._rendering = { dont_optimize: dont_optimize };\n               this._rendering.screen_rectangle = this.calcCanvasSize();\n\n               if (force) {\n                  track_container.removeAllChildren();\n                  signal_container.removeAllChildren();\n                  ui_container.removeAllChildren();\n                  train_container.removeAllChildren();\n                  object_container.removeAllChildren();\n                  debug_container.removeAllChildren();\n                  selection_container.removeAllChildren();\n\n                  // Clear the overlay container\n                  overlay_container.removeAllChildren();\n\n                  this.calcRenderValues();\n               } else {\n                                 //if we passed the LOD in either direction we have to rerender the tracks\n               if (_utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.between(this.LOD, this._lastRenderScale, stage.scale)) {\n                  this._rendering.lodChanged = true;\n               }\n               }\n\n               try {\n                  this.renderAllTracks(force);\n                  this.renderAllSignals(force);\n                  this.renderAllTrains();\n                  this.renderAllGenericObjects();\n                  this._lastRenderScale = stage.scale;\n                  if (!dont_optimize) this.cleanUp();\n               } catch (error) {\n                  console.error(\"Error during rendering:\", error);\n                  throw error;\n               } finally {\n                  delete this._rendering;\n                  stage.update();\n               }\n            } catch (error) {\n               console.error(\"Critical rendering error:\", error);\n               _ui_js__WEBPACK_IMPORTED_MODULE_7__.ui.showErrorToast(error);\n               // Attempt to recover by clearing rendering state\n               delete this._rendering;\n               throw error;\n            }\n         }\n      }\n   }\n\n   calcRenderValues() {\n      this.schwellenImg = pl.getImage(\"schwellen\");\n      this.bumperImg = pl.getImage(\"bumper\");\n      this.sleepersImgWidth = this.schwellenImg.width / trackRendering_textured.SCHWELLEN_VARIANTEN;\n      this.schwellenHöhe = this.schwellenImg.height * trackRendering_textured.TRACK_SCALE;\n      this.schwellenHöhe_2 = this.schwellenHöhe / 2;\n      this.schwellenBreite = this.sleepersImgWidth * trackRendering_textured.TRACK_SCALE;\n      this.schwellenGap = this.schwellenBreite * 1.1; // distance between the sleepers\n      this.sleeperIntervall = this.schwellenBreite + this.schwellenGap;\n      this.rail_offset = this.schwellenHöhe / 4.7; // distance between the rail and the end of the sleeper\n      this.rail_distance = this.schwellenHöhe_2 - this.rail_offset; // distance between the rail and the center of the track\n\n      this.TRAIN_HEIGHT = this.schwellenHöhe - this.rail_offset;\n      this.TRAIN_WIDTH = GRID_SIZE * 0.7;\n\n      this.main_x1 = (Math.sin(Math.PI / 8) * trackRendering_textured.CURVE_RADIUS) / Math.cos(Math.PI / 8);\n   }\n\n   renderAllTrains() {\n      train_container.removeAllChildren();\n\n      // Only render trains that aren't coupled to another train's front\n      // This ensures we only create containers for lead cars\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains\n         .filter((train) => !train.trainCoupledFront)\n         .forEach((train) => {\n            const c = new createjs.Container();\n            c.name = \"train\";\n            c.train = train;\n            c.mouseChildren = true;\n\n            // Start rendering from the first car (locomotive)\n            this.renderCar(train, c);\n            \n            train_container.addChild(c);\n         });\n   }\n\n   renderCar(car, container) {\n      // Create graphics for the car\n      const g = new createjs.Graphics();\n      g.setStrokeStyle(1);\n      g.beginStroke(createjs.Graphics.getRGB(0, 0, 0));\n      g.beginFill(car.color);\n\n      // Use the car's actual length for width instead of fixed TRAIN_WIDTH\n      const carWidth = car.length;\n      const carHeight = this.TRAIN_HEIGHT;\n\n      // Set corner radius based on car type and position in train\n      let corner = [1.5, 1.5, 1.5, 1.5];\n\n      // If this is the first car (locomotive), round the front\n      if (car.type == _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.CAR_TYPES.LOCOMOTIVE) {\n         corner[0] = corner[3] = corner[1] = corner[2] = 8;\n      }\n\n      /* // If this is the last car, round the back\n      if (car.trainCoupledBack == null) {\n         corner[1] = corner[2] = 20;\n      } */\n\n      // Draw car with rounded corners\n      g.drawRoundRectComplex(0, 0, carWidth, carHeight, corner[0], corner[1], corner[2], corner[3]);\n\n      // Create the shape and position it\n      const s = new createjs.Shape(g);\n      s.data = car;\n      s.mouseChildren = false;\n      s.name = \"train\";\n\n      // Get the position on the track based on the car's km position\n      const p = car.track.getPointFromKm(car.pos);\n\n      s.x = p.x;\n      s.y = p.y;\n      s.regX = carWidth / 2;\n      s.regY = carHeight / 2;\n      s.rotation = car.track.deg;\n\n      container.addChild(s);\n      // Add train number if it exists\n      if (car.number && car.type == _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.CAR_TYPES.LOCOMOTIVE) {\n         const text = new createjs.Text(car.number, \"10px Arial\", \"#000000\");\n         text.textAlign = \"center\";\n         text.x = p.x;\n         text.y = p.y;\n         text.textBaseline = \"middle\";\n         container.addChild(text);\n      }\n      // Recursively render coupled cars\n      if (car.trainCoupledBack) {\n         this.renderCar(car.trainCoupledBack, container);\n      }\n   }\n\n   renderAllGenericObjects() {\n      object_container.removeAllChildren();\n      _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects.forEach((o) => {\n         const c = new createjs.Container();\n         c.name = \"GenericObject\";\n         c.data = o;\n         c.mouseChildren = false;\n         c.x = o.pos().x;\n         c.y = o.pos().y;\n\n         if (o.type() === _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.OBJECT_TYPE.text) this.renderTextObject(o, c);\n         else if (o.type() === _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.OBJECT_TYPE.plattform) this.renderPlattformObject(o, c);\n         else throw new Error(\"Unknown Object\");\n\n         object_container.addChild(c);\n      });\n   }\n\n   renderTextObject(text_object, container) {\n      var text = new createjs.Text(text_object.content(), \"24px Arial\", \"#000000\");\n      text.textBaseline = \"alphabetic\";\n      const height = text.getMeasuredHeight();\n      const width = text.getMeasuredWidth();\n\n      const hit = new createjs.Shape();\n      hit.graphics.beginFill(\"#000\").mt(0, 0).lt(width, 0).lt(width, -height).lt(0, -height).lt(0, 0);\n\n      text.hitArea = hit;\n\n      container.addChild(text);\n   }\n\n   renderPlattformObject(plattform, container) {\n      const shape = new createjs.Shape();\n      container.addChild(shape);\n      const size = plattform.size();\n      shape.graphics.beginStroke(\"#111111\").beginFill(\"#444\").drawRect(0, 0, size.width, size.height);\n      shape.setBounds(0, 0, size.width, size.height);\n\n      var text = new createjs.Text(plattform.content(), \"16px Arial\", \"#eee\");\n      text.textBaseline = \"middle\";\n      text.textAlign = \"center\";\n      text.x = plattform.size().width / 2;\n      text.y = plattform.size().height / 2;\n\n      container.addChild(text);\n   }\n\n   renderAllSignals(force) {\n      signal_container.removeAllChildren();\n      _signal_js__WEBPACK_IMPORTED_MODULE_2__.Signal.allSignals.forEach((signal) => {\n         let container = signal_container.addChild(_signal_js__WEBPACK_IMPORTED_MODULE_2__.SignalRenderer.createSignalContainer(signal));\n         alignSignalContainerWithTrack(container, signal._positioning);\n         \n      });\n   }\n\n   renderAllTracks(force) {\n      //if we have to force a redraw, we have to create the containers for the sleepers and rails\n      if (force) {\n         const sleepers_container = new createjs.Container();\n         sleepers_container.name = \"global_sleepers\";\n         sleepers_container.mouseChildren = true;\n\n         const rails_container = new createjs.Container();\n         rails_container.name = \"global_rails\";\n         rails_container.mouseChildren = true;\n\n         this._rendering.sleepers_container = sleepers_container;\n         this._rendering.rails_container = rails_container;\n\n         track_container.addChild(sleepers_container);\n         track_container.addChild(rails_container);\n         track_container.renderedTracks = new Set();\n         track_container.renderedSwitches = new Set();\n      } else {\n         this._rendering.sleepers_container = track_container.children[0];\n         this._rendering.rails_container = track_container.children[1];\n      }\n\n      for (const t of _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks) {\n         if (this.TrackVisible(t)) {\n            //either we have a forced redraw or the track is not rendered yet\n            if (force || !track_container.renderedTracks.has(t)) {\n               this.renderTrack(t);\n               track_container.renderedTracks.add(t);\n            } else if (this._rendering.lodChanged) {\n               this.updateTrack(t);\n            }\n         }\n      }\n\n      for (const sw of _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches) {\n         if (this.SwitchVisible(sw)) {\n            if (force || !track_container.renderedSwitches.has(sw)) {\n               this.renderSwitch(sw);\n               track_container.renderedSwitches.add(sw);\n            } else if (this._rendering.lodChanged) {\n               this.updateSwitch(sw);\n            }\n         }\n      }\n   }\n\n   ///calculate start and end points for each node of a track and the control point for the curve\n   ///start and end points of straight segments are adjusted for the curves\n   calculateTrackPoints(track) {\n      const startConnection = track.switchAtTheStart;\n      const endConnection = track.switchAtTheEnd;\n\n      let startPoint = track.start;\n      let endPoint = track.end;\n\n      // Handle the start of the track\n      if (startConnection) {\n         // If there's a connection, shorten the track to make space\n         const size = startConnection instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch ? startConnection.size : GRID_SIZE_2;\n         startPoint = startPoint.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(track.unit, size));\n      } else {\n         // If there's no connection, extend it for the bumper\n         startPoint = startPoint.sub(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(track.unit, GRID_SIZE_2));\n      }\n\n      let straightEndPoint = endPoint;\n      let curveEnd = null;\n      let controlPoint = null;\n      let nextUnit = null;\n\n      // Handle the end of the track\n      if (endConnection) {\n         // If there's a connection, shorten the track to make space for the switch or curve\n         const size = endConnection instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch ? endConnection.size : GRID_SIZE_2;\n         straightEndPoint = endPoint.sub(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(track.unit, size));\n\n         if (endConnection instanceof _track_js__WEBPACK_IMPORTED_MODULE_0__.Track) {\n            // If the connection is another track, calculate the curve\n            const nextTrack = endConnection;\n            nextUnit = nextTrack.unit;\n            // The curve should end at the *shortened* start of the next track\n            curveEnd = nextTrack.start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(nextUnit, GRID_SIZE_2));\n            controlPoint = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(straightEndPoint, track.unit, curveEnd, nextUnit);\n         }\n      } else {\n         // If there's no connection, extend the track for the bumper.\n         straightEndPoint = endPoint.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(track.unit, GRID_SIZE_2));\n      }\n\n      const centerLine = {\n         track: track,\n         start: startPoint,\n         straightEnd: straightEndPoint, // This is the end of the straight part, before any curve.\n         end: endPoint, // Original end point for reference.\n         unit: track.unit,\n         curveEnd: curveEnd, // End point of the curve.\n         controlPoint: controlPoint, // Control point for the curve.\n         nextUnit: nextUnit, // Unit vector of the next track.\n      };\n\n      this.calculateRailPositions(centerLine);\n      this.calculateSleeperOutline(centerLine);\n\n      return [centerLine];\n   }\n\n   /**\n    * Calculate sleeper outline for a track segment\n    * @param {Object} centerLine - The centerline object to add sleeper outline to\n    */\n   calculateSleeperOutline(centerLine) {\n      const sleeperOffset = this.schwellenHöhe_2;\n      const sleeperOffsetVector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(centerLine.unit.multiply(sleeperOffset));\n\n      centerLine.sleeperOutline = {\n         straight: {\n            inner: {\n               start: centerLine.start.add(sleeperOffsetVector),\n               end: centerLine.straightEnd.add(sleeperOffsetVector),\n            },\n            outer: {\n               start: centerLine.start.sub(sleeperOffsetVector),\n               end: centerLine.straightEnd.sub(sleeperOffsetVector),\n            },\n         },\n      };\n\n      if (centerLine.controlPoint) {\n         const nextSleeperOffsetVector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(centerLine.nextUnit.multiply(sleeperOffset));\n\n         const curveOuterEnd = centerLine.curveEnd.sub(nextSleeperOffsetVector);\n         const curveInnerEnd = centerLine.curveEnd.add(nextSleeperOffsetVector);\n\n         const curveOuterStart = centerLine.sleeperOutline.straight.outer.end;\n         const curveInnerStart = centerLine.sleeperOutline.straight.inner.end;\n\n         const cpOuter = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(curveOuterStart, centerLine.unit, curveOuterEnd, centerLine.nextUnit);\n         const cpInner = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(curveInnerStart, centerLine.unit, curveInnerEnd, centerLine.nextUnit);\n\n         centerLine.sleeperOutline.curve = {\n            outer: { start: curveOuterStart, end: curveOuterEnd, cp: cpOuter },\n            inner: { start: curveInnerStart, end: curveInnerEnd, cp: cpInner },\n         };\n      }\n   }\n\n   /**\n    * Calculate rail positions for a track segment\n    * @param {Object} centerLine - The centerline object to add rail positions to\n    */\n   calculateRailPositions(centerLine) {\n      // Calculate rail offset vectors\n      const railOffsetVector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(centerLine.unit.multiply(this.rail_distance));\n\n      // Calculate rail positions for straight segment\n      centerLine.rails = {\n         straight: {\n            // Inner rail (usually the right side in the direction of travel)\n            inner: {\n               start: centerLine.start.add(railOffsetVector),\n               end: centerLine.straightEnd.add(railOffsetVector),\n            },\n            // Outer rail (usually the left side in the direction of travel)\n            outer: {\n               start: centerLine.start.sub(railOffsetVector),\n               end: centerLine.straightEnd.sub(railOffsetVector),\n            },\n         },\n      };\n\n      // Calculate rail positions for curve if it exists\n      if (centerLine.controlPoint) {\n         const nextRailOffsetVector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(centerLine.nextUnit.multiply(this.rail_distance));\n\n         // Calculate curve endpoints\n         const curveInnerEnd = centerLine.curveEnd.add(nextRailOffsetVector);\n         const curveOuterEnd = centerLine.curveEnd.sub(nextRailOffsetVector);\n\n         // Calculate curve startpoints (same as straight segment endpoints)\n         const curveInnerStart = centerLine.rails.straight.inner.end;\n         const curveOuterStart = centerLine.rails.straight.outer.end;\n\n         // Calculate control points for inner and outer rail curves\n         const cpInner = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(curveInnerStart, centerLine.unit, curveInnerEnd, centerLine.nextUnit);\n         const cpOuter = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(curveOuterStart, centerLine.unit, curveOuterEnd, centerLine.nextUnit);\n\n         // Store curve rail positions\n         centerLine.rails.curve = {\n            inner: {\n               start: curveInnerStart,\n               end: curveInnerEnd,\n               cp: cpInner,\n            },\n            outer: {\n               start: curveOuterStart,\n               end: curveOuterEnd,\n               cp: cpOuter,\n            },\n         };\n      }\n   }\n\n   renderTrack(track) {\n      const points = this.calculateTrackPoints(track);\n\n      const sleepers_container = new createjs.Container();\n      sleepers_container.name = \"track\";\n      sleepers_container.mouseChildren = false;\n      sleepers_container.data = track;\n      this._rendering.sleepers_container.addChild(sleepers_container);\n\n      const hitArea = new createjs.Shape();\n      hitArea.graphics.beginFill(\"#000\"); // Color doesn't matter, only need one fill\n      for (const p of points) {\n         const straight = p.sleeperOutline.straight;\n         hitArea.graphics\n            .moveTo(straight.outer.start.x, straight.outer.start.y)\n            .lineTo(straight.outer.end.x, straight.outer.end.y)\n            .lineTo(straight.inner.end.x, straight.inner.end.y)\n            .lineTo(straight.inner.start.x, straight.inner.start.y)\n            .closePath();\n\n         if (p.sleeperOutline.curve) {\n            const curve = p.sleeperOutline.curve;\n            hitArea.graphics\n               .moveTo(curve.inner.start.x, curve.inner.start.y)\n               .quadraticCurveTo(curve.inner.cp.x, curve.inner.cp.y, curve.inner.end.x, curve.inner.end.y)\n               .lineTo(curve.outer.end.x, curve.outer.end.y)\n               .quadraticCurveTo(curve.outer.cp.x, curve.outer.cp.y, curve.outer.start.x, curve.outer.start.y)\n               .closePath();\n         }\n      }\n      sleepers_container.hitArea = hitArea;\n\n      this.drawTrackSleepers(points, sleepers_container);\n\n      // Draw rails\n      const railShape = this.renderRails(track, points);\n\n      // Get bounds from the rail shape\n      const bounds = railShape.getBounds();\n\n      // Create a track object that combines rail and sleeper information\n      track._renderData = {\n         bounds: bounds,\n         points: points,\n      };\n\n      this.drawBumper(track, this._rendering.rails_container);\n   }\n\n   calculateRailBounds(points) {\n      // Initialize bounds with first point\n      let minX = Infinity,\n         minY = Infinity,\n         maxX = -Infinity,\n         maxY = -Infinity;\n\n      // Helper to update bounds with a point\n      const updateBounds = (point) => {\n         minX = Math.min(minX, point.x);\n         minY = Math.min(minY, point.y);\n         maxX = Math.max(maxX, point.x);\n         maxY = Math.max(maxY, point.y);\n      };\n\n      // Iterate through all points and collect extremes\n      for (const point of points) {\n         // Add all straight segment points to bounds\n         const { inner, outer } = point.rails.straight;\n         updateBounds(inner.start);\n         updateBounds(inner.end);\n         updateBounds(outer.start);\n         updateBounds(outer.end);\n\n         // Handle curve segments\n         if (point.rails.curve) {\n            const curve = point.rails.curve;\n\n            // Add curve endpoints and control points\n            updateBounds(curve.inner.start);\n            updateBounds(curve.inner.end);\n            updateBounds(curve.outer.start);\n            updateBounds(curve.outer.end);\n         }\n      }\n\n      // Add padding for line thickness\n      const padding = trackRendering_textured.RAILS[0][0] * 0.5; // Half of the thickest rail\n      return {\n         x: minX - padding,\n         y: minY - padding,\n         width: maxX - minX + padding * 2,\n         height: maxY - minY + padding * 2,\n      };\n   }\n\n   renderRails(track, points) {\n      const rail_shape = new createjs.Shape();\n      rail_shape.name = \"track\";\n      rail_shape.snapToPixel = true;\n      rail_shape.data = track;\n      this._rendering.rails_container.addChild(rail_shape);\n\n      for (const point of points) {\n         // Use pre-calculated rail positions\n         const { straight, curve } = point.rails;\n\n         trackRendering_textured.RAILS.forEach((rail) => {\n            rail_shape.graphics.setStrokeStyle(rail[0]).beginStroke(rail[1]);\n\n            // Draw straight segments\n            rail_shape.graphics\n               .mt(straight.inner.start.x, straight.inner.start.y)\n               .lt(straight.inner.end.x, straight.inner.end.y)\n               .mt(straight.outer.start.x, straight.outer.start.y)\n               .lt(straight.outer.end.x, straight.outer.end.y);\n\n            // Draw curves if present\n            if (curve) {\n               rail_shape.graphics\n                  .mt(curve.outer.start.x, curve.outer.start.y)\n                  .quadraticCurveTo(curve.outer.cp.x, curve.outer.cp.y, curve.outer.end.x, curve.outer.end.y)\n                  .mt(curve.inner.start.x, curve.inner.start.y)\n                  .quadraticCurveTo(curve.inner.cp.x, curve.inner.cp.y, curve.inner.end.x, curve.inner.end.y);\n            }\n\n            rail_shape.graphics.endStroke();\n         });\n      }\n\n      // Calculate and set bounds for the rail shape\n      const bounds = this.calculateRailBounds(points);\n      rail_shape.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);\n\n      // If debug mode is enabled, visualize the bounds\n      if (window.DEBUG_BOUNDS) {\n         this.visualizeTrackBounds(track, bounds);\n      }\n\n      return rail_shape;\n   }\n\n   drawTrackSleepers(points, container) {\n      for (const point of points) {\n         // Draw sleepers for straight segment\n         this.drawSleepers(point.track, point.start, point.straightEnd, container);\n\n         // Draw sleepers for curve if exists\n         if (point.rails.curve) {\n            this.drawSleepersAlongCurve(point.straightEnd, point.curveEnd, point.controlPoint, container);\n         }\n      }\n   }\n\n   drawSleepersAlongCurve(startPoint, endPoint, controlPoint, container) {\n      //the curve is eproximat 11% times longer than the straight line\n      const steps = Math.floor((_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(startPoint, endPoint) * 1.11) / this.sleeperIntervall);\n      const step = 1 / steps;\n      let t = 0.25 / steps,\n         point,\n         angle;\n\n      for (let i = 0; i < steps; i++) {\n         point = this.getPointOnCurve(t, startPoint, controlPoint, endPoint);\n         angle = this.getDegreeOfTangentOnCurve(t, startPoint, controlPoint, endPoint);\n\n         this.drawSleeper(i, point.x, point.y, angle, container);\n         t += step;\n      }\n   }\n\n   drawSleepers(track, startPoint, endPoint, container) {\n      let x = startPoint.x;\n      let y = startPoint.y;\n\n      const l = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(startPoint, endPoint);\n      // Calculate how many sleepers fit\n      const amount = Math.floor(l / this.sleeperIntervall);\n\n      // Calculate the remaining space after fitting full sleepers\n      const remainingSpace = l % this.sleeperIntervall;\n      // Distribute the remaining space evenly between sleepers\n      const adjustedInterval = this.sleeperIntervall + remainingSpace / amount;\n\n      const step_x = track.cos * adjustedInterval,\n         step_y = track.sin * adjustedInterval;\n\n      // Add the end gap\n      x += track.cos * (this.schwellenGap / 2);\n      y += track.sin * (this.schwellenGap / 2);\n\n      for (let i = 0; i < amount; i++) {\n         this.drawSleeper(i, x, y, track.deg, container);\n         // Move to next position using sleeperIntervall\n         y += step_y;\n         x += step_x;\n      }\n   }\n\n   drawSleeper(i, x, y, angle, container, length = this.schwellenHöhe, regY) {\n      if (stage.scale < this.LOD) {\n         // For simple shapes at low LOD\n         const ry = regY == null ? length / 2 : regY;\n\n         // Create a unique cache key based on the length\n         const cacheKey = `shape_${length}`;\n\n         // Get cached shape or create a new one\n         let sleeperShape = this._sleeperCache[cacheKey];\n         if (!sleeperShape) {\n            sleeperShape = new createjs.Shape();\n            sleeperShape.graphics\n               .setStrokeStyle(0.2, \"round\")\n               .beginStroke(\"black\")\n               .beginFill(\"#99735b\")\n               .r(0, 0, this.schwellenBreite, length)\n               .ef();\n            sleeperShape.setBounds(0, 0, this.schwellenBreite, length);\n            // Store in cache\n            this._sleeperCache[cacheKey] = sleeperShape;\n         }\n\n         // Clone the cached shape for this instance\n         let sleeper = sleeperShape.clone();\n         sleeper.x = x;\n         sleeper.y = y;\n         sleeper.rotation = angle;\n         sleeper.regY = ry;\n         sleeper.regX = 0;\n\n         container.addChild(sleeper);\n      } else {\n         // Use bitmap rendering at higher LOD\n         i = i % trackRendering_textured.SCHWELLEN_VARIANTEN;\n         const scaleY = length / this.schwellenHöhe;\n         const ry = regY == null ? this.schwellenImg.height / 2 : regY / (trackRendering_textured.TRACK_SCALE * scaleY);\n\n         // Check if we have a cached bitmap for this index\n         if (!this._bitmapCache[i]) {\n            // Create the sourceRect for this index\n            const sourceRect = new createjs.Rectangle(\n               (i * this.schwellenImg.width) / trackRendering_textured.SCHWELLEN_VARIANTEN,\n               0,\n               this.sleepersImgWidth,\n               this.schwellenImg.height\n            );\n\n            // Create and cache the bitmap\n            const bitmap = new createjs.Bitmap(this.schwellenImg);\n            bitmap.sourceRect = sourceRect;\n            this._bitmapCache[i] = bitmap;\n         }\n\n         // Clone the cached bitmap\n         const sleeperBitmap = this._bitmapCache[i].clone();\n\n         // Set position and transformation properties\n         sleeperBitmap.x = x;\n         sleeperBitmap.y = y;\n         sleeperBitmap.regY = ry;\n         sleeperBitmap.regX = 0;\n         sleeperBitmap.scale = trackRendering_textured.TRACK_SCALE;\n         sleeperBitmap.scaleY = trackRendering_textured.TRACK_SCALE * scaleY;\n         sleeperBitmap.rotation = angle;\n\n         container.addChild(sleeperBitmap);\n      }\n   }\n\n   getPointOnCurve(t, p0, cp, p1) {\n      const oneMinusT = 1 - t;\n      const tSquared = t * t;\n      const oneMinusTSquared = oneMinusT * oneMinusT;\n      const twoTimesT = 2 * oneMinusT * t;\n\n      return new _tools_js__WEBPACK_IMPORTED_MODULE_5__.Point(\n         oneMinusTSquared * p0.x + twoTimesT * cp.x + tSquared * p1.x,\n         oneMinusTSquared * p0.y + twoTimesT * cp.y + tSquared * p1.y\n      );\n   }\n\n   getDegreeOfTangentOnCurve(t, p0, cp, p1) {\n      const mt = 1 - t;\n      const dx = 2 * (mt * (cp.x - p0.x) + t * (p1.x - cp.x));\n      const dy = 2 * (mt * (cp.y - p0.y) + t * (p1.y - cp.y));\n      return Math.atan2(dy, dx) * (180 / Math.PI);\n   }\n\n   drawBumper(track, track_container) {\n      if (track.switchAtTheEnd == null) {\n         track_container.addChild(\n            new createjs.Bitmap(this.bumperImg).set({\n               y: track.end.y,\n               x: track.end.x,\n               scale: trackRendering_textured.TRACK_SCALE,\n               scaleX: -trackRendering_textured.TRACK_SCALE,\n               rotation: track.deg,\n               regY: this.bumperImg.height / 2,\n               regX: this.bumperImg.width,\n            })\n         );\n      }\n\n      if (track.switchAtTheStart == null) {\n         track_container.addChild(\n            new createjs.Bitmap(this.bumperImg).set({\n               y: track.start.y,\n               x: track.start.x,\n               scale: trackRendering_textured.TRACK_SCALE,\n               scaleX: trackRendering_textured.TRACK_SCALE,\n               rotation: track.deg,\n               regY: this.bumperImg.height / 2,\n               regX: this.bumperImg.width,\n            })\n         );\n      }\n   }\n\n   updateTrack(track) {\n      // Find the sleepers container for this track\n      const sleepersContainer = this._rendering.sleepers_container.children.find((c) => c.data === track);\n      if (!sleepersContainer) return;\n\n      // Remove existing sleepers\n      sleepersContainer.removeAllChildren();\n\n      // Calculate points and redraw sleepers with current LOD\n      const points = this.calculateTrackPoints(track);\n      this.drawTrackSleepers(points, sleepersContainer);\n\n      if (track == track.switchAtTheEnd?.t1) {\n         const switchSleepersContainer = this._rendering.sleepers_container.children.find((c) => c.data === track.switchAtTheEnd);\n         const switchRenderingParameter = this.getSwitchRenderingParameter(track.switchAtTheEnd);\n         this.drawSleepersOnSwitch(track.switchAtTheEnd, switchRenderingParameter, switchSleepersContainer);\n      }\n\n      if (track == track.switchAtTheStart?.t1) {\n         const switchSleepersContainer = this._rendering.sleepers_container.children.find(\n            (c) => c.data === track.switchAtTheStart\n         );\n         const switchRenderingParameter = this.getSwitchRenderingParameter(track.switchAtTheStart);\n         this.drawSleepersOnSwitch(track.switchAtTheStart, switchRenderingParameter, switchSleepersContainer);\n      }\n   }\n\n   updateSwitch(sw) {\n      // Find the sleepers container for this switch\n      const sleepersContainer = this._rendering.sleepers_container.children.find((c) => c.data === sw);\n      if (!sleepersContainer) return;\n\n      // Get rendering parameters\n      const switchRenderingParameter = this.getSwitchRenderingParameter(sw);\n\n      // Redraw sleepers with current LOD\n      this.drawSleepersOnSwitch(sw, switchRenderingParameter, sleepersContainer);\n   }\n\n   /**\n    * Creates a shape for a track endpoint\n    * @param {Point} point - The point where the endpoint should be\n    * @param {Track} track - The track this endpoint belongs to\n    * @param {string} endpointType - Either \"start\" or \"end\"\n    * @returns {createjs.Shape} The created shape\n    */\n   createEndpointShape(point, track, endpointType) {\n      const RECT_SIZE = 8;\n      const shape = new createjs.Shape();\n      \n      // Set properties to identify the shape\n      shape.name = \"track_endpoint\";\n      shape.endpoint = endpointType;\n      shape.track = track;\n      \n      // Create hit area\n      const hitArea = new createjs.Shape();\n      hitArea.graphics\n         .beginFill(\"#000\")\n         .drawRect(point.x - RECT_SIZE/2, point.y - RECT_SIZE/2, RECT_SIZE, RECT_SIZE);\n      shape.hitArea = hitArea;\n      \n      // Draw rectangle\n      shape.graphics\n         .setStrokeStyle(2)\n         .beginStroke(\"#ff0000\")\n         .drawRect(point.x - RECT_SIZE/2, point.y - RECT_SIZE/2, RECT_SIZE, RECT_SIZE);\n      \n      return shape;\n   }\n\n   /**\n    * Draws selection rectangles at the start and end points of a track\n    * @param {Track} track - The track to draw selection rectangles for\n    */\n   drawTrackEndpoints(track) {\n      // Create and add shapes for start and end points\n      selection_container.addChild(this.createEndpointShape(track.start, track, \"start\"));\n      selection_container.addChild(this.createEndpointShape(track.end, track, \"end\"));\n   }\n\n   updateSelection() {\n      selection_container.removeAllChildren();\n\n      if (selection.type == \"Track\") {\n         track_container.children[0].children.forEach((c) => {\n            if (selection.isSelectedObject(c.data)) {\n               this.visualizeTrackBounds(c);\n               this.drawTrackEndpoints(c.data);\n            }\n         });\n      } else if (selection.type == \"Signal\") {\n         signal_container.children.forEach((c) => {\n            if (c.data) {\n               if (selection.isSelectedObject(c.data)) this.visualizeTrackBounds(c);\n            }\n         });\n      } else if (selection.type == \"GenericObject\") {\n         object_container.children.forEach((c) => {\n            if (c.data) {\n               if (selection.isSelectedObject(c.data)) this.visualizeTrackBounds(c);\n            }\n         });\n      }\n      stage.update();\n   }\n\n   drawSleepersOnSwitch(sw, switchRenderingParameter, container) {\n      const { mainTrack, straightBranch, curvedBranch, curvedBranch2, flipped, mirrored } = switchRenderingParameter;\n\n      if (container == null) {\n         container = new createjs.Container();\n         container.name = \"switch_sleepers\";\n         container.data = sw;\n         container.mouseChildren = false;\n         this._rendering.sleepers_container.addChild(container);\n      } else {\n         container.removeAllChildren();\n      }\n\n      const deg = sw.track1.deg;\n\n                     const back2front = _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.is(sw.type, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_RIGHT, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_LEFT);\n\n      if (curvedBranch2 == null) {\n         const cp = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n            mainTrack.sleepers.outer,\n            mainTrack.unit,\n            curvedBranch.sleepers.outer,\n            curvedBranch.unit\n         );\n\n         const length = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(mainTrack.sleepers.inner, straightBranch.sleepers.inner); //length of the straight part + half of the gap, to minimize the gap the to next track\n         const length2 = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(mainTrack.sleepers.outer, curvedBranch.sleepers.outer); //almost the length of the curve\n\n         const amount_on_straight_rail = Math.floor(length / this.sleeperIntervall);\n         const amount_on_curved_rail = Math.floor(length2 / (this.sleeperIntervall * 1.15));\n         const new_intervall = (this.sleeperIntervall + (length % this.sleeperIntervall) / amount_on_straight_rail) * mirrored; //new intervall to minimize the gap and using the leftover from the division\n         let p1, t, sleeper_length;\n\n         if (back2front) p1 = mainTrack.sleepers.inner.sub(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(mainTrack.unit, this.sleeperIntervall));\n         else p1 = mainTrack.sleepers.inner.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(mainTrack.unit, (this.schwellenGap / 2) * mirrored));\n\n         const step_vector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(mainTrack.unit, new_intervall);\n\n         for (let i = 0; i < amount_on_curved_rail; i++) {\n            t = i / amount_on_curved_rail + 0.4 / amount_on_curved_rail;\n\n            sleeper_length = Math.max(\n               _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(this.getPointOnCurve(t, mainTrack.sleepers.outer, cp, curvedBranch.sleepers.outer), p1),\n               this.schwellenHöhe\n            );\n\n            this.drawSleeper(i, p1.x, p1.y, deg, container, -sleeper_length * flipped, 0);\n            p1 = p1.add(step_vector);\n         }\n\n         for (let i = amount_on_curved_rail; i < amount_on_straight_rail; i++) {\n            t = (this.sleeperIntervall * i) / length2;\n            //subtract the sleeper intervall to create a gap to the next sleeper\n            sleeper_length = Math.max(\n               _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(\n                  _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n                     curvedBranch.sleepers.outer,\n                     _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(curvedBranch.unit),\n                     p1,\n                     _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(mainTrack.unit)\n                  ),\n                  p1\n               ),\n               this.schwellenHöhe\n            );\n\n            this.drawSleeper(i, p1.x, p1.y, deg, container, -sleeper_length * flipped, 0);\n            p1 = p1.add(step_vector);\n         }\n      } else {\n         // Calculate starting point and offset vector\n         let centerPoint = straightBranch.position.add(mainTrack.unit.multiply(this.sleeperIntervall / 4));\n         const step_vector = mainTrack.unit.multiply(this.sleeperIntervall);\n         \n         // Create a full symmetric pattern from the half pattern\n         const pattern = trackRendering_textured.FOUR_WAY_SLEEPER_PATTERN;\n         const reversed_pattern = pattern.slice(0, -1).reverse(); //remove the last element because its right on the point of the switch\n         const point_symmetric_pattern = reversed_pattern.map(p => ({ offset: (2 * p.length) - p.offset, length: p.length }));\n         const fullPattern = [...pattern, ...point_symmetric_pattern];\n\n         // Draw sleepers using the pattern\n         fullPattern.forEach((data, i) => {\n            this.drawSleeper(\n               i,\n               centerPoint.x,\n               centerPoint.y,\n               deg,\n               container,\n               data.length * this.schwellenHöhe,\n               data.offset * this.schwellenHöhe_2\n            );\n            centerPoint = centerPoint.add(step_vector);\n         });\n      }\n   }\n\n   renderSwitch(sw, force) {\n      const switchRenderingParameter = this.getSwitchRenderingParameter(sw);\n\n      const shape = new createjs.Shape();\n      shape.data = sw;\n      shape.snapToPixel = true;\n      this._rendering.rails_container.addChild(shape);\n\n      // Draw track based on the number of tracks\n      if (switchRenderingParameter.curvedBranch2 == null) {\n         this.renderThreeWaySwitch(shape, switchRenderingParameter);\n      } else {\n         this.renderFourWaySwitch(shape, switchRenderingParameter);\n      }\n\n      this.drawSleepersOnSwitch(sw, switchRenderingParameter);\n      this.renderSwitchUI(sw);\n   }\n\n   getSwitchRenderingParameter(sw) {\n               const flipped = _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.is(sw.type, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_RIGHT, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.TO_RIGHT) ? -1 : 1;\n         const mirrored = _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.is(sw.type, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_LEFT, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_RIGHT) ? -1 : 1;\n\n      // Calculate track data for each track\n      const calcTrackData = (index) => {\n         let track = sw.tracks[index];\n         let unit = sw.track_directions[index];\n         if (!unit) {\n            // This can happen if calculateParameters hasn't been called on the switch.\n            // For robustness, we can calculate it here, but it's better to ensure it's calculated in the switch class.\n            console.warn(\"Switch track_directions not calculated, calculating on the fly.\");\n            sw.calculateParameters();\n            unit = sw.track_directions[index];\n         }\n\n         const railOffset = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit.multiply(this.rail_distance * flipped));\n         const sleeperOffset = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit.multiply(this.schwellenHöhe_2 * flipped));\n         // The position should be on the track, at a certain distance from the switch location.\n         const position = sw.location.add(unit.multiply(sw.size));\n\n         return {\n            unit: track.unit,\n            position: position,\n            rails: {\n               inner: position.add(railOffset),\n               outer: position.sub(railOffset),\n            },\n            sleepers: {\n               inner: position.add(sleeperOffset),\n               outer: position.sub(sleeperOffset),\n            },\n         };\n      };\n\n      const mainTrack = calcTrackData(0);\n      const straightBranch = calcTrackData(1);\n      const curvedBranch = calcTrackData(2);\n      const curvedBranch2 = sw.track4 ? calcTrackData(3) : null;\n\n      return { mainTrack, straightBranch, curvedBranch, curvedBranch2, flipped, mirrored };\n   }\n\n   renderThreeWaySwitch(shape, switchRenderingParameter) {\n      const g = shape.graphics;\n      const { mainTrack, straightBranch, curvedBranch, flipped, mirrored } = switchRenderingParameter;\n\n      // Calculate intersection points once - reuse for all rail sizes\n      const intersections = {\n         outerCurve: _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n            mainTrack.rails.outer,\n            mainTrack.unit,\n            curvedBranch.rails.outer,\n            curvedBranch.unit\n         ),\n\n         frog: _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n            straightBranch.rails.outer,\n            straightBranch.unit,\n            curvedBranch.rails.inner,\n            curvedBranch.unit\n         ),\n      };\n\n      // Calculate inner curve control point using the already calculated frog point\n      intersections.innerCurve = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n         mainTrack.rails.inner,\n         mainTrack.unit,\n         intersections.frog,\n         curvedBranch.unit\n      );\n\n      // Pre-calculate all herzstück (frog) points\n      const frogOffset = -trackRendering_textured.RAILS[0][0] * mirrored; //thats the distance between the frog and the point blades\n      const guardRailLength = 10 * mirrored;\n      const frogPoints = {\n         curveEnd: _tools_js__WEBPACK_IMPORTED_MODULE_5__.Point.fromPoint(intersections.frog).add(curvedBranch.unit.multiply(frogOffset)),\n         straightStart: _tools_js__WEBPACK_IMPORTED_MODULE_5__.Point.fromPoint(intersections.frog).add(straightBranch.unit.multiply(frogOffset)),\n      };\n\n      // Calculate end points using the pre-calculated points\n      frogPoints.straightEnd = frogPoints.curveEnd.add(straightBranch.unit.multiply(guardRailLength));\n      frogPoints.curveStart = frogPoints.straightStart.add(curvedBranch.unit.multiply(guardRailLength));\n\n      // Draw all rails with different thicknesses in one pass\n      for (const rail of trackRendering_textured.RAILS) {\n         g.setStrokeStyle(rail[0]).beginStroke(rail[1]);\n\n         // Outer curved branch\n         g.mt(mainTrack.rails.outer.x, mainTrack.rails.outer.y).quadraticCurveTo(\n            intersections.outerCurve.x,\n            intersections.outerCurve.y,\n            curvedBranch.rails.outer.x,\n            curvedBranch.rails.outer.y\n         );\n\n         // Inner curved branch with frog connection\n         g.mt(mainTrack.rails.inner.x, mainTrack.rails.inner.y)\n            .quadraticCurveTo(\n               intersections.innerCurve.x - flipped,\n               intersections.innerCurve.y - flipped,\n               frogPoints.curveEnd.x,\n               frogPoints.curveEnd.y\n            )\n            .lt(frogPoints.straightEnd.x, frogPoints.straightEnd.y);\n\n         // Frog point and connecting rails\n         g.mt(straightBranch.rails.outer.x, straightBranch.rails.outer.y)\n            .lt(intersections.frog.x, intersections.frog.y)\n            .lt(curvedBranch.rails.inner.x, curvedBranch.rails.inner.y);\n\n         // Straight connection\n         g.mt(mainTrack.rails.inner.x, mainTrack.rails.inner.y).lt(straightBranch.rails.inner.x, straightBranch.rails.inner.y);\n\n         // Guard rail\n         g.mt(frogPoints.curveStart.x, frogPoints.curveStart.y)\n            .lt(frogPoints.straightStart.x, frogPoints.straightStart.y)\n            .lt(mainTrack.rails.outer.x, mainTrack.rails.outer.y + 2 * flipped); //TODO  we can implement switching the switch here\n\n         g.endStroke();\n      }\n   }\n\n   renderFourWaySwitch(shape, switchRenderingParameter) {\n      const { mainTrack, straightBranch, curvedBranch, curvedBranch2 } = switchRenderingParameter;\n\n      const drawRail = (graphics, startTrack, endTrack, railSide) => {\n         // railSide: 'inner' or 'outer'\n\n         const startPoint = startTrack.rails[railSide];\n         const endPoint = endTrack.rails[railSide];\n\n         const cp1 = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.add(startPoint, _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(startTrack.unit, trackRendering_textured.CURVATURE_4WAY_SWITCH));\n         const cp2 = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.add(endPoint, _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(endTrack.unit, -trackRendering_textured.CURVATURE_4WAY_SWITCH));\n\n         graphics.mt(startPoint.x, startPoint.y).bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, endPoint.x, endPoint.y);\n      };\n\n      const g = shape.graphics;\n\n      // Draw all rails with different thicknesses\n      for (const rail of trackRendering_textured.RAILS) {\n         g.setStrokeStyle(rail[0]).beginStroke(rail[1]);\n\n         // Draw using the helper method for consistent curve rendering\n         drawRail(g, straightBranch, curvedBranch2, \"outer\");\n         drawRail(g, curvedBranch, mainTrack, \"inner\");\n         drawRail(g, straightBranch, curvedBranch2, \"inner\");\n         drawRail(g, curvedBranch, mainTrack, \"outer\");\n\n         // Draw straight connections\n         g.mt(mainTrack.rails.inner.x, mainTrack.rails.inner.y).lt(straightBranch.rails.inner.x, straightBranch.rails.inner.y);\n\n         g.mt(mainTrack.rails.outer.x, mainTrack.rails.outer.y).lt(straightBranch.rails.outer.x, straightBranch.rails.outer.y);\n\n         g.mt(curvedBranch.rails.inner.x, curvedBranch.rails.inner.y).lt(\n            curvedBranch2.rails.inner.x,\n            curvedBranch2.rails.inner.y\n         );\n\n         g.mt(curvedBranch.rails.outer.x, curvedBranch.rails.outer.y).lt(\n            curvedBranch2.rails.outer.x,\n            curvedBranch2.rails.outer.y\n         );\n\n         g.endStroke();\n      }\n   }\n\n   renderSwitchUI(sw) {      \n\n      const drawArrow = (graphics, length, size) => {\n         graphics.mt(0, 0)\n            .lt(length, 0)\n            .mt(length - size, -size / 2)\n            .lt(length, 0)\n            .lt(length - size, size / 2);\n      }\n\n      // Check if a container already exists for this switch\n      let container = ui_container.children.find((c) => c.data === sw);\n\n      if (container) {\n         // If container exists, clear it but keep it\n         container.removeAllChildren();\n      } else {\n         // Create a new container if none exists\n         container = new createjs.Container();\n         container.mouseChildren = false;\n         container.name = \"switch\";\n         container.data = sw;\n         ui_container.addChild(container);\n      }\n\n      // Add arrows for both tracks\n      [sw.from, sw.branch].forEach((t) => {\n         const arrow = new createjs.Shape();\n         container.addChild(arrow);\n\n         arrow.graphics.setStrokeStyle(trackRendering_textured.SWITCH_UI_STROKE, \"round\").beginStroke(\"#333\");\n         drawArrow(arrow.graphics, 20, 5);\n         arrow.x = sw.location.x;\n         arrow.y = sw.location.y;\n         arrow.rotation = _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.findAngle(sw.location, t.end.equals(sw.location) ? t.start : t.end);\n      });\n   }\n\n   PointVisible(p1) {\n      if (this._rendering?.dont_optimize) return true;\n      const screen_rectangle = this._rendering.screen_rectangle;\n\n      return (\n         _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.between(p1.x, screen_rectangle.left, screen_rectangle.right) &&\n         _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.between(p1.y, screen_rectangle.top, screen_rectangle.bottom)\n      );\n   }\n\n   TrackVisible(track, screen_rectangle = this._rendering.screen_rectangle) {\n      if (this._rendering?.dont_optimize) return true;\n\n      const isInside = (point, rect) =>\n         point.x > rect.left && point.x < rect.right && point.y > rect.top && point.y < rect.bottom;\n\n      //first the easy part, if either on of its end points is visible\n      if (isInside(track.start, screen_rectangle) || isInside(track.end, screen_rectangle)) return true; //\n\n      //now we have to make sure, if the track is going through the whole screen\n      //we check, if the track intersects one of the screen borders\n\n      //left\n      let p1 = { x: screen_rectangle.left, y: screen_rectangle.top },\n         p2 = { x: screen_rectangle.left, y: screen_rectangle.bottom };\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.doLineSegmentsIntersect(p1, p2, track.start, track.end)) return true;\n      //bottom\n      p1 = p2;\n      p2 = { x: screen_rectangle.right, y: screen_rectangle.bottom };\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.doLineSegmentsIntersect(p1, p2, track.start, track.end)) return true;\n      //right\n      p1 = p2;\n      p2 = { x: screen_rectangle.right, y: screen_rectangle.top };\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.doLineSegmentsIntersect(p1, p2, track.start, track.end)) return true;\n      //top we do not need to check all borders\n      /* p1 = p2;\n      p2 = { x: x, y: y };\n      if (geometry.doLineSegmentsIntersect(p1, p2, track.start, track.end)) return true; */\n\n      return false;\n   }\n\n   SwitchVisible(sw) {\n      if (this._rendering?.dont_optimize) return true;\n      const screen_rectangle = this._rendering.screen_rectangle;\n\n      // Check if switch location is visible\n      if (this.PointVisible(sw.location)) return true;\n\n      // Check if any of the switch's tracks are visible\n      const tracks = [sw.track1, sw.track2, sw.track3, sw.track4].filter(t => t);\n      return tracks.some(track => this.TrackVisible(track, screen_rectangle));\n   }\n\n   /**\n    * Visualize track bounds for debugging\n    * @param {Object} container - The container to visualize bounds for\n    */\n   visualizeTrackBounds(container) {\n      const bounds = container.getTransformedBounds();\n      const object = container.data;\n\n      if (bounds == null) throw new Error(\"Bounds are null\");\n\n      // Add padding to bounds\n      const padding = 5;\n      bounds.x -= padding;\n      bounds.y -= padding;\n      bounds.width += padding * 2;\n      bounds.height += padding * 2;\n\n      // Create a shape for the bounds visualization\n      const boundsShape = new createjs.Shape();\n      boundsShape.name = \"selection\";\n      boundsShape.mouseEnabled = false;\n      boundsShape.data = object;\n\n      // Draw the bounds rectangle\n      boundsShape.graphics\n         .setStrokeStyle(2)\n         .setStrokeDash([5, 5])\n         .beginStroke(\"rgba(0, 0, 0, 0.7)\")\n         .drawRect(bounds.x, bounds.y, bounds.width, bounds.height)\n         .endStroke();\n\n      selection_container.addChild(boundsShape);\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS90cmFja1JlbmRlcmluZ190ZXh0dXJlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTs7QUFFYjtBQUNtQztBQUNFO0FBQ2dCO0FBQ2xCO0FBQ2lCO0FBQ1A7QUFDSjtBQUNaOztBQUV0QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQyxRQUFRLHdCQUF3QjtBQUNoQyxRQUFRLDBCQUEwQjtBQUNsQyxRQUFRLDBCQUEwQjtBQUNsQyxRQUFRLDBCQUEwQjtBQUNsQyxRQUFRLDBCQUEwQjtBQUNsQyxRQUFRLDJCQUEyQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFNO0FBQ2hDLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGtEQUFXO0FBQ3BCLFNBQVMsa0RBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5R0FBeUc7O0FBRXpHO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbURBQW1EO0FBQ3BFLGdCQUFnQjtBQUNoQixVQUFVLCtDQUFRO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVSwrQ0FBUTtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVUsK0NBQVE7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYix5RkFBeUY7O0FBRXpGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nbGVpc3BsYW5lZGl0b3IvLi93d3cvY29kZS90cmFja1JlbmRlcmluZ190ZXh0dXJlZC5qcz9mNzRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay5qcyc7XG5pbXBvcnQgeyBTd2l0Y2ggfSBmcm9tICcuL3N3aXRjaC5qcyc7XG5pbXBvcnQgeyBTaWduYWwsIFNpZ25hbFJlbmRlcmVyIH0gZnJvbSAnLi9zaWduYWwuanMnO1xuaW1wb3J0IHsgVHJhaW4gfSBmcm9tICcuL3RyYWluLmpzJztcbmltcG9ydCB7IEdlbmVyaWNPYmplY3QgfSBmcm9tICcuL2dlbmVyaWNfb2JqZWN0LmpzJztcbmltcG9ydCB7IGdlb21ldHJ5LCBQb2ludCB9IGZyb20gJy4vdG9vbHMuanMnO1xuaW1wb3J0IHsgTnVtYmVyVXRpbHMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHVpIH0gZnJvbSAnLi91aS5qcyc7XG5cbmV4cG9ydCBjbGFzcyB0cmFja1JlbmRlcmluZ190ZXh0dXJlZCB7XG4gICBzdGF0aWMgU1dJVENIX1VJX1NUUk9LRSA9IDM7XG4gICBzdGF0aWMgVFJBQ0tfU0NBTEUgPSAwLjM7XG4gICBzdGF0aWMgc2lnbmFsZV9zY2FsZSA9IDAuNTtcbiAgIHN0YXRpYyBTQ0hXRUxMRU5fVkFSSUFOVEVOID0gMjQ7XG4gICBzdGF0aWMgQ1VSVkFUVVJFXzRXQVlfU1dJVENIID0gNzA7XG4gICBzdGF0aWMgUkFJTFMgPSBbXG4gICAgICBbMy4yLCBcIiMyMjJcIl0sXG4gICAgICBbMi44LCBcIiM5OTlcIl0sXG4gICAgICBbMS40LCBcIiNlZWVcIl0sXG4gICBdO1xuXG4gICAvLyBEZWZpbmUgc2xlZXBlciBwYXR0ZXJuIGZvciA0LXdheSBzd2l0Y2hcbiAgIHN0YXRpYyBGT1VSX1dBWV9TTEVFUEVSX1BBVFRFUk4gPSBbXG4gICAgICB7IG9mZnNldDogMSwgbGVuZ3RoOiAxLjAgfSwgLy8gU3RhcnQgc3RyYWlnaHRcbiAgICAgIHsgb2Zmc2V0OiAxLCBsZW5ndGg6IDEuNCB9LCAvLyBTdGFydCBzdHJhaWdodFxuICAgICAgeyBvZmZzZXQ6IDEuMSwgbGVuZ3RoOiAxLjcgfSwgLy8gQmVnaW4gdHJhbnNpdGlvblxuICAgICAgeyBvZmZzZXQ6IDEuMiwgbGVuZ3RoOiAxLjkgfSwgLy8gUGVhayBvZiBjdXJ2ZVxuICAgICAgeyBvZmZzZXQ6IDEuNCwgbGVuZ3RoOiAxLjggfSwgLy8gUGVhayBvZiBjdXJ2ZVxuICAgICAgeyBvZmZzZXQ6IDEuNSwgbGVuZ3RoOiAxLjcgfSwgLy8gQ3VydmVcbiAgICAgIHsgb2Zmc2V0OiAxLjcsIGxlbmd0aDogMS42NSB9LCAvLyBDdXJ2ZVxuICAgXTtcblxuICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAvL2NhdXNlIHRoZSBjbGFzcyBpcyBiZWVuIGxvYWRlZCBiZWZvcmUgc3RhcnQuanMsIHdlIGhhdmUgdG8gaGFjayBhbmQgY2FsY3VsYXRlIHRoaXMgY29uc3RhbnQgaGVyZVxuICAgICAgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuQ1VSVkVfUkFESVVTID0gd2luZG93LkdSSURfU0laRSAqIDEuMjE7XG5cbiAgICAgIHRoaXMuU0lHTkFMX0RJU1RBTkNFX0ZST01fVFJBQ0sgPSAzNTtcblxuICAgICAgdGhpcy5MT0QgPSA1O1xuICAgICAgdGhpcy5fbGFzdFJlbmRlclNjYWxlID0gMDtcblxuICAgICAgLy8gQ2FjaGUgZm9yIHNsZWVwZXIgc2hhcGVzIGFuZCBiaXRtYXBzXG4gICAgICB0aGlzLl9zbGVlcGVyQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuX2JpdG1hcENhY2hlID0gbmV3IEFycmF5KHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlNDSFdFTExFTl9WQVJJQU5URU4pO1xuICAgfVxuXG4gICBjbGVhblVwKCkge1xuICAgICAgaWYgKHRoaXMuX2lkbGVDYWxsYmFjaykge1xuICAgICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKSBjYW5jZWxJZGxlQ2FsbGJhY2sodGhpcy5faWRsZUNhbGxiYWNrKTtcbiAgICAgICAgIGVsc2UgY2xlYXJUaW1lb3V0KHRoaXMuX2lkbGVDYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG15SWRsZUNhbGxiYWNrID1cbiAgICAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8XG4gICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxKTtcbiAgICAgICAgIH07XG5cbiAgICAgIHRoaXMuX2lkbGVDYWxsYmFjayA9IG15SWRsZUNhbGxiYWNrKFxuICAgICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIGlmICh0cmFja19jb250YWluZXIucmVuZGVyZWRUcmFja3Muc2l6ZSA9PSAwIHx8IHRoaXMuX3JlbmRlcmluZyAhPSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmNhbGNDYW52YXNTaXplKCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdHJhY2tzIHRoYXQgYXJlIG5vIGxvbmdlciB2aXNpYmxlXG4gICAgICAgICAgICBjb25zdCB0b0JlUmVtb3ZlZCA9IFtdO1xuICAgICAgICAgICAgdHJhY2tfY29udGFpbmVyLnJlbmRlcmVkVHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICBpZiAoIXRoaXMuVHJhY2tWaXNpYmxlKHRyYWNrLCBib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgICB0b0JlUmVtb3ZlZC5wdXNoKHRyYWNrKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdHJhY2tzIGFuZCB0aGVpciBhc3NvY2lhdGVkIHNpZ25hbHNcbiAgICAgICAgICAgIHRvQmVSZW1vdmVkLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAvLyBSZW1vdmUgYXNzb2NpYXRlZCBzaWduYWxzXG4gICAgICAgICAgICAgICBjb25zdCBzaWduYWxzVG9CZVJlbW92ZWQgPSBzaWduYWxfY29udGFpbmVyLmNoaWxkcmVuLmZpbHRlcigoY3MpID0+IGNzLmRhdGEuX3Bvc2l0aW9uaW5nLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgICAgICAgICBzaWduYWxzVG9CZVJlbW92ZWQuZm9yRWFjaCgoY3MpID0+IHtcbiAgICAgICAgICAgICAgICAgIHNpZ25hbF9jb250YWluZXIucmVtb3ZlQ2hpbGQoY3MpO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhY2sgZnJvbSByZW5kZXJlZCBzZXRcbiAgICAgICAgICAgICAgIHRyYWNrX2NvbnRhaW5lci5yZW5kZXJlZFRyYWNrcy5kZWxldGUodHJhY2spO1xuXG4gICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhY2sgZWxlbWVudHMgZnJvbSBib3RoIGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgIGNvbnN0IHNsZWVwZXJzVG9SZW1vdmUgPSB0cmFja19jb250YWluZXIuY2hpbGRyZW5bMF0uY2hpbGRyZW4uZmlsdGVyKChjKSA9PiBjLmRhdGEgPT09IHRyYWNrKTtcbiAgICAgICAgICAgICAgIGNvbnN0IHJhaWxzVG9SZW1vdmUgPSB0cmFja19jb250YWluZXIuY2hpbGRyZW5bMV0uY2hpbGRyZW4uZmlsdGVyKChjKSA9PiBjLmRhdGEgPT09IHRyYWNrKTtcblxuICAgICAgICAgICAgICAgc2xlZXBlcnNUb1JlbW92ZS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgYy50cmFjaztcbiAgICAgICAgICAgICAgICAgIHRyYWNrX2NvbnRhaW5lci5jaGlsZHJlblswXS5yZW1vdmVDaGlsZChjKTtcbiAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICByYWlsc1RvUmVtb3ZlLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjLnRyYWNrO1xuICAgICAgICAgICAgICAgICAgdHJhY2tfY29udGFpbmVyLmNoaWxkcmVuWzFdLnJlbW92ZUNoaWxkKGMpO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgc2xlZXBlciBjYWNoZSBpZiBpdCdzIGdldHRpbmcgdG9vIGxhcmdlIChtb3JlIHRoYW4gMjAwIGVudHJpZXMpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc2xlZXBlckNhY2hlKS5sZW5ndGggPiAyMDApIHtcbiAgICAgICAgICAgICAgIHRoaXMuX3NsZWVwZXJDYWNoZSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9pZGxlQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgfVxuXG4gICBjYWxjQ2FudmFzU2l6ZSgpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gKHN0YWdlLmNhbnZhcy53aWR0aCArIEdSSURfU0laRSAqIDIpIC8gc3RhZ2Uuc2NhbGVYLFxuICAgICAgICAgaGVpZ2h0ID0gKHN0YWdlLmNhbnZhcy5oZWlnaHQgKyBHUklEX1NJWkUgKiAyKSAvIHN0YWdlLnNjYWxlWSxcbiAgICAgICAgIHggPSAoLXN0YWdlLnggLSBHUklEX1NJWkUpIC8gc3RhZ2Uuc2NhbGVYLFxuICAgICAgICAgeSA9ICgtc3RhZ2UueSAtIEdSSURfU0laRSkgLyBzdGFnZS5zY2FsZVk7XG4gICAgICByZXR1cm4geyBsZWZ0OiB4LCB0b3A6IHksIHJpZ2h0OiB4ICsgd2lkdGgsIGJvdHRvbTogeSArIGhlaWdodCB9O1xuICAgfVxuXG4gICAvLy9mb3JjZT1mYWxzZSBtZWFucywgZWFjaCBlbGVtZW50IGRlY2lkZXMgaWYgaXQgbmVlZHMgdG8gYmUgcmVkcmF3bi4gSWYgc29tZXRoaW5nIGdsb2JhbCBjaGFuZ2VkLFxuICAgLy8vbGlrZSB0aGUgc2NhbGUsIGZvcmNlIG5lZWRzIHRvIGJlIHRydWUuXG4gICAvLy8gZG9udF9vcHRpbWl6ZSBwYXJhbWV0ZXIgZGlzYWJsZXMgdGhlIG9wdGltYXNhdGlvbiB0byBvbmx5IGhhbmRsZSBhbmQgZHJhdyBlbGVtZW50cyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gICAvLy8gYW5kIGRpc2FibGVzIGNhY2hpbmcuIGl0cyB1c2VkIGJ5IHRoZSBleHBvcnQgdG8gaW1hZ2UgZnVuY3Rpb25hbGl0eVxuICAgcmVEcmF3RXZlcnl0aGluZyhmb3JjZSA9IGZhbHNlLCBkb250X29wdGltaXplID0gZmFsc2UpIHtcbiAgICAgIGlmICghcGwubG9hZGVkKVxuICAgICAgICAgLy9zdHVwaWQgY29kZSB0aGF0IHNob3VsZCBwcmV2ZW50IGRyYXdpbmcsIGJlZm9yZSB0aGUgcHJlbG9hZGVyIGlzIHJlYWR5XG4gICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVEcmF3RXZlcnl0aGluZyhmb3JjZSwgZG9udF9vcHRpbWl6ZSk7XG4gICAgICAgICB9LCA1MDApO1xuICAgICAgZWxzZSB7XG4gICAgICAgICBpZiAodGhpcy5fcmVuZGVyaW5nID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmluZyA9IHsgZG9udF9vcHRpbWl6ZTogZG9udF9vcHRpbWl6ZSB9O1xuICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyaW5nLnNjcmVlbl9yZWN0YW5nbGUgPSB0aGlzLmNhbGNDYW52YXNTaXplKCk7XG5cbiAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgdHJhY2tfY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICBzaWduYWxfY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICB1aV9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICAgIHRyYWluX2NvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgb2JqZWN0X2NvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgZGVidWdfY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBvdmVybGF5IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgb3ZlcmxheV9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjUmVuZGVyVmFsdWVzKCk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBwYXNzZWQgdGhlIExPRCBpbiBlaXRoZXIgZGlyZWN0aW9uIHdlIGhhdmUgdG8gcmVyZW5kZXIgdGhlIHRyYWNrc1xuICAgICAgICAgICAgICAgaWYgKE51bWJlclV0aWxzLmJldHdlZW4odGhpcy5MT0QsIHRoaXMuX2xhc3RSZW5kZXJTY2FsZSwgc3RhZ2Uuc2NhbGUpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJpbmcubG9kQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckFsbFRyYWNrcyhmb3JjZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckFsbFNpZ25hbHMoZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJBbGxUcmFpbnMoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQWxsR2VuZXJpY09iamVjdHMoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RSZW5kZXJTY2FsZSA9IHN0YWdlLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgaWYgKCFkb250X29wdGltaXplKSB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHJlbmRlcmluZzpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlcmluZztcbiAgICAgICAgICAgICAgICAgIHN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDcml0aWNhbCByZW5kZXJpbmcgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgIHVpLnNob3dFcnJvclRvYXN0KGVycm9yKTtcbiAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcmVjb3ZlciBieSBjbGVhcmluZyByZW5kZXJpbmcgc3RhdGVcbiAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJpbmc7XG4gICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgY2FsY1JlbmRlclZhbHVlcygpIHtcbiAgICAgIHRoaXMuc2Nod2VsbGVuSW1nID0gcGwuZ2V0SW1hZ2UoXCJzY2h3ZWxsZW5cIik7XG4gICAgICB0aGlzLmJ1bXBlckltZyA9IHBsLmdldEltYWdlKFwiYnVtcGVyXCIpO1xuICAgICAgdGhpcy5zbGVlcGVyc0ltZ1dpZHRoID0gdGhpcy5zY2h3ZWxsZW5JbWcud2lkdGggLyB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5TQ0hXRUxMRU5fVkFSSUFOVEVOO1xuICAgICAgdGhpcy5zY2h3ZWxsZW5Iw7ZoZSA9IHRoaXMuc2Nod2VsbGVuSW1nLmhlaWdodCAqIHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlRSQUNLX1NDQUxFO1xuICAgICAgdGhpcy5zY2h3ZWxsZW5Iw7ZoZV8yID0gdGhpcy5zY2h3ZWxsZW5Iw7ZoZSAvIDI7XG4gICAgICB0aGlzLnNjaHdlbGxlbkJyZWl0ZSA9IHRoaXMuc2xlZXBlcnNJbWdXaWR0aCAqIHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlRSQUNLX1NDQUxFO1xuICAgICAgdGhpcy5zY2h3ZWxsZW5HYXAgPSB0aGlzLnNjaHdlbGxlbkJyZWl0ZSAqIDEuMTsgLy8gZGlzdGFuY2UgYmV0d2VlbiB0aGUgc2xlZXBlcnNcbiAgICAgIHRoaXMuc2xlZXBlckludGVydmFsbCA9IHRoaXMuc2Nod2VsbGVuQnJlaXRlICsgdGhpcy5zY2h3ZWxsZW5HYXA7XG4gICAgICB0aGlzLnJhaWxfb2Zmc2V0ID0gdGhpcy5zY2h3ZWxsZW5Iw7ZoZSAvIDQuNzsgLy8gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmFpbCBhbmQgdGhlIGVuZCBvZiB0aGUgc2xlZXBlclxuICAgICAgdGhpcy5yYWlsX2Rpc3RhbmNlID0gdGhpcy5zY2h3ZWxsZW5Iw7ZoZV8yIC0gdGhpcy5yYWlsX29mZnNldDsgLy8gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmFpbCBhbmQgdGhlIGNlbnRlciBvZiB0aGUgdHJhY2tcblxuICAgICAgdGhpcy5UUkFJTl9IRUlHSFQgPSB0aGlzLnNjaHdlbGxlbkjDtmhlIC0gdGhpcy5yYWlsX29mZnNldDtcbiAgICAgIHRoaXMuVFJBSU5fV0lEVEggPSBHUklEX1NJWkUgKiAwLjc7XG5cbiAgICAgIHRoaXMubWFpbl94MSA9IChNYXRoLnNpbihNYXRoLlBJIC8gOCkgKiB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5DVVJWRV9SQURJVVMpIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDgpO1xuICAgfVxuXG4gICByZW5kZXJBbGxUcmFpbnMoKSB7XG4gICAgICB0cmFpbl9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblxuICAgICAgLy8gT25seSByZW5kZXIgdHJhaW5zIHRoYXQgYXJlbid0IGNvdXBsZWQgdG8gYW5vdGhlciB0cmFpbidzIGZyb250XG4gICAgICAvLyBUaGlzIGVuc3VyZXMgd2Ugb25seSBjcmVhdGUgY29udGFpbmVycyBmb3IgbGVhZCBjYXJzXG4gICAgICBUcmFpbi5hbGxUcmFpbnNcbiAgICAgICAgIC5maWx0ZXIoKHRyYWluKSA9PiAhdHJhaW4udHJhaW5Db3VwbGVkRnJvbnQpXG4gICAgICAgICAuZm9yRWFjaCgodHJhaW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBjLm5hbWUgPSBcInRyYWluXCI7XG4gICAgICAgICAgICBjLnRyYWluID0gdHJhaW47XG4gICAgICAgICAgICBjLm1vdXNlQ2hpbGRyZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBTdGFydCByZW5kZXJpbmcgZnJvbSB0aGUgZmlyc3QgY2FyIChsb2NvbW90aXZlKVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDYXIodHJhaW4sIGMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0cmFpbl9jb250YWluZXIuYWRkQ2hpbGQoYyk7XG4gICAgICAgICB9KTtcbiAgIH1cblxuICAgcmVuZGVyQ2FyKGNhciwgY29udGFpbmVyKSB7XG4gICAgICAvLyBDcmVhdGUgZ3JhcGhpY3MgZm9yIHRoZSBjYXJcbiAgICAgIGNvbnN0IGcgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcbiAgICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG4gICAgICBnLmJlZ2luU3Ryb2tlKGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigwLCAwLCAwKSk7XG4gICAgICBnLmJlZ2luRmlsbChjYXIuY29sb3IpO1xuXG4gICAgICAvLyBVc2UgdGhlIGNhcidzIGFjdHVhbCBsZW5ndGggZm9yIHdpZHRoIGluc3RlYWQgb2YgZml4ZWQgVFJBSU5fV0lEVEhcbiAgICAgIGNvbnN0IGNhcldpZHRoID0gY2FyLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNhckhlaWdodCA9IHRoaXMuVFJBSU5fSEVJR0hUO1xuXG4gICAgICAvLyBTZXQgY29ybmVyIHJhZGl1cyBiYXNlZCBvbiBjYXIgdHlwZSBhbmQgcG9zaXRpb24gaW4gdHJhaW5cbiAgICAgIGxldCBjb3JuZXIgPSBbMS41LCAxLjUsIDEuNSwgMS41XTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgY2FyIChsb2NvbW90aXZlKSwgcm91bmQgdGhlIGZyb250XG4gICAgICBpZiAoY2FyLnR5cGUgPT0gVHJhaW4uQ0FSX1RZUEVTLkxPQ09NT1RJVkUpIHtcbiAgICAgICAgIGNvcm5lclswXSA9IGNvcm5lclszXSA9IGNvcm5lclsxXSA9IGNvcm5lclsyXSA9IDg7XG4gICAgICB9XG5cbiAgICAgIC8qIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgY2FyLCByb3VuZCB0aGUgYmFja1xuICAgICAgaWYgKGNhci50cmFpbkNvdXBsZWRCYWNrID09IG51bGwpIHtcbiAgICAgICAgIGNvcm5lclsxXSA9IGNvcm5lclsyXSA9IDIwO1xuICAgICAgfSAqL1xuXG4gICAgICAvLyBEcmF3IGNhciB3aXRoIHJvdW5kZWQgY29ybmVyc1xuICAgICAgZy5kcmF3Um91bmRSZWN0Q29tcGxleCgwLCAwLCBjYXJXaWR0aCwgY2FySGVpZ2h0LCBjb3JuZXJbMF0sIGNvcm5lclsxXSwgY29ybmVyWzJdLCBjb3JuZXJbM10pO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHNoYXBlIGFuZCBwb3NpdGlvbiBpdFxuICAgICAgY29uc3QgcyA9IG5ldyBjcmVhdGVqcy5TaGFwZShnKTtcbiAgICAgIHMuZGF0YSA9IGNhcjtcbiAgICAgIHMubW91c2VDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgcy5uYW1lID0gXCJ0cmFpblwiO1xuXG4gICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9uIHRoZSB0cmFjayBiYXNlZCBvbiB0aGUgY2FyJ3Mga20gcG9zaXRpb25cbiAgICAgIGNvbnN0IHAgPSBjYXIudHJhY2suZ2V0UG9pbnRGcm9tS20oY2FyLnBvcyk7XG5cbiAgICAgIHMueCA9IHAueDtcbiAgICAgIHMueSA9IHAueTtcbiAgICAgIHMucmVnWCA9IGNhcldpZHRoIC8gMjtcbiAgICAgIHMucmVnWSA9IGNhckhlaWdodCAvIDI7XG4gICAgICBzLnJvdGF0aW9uID0gY2FyLnRyYWNrLmRlZztcblxuICAgICAgY29udGFpbmVyLmFkZENoaWxkKHMpO1xuICAgICAgLy8gQWRkIHRyYWluIG51bWJlciBpZiBpdCBleGlzdHNcbiAgICAgIGlmIChjYXIubnVtYmVyICYmIGNhci50eXBlID09IFRyYWluLkNBUl9UWVBFUy5MT0NPTU9USVZFKSB7XG4gICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IGNyZWF0ZWpzLlRleHQoY2FyLm51bWJlciwgXCIxMHB4IEFyaWFsXCIsIFwiIzAwMDAwMFwiKTtcbiAgICAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgIHRleHQueCA9IHAueDtcbiAgICAgICAgIHRleHQueSA9IHAueTtcbiAgICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0ZXh0KTtcbiAgICAgIH1cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IHJlbmRlciBjb3VwbGVkIGNhcnNcbiAgICAgIGlmIChjYXIudHJhaW5Db3VwbGVkQmFjaykge1xuICAgICAgICAgdGhpcy5yZW5kZXJDYXIoY2FyLnRyYWluQ291cGxlZEJhY2ssIGNvbnRhaW5lcik7XG4gICAgICB9XG4gICB9XG5cbiAgIHJlbmRlckFsbEdlbmVyaWNPYmplY3RzKCkge1xuICAgICAgb2JqZWN0X2NvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgR2VuZXJpY09iamVjdC5hbGxfb2JqZWN0cy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICBjb25zdCBjID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgYy5uYW1lID0gXCJHZW5lcmljT2JqZWN0XCI7XG4gICAgICAgICBjLmRhdGEgPSBvO1xuICAgICAgICAgYy5tb3VzZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICBjLnggPSBvLnBvcygpLng7XG4gICAgICAgICBjLnkgPSBvLnBvcygpLnk7XG5cbiAgICAgICAgIGlmIChvLnR5cGUoKSA9PT0gR2VuZXJpY09iamVjdC5PQkpFQ1RfVFlQRS50ZXh0KSB0aGlzLnJlbmRlclRleHRPYmplY3QobywgYyk7XG4gICAgICAgICBlbHNlIGlmIChvLnR5cGUoKSA9PT0gR2VuZXJpY09iamVjdC5PQkpFQ1RfVFlQRS5wbGF0dGZvcm0pIHRoaXMucmVuZGVyUGxhdHRmb3JtT2JqZWN0KG8sIGMpO1xuICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIE9iamVjdFwiKTtcblxuICAgICAgICAgb2JqZWN0X2NvbnRhaW5lci5hZGRDaGlsZChjKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICByZW5kZXJUZXh0T2JqZWN0KHRleHRfb2JqZWN0LCBjb250YWluZXIpIHtcbiAgICAgIHZhciB0ZXh0ID0gbmV3IGNyZWF0ZWpzLlRleHQodGV4dF9vYmplY3QuY29udGVudCgpLCBcIjI0cHggQXJpYWxcIiwgXCIjMDAwMDAwXCIpO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRleHQuZ2V0TWVhc3VyZWRIZWlnaHQoKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGV4dC5nZXRNZWFzdXJlZFdpZHRoKCk7XG5cbiAgICAgIGNvbnN0IGhpdCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgaGl0LmdyYXBoaWNzLmJlZ2luRmlsbChcIiMwMDBcIikubXQoMCwgMCkubHQod2lkdGgsIDApLmx0KHdpZHRoLCAtaGVpZ2h0KS5sdCgwLCAtaGVpZ2h0KS5sdCgwLCAwKTtcblxuICAgICAgdGV4dC5oaXRBcmVhID0gaGl0O1xuXG4gICAgICBjb250YWluZXIuYWRkQ2hpbGQodGV4dCk7XG4gICB9XG5cbiAgIHJlbmRlclBsYXR0Zm9ybU9iamVjdChwbGF0dGZvcm0sIGNvbnRhaW5lcikge1xuICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzaGFwZSk7XG4gICAgICBjb25zdCBzaXplID0gcGxhdHRmb3JtLnNpemUoKTtcbiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luU3Ryb2tlKFwiIzExMTExMVwiKS5iZWdpbkZpbGwoXCIjNDQ0XCIpLmRyYXdSZWN0KDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcbiAgICAgIHNoYXBlLnNldEJvdW5kcygwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cbiAgICAgIHZhciB0ZXh0ID0gbmV3IGNyZWF0ZWpzLlRleHQocGxhdHRmb3JtLmNvbnRlbnQoKSwgXCIxNnB4IEFyaWFsXCIsIFwiI2VlZVwiKTtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgIHRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgIHRleHQueCA9IHBsYXR0Zm9ybS5zaXplKCkud2lkdGggLyAyO1xuICAgICAgdGV4dC55ID0gcGxhdHRmb3JtLnNpemUoKS5oZWlnaHQgLyAyO1xuXG4gICAgICBjb250YWluZXIuYWRkQ2hpbGQodGV4dCk7XG4gICB9XG5cbiAgIHJlbmRlckFsbFNpZ25hbHMoZm9yY2UpIHtcbiAgICAgIHNpZ25hbF9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIFNpZ25hbC5hbGxTaWduYWxzLmZvckVhY2goKHNpZ25hbCkgPT4ge1xuICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHNpZ25hbF9jb250YWluZXIuYWRkQ2hpbGQoU2lnbmFsUmVuZGVyZXIuY3JlYXRlU2lnbmFsQ29udGFpbmVyKHNpZ25hbCkpO1xuICAgICAgICAgYWxpZ25TaWduYWxDb250YWluZXJXaXRoVHJhY2soY29udGFpbmVyLCBzaWduYWwuX3Bvc2l0aW9uaW5nKTtcbiAgICAgICAgIFxuICAgICAgfSk7XG4gICB9XG5cbiAgIHJlbmRlckFsbFRyYWNrcyhmb3JjZSkge1xuICAgICAgLy9pZiB3ZSBoYXZlIHRvIGZvcmNlIGEgcmVkcmF3LCB3ZSBoYXZlIHRvIGNyZWF0ZSB0aGUgY29udGFpbmVycyBmb3IgdGhlIHNsZWVwZXJzIGFuZCByYWlsc1xuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICBjb25zdCBzbGVlcGVyc19jb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gICAgICAgICBzbGVlcGVyc19jb250YWluZXIubmFtZSA9IFwiZ2xvYmFsX3NsZWVwZXJzXCI7XG4gICAgICAgICBzbGVlcGVyc19jb250YWluZXIubW91c2VDaGlsZHJlbiA9IHRydWU7XG5cbiAgICAgICAgIGNvbnN0IHJhaWxzX2NvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgIHJhaWxzX2NvbnRhaW5lci5uYW1lID0gXCJnbG9iYWxfcmFpbHNcIjtcbiAgICAgICAgIHJhaWxzX2NvbnRhaW5lci5tb3VzZUNoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICAgdGhpcy5fcmVuZGVyaW5nLnNsZWVwZXJzX2NvbnRhaW5lciA9IHNsZWVwZXJzX2NvbnRhaW5lcjtcbiAgICAgICAgIHRoaXMuX3JlbmRlcmluZy5yYWlsc19jb250YWluZXIgPSByYWlsc19jb250YWluZXI7XG5cbiAgICAgICAgIHRyYWNrX2NvbnRhaW5lci5hZGRDaGlsZChzbGVlcGVyc19jb250YWluZXIpO1xuICAgICAgICAgdHJhY2tfY29udGFpbmVyLmFkZENoaWxkKHJhaWxzX2NvbnRhaW5lcik7XG4gICAgICAgICB0cmFja19jb250YWluZXIucmVuZGVyZWRUcmFja3MgPSBuZXcgU2V0KCk7XG4gICAgICAgICB0cmFja19jb250YWluZXIucmVuZGVyZWRTd2l0Y2hlcyA9IG5ldyBTZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aGlzLl9yZW5kZXJpbmcuc2xlZXBlcnNfY29udGFpbmVyID0gdHJhY2tfY29udGFpbmVyLmNoaWxkcmVuWzBdO1xuICAgICAgICAgdGhpcy5fcmVuZGVyaW5nLnJhaWxzX2NvbnRhaW5lciA9IHRyYWNrX2NvbnRhaW5lci5jaGlsZHJlblsxXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0IG9mIFRyYWNrLmFsbFRyYWNrcykge1xuICAgICAgICAgaWYgKHRoaXMuVHJhY2tWaXNpYmxlKHQpKSB7XG4gICAgICAgICAgICAvL2VpdGhlciB3ZSBoYXZlIGEgZm9yY2VkIHJlZHJhdyBvciB0aGUgdHJhY2sgaXMgbm90IHJlbmRlcmVkIHlldFxuICAgICAgICAgICAgaWYgKGZvcmNlIHx8ICF0cmFja19jb250YWluZXIucmVuZGVyZWRUcmFja3MuaGFzKHQpKSB7XG4gICAgICAgICAgICAgICB0aGlzLnJlbmRlclRyYWNrKHQpO1xuICAgICAgICAgICAgICAgdHJhY2tfY29udGFpbmVyLnJlbmRlcmVkVHJhY2tzLmFkZCh0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcmVuZGVyaW5nLmxvZENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhY2sodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qgc3cgb2YgU3dpdGNoLmFsbFN3aXRjaGVzKSB7XG4gICAgICAgICBpZiAodGhpcy5Td2l0Y2hWaXNpYmxlKHN3KSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlIHx8ICF0cmFja19jb250YWluZXIucmVuZGVyZWRTd2l0Y2hlcy5oYXMoc3cpKSB7XG4gICAgICAgICAgICAgICB0aGlzLnJlbmRlclN3aXRjaChzdyk7XG4gICAgICAgICAgICAgICB0cmFja19jb250YWluZXIucmVuZGVyZWRTd2l0Y2hlcy5hZGQoc3cpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9yZW5kZXJpbmcubG9kQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTd2l0Y2goc3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuXG4gICAvLy9jYWxjdWxhdGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgZm9yIGVhY2ggbm9kZSBvZiBhIHRyYWNrIGFuZCB0aGUgY29udHJvbCBwb2ludCBmb3IgdGhlIGN1cnZlXG4gICAvLy9zdGFydCBhbmQgZW5kIHBvaW50cyBvZiBzdHJhaWdodCBzZWdtZW50cyBhcmUgYWRqdXN0ZWQgZm9yIHRoZSBjdXJ2ZXNcbiAgIGNhbGN1bGF0ZVRyYWNrUG9pbnRzKHRyYWNrKSB7XG4gICAgICBjb25zdCBzdGFydENvbm5lY3Rpb24gPSB0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0O1xuICAgICAgY29uc3QgZW5kQ29ubmVjdGlvbiA9IHRyYWNrLnN3aXRjaEF0VGhlRW5kO1xuXG4gICAgICBsZXQgc3RhcnRQb2ludCA9IHRyYWNrLnN0YXJ0O1xuICAgICAgbGV0IGVuZFBvaW50ID0gdHJhY2suZW5kO1xuXG4gICAgICAvLyBIYW5kbGUgdGhlIHN0YXJ0IG9mIHRoZSB0cmFja1xuICAgICAgaWYgKHN0YXJ0Q29ubmVjdGlvbikge1xuICAgICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbm5lY3Rpb24sIHNob3J0ZW4gdGhlIHRyYWNrIHRvIG1ha2Ugc3BhY2VcbiAgICAgICAgIGNvbnN0IHNpemUgPSBzdGFydENvbm5lY3Rpb24gaW5zdGFuY2VvZiBTd2l0Y2ggPyBzdGFydENvbm5lY3Rpb24uc2l6ZSA6IEdSSURfU0laRV8yO1xuICAgICAgICAgc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQuYWRkKGdlb21ldHJ5Lm11bHRpcGx5KHRyYWNrLnVuaXQsIHNpemUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGNvbm5lY3Rpb24sIGV4dGVuZCBpdCBmb3IgdGhlIGJ1bXBlclxuICAgICAgICAgc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQuc3ViKGdlb21ldHJ5Lm11bHRpcGx5KHRyYWNrLnVuaXQsIEdSSURfU0laRV8yKSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzdHJhaWdodEVuZFBvaW50ID0gZW5kUG9pbnQ7XG4gICAgICBsZXQgY3VydmVFbmQgPSBudWxsO1xuICAgICAgbGV0IGNvbnRyb2xQb2ludCA9IG51bGw7XG4gICAgICBsZXQgbmV4dFVuaXQgPSBudWxsO1xuXG4gICAgICAvLyBIYW5kbGUgdGhlIGVuZCBvZiB0aGUgdHJhY2tcbiAgICAgIGlmIChlbmRDb25uZWN0aW9uKSB7XG4gICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY29ubmVjdGlvbiwgc2hvcnRlbiB0aGUgdHJhY2sgdG8gbWFrZSBzcGFjZSBmb3IgdGhlIHN3aXRjaCBvciBjdXJ2ZVxuICAgICAgICAgY29uc3Qgc2l6ZSA9IGVuZENvbm5lY3Rpb24gaW5zdGFuY2VvZiBTd2l0Y2ggPyBlbmRDb25uZWN0aW9uLnNpemUgOiBHUklEX1NJWkVfMjtcbiAgICAgICAgIHN0cmFpZ2h0RW5kUG9pbnQgPSBlbmRQb2ludC5zdWIoZ2VvbWV0cnkubXVsdGlwbHkodHJhY2sudW5pdCwgc2l6ZSkpO1xuXG4gICAgICAgICBpZiAoZW5kQ29ubmVjdGlvbiBpbnN0YW5jZW9mIFRyYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpcyBhbm90aGVyIHRyYWNrLCBjYWxjdWxhdGUgdGhlIGN1cnZlXG4gICAgICAgICAgICBjb25zdCBuZXh0VHJhY2sgPSBlbmRDb25uZWN0aW9uO1xuICAgICAgICAgICAgbmV4dFVuaXQgPSBuZXh0VHJhY2sudW5pdDtcbiAgICAgICAgICAgIC8vIFRoZSBjdXJ2ZSBzaG91bGQgZW5kIGF0IHRoZSAqc2hvcnRlbmVkKiBzdGFydCBvZiB0aGUgbmV4dCB0cmFja1xuICAgICAgICAgICAgY3VydmVFbmQgPSBuZXh0VHJhY2suc3RhcnQuYWRkKGdlb21ldHJ5Lm11bHRpcGx5KG5leHRVbml0LCBHUklEX1NJWkVfMikpO1xuICAgICAgICAgICAgY29udHJvbFBvaW50ID0gZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uUG9pbnRYKHN0cmFpZ2h0RW5kUG9pbnQsIHRyYWNrLnVuaXQsIGN1cnZlRW5kLCBuZXh0VW5pdCk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBjb25uZWN0aW9uLCBleHRlbmQgdGhlIHRyYWNrIGZvciB0aGUgYnVtcGVyLlxuICAgICAgICAgc3RyYWlnaHRFbmRQb2ludCA9IGVuZFBvaW50LmFkZChnZW9tZXRyeS5tdWx0aXBseSh0cmFjay51bml0LCBHUklEX1NJWkVfMikpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjZW50ZXJMaW5lID0ge1xuICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgc3RhcnQ6IHN0YXJ0UG9pbnQsXG4gICAgICAgICBzdHJhaWdodEVuZDogc3RyYWlnaHRFbmRQb2ludCwgLy8gVGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBzdHJhaWdodCBwYXJ0LCBiZWZvcmUgYW55IGN1cnZlLlxuICAgICAgICAgZW5kOiBlbmRQb2ludCwgLy8gT3JpZ2luYWwgZW5kIHBvaW50IGZvciByZWZlcmVuY2UuXG4gICAgICAgICB1bml0OiB0cmFjay51bml0LFxuICAgICAgICAgY3VydmVFbmQ6IGN1cnZlRW5kLCAvLyBFbmQgcG9pbnQgb2YgdGhlIGN1cnZlLlxuICAgICAgICAgY29udHJvbFBvaW50OiBjb250cm9sUG9pbnQsIC8vIENvbnRyb2wgcG9pbnQgZm9yIHRoZSBjdXJ2ZS5cbiAgICAgICAgIG5leHRVbml0OiBuZXh0VW5pdCwgLy8gVW5pdCB2ZWN0b3Igb2YgdGhlIG5leHQgdHJhY2suXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNhbGN1bGF0ZVJhaWxQb3NpdGlvbnMoY2VudGVyTGluZSk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZVNsZWVwZXJPdXRsaW5lKGNlbnRlckxpbmUpO1xuXG4gICAgICByZXR1cm4gW2NlbnRlckxpbmVdO1xuICAgfVxuXG4gICAvKipcbiAgICAqIENhbGN1bGF0ZSBzbGVlcGVyIG91dGxpbmUgZm9yIGEgdHJhY2sgc2VnbWVudFxuICAgICogQHBhcmFtIHtPYmplY3R9IGNlbnRlckxpbmUgLSBUaGUgY2VudGVybGluZSBvYmplY3QgdG8gYWRkIHNsZWVwZXIgb3V0bGluZSB0b1xuICAgICovXG4gICBjYWxjdWxhdGVTbGVlcGVyT3V0bGluZShjZW50ZXJMaW5lKSB7XG4gICAgICBjb25zdCBzbGVlcGVyT2Zmc2V0ID0gdGhpcy5zY2h3ZWxsZW5Iw7ZoZV8yO1xuICAgICAgY29uc3Qgc2xlZXBlck9mZnNldFZlY3RvciA9IGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIoY2VudGVyTGluZS51bml0Lm11bHRpcGx5KHNsZWVwZXJPZmZzZXQpKTtcblxuICAgICAgY2VudGVyTGluZS5zbGVlcGVyT3V0bGluZSA9IHtcbiAgICAgICAgIHN0cmFpZ2h0OiB7XG4gICAgICAgICAgICBpbm5lcjoge1xuICAgICAgICAgICAgICAgc3RhcnQ6IGNlbnRlckxpbmUuc3RhcnQuYWRkKHNsZWVwZXJPZmZzZXRWZWN0b3IpLFxuICAgICAgICAgICAgICAgZW5kOiBjZW50ZXJMaW5lLnN0cmFpZ2h0RW5kLmFkZChzbGVlcGVyT2Zmc2V0VmVjdG9yKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvdXRlcjoge1xuICAgICAgICAgICAgICAgc3RhcnQ6IGNlbnRlckxpbmUuc3RhcnQuc3ViKHNsZWVwZXJPZmZzZXRWZWN0b3IpLFxuICAgICAgICAgICAgICAgZW5kOiBjZW50ZXJMaW5lLnN0cmFpZ2h0RW5kLnN1YihzbGVlcGVyT2Zmc2V0VmVjdG9yKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgaWYgKGNlbnRlckxpbmUuY29udHJvbFBvaW50KSB7XG4gICAgICAgICBjb25zdCBuZXh0U2xlZXBlck9mZnNldFZlY3RvciA9IGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIoY2VudGVyTGluZS5uZXh0VW5pdC5tdWx0aXBseShzbGVlcGVyT2Zmc2V0KSk7XG5cbiAgICAgICAgIGNvbnN0IGN1cnZlT3V0ZXJFbmQgPSBjZW50ZXJMaW5lLmN1cnZlRW5kLnN1YihuZXh0U2xlZXBlck9mZnNldFZlY3Rvcik7XG4gICAgICAgICBjb25zdCBjdXJ2ZUlubmVyRW5kID0gY2VudGVyTGluZS5jdXJ2ZUVuZC5hZGQobmV4dFNsZWVwZXJPZmZzZXRWZWN0b3IpO1xuXG4gICAgICAgICBjb25zdCBjdXJ2ZU91dGVyU3RhcnQgPSBjZW50ZXJMaW5lLnNsZWVwZXJPdXRsaW5lLnN0cmFpZ2h0Lm91dGVyLmVuZDtcbiAgICAgICAgIGNvbnN0IGN1cnZlSW5uZXJTdGFydCA9IGNlbnRlckxpbmUuc2xlZXBlck91dGxpbmUuc3RyYWlnaHQuaW5uZXIuZW5kO1xuXG4gICAgICAgICBjb25zdCBjcE91dGVyID0gZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uUG9pbnRYKGN1cnZlT3V0ZXJTdGFydCwgY2VudGVyTGluZS51bml0LCBjdXJ2ZU91dGVyRW5kLCBjZW50ZXJMaW5lLm5leHRVbml0KTtcbiAgICAgICAgIGNvbnN0IGNwSW5uZXIgPSBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludFgoY3VydmVJbm5lclN0YXJ0LCBjZW50ZXJMaW5lLnVuaXQsIGN1cnZlSW5uZXJFbmQsIGNlbnRlckxpbmUubmV4dFVuaXQpO1xuXG4gICAgICAgICBjZW50ZXJMaW5lLnNsZWVwZXJPdXRsaW5lLmN1cnZlID0ge1xuICAgICAgICAgICAgb3V0ZXI6IHsgc3RhcnQ6IGN1cnZlT3V0ZXJTdGFydCwgZW5kOiBjdXJ2ZU91dGVyRW5kLCBjcDogY3BPdXRlciB9LFxuICAgICAgICAgICAgaW5uZXI6IHsgc3RhcnQ6IGN1cnZlSW5uZXJTdGFydCwgZW5kOiBjdXJ2ZUlubmVyRW5kLCBjcDogY3BJbm5lciB9LFxuICAgICAgICAgfTtcbiAgICAgIH1cbiAgIH1cblxuICAgLyoqXG4gICAgKiBDYWxjdWxhdGUgcmFpbCBwb3NpdGlvbnMgZm9yIGEgdHJhY2sgc2VnbWVudFxuICAgICogQHBhcmFtIHtPYmplY3R9IGNlbnRlckxpbmUgLSBUaGUgY2VudGVybGluZSBvYmplY3QgdG8gYWRkIHJhaWwgcG9zaXRpb25zIHRvXG4gICAgKi9cbiAgIGNhbGN1bGF0ZVJhaWxQb3NpdGlvbnMoY2VudGVyTGluZSkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHJhaWwgb2Zmc2V0IHZlY3RvcnNcbiAgICAgIGNvbnN0IHJhaWxPZmZzZXRWZWN0b3IgPSBnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKGNlbnRlckxpbmUudW5pdC5tdWx0aXBseSh0aGlzLnJhaWxfZGlzdGFuY2UpKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHJhaWwgcG9zaXRpb25zIGZvciBzdHJhaWdodCBzZWdtZW50XG4gICAgICBjZW50ZXJMaW5lLnJhaWxzID0ge1xuICAgICAgICAgc3RyYWlnaHQ6IHtcbiAgICAgICAgICAgIC8vIElubmVyIHJhaWwgKHVzdWFsbHkgdGhlIHJpZ2h0IHNpZGUgaW4gdGhlIGRpcmVjdGlvbiBvZiB0cmF2ZWwpXG4gICAgICAgICAgICBpbm5lcjoge1xuICAgICAgICAgICAgICAgc3RhcnQ6IGNlbnRlckxpbmUuc3RhcnQuYWRkKHJhaWxPZmZzZXRWZWN0b3IpLFxuICAgICAgICAgICAgICAgZW5kOiBjZW50ZXJMaW5lLnN0cmFpZ2h0RW5kLmFkZChyYWlsT2Zmc2V0VmVjdG9yKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBPdXRlciByYWlsICh1c3VhbGx5IHRoZSBsZWZ0IHNpZGUgaW4gdGhlIGRpcmVjdGlvbiBvZiB0cmF2ZWwpXG4gICAgICAgICAgICBvdXRlcjoge1xuICAgICAgICAgICAgICAgc3RhcnQ6IGNlbnRlckxpbmUuc3RhcnQuc3ViKHJhaWxPZmZzZXRWZWN0b3IpLFxuICAgICAgICAgICAgICAgZW5kOiBjZW50ZXJMaW5lLnN0cmFpZ2h0RW5kLnN1YihyYWlsT2Zmc2V0VmVjdG9yKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHJhaWwgcG9zaXRpb25zIGZvciBjdXJ2ZSBpZiBpdCBleGlzdHNcbiAgICAgIGlmIChjZW50ZXJMaW5lLmNvbnRyb2xQb2ludCkge1xuICAgICAgICAgY29uc3QgbmV4dFJhaWxPZmZzZXRWZWN0b3IgPSBnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKGNlbnRlckxpbmUubmV4dFVuaXQubXVsdGlwbHkodGhpcy5yYWlsX2Rpc3RhbmNlKSk7XG5cbiAgICAgICAgIC8vIENhbGN1bGF0ZSBjdXJ2ZSBlbmRwb2ludHNcbiAgICAgICAgIGNvbnN0IGN1cnZlSW5uZXJFbmQgPSBjZW50ZXJMaW5lLmN1cnZlRW5kLmFkZChuZXh0UmFpbE9mZnNldFZlY3Rvcik7XG4gICAgICAgICBjb25zdCBjdXJ2ZU91dGVyRW5kID0gY2VudGVyTGluZS5jdXJ2ZUVuZC5zdWIobmV4dFJhaWxPZmZzZXRWZWN0b3IpO1xuXG4gICAgICAgICAvLyBDYWxjdWxhdGUgY3VydmUgc3RhcnRwb2ludHMgKHNhbWUgYXMgc3RyYWlnaHQgc2VnbWVudCBlbmRwb2ludHMpXG4gICAgICAgICBjb25zdCBjdXJ2ZUlubmVyU3RhcnQgPSBjZW50ZXJMaW5lLnJhaWxzLnN0cmFpZ2h0LmlubmVyLmVuZDtcbiAgICAgICAgIGNvbnN0IGN1cnZlT3V0ZXJTdGFydCA9IGNlbnRlckxpbmUucmFpbHMuc3RyYWlnaHQub3V0ZXIuZW5kO1xuXG4gICAgICAgICAvLyBDYWxjdWxhdGUgY29udHJvbCBwb2ludHMgZm9yIGlubmVyIGFuZCBvdXRlciByYWlsIGN1cnZlc1xuICAgICAgICAgY29uc3QgY3BJbm5lciA9IGdlb21ldHJ5LmdldEludGVyc2VjdGlvblBvaW50WChjdXJ2ZUlubmVyU3RhcnQsIGNlbnRlckxpbmUudW5pdCwgY3VydmVJbm5lckVuZCwgY2VudGVyTGluZS5uZXh0VW5pdCk7XG4gICAgICAgICBjb25zdCBjcE91dGVyID0gZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uUG9pbnRYKGN1cnZlT3V0ZXJTdGFydCwgY2VudGVyTGluZS51bml0LCBjdXJ2ZU91dGVyRW5kLCBjZW50ZXJMaW5lLm5leHRVbml0KTtcblxuICAgICAgICAgLy8gU3RvcmUgY3VydmUgcmFpbCBwb3NpdGlvbnNcbiAgICAgICAgIGNlbnRlckxpbmUucmFpbHMuY3VydmUgPSB7XG4gICAgICAgICAgICBpbm5lcjoge1xuICAgICAgICAgICAgICAgc3RhcnQ6IGN1cnZlSW5uZXJTdGFydCxcbiAgICAgICAgICAgICAgIGVuZDogY3VydmVJbm5lckVuZCxcbiAgICAgICAgICAgICAgIGNwOiBjcElubmVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dGVyOiB7XG4gICAgICAgICAgICAgICBzdGFydDogY3VydmVPdXRlclN0YXJ0LFxuICAgICAgICAgICAgICAgZW5kOiBjdXJ2ZU91dGVyRW5kLFxuICAgICAgICAgICAgICAgY3A6IGNwT3V0ZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgfTtcbiAgICAgIH1cbiAgIH1cblxuICAgcmVuZGVyVHJhY2sodHJhY2spIHtcbiAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY2FsY3VsYXRlVHJhY2tQb2ludHModHJhY2spO1xuXG4gICAgICBjb25zdCBzbGVlcGVyc19jb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gICAgICBzbGVlcGVyc19jb250YWluZXIubmFtZSA9IFwidHJhY2tcIjtcbiAgICAgIHNsZWVwZXJzX2NvbnRhaW5lci5tb3VzZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICBzbGVlcGVyc19jb250YWluZXIuZGF0YSA9IHRyYWNrO1xuICAgICAgdGhpcy5fcmVuZGVyaW5nLnNsZWVwZXJzX2NvbnRhaW5lci5hZGRDaGlsZChzbGVlcGVyc19jb250YWluZXIpO1xuXG4gICAgICBjb25zdCBoaXRBcmVhID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICBoaXRBcmVhLmdyYXBoaWNzLmJlZ2luRmlsbChcIiMwMDBcIik7IC8vIENvbG9yIGRvZXNuJ3QgbWF0dGVyLCBvbmx5IG5lZWQgb25lIGZpbGxcbiAgICAgIGZvciAoY29uc3QgcCBvZiBwb2ludHMpIHtcbiAgICAgICAgIGNvbnN0IHN0cmFpZ2h0ID0gcC5zbGVlcGVyT3V0bGluZS5zdHJhaWdodDtcbiAgICAgICAgIGhpdEFyZWEuZ3JhcGhpY3NcbiAgICAgICAgICAgIC5tb3ZlVG8oc3RyYWlnaHQub3V0ZXIuc3RhcnQueCwgc3RyYWlnaHQub3V0ZXIuc3RhcnQueSlcbiAgICAgICAgICAgIC5saW5lVG8oc3RyYWlnaHQub3V0ZXIuZW5kLngsIHN0cmFpZ2h0Lm91dGVyLmVuZC55KVxuICAgICAgICAgICAgLmxpbmVUbyhzdHJhaWdodC5pbm5lci5lbmQueCwgc3RyYWlnaHQuaW5uZXIuZW5kLnkpXG4gICAgICAgICAgICAubGluZVRvKHN0cmFpZ2h0LmlubmVyLnN0YXJ0LngsIHN0cmFpZ2h0LmlubmVyLnN0YXJ0LnkpXG4gICAgICAgICAgICAuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgIGlmIChwLnNsZWVwZXJPdXRsaW5lLmN1cnZlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJ2ZSA9IHAuc2xlZXBlck91dGxpbmUuY3VydmU7XG4gICAgICAgICAgICBoaXRBcmVhLmdyYXBoaWNzXG4gICAgICAgICAgICAgICAubW92ZVRvKGN1cnZlLmlubmVyLnN0YXJ0LngsIGN1cnZlLmlubmVyLnN0YXJ0LnkpXG4gICAgICAgICAgICAgICAucXVhZHJhdGljQ3VydmVUbyhjdXJ2ZS5pbm5lci5jcC54LCBjdXJ2ZS5pbm5lci5jcC55LCBjdXJ2ZS5pbm5lci5lbmQueCwgY3VydmUuaW5uZXIuZW5kLnkpXG4gICAgICAgICAgICAgICAubGluZVRvKGN1cnZlLm91dGVyLmVuZC54LCBjdXJ2ZS5vdXRlci5lbmQueSlcbiAgICAgICAgICAgICAgIC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlLm91dGVyLmNwLngsIGN1cnZlLm91dGVyLmNwLnksIGN1cnZlLm91dGVyLnN0YXJ0LngsIGN1cnZlLm91dGVyLnN0YXJ0LnkpXG4gICAgICAgICAgICAgICAuY2xvc2VQYXRoKCk7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBzbGVlcGVyc19jb250YWluZXIuaGl0QXJlYSA9IGhpdEFyZWE7XG5cbiAgICAgIHRoaXMuZHJhd1RyYWNrU2xlZXBlcnMocG9pbnRzLCBzbGVlcGVyc19jb250YWluZXIpO1xuXG4gICAgICAvLyBEcmF3IHJhaWxzXG4gICAgICBjb25zdCByYWlsU2hhcGUgPSB0aGlzLnJlbmRlclJhaWxzKHRyYWNrLCBwb2ludHMpO1xuXG4gICAgICAvLyBHZXQgYm91bmRzIGZyb20gdGhlIHJhaWwgc2hhcGVcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHJhaWxTaGFwZS5nZXRCb3VuZHMoKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgdHJhY2sgb2JqZWN0IHRoYXQgY29tYmluZXMgcmFpbCBhbmQgc2xlZXBlciBpbmZvcm1hdGlvblxuICAgICAgdHJhY2suX3JlbmRlckRhdGEgPSB7XG4gICAgICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5kcmF3QnVtcGVyKHRyYWNrLCB0aGlzLl9yZW5kZXJpbmcucmFpbHNfY29udGFpbmVyKTtcbiAgIH1cblxuICAgY2FsY3VsYXRlUmFpbEJvdW5kcyhwb2ludHMpIHtcbiAgICAgIC8vIEluaXRpYWxpemUgYm91bmRzIHdpdGggZmlyc3QgcG9pbnRcbiAgICAgIGxldCBtaW5YID0gSW5maW5pdHksXG4gICAgICAgICBtaW5ZID0gSW5maW5pdHksXG4gICAgICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgICAgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgICAgLy8gSGVscGVyIHRvIHVwZGF0ZSBib3VuZHMgd2l0aCBhIHBvaW50XG4gICAgICBjb25zdCB1cGRhdGVCb3VuZHMgPSAocG9pbnQpID0+IHtcbiAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBwb2ludC54KTtcbiAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBwb2ludC55KTtcbiAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwb2ludC54KTtcbiAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBwb2ludC55KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgcG9pbnRzIGFuZCBjb2xsZWN0IGV4dHJlbWVzXG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xuICAgICAgICAgLy8gQWRkIGFsbCBzdHJhaWdodCBzZWdtZW50IHBvaW50cyB0byBib3VuZHNcbiAgICAgICAgIGNvbnN0IHsgaW5uZXIsIG91dGVyIH0gPSBwb2ludC5yYWlscy5zdHJhaWdodDtcbiAgICAgICAgIHVwZGF0ZUJvdW5kcyhpbm5lci5zdGFydCk7XG4gICAgICAgICB1cGRhdGVCb3VuZHMoaW5uZXIuZW5kKTtcbiAgICAgICAgIHVwZGF0ZUJvdW5kcyhvdXRlci5zdGFydCk7XG4gICAgICAgICB1cGRhdGVCb3VuZHMob3V0ZXIuZW5kKTtcblxuICAgICAgICAgLy8gSGFuZGxlIGN1cnZlIHNlZ21lbnRzXG4gICAgICAgICBpZiAocG9pbnQucmFpbHMuY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnZlID0gcG9pbnQucmFpbHMuY3VydmU7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjdXJ2ZSBlbmRwb2ludHMgYW5kIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICB1cGRhdGVCb3VuZHMoY3VydmUuaW5uZXIuc3RhcnQpO1xuICAgICAgICAgICAgdXBkYXRlQm91bmRzKGN1cnZlLmlubmVyLmVuZCk7XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHMoY3VydmUub3V0ZXIuc3RhcnQpO1xuICAgICAgICAgICAgdXBkYXRlQm91bmRzKGN1cnZlLm91dGVyLmVuZCk7XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBwYWRkaW5nIGZvciBsaW5lIHRoaWNrbmVzc1xuICAgICAgY29uc3QgcGFkZGluZyA9IHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlJBSUxTWzBdWzBdICogMC41OyAvLyBIYWxmIG9mIHRoZSB0aGlja2VzdCByYWlsXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgeDogbWluWCAtIHBhZGRpbmcsXG4gICAgICAgICB5OiBtaW5ZIC0gcGFkZGluZyxcbiAgICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCArIHBhZGRpbmcgKiAyLFxuICAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSArIHBhZGRpbmcgKiAyLFxuICAgICAgfTtcbiAgIH1cblxuICAgcmVuZGVyUmFpbHModHJhY2ssIHBvaW50cykge1xuICAgICAgY29uc3QgcmFpbF9zaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgcmFpbF9zaGFwZS5uYW1lID0gXCJ0cmFja1wiO1xuICAgICAgcmFpbF9zaGFwZS5zbmFwVG9QaXhlbCA9IHRydWU7XG4gICAgICByYWlsX3NoYXBlLmRhdGEgPSB0cmFjaztcbiAgICAgIHRoaXMuX3JlbmRlcmluZy5yYWlsc19jb250YWluZXIuYWRkQ2hpbGQocmFpbF9zaGFwZSk7XG5cbiAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgICAvLyBVc2UgcHJlLWNhbGN1bGF0ZWQgcmFpbCBwb3NpdGlvbnNcbiAgICAgICAgIGNvbnN0IHsgc3RyYWlnaHQsIGN1cnZlIH0gPSBwb2ludC5yYWlscztcblxuICAgICAgICAgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuUkFJTFMuZm9yRWFjaCgocmFpbCkgPT4ge1xuICAgICAgICAgICAgcmFpbF9zaGFwZS5ncmFwaGljcy5zZXRTdHJva2VTdHlsZShyYWlsWzBdKS5iZWdpblN0cm9rZShyYWlsWzFdKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBzdHJhaWdodCBzZWdtZW50c1xuICAgICAgICAgICAgcmFpbF9zaGFwZS5ncmFwaGljc1xuICAgICAgICAgICAgICAgLm10KHN0cmFpZ2h0LmlubmVyLnN0YXJ0LngsIHN0cmFpZ2h0LmlubmVyLnN0YXJ0LnkpXG4gICAgICAgICAgICAgICAubHQoc3RyYWlnaHQuaW5uZXIuZW5kLngsIHN0cmFpZ2h0LmlubmVyLmVuZC55KVxuICAgICAgICAgICAgICAgLm10KHN0cmFpZ2h0Lm91dGVyLnN0YXJ0LngsIHN0cmFpZ2h0Lm91dGVyLnN0YXJ0LnkpXG4gICAgICAgICAgICAgICAubHQoc3RyYWlnaHQub3V0ZXIuZW5kLngsIHN0cmFpZ2h0Lm91dGVyLmVuZC55KTtcblxuICAgICAgICAgICAgLy8gRHJhdyBjdXJ2ZXMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGN1cnZlKSB7XG4gICAgICAgICAgICAgICByYWlsX3NoYXBlLmdyYXBoaWNzXG4gICAgICAgICAgICAgICAgICAubXQoY3VydmUub3V0ZXIuc3RhcnQueCwgY3VydmUub3V0ZXIuc3RhcnQueSlcbiAgICAgICAgICAgICAgICAgIC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlLm91dGVyLmNwLngsIGN1cnZlLm91dGVyLmNwLnksIGN1cnZlLm91dGVyLmVuZC54LCBjdXJ2ZS5vdXRlci5lbmQueSlcbiAgICAgICAgICAgICAgICAgIC5tdChjdXJ2ZS5pbm5lci5zdGFydC54LCBjdXJ2ZS5pbm5lci5zdGFydC55KVxuICAgICAgICAgICAgICAgICAgLnF1YWRyYXRpY0N1cnZlVG8oY3VydmUuaW5uZXIuY3AueCwgY3VydmUuaW5uZXIuY3AueSwgY3VydmUuaW5uZXIuZW5kLngsIGN1cnZlLmlubmVyLmVuZC55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmFpbF9zaGFwZS5ncmFwaGljcy5lbmRTdHJva2UoKTtcbiAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgYW5kIHNldCBib3VuZHMgZm9yIHRoZSByYWlsIHNoYXBlXG4gICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmNhbGN1bGF0ZVJhaWxCb3VuZHMocG9pbnRzKTtcbiAgICAgIHJhaWxfc2hhcGUuc2V0Qm91bmRzKGJvdW5kcy54LCBib3VuZHMueSwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcblxuICAgICAgLy8gSWYgZGVidWcgbW9kZSBpcyBlbmFibGVkLCB2aXN1YWxpemUgdGhlIGJvdW5kc1xuICAgICAgaWYgKHdpbmRvdy5ERUJVR19CT1VORFMpIHtcbiAgICAgICAgIHRoaXMudmlzdWFsaXplVHJhY2tCb3VuZHModHJhY2ssIGJvdW5kcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYWlsX3NoYXBlO1xuICAgfVxuXG4gICBkcmF3VHJhY2tTbGVlcGVycyhwb2ludHMsIGNvbnRhaW5lcikge1xuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgICAgIC8vIERyYXcgc2xlZXBlcnMgZm9yIHN0cmFpZ2h0IHNlZ21lbnRcbiAgICAgICAgIHRoaXMuZHJhd1NsZWVwZXJzKHBvaW50LnRyYWNrLCBwb2ludC5zdGFydCwgcG9pbnQuc3RyYWlnaHRFbmQsIGNvbnRhaW5lcik7XG5cbiAgICAgICAgIC8vIERyYXcgc2xlZXBlcnMgZm9yIGN1cnZlIGlmIGV4aXN0c1xuICAgICAgICAgaWYgKHBvaW50LnJhaWxzLmN1cnZlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTbGVlcGVyc0Fsb25nQ3VydmUocG9pbnQuc3RyYWlnaHRFbmQsIHBvaW50LmN1cnZlRW5kLCBwb2ludC5jb250cm9sUG9pbnQsIGNvbnRhaW5lcik7XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG5cbiAgIGRyYXdTbGVlcGVyc0Fsb25nQ3VydmUoc3RhcnRQb2ludCwgZW5kUG9pbnQsIGNvbnRyb2xQb2ludCwgY29udGFpbmVyKSB7XG4gICAgICAvL3RoZSBjdXJ2ZSBpcyBlcHJveGltYXQgMTElIHRpbWVzIGxvbmdlciB0aGFuIHRoZSBzdHJhaWdodCBsaW5lXG4gICAgICBjb25zdCBzdGVwcyA9IE1hdGguZmxvb3IoKGdlb21ldHJ5LmRpc3RhbmNlKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSAqIDEuMTEpIC8gdGhpcy5zbGVlcGVySW50ZXJ2YWxsKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gc3RlcHM7XG4gICAgICBsZXQgdCA9IDAuMjUgLyBzdGVwcyxcbiAgICAgICAgIHBvaW50LFxuICAgICAgICAgYW5nbGU7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHM7IGkrKykge1xuICAgICAgICAgcG9pbnQgPSB0aGlzLmdldFBvaW50T25DdXJ2ZSh0LCBzdGFydFBvaW50LCBjb250cm9sUG9pbnQsIGVuZFBvaW50KTtcbiAgICAgICAgIGFuZ2xlID0gdGhpcy5nZXREZWdyZWVPZlRhbmdlbnRPbkN1cnZlKHQsIHN0YXJ0UG9pbnQsIGNvbnRyb2xQb2ludCwgZW5kUG9pbnQpO1xuXG4gICAgICAgICB0aGlzLmRyYXdTbGVlcGVyKGksIHBvaW50LngsIHBvaW50LnksIGFuZ2xlLCBjb250YWluZXIpO1xuICAgICAgICAgdCArPSBzdGVwO1xuICAgICAgfVxuICAgfVxuXG4gICBkcmF3U2xlZXBlcnModHJhY2ssIHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBjb250YWluZXIpIHtcbiAgICAgIGxldCB4ID0gc3RhcnRQb2ludC54O1xuICAgICAgbGV0IHkgPSBzdGFydFBvaW50Lnk7XG5cbiAgICAgIGNvbnN0IGwgPSBnZW9tZXRyeS5kaXN0YW5jZShzdGFydFBvaW50LCBlbmRQb2ludCk7XG4gICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgc2xlZXBlcnMgZml0XG4gICAgICBjb25zdCBhbW91bnQgPSBNYXRoLmZsb29yKGwgLyB0aGlzLnNsZWVwZXJJbnRlcnZhbGwpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHJlbWFpbmluZyBzcGFjZSBhZnRlciBmaXR0aW5nIGZ1bGwgc2xlZXBlcnNcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1NwYWNlID0gbCAlIHRoaXMuc2xlZXBlckludGVydmFsbDtcbiAgICAgIC8vIERpc3RyaWJ1dGUgdGhlIHJlbWFpbmluZyBzcGFjZSBldmVubHkgYmV0d2VlbiBzbGVlcGVyc1xuICAgICAgY29uc3QgYWRqdXN0ZWRJbnRlcnZhbCA9IHRoaXMuc2xlZXBlckludGVydmFsbCArIHJlbWFpbmluZ1NwYWNlIC8gYW1vdW50O1xuXG4gICAgICBjb25zdCBzdGVwX3ggPSB0cmFjay5jb3MgKiBhZGp1c3RlZEludGVydmFsLFxuICAgICAgICAgc3RlcF95ID0gdHJhY2suc2luICogYWRqdXN0ZWRJbnRlcnZhbDtcblxuICAgICAgLy8gQWRkIHRoZSBlbmQgZ2FwXG4gICAgICB4ICs9IHRyYWNrLmNvcyAqICh0aGlzLnNjaHdlbGxlbkdhcCAvIDIpO1xuICAgICAgeSArPSB0cmFjay5zaW4gKiAodGhpcy5zY2h3ZWxsZW5HYXAgLyAyKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgICAgdGhpcy5kcmF3U2xlZXBlcihpLCB4LCB5LCB0cmFjay5kZWcsIGNvbnRhaW5lcik7XG4gICAgICAgICAvLyBNb3ZlIHRvIG5leHQgcG9zaXRpb24gdXNpbmcgc2xlZXBlckludGVydmFsbFxuICAgICAgICAgeSArPSBzdGVwX3k7XG4gICAgICAgICB4ICs9IHN0ZXBfeDtcbiAgICAgIH1cbiAgIH1cblxuICAgZHJhd1NsZWVwZXIoaSwgeCwgeSwgYW5nbGUsIGNvbnRhaW5lciwgbGVuZ3RoID0gdGhpcy5zY2h3ZWxsZW5Iw7ZoZSwgcmVnWSkge1xuICAgICAgaWYgKHN0YWdlLnNjYWxlIDwgdGhpcy5MT0QpIHtcbiAgICAgICAgIC8vIEZvciBzaW1wbGUgc2hhcGVzIGF0IGxvdyBMT0RcbiAgICAgICAgIGNvbnN0IHJ5ID0gcmVnWSA9PSBudWxsID8gbGVuZ3RoIC8gMiA6IHJlZ1k7XG5cbiAgICAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBjYWNoZSBrZXkgYmFzZWQgb24gdGhlIGxlbmd0aFxuICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgc2hhcGVfJHtsZW5ndGh9YDtcblxuICAgICAgICAgLy8gR2V0IGNhY2hlZCBzaGFwZSBvciBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgICBsZXQgc2xlZXBlclNoYXBlID0gdGhpcy5fc2xlZXBlckNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgIGlmICghc2xlZXBlclNoYXBlKSB7XG4gICAgICAgICAgICBzbGVlcGVyU2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgICAgICAgIHNsZWVwZXJTaGFwZS5ncmFwaGljc1xuICAgICAgICAgICAgICAgLnNldFN0cm9rZVN0eWxlKDAuMiwgXCJyb3VuZFwiKVxuICAgICAgICAgICAgICAgLmJlZ2luU3Ryb2tlKFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgIC5iZWdpbkZpbGwoXCIjOTk3MzViXCIpXG4gICAgICAgICAgICAgICAucigwLCAwLCB0aGlzLnNjaHdlbGxlbkJyZWl0ZSwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgLmVmKCk7XG4gICAgICAgICAgICBzbGVlcGVyU2hhcGUuc2V0Qm91bmRzKDAsIDAsIHRoaXMuc2Nod2VsbGVuQnJlaXRlLCBsZW5ndGgpO1xuICAgICAgICAgICAgLy8gU3RvcmUgaW4gY2FjaGVcbiAgICAgICAgICAgIHRoaXMuX3NsZWVwZXJDYWNoZVtjYWNoZUtleV0gPSBzbGVlcGVyU2hhcGU7XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIENsb25lIHRoZSBjYWNoZWQgc2hhcGUgZm9yIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgIGxldCBzbGVlcGVyID0gc2xlZXBlclNoYXBlLmNsb25lKCk7XG4gICAgICAgICBzbGVlcGVyLnggPSB4O1xuICAgICAgICAgc2xlZXBlci55ID0geTtcbiAgICAgICAgIHNsZWVwZXIucm90YXRpb24gPSBhbmdsZTtcbiAgICAgICAgIHNsZWVwZXIucmVnWSA9IHJ5O1xuICAgICAgICAgc2xlZXBlci5yZWdYID0gMDtcblxuICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHNsZWVwZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vIFVzZSBiaXRtYXAgcmVuZGVyaW5nIGF0IGhpZ2hlciBMT0RcbiAgICAgICAgIGkgPSBpICUgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuU0NIV0VMTEVOX1ZBUklBTlRFTjtcbiAgICAgICAgIGNvbnN0IHNjYWxlWSA9IGxlbmd0aCAvIHRoaXMuc2Nod2VsbGVuSMO2aGU7XG4gICAgICAgICBjb25zdCByeSA9IHJlZ1kgPT0gbnVsbCA/IHRoaXMuc2Nod2VsbGVuSW1nLmhlaWdodCAvIDIgOiByZWdZIC8gKHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlRSQUNLX1NDQUxFICogc2NhbGVZKTtcblxuICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGNhY2hlZCBiaXRtYXAgZm9yIHRoaXMgaW5kZXhcbiAgICAgICAgIGlmICghdGhpcy5fYml0bWFwQ2FjaGVbaV0pIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc291cmNlUmVjdCBmb3IgdGhpcyBpbmRleFxuICAgICAgICAgICAgY29uc3Qgc291cmNlUmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAoaSAqIHRoaXMuc2Nod2VsbGVuSW1nLndpZHRoKSAvIHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlNDSFdFTExFTl9WQVJJQU5URU4sXG4gICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgdGhpcy5zbGVlcGVyc0ltZ1dpZHRoLFxuICAgICAgICAgICAgICAgdGhpcy5zY2h3ZWxsZW5JbWcuaGVpZ2h0XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGNhY2hlIHRoZSBiaXRtYXBcbiAgICAgICAgICAgIGNvbnN0IGJpdG1hcCA9IG5ldyBjcmVhdGVqcy5CaXRtYXAodGhpcy5zY2h3ZWxsZW5JbWcpO1xuICAgICAgICAgICAgYml0bWFwLnNvdXJjZVJlY3QgPSBzb3VyY2VSZWN0O1xuICAgICAgICAgICAgdGhpcy5fYml0bWFwQ2FjaGVbaV0gPSBiaXRtYXA7XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIENsb25lIHRoZSBjYWNoZWQgYml0bWFwXG4gICAgICAgICBjb25zdCBzbGVlcGVyQml0bWFwID0gdGhpcy5fYml0bWFwQ2FjaGVbaV0uY2xvbmUoKTtcblxuICAgICAgICAgLy8gU2V0IHBvc2l0aW9uIGFuZCB0cmFuc2Zvcm1hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICAgICBzbGVlcGVyQml0bWFwLnggPSB4O1xuICAgICAgICAgc2xlZXBlckJpdG1hcC55ID0geTtcbiAgICAgICAgIHNsZWVwZXJCaXRtYXAucmVnWSA9IHJ5O1xuICAgICAgICAgc2xlZXBlckJpdG1hcC5yZWdYID0gMDtcbiAgICAgICAgIHNsZWVwZXJCaXRtYXAuc2NhbGUgPSB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5UUkFDS19TQ0FMRTtcbiAgICAgICAgIHNsZWVwZXJCaXRtYXAuc2NhbGVZID0gdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuVFJBQ0tfU0NBTEUgKiBzY2FsZVk7XG4gICAgICAgICBzbGVlcGVyQml0bWFwLnJvdGF0aW9uID0gYW5nbGU7XG5cbiAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzbGVlcGVyQml0bWFwKTtcbiAgICAgIH1cbiAgIH1cblxuICAgZ2V0UG9pbnRPbkN1cnZlKHQsIHAwLCBjcCwgcDEpIHtcbiAgICAgIGNvbnN0IG9uZU1pbnVzVCA9IDEgLSB0O1xuICAgICAgY29uc3QgdFNxdWFyZWQgPSB0ICogdDtcbiAgICAgIGNvbnN0IG9uZU1pbnVzVFNxdWFyZWQgPSBvbmVNaW51c1QgKiBvbmVNaW51c1Q7XG4gICAgICBjb25zdCB0d29UaW1lc1QgPSAyICogb25lTWludXNUICogdDtcblxuICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgIG9uZU1pbnVzVFNxdWFyZWQgKiBwMC54ICsgdHdvVGltZXNUICogY3AueCArIHRTcXVhcmVkICogcDEueCxcbiAgICAgICAgIG9uZU1pbnVzVFNxdWFyZWQgKiBwMC55ICsgdHdvVGltZXNUICogY3AueSArIHRTcXVhcmVkICogcDEueVxuICAgICAgKTtcbiAgIH1cblxuICAgZ2V0RGVncmVlT2ZUYW5nZW50T25DdXJ2ZSh0LCBwMCwgY3AsIHAxKSB7XG4gICAgICBjb25zdCBtdCA9IDEgLSB0O1xuICAgICAgY29uc3QgZHggPSAyICogKG10ICogKGNwLnggLSBwMC54KSArIHQgKiAocDEueCAtIGNwLngpKTtcbiAgICAgIGNvbnN0IGR5ID0gMiAqIChtdCAqIChjcC55IC0gcDAueSkgKyB0ICogKHAxLnkgLSBjcC55KSk7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMihkeSwgZHgpICogKDE4MCAvIE1hdGguUEkpO1xuICAgfVxuXG4gICBkcmF3QnVtcGVyKHRyYWNrLCB0cmFja19jb250YWluZXIpIHtcbiAgICAgIGlmICh0cmFjay5zd2l0Y2hBdFRoZUVuZCA9PSBudWxsKSB7XG4gICAgICAgICB0cmFja19jb250YWluZXIuYWRkQ2hpbGQoXG4gICAgICAgICAgICBuZXcgY3JlYXRlanMuQml0bWFwKHRoaXMuYnVtcGVySW1nKS5zZXQoe1xuICAgICAgICAgICAgICAgeTogdHJhY2suZW5kLnksXG4gICAgICAgICAgICAgICB4OiB0cmFjay5lbmQueCxcbiAgICAgICAgICAgICAgIHNjYWxlOiB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5UUkFDS19TQ0FMRSxcbiAgICAgICAgICAgICAgIHNjYWxlWDogLXRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlRSQUNLX1NDQUxFLFxuICAgICAgICAgICAgICAgcm90YXRpb246IHRyYWNrLmRlZyxcbiAgICAgICAgICAgICAgIHJlZ1k6IHRoaXMuYnVtcGVySW1nLmhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICByZWdYOiB0aGlzLmJ1bXBlckltZy53aWR0aCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2suc3dpdGNoQXRUaGVTdGFydCA9PSBudWxsKSB7XG4gICAgICAgICB0cmFja19jb250YWluZXIuYWRkQ2hpbGQoXG4gICAgICAgICAgICBuZXcgY3JlYXRlanMuQml0bWFwKHRoaXMuYnVtcGVySW1nKS5zZXQoe1xuICAgICAgICAgICAgICAgeTogdHJhY2suc3RhcnQueSxcbiAgICAgICAgICAgICAgIHg6IHRyYWNrLnN0YXJ0LngsXG4gICAgICAgICAgICAgICBzY2FsZTogdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuVFJBQ0tfU0NBTEUsXG4gICAgICAgICAgICAgICBzY2FsZVg6IHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlRSQUNLX1NDQUxFLFxuICAgICAgICAgICAgICAgcm90YXRpb246IHRyYWNrLmRlZyxcbiAgICAgICAgICAgICAgIHJlZ1k6IHRoaXMuYnVtcGVySW1nLmhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICByZWdYOiB0aGlzLmJ1bXBlckltZy53aWR0aCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICApO1xuICAgICAgfVxuICAgfVxuXG4gICB1cGRhdGVUcmFjayh0cmFjaykge1xuICAgICAgLy8gRmluZCB0aGUgc2xlZXBlcnMgY29udGFpbmVyIGZvciB0aGlzIHRyYWNrXG4gICAgICBjb25zdCBzbGVlcGVyc0NvbnRhaW5lciA9IHRoaXMuX3JlbmRlcmluZy5zbGVlcGVyc19jb250YWluZXIuY2hpbGRyZW4uZmluZCgoYykgPT4gYy5kYXRhID09PSB0cmFjayk7XG4gICAgICBpZiAoIXNsZWVwZXJzQ29udGFpbmVyKSByZXR1cm47XG5cbiAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBzbGVlcGVyc1xuICAgICAgc2xlZXBlcnNDb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHBvaW50cyBhbmQgcmVkcmF3IHNsZWVwZXJzIHdpdGggY3VycmVudCBMT0RcbiAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY2FsY3VsYXRlVHJhY2tQb2ludHModHJhY2spO1xuICAgICAgdGhpcy5kcmF3VHJhY2tTbGVlcGVycyhwb2ludHMsIHNsZWVwZXJzQ29udGFpbmVyKTtcblxuICAgICAgaWYgKHRyYWNrID09IHRyYWNrLnN3aXRjaEF0VGhlRW5kPy50MSkge1xuICAgICAgICAgY29uc3Qgc3dpdGNoU2xlZXBlcnNDb250YWluZXIgPSB0aGlzLl9yZW5kZXJpbmcuc2xlZXBlcnNfY29udGFpbmVyLmNoaWxkcmVuLmZpbmQoKGMpID0+IGMuZGF0YSA9PT0gdHJhY2suc3dpdGNoQXRUaGVFbmQpO1xuICAgICAgICAgY29uc3Qgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyID0gdGhpcy5nZXRTd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIodHJhY2suc3dpdGNoQXRUaGVFbmQpO1xuICAgICAgICAgdGhpcy5kcmF3U2xlZXBlcnNPblN3aXRjaCh0cmFjay5zd2l0Y2hBdFRoZUVuZCwgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyLCBzd2l0Y2hTbGVlcGVyc0NvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFjayA9PSB0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0Py50MSkge1xuICAgICAgICAgY29uc3Qgc3dpdGNoU2xlZXBlcnNDb250YWluZXIgPSB0aGlzLl9yZW5kZXJpbmcuc2xlZXBlcnNfY29udGFpbmVyLmNoaWxkcmVuLmZpbmQoXG4gICAgICAgICAgICAoYykgPT4gYy5kYXRhID09PSB0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0XG4gICAgICAgICApO1xuICAgICAgICAgY29uc3Qgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyID0gdGhpcy5nZXRTd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIodHJhY2suc3dpdGNoQXRUaGVTdGFydCk7XG4gICAgICAgICB0aGlzLmRyYXdTbGVlcGVyc09uU3dpdGNoKHRyYWNrLnN3aXRjaEF0VGhlU3RhcnQsIHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlciwgc3dpdGNoU2xlZXBlcnNDb250YWluZXIpO1xuICAgICAgfVxuICAgfVxuXG4gICB1cGRhdGVTd2l0Y2goc3cpIHtcbiAgICAgIC8vIEZpbmQgdGhlIHNsZWVwZXJzIGNvbnRhaW5lciBmb3IgdGhpcyBzd2l0Y2hcbiAgICAgIGNvbnN0IHNsZWVwZXJzQ29udGFpbmVyID0gdGhpcy5fcmVuZGVyaW5nLnNsZWVwZXJzX2NvbnRhaW5lci5jaGlsZHJlbi5maW5kKChjKSA9PiBjLmRhdGEgPT09IHN3KTtcbiAgICAgIGlmICghc2xlZXBlcnNDb250YWluZXIpIHJldHVybjtcblxuICAgICAgLy8gR2V0IHJlbmRlcmluZyBwYXJhbWV0ZXJzXG4gICAgICBjb25zdCBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIgPSB0aGlzLmdldFN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlcihzdyk7XG5cbiAgICAgIC8vIFJlZHJhdyBzbGVlcGVycyB3aXRoIGN1cnJlbnQgTE9EXG4gICAgICB0aGlzLmRyYXdTbGVlcGVyc09uU3dpdGNoKHN3LCBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIsIHNsZWVwZXJzQ29udGFpbmVyKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgc2hhcGUgZm9yIGEgdHJhY2sgZW5kcG9pbnRcbiAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHdoZXJlIHRoZSBlbmRwb2ludCBzaG91bGQgYmVcbiAgICAqIEBwYXJhbSB7VHJhY2t9IHRyYWNrIC0gVGhlIHRyYWNrIHRoaXMgZW5kcG9pbnQgYmVsb25ncyB0b1xuICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50VHlwZSAtIEVpdGhlciBcInN0YXJ0XCIgb3IgXCJlbmRcIlxuICAgICogQHJldHVybnMge2NyZWF0ZWpzLlNoYXBlfSBUaGUgY3JlYXRlZCBzaGFwZVxuICAgICovXG4gICBjcmVhdGVFbmRwb2ludFNoYXBlKHBvaW50LCB0cmFjaywgZW5kcG9pbnRUeXBlKSB7XG4gICAgICBjb25zdCBSRUNUX1NJWkUgPSA4O1xuICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IHByb3BlcnRpZXMgdG8gaWRlbnRpZnkgdGhlIHNoYXBlXG4gICAgICBzaGFwZS5uYW1lID0gXCJ0cmFja19lbmRwb2ludFwiO1xuICAgICAgc2hhcGUuZW5kcG9pbnQgPSBlbmRwb2ludFR5cGU7XG4gICAgICBzaGFwZS50cmFjayA9IHRyYWNrO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgaGl0IGFyZWFcbiAgICAgIGNvbnN0IGhpdEFyZWEgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIGhpdEFyZWEuZ3JhcGhpY3NcbiAgICAgICAgIC5iZWdpbkZpbGwoXCIjMDAwXCIpXG4gICAgICAgICAuZHJhd1JlY3QocG9pbnQueCAtIFJFQ1RfU0laRS8yLCBwb2ludC55IC0gUkVDVF9TSVpFLzIsIFJFQ1RfU0laRSwgUkVDVF9TSVpFKTtcbiAgICAgIHNoYXBlLmhpdEFyZWEgPSBoaXRBcmVhO1xuICAgICAgXG4gICAgICAvLyBEcmF3IHJlY3RhbmdsZVxuICAgICAgc2hhcGUuZ3JhcGhpY3NcbiAgICAgICAgIC5zZXRTdHJva2VTdHlsZSgyKVxuICAgICAgICAgLmJlZ2luU3Ryb2tlKFwiI2ZmMDAwMFwiKVxuICAgICAgICAgLmRyYXdSZWN0KHBvaW50LnggLSBSRUNUX1NJWkUvMiwgcG9pbnQueSAtIFJFQ1RfU0laRS8yLCBSRUNUX1NJWkUsIFJFQ1RfU0laRSk7XG4gICAgICBcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBEcmF3cyBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSB0cmFja1xuICAgICogQHBhcmFtIHtUcmFja30gdHJhY2sgLSBUaGUgdHJhY2sgdG8gZHJhdyBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmb3JcbiAgICAqL1xuICAgZHJhd1RyYWNrRW5kcG9pbnRzKHRyYWNrKSB7XG4gICAgICAvLyBDcmVhdGUgYW5kIGFkZCBzaGFwZXMgZm9yIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgICBzZWxlY3Rpb25fY29udGFpbmVyLmFkZENoaWxkKHRoaXMuY3JlYXRlRW5kcG9pbnRTaGFwZSh0cmFjay5zdGFydCwgdHJhY2ssIFwic3RhcnRcIikpO1xuICAgICAgc2VsZWN0aW9uX2NvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmNyZWF0ZUVuZHBvaW50U2hhcGUodHJhY2suZW5kLCB0cmFjaywgXCJlbmRcIikpO1xuICAgfVxuXG4gICB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICBzZWxlY3Rpb25fY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24udHlwZSA9PSBcIlRyYWNrXCIpIHtcbiAgICAgICAgIHRyYWNrX2NvbnRhaW5lci5jaGlsZHJlblswXS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3QoYy5kYXRhKSkge1xuICAgICAgICAgICAgICAgdGhpcy52aXN1YWxpemVUcmFja0JvdW5kcyhjKTtcbiAgICAgICAgICAgICAgIHRoaXMuZHJhd1RyYWNrRW5kcG9pbnRzKGMuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uLnR5cGUgPT0gXCJTaWduYWxcIikge1xuICAgICAgICAgc2lnbmFsX2NvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYy5kYXRhKSB7XG4gICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3QoYy5kYXRhKSkgdGhpcy52aXN1YWxpemVUcmFja0JvdW5kcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb24udHlwZSA9PSBcIkdlbmVyaWNPYmplY3RcIikge1xuICAgICAgICAgb2JqZWN0X2NvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYy5kYXRhKSB7XG4gICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3QoYy5kYXRhKSkgdGhpcy52aXN1YWxpemVUcmFja0JvdW5kcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RhZ2UudXBkYXRlKCk7XG4gICB9XG5cbiAgIGRyYXdTbGVlcGVyc09uU3dpdGNoKHN3LCBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIsIGNvbnRhaW5lcikge1xuICAgICAgY29uc3QgeyBtYWluVHJhY2ssIHN0cmFpZ2h0QnJhbmNoLCBjdXJ2ZWRCcmFuY2gsIGN1cnZlZEJyYW5jaDIsIGZsaXBwZWQsIG1pcnJvcmVkIH0gPSBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXI7XG5cbiAgICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgY29udGFpbmVyLm5hbWUgPSBcInN3aXRjaF9zbGVlcGVyc1wiO1xuICAgICAgICAgY29udGFpbmVyLmRhdGEgPSBzdztcbiAgICAgICAgIGNvbnRhaW5lci5tb3VzZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICB0aGlzLl9yZW5kZXJpbmcuc2xlZXBlcnNfY29udGFpbmVyLmFkZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlZyA9IHN3LnRyYWNrMS5kZWc7XG5cbiAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2syZnJvbnQgPSBOdW1iZXJVdGlscy5pcyhzdy50eXBlLCBTd2l0Y2guU1dJVENIX1RZUEUuRlJPTV9SSUdIVCwgU3dpdGNoLlNXSVRDSF9UWVBFLkZST01fTEVGVCk7XG5cbiAgICAgIGlmIChjdXJ2ZWRCcmFuY2gyID09IG51bGwpIHtcbiAgICAgICAgIGNvbnN0IGNwID0gZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uUG9pbnRYKFxuICAgICAgICAgICAgbWFpblRyYWNrLnNsZWVwZXJzLm91dGVyLFxuICAgICAgICAgICAgbWFpblRyYWNrLnVuaXQsXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2guc2xlZXBlcnMub3V0ZXIsXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2gudW5pdFxuICAgICAgICAgKTtcblxuICAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2VvbWV0cnkuZGlzdGFuY2UobWFpblRyYWNrLnNsZWVwZXJzLmlubmVyLCBzdHJhaWdodEJyYW5jaC5zbGVlcGVycy5pbm5lcik7IC8vbGVuZ3RoIG9mIHRoZSBzdHJhaWdodCBwYXJ0ICsgaGFsZiBvZiB0aGUgZ2FwLCB0byBtaW5pbWl6ZSB0aGUgZ2FwIHRoZSB0byBuZXh0IHRyYWNrXG4gICAgICAgICBjb25zdCBsZW5ndGgyID0gZ2VvbWV0cnkuZGlzdGFuY2UobWFpblRyYWNrLnNsZWVwZXJzLm91dGVyLCBjdXJ2ZWRCcmFuY2guc2xlZXBlcnMub3V0ZXIpOyAvL2FsbW9zdCB0aGUgbGVuZ3RoIG9mIHRoZSBjdXJ2ZVxuXG4gICAgICAgICBjb25zdCBhbW91bnRfb25fc3RyYWlnaHRfcmFpbCA9IE1hdGguZmxvb3IobGVuZ3RoIC8gdGhpcy5zbGVlcGVySW50ZXJ2YWxsKTtcbiAgICAgICAgIGNvbnN0IGFtb3VudF9vbl9jdXJ2ZWRfcmFpbCA9IE1hdGguZmxvb3IobGVuZ3RoMiAvICh0aGlzLnNsZWVwZXJJbnRlcnZhbGwgKiAxLjE1KSk7XG4gICAgICAgICBjb25zdCBuZXdfaW50ZXJ2YWxsID0gKHRoaXMuc2xlZXBlckludGVydmFsbCArIChsZW5ndGggJSB0aGlzLnNsZWVwZXJJbnRlcnZhbGwpIC8gYW1vdW50X29uX3N0cmFpZ2h0X3JhaWwpICogbWlycm9yZWQ7IC8vbmV3IGludGVydmFsbCB0byBtaW5pbWl6ZSB0aGUgZ2FwIGFuZCB1c2luZyB0aGUgbGVmdG92ZXIgZnJvbSB0aGUgZGl2aXNpb25cbiAgICAgICAgIGxldCBwMSwgdCwgc2xlZXBlcl9sZW5ndGg7XG5cbiAgICAgICAgIGlmIChiYWNrMmZyb250KSBwMSA9IG1haW5UcmFjay5zbGVlcGVycy5pbm5lci5zdWIoZ2VvbWV0cnkubXVsdGlwbHkobWFpblRyYWNrLnVuaXQsIHRoaXMuc2xlZXBlckludGVydmFsbCkpO1xuICAgICAgICAgZWxzZSBwMSA9IG1haW5UcmFjay5zbGVlcGVycy5pbm5lci5hZGQoZ2VvbWV0cnkubXVsdGlwbHkobWFpblRyYWNrLnVuaXQsICh0aGlzLnNjaHdlbGxlbkdhcCAvIDIpICogbWlycm9yZWQpKTtcblxuICAgICAgICAgY29uc3Qgc3RlcF92ZWN0b3IgPSBnZW9tZXRyeS5tdWx0aXBseShtYWluVHJhY2sudW5pdCwgbmV3X2ludGVydmFsbCk7XG5cbiAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50X29uX2N1cnZlZF9yYWlsOyBpKyspIHtcbiAgICAgICAgICAgIHQgPSBpIC8gYW1vdW50X29uX2N1cnZlZF9yYWlsICsgMC40IC8gYW1vdW50X29uX2N1cnZlZF9yYWlsO1xuXG4gICAgICAgICAgICBzbGVlcGVyX2xlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgZ2VvbWV0cnkuZGlzdGFuY2UodGhpcy5nZXRQb2ludE9uQ3VydmUodCwgbWFpblRyYWNrLnNsZWVwZXJzLm91dGVyLCBjcCwgY3VydmVkQnJhbmNoLnNsZWVwZXJzLm91dGVyKSwgcDEpLFxuICAgICAgICAgICAgICAgdGhpcy5zY2h3ZWxsZW5Iw7ZoZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5kcmF3U2xlZXBlcihpLCBwMS54LCBwMS55LCBkZWcsIGNvbnRhaW5lciwgLXNsZWVwZXJfbGVuZ3RoICogZmxpcHBlZCwgMCk7XG4gICAgICAgICAgICBwMSA9IHAxLmFkZChzdGVwX3ZlY3Rvcik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGZvciAobGV0IGkgPSBhbW91bnRfb25fY3VydmVkX3JhaWw7IGkgPCBhbW91bnRfb25fc3RyYWlnaHRfcmFpbDsgaSsrKSB7XG4gICAgICAgICAgICB0ID0gKHRoaXMuc2xlZXBlckludGVydmFsbCAqIGkpIC8gbGVuZ3RoMjtcbiAgICAgICAgICAgIC8vc3VidHJhY3QgdGhlIHNsZWVwZXIgaW50ZXJ2YWxsIHRvIGNyZWF0ZSBhIGdhcCB0byB0aGUgbmV4dCBzbGVlcGVyXG4gICAgICAgICAgICBzbGVlcGVyX2xlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgZ2VvbWV0cnkuZGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgICBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludFgoXG4gICAgICAgICAgICAgICAgICAgICBjdXJ2ZWRCcmFuY2guc2xlZXBlcnMub3V0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKGN1cnZlZEJyYW5jaC51bml0KSxcbiAgICAgICAgICAgICAgICAgICAgIHAxLFxuICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkucGVycGVuZGljdWxhcihtYWluVHJhY2sudW5pdClcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBwMVxuICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgIHRoaXMuc2Nod2VsbGVuSMO2aGVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMuZHJhd1NsZWVwZXIoaSwgcDEueCwgcDEueSwgZGVnLCBjb250YWluZXIsIC1zbGVlcGVyX2xlbmd0aCAqIGZsaXBwZWQsIDApO1xuICAgICAgICAgICAgcDEgPSBwMS5hZGQoc3RlcF92ZWN0b3IpO1xuICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vIENhbGN1bGF0ZSBzdGFydGluZyBwb2ludCBhbmQgb2Zmc2V0IHZlY3RvclxuICAgICAgICAgbGV0IGNlbnRlclBvaW50ID0gc3RyYWlnaHRCcmFuY2gucG9zaXRpb24uYWRkKG1haW5UcmFjay51bml0Lm11bHRpcGx5KHRoaXMuc2xlZXBlckludGVydmFsbCAvIDQpKTtcbiAgICAgICAgIGNvbnN0IHN0ZXBfdmVjdG9yID0gbWFpblRyYWNrLnVuaXQubXVsdGlwbHkodGhpcy5zbGVlcGVySW50ZXJ2YWxsKTtcbiAgICAgICAgIFxuICAgICAgICAgLy8gQ3JlYXRlIGEgZnVsbCBzeW1tZXRyaWMgcGF0dGVybiBmcm9tIHRoZSBoYWxmIHBhdHRlcm5cbiAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5GT1VSX1dBWV9TTEVFUEVSX1BBVFRFUk47XG4gICAgICAgICBjb25zdCByZXZlcnNlZF9wYXR0ZXJuID0gcGF0dGVybi5zbGljZSgwLCAtMSkucmV2ZXJzZSgpOyAvL3JlbW92ZSB0aGUgbGFzdCBlbGVtZW50IGJlY2F1c2UgaXRzIHJpZ2h0IG9uIHRoZSBwb2ludCBvZiB0aGUgc3dpdGNoXG4gICAgICAgICBjb25zdCBwb2ludF9zeW1tZXRyaWNfcGF0dGVybiA9IHJldmVyc2VkX3BhdHRlcm4ubWFwKHAgPT4gKHsgb2Zmc2V0OiAoMiAqIHAubGVuZ3RoKSAtIHAub2Zmc2V0LCBsZW5ndGg6IHAubGVuZ3RoIH0pKTtcbiAgICAgICAgIGNvbnN0IGZ1bGxQYXR0ZXJuID0gWy4uLnBhdHRlcm4sIC4uLnBvaW50X3N5bW1ldHJpY19wYXR0ZXJuXTtcblxuICAgICAgICAgLy8gRHJhdyBzbGVlcGVycyB1c2luZyB0aGUgcGF0dGVyblxuICAgICAgICAgZnVsbFBhdHRlcm4uZm9yRWFjaCgoZGF0YSwgaSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmF3U2xlZXBlcihcbiAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICBjZW50ZXJQb2ludC54LFxuICAgICAgICAgICAgICAgY2VudGVyUG9pbnQueSxcbiAgICAgICAgICAgICAgIGRlZyxcbiAgICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoICogdGhpcy5zY2h3ZWxsZW5Iw7ZoZSxcbiAgICAgICAgICAgICAgIGRhdGEub2Zmc2V0ICogdGhpcy5zY2h3ZWxsZW5Iw7ZoZV8yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY2VudGVyUG9pbnQgPSBjZW50ZXJQb2ludC5hZGQoc3RlcF92ZWN0b3IpO1xuICAgICAgICAgfSk7XG4gICAgICB9XG4gICB9XG5cbiAgIHJlbmRlclN3aXRjaChzdywgZm9yY2UpIHtcbiAgICAgIGNvbnN0IHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlciA9IHRoaXMuZ2V0U3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyKHN3KTtcblxuICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIHNoYXBlLmRhdGEgPSBzdztcbiAgICAgIHNoYXBlLnNuYXBUb1BpeGVsID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlbmRlcmluZy5yYWlsc19jb250YWluZXIuYWRkQ2hpbGQoc2hhcGUpO1xuXG4gICAgICAvLyBEcmF3IHRyYWNrIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgdHJhY2tzXG4gICAgICBpZiAoc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyLmN1cnZlZEJyYW5jaDIgPT0gbnVsbCkge1xuICAgICAgICAgdGhpcy5yZW5kZXJUaHJlZVdheVN3aXRjaChzaGFwZSwgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aGlzLnJlbmRlckZvdXJXYXlTd2l0Y2goc2hhcGUsIHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJhd1NsZWVwZXJzT25Td2l0Y2goc3csIHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlcik7XG4gICAgICB0aGlzLnJlbmRlclN3aXRjaFVJKHN3KTtcbiAgIH1cblxuICAgZ2V0U3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyKHN3KSB7XG4gICAgICAgICAgICAgICBjb25zdCBmbGlwcGVkID0gTnVtYmVyVXRpbHMuaXMoc3cudHlwZSwgU3dpdGNoLlNXSVRDSF9UWVBFLkZST01fUklHSFQsIFN3aXRjaC5TV0lUQ0hfVFlQRS5UT19SSUdIVCkgPyAtMSA6IDE7XG4gICAgICAgICBjb25zdCBtaXJyb3JlZCA9IE51bWJlclV0aWxzLmlzKHN3LnR5cGUsIFN3aXRjaC5TV0lUQ0hfVFlQRS5GUk9NX0xFRlQsIFN3aXRjaC5TV0lUQ0hfVFlQRS5GUk9NX1JJR0hUKSA/IC0xIDogMTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRyYWNrIGRhdGEgZm9yIGVhY2ggdHJhY2tcbiAgICAgIGNvbnN0IGNhbGNUcmFja0RhdGEgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgIGxldCB0cmFjayA9IHN3LnRyYWNrc1tpbmRleF07XG4gICAgICAgICBsZXQgdW5pdCA9IHN3LnRyYWNrX2RpcmVjdGlvbnNbaW5kZXhdO1xuICAgICAgICAgaWYgKCF1bml0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgY2FsY3VsYXRlUGFyYW1ldGVycyBoYXNuJ3QgYmVlbiBjYWxsZWQgb24gdGhlIHN3aXRjaC5cbiAgICAgICAgICAgIC8vIEZvciByb2J1c3RuZXNzLCB3ZSBjYW4gY2FsY3VsYXRlIGl0IGhlcmUsIGJ1dCBpdCdzIGJldHRlciB0byBlbnN1cmUgaXQncyBjYWxjdWxhdGVkIGluIHRoZSBzd2l0Y2ggY2xhc3MuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTd2l0Y2ggdHJhY2tfZGlyZWN0aW9ucyBub3QgY2FsY3VsYXRlZCwgY2FsY3VsYXRpbmcgb24gdGhlIGZseS5cIik7XG4gICAgICAgICAgICBzdy5jYWxjdWxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICB1bml0ID0gc3cudHJhY2tfZGlyZWN0aW9uc1tpbmRleF07XG4gICAgICAgICB9XG5cbiAgICAgICAgIGNvbnN0IHJhaWxPZmZzZXQgPSBnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKHRyYWNrLnVuaXQubXVsdGlwbHkodGhpcy5yYWlsX2Rpc3RhbmNlICogZmxpcHBlZCkpO1xuICAgICAgICAgY29uc3Qgc2xlZXBlck9mZnNldCA9IGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdC5tdWx0aXBseSh0aGlzLnNjaHdlbGxlbkjDtmhlXzIgKiBmbGlwcGVkKSk7XG4gICAgICAgICAvLyBUaGUgcG9zaXRpb24gc2hvdWxkIGJlIG9uIHRoZSB0cmFjaywgYXQgYSBjZXJ0YWluIGRpc3RhbmNlIGZyb20gdGhlIHN3aXRjaCBsb2NhdGlvbi5cbiAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gc3cubG9jYXRpb24uYWRkKHVuaXQubXVsdGlwbHkoc3cuc2l6ZSkpO1xuXG4gICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5pdDogdHJhY2sudW5pdCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHJhaWxzOiB7XG4gICAgICAgICAgICAgICBpbm5lcjogcG9zaXRpb24uYWRkKHJhaWxPZmZzZXQpLFxuICAgICAgICAgICAgICAgb3V0ZXI6IHBvc2l0aW9uLnN1YihyYWlsT2Zmc2V0KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbGVlcGVyczoge1xuICAgICAgICAgICAgICAgaW5uZXI6IHBvc2l0aW9uLmFkZChzbGVlcGVyT2Zmc2V0KSxcbiAgICAgICAgICAgICAgIG91dGVyOiBwb3NpdGlvbi5zdWIoc2xlZXBlck9mZnNldCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1haW5UcmFjayA9IGNhbGNUcmFja0RhdGEoMCk7XG4gICAgICBjb25zdCBzdHJhaWdodEJyYW5jaCA9IGNhbGNUcmFja0RhdGEoMSk7XG4gICAgICBjb25zdCBjdXJ2ZWRCcmFuY2ggPSBjYWxjVHJhY2tEYXRhKDIpO1xuICAgICAgY29uc3QgY3VydmVkQnJhbmNoMiA9IHN3LnRyYWNrNCA/IGNhbGNUcmFja0RhdGEoMykgOiBudWxsO1xuXG4gICAgICByZXR1cm4geyBtYWluVHJhY2ssIHN0cmFpZ2h0QnJhbmNoLCBjdXJ2ZWRCcmFuY2gsIGN1cnZlZEJyYW5jaDIsIGZsaXBwZWQsIG1pcnJvcmVkIH07XG4gICB9XG5cbiAgIHJlbmRlclRocmVlV2F5U3dpdGNoKHNoYXBlLCBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIpIHtcbiAgICAgIGNvbnN0IGcgPSBzaGFwZS5ncmFwaGljcztcbiAgICAgIGNvbnN0IHsgbWFpblRyYWNrLCBzdHJhaWdodEJyYW5jaCwgY3VydmVkQnJhbmNoLCBmbGlwcGVkLCBtaXJyb3JlZCB9ID0gc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIHBvaW50cyBvbmNlIC0gcmV1c2UgZm9yIGFsbCByYWlsIHNpemVzXG4gICAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0ge1xuICAgICAgICAgb3V0ZXJDdXJ2ZTogZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uUG9pbnRYKFxuICAgICAgICAgICAgbWFpblRyYWNrLnJhaWxzLm91dGVyLFxuICAgICAgICAgICAgbWFpblRyYWNrLnVuaXQsXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2gucmFpbHMub3V0ZXIsXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2gudW5pdFxuICAgICAgICAgKSxcblxuICAgICAgICAgZnJvZzogZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uUG9pbnRYKFxuICAgICAgICAgICAgc3RyYWlnaHRCcmFuY2gucmFpbHMub3V0ZXIsXG4gICAgICAgICAgICBzdHJhaWdodEJyYW5jaC51bml0LFxuICAgICAgICAgICAgY3VydmVkQnJhbmNoLnJhaWxzLmlubmVyLFxuICAgICAgICAgICAgY3VydmVkQnJhbmNoLnVuaXRcbiAgICAgICAgICksXG4gICAgICB9O1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaW5uZXIgY3VydmUgY29udHJvbCBwb2ludCB1c2luZyB0aGUgYWxyZWFkeSBjYWxjdWxhdGVkIGZyb2cgcG9pbnRcbiAgICAgIGludGVyc2VjdGlvbnMuaW5uZXJDdXJ2ZSA9IGdlb21ldHJ5LmdldEludGVyc2VjdGlvblBvaW50WChcbiAgICAgICAgIG1haW5UcmFjay5yYWlscy5pbm5lcixcbiAgICAgICAgIG1haW5UcmFjay51bml0LFxuICAgICAgICAgaW50ZXJzZWN0aW9ucy5mcm9nLFxuICAgICAgICAgY3VydmVkQnJhbmNoLnVuaXRcbiAgICAgICk7XG5cbiAgICAgIC8vIFByZS1jYWxjdWxhdGUgYWxsIGhlcnpzdMO8Y2sgKGZyb2cpIHBvaW50c1xuICAgICAgY29uc3QgZnJvZ09mZnNldCA9IC10cmFja1JlbmRlcmluZ190ZXh0dXJlZC5SQUlMU1swXVswXSAqIG1pcnJvcmVkOyAvL3RoYXRzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBmcm9nIGFuZCB0aGUgcG9pbnQgYmxhZGVzXG4gICAgICBjb25zdCBndWFyZFJhaWxMZW5ndGggPSAxMCAqIG1pcnJvcmVkO1xuICAgICAgY29uc3QgZnJvZ1BvaW50cyA9IHtcbiAgICAgICAgIGN1cnZlRW5kOiBQb2ludC5mcm9tUG9pbnQoaW50ZXJzZWN0aW9ucy5mcm9nKS5hZGQoY3VydmVkQnJhbmNoLnVuaXQubXVsdGlwbHkoZnJvZ09mZnNldCkpLFxuICAgICAgICAgc3RyYWlnaHRTdGFydDogUG9pbnQuZnJvbVBvaW50KGludGVyc2VjdGlvbnMuZnJvZykuYWRkKHN0cmFpZ2h0QnJhbmNoLnVuaXQubXVsdGlwbHkoZnJvZ09mZnNldCkpLFxuICAgICAgfTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGVuZCBwb2ludHMgdXNpbmcgdGhlIHByZS1jYWxjdWxhdGVkIHBvaW50c1xuICAgICAgZnJvZ1BvaW50cy5zdHJhaWdodEVuZCA9IGZyb2dQb2ludHMuY3VydmVFbmQuYWRkKHN0cmFpZ2h0QnJhbmNoLnVuaXQubXVsdGlwbHkoZ3VhcmRSYWlsTGVuZ3RoKSk7XG4gICAgICBmcm9nUG9pbnRzLmN1cnZlU3RhcnQgPSBmcm9nUG9pbnRzLnN0cmFpZ2h0U3RhcnQuYWRkKGN1cnZlZEJyYW5jaC51bml0Lm11bHRpcGx5KGd1YXJkUmFpbExlbmd0aCkpO1xuXG4gICAgICAvLyBEcmF3IGFsbCByYWlscyB3aXRoIGRpZmZlcmVudCB0aGlja25lc3NlcyBpbiBvbmUgcGFzc1xuICAgICAgZm9yIChjb25zdCByYWlsIG9mIHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlJBSUxTKSB7XG4gICAgICAgICBnLnNldFN0cm9rZVN0eWxlKHJhaWxbMF0pLmJlZ2luU3Ryb2tlKHJhaWxbMV0pO1xuXG4gICAgICAgICAvLyBPdXRlciBjdXJ2ZWQgYnJhbmNoXG4gICAgICAgICBnLm10KG1haW5UcmFjay5yYWlscy5vdXRlci54LCBtYWluVHJhY2sucmFpbHMub3V0ZXIueSkucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgIGludGVyc2VjdGlvbnMub3V0ZXJDdXJ2ZS54LFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5vdXRlckN1cnZlLnksXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2gucmFpbHMub3V0ZXIueCxcbiAgICAgICAgICAgIGN1cnZlZEJyYW5jaC5yYWlscy5vdXRlci55XG4gICAgICAgICApO1xuXG4gICAgICAgICAvLyBJbm5lciBjdXJ2ZWQgYnJhbmNoIHdpdGggZnJvZyBjb25uZWN0aW9uXG4gICAgICAgICBnLm10KG1haW5UcmFjay5yYWlscy5pbm5lci54LCBtYWluVHJhY2sucmFpbHMuaW5uZXIueSlcbiAgICAgICAgICAgIC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5pbm5lckN1cnZlLnggLSBmbGlwcGVkLFxuICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5pbm5lckN1cnZlLnkgLSBmbGlwcGVkLFxuICAgICAgICAgICAgICAgZnJvZ1BvaW50cy5jdXJ2ZUVuZC54LFxuICAgICAgICAgICAgICAgZnJvZ1BvaW50cy5jdXJ2ZUVuZC55XG4gICAgICAgICAgICApXG4gICAgICAgICAgICAubHQoZnJvZ1BvaW50cy5zdHJhaWdodEVuZC54LCBmcm9nUG9pbnRzLnN0cmFpZ2h0RW5kLnkpO1xuXG4gICAgICAgICAvLyBGcm9nIHBvaW50IGFuZCBjb25uZWN0aW5nIHJhaWxzXG4gICAgICAgICBnLm10KHN0cmFpZ2h0QnJhbmNoLnJhaWxzLm91dGVyLngsIHN0cmFpZ2h0QnJhbmNoLnJhaWxzLm91dGVyLnkpXG4gICAgICAgICAgICAubHQoaW50ZXJzZWN0aW9ucy5mcm9nLngsIGludGVyc2VjdGlvbnMuZnJvZy55KVxuICAgICAgICAgICAgLmx0KGN1cnZlZEJyYW5jaC5yYWlscy5pbm5lci54LCBjdXJ2ZWRCcmFuY2gucmFpbHMuaW5uZXIueSk7XG5cbiAgICAgICAgIC8vIFN0cmFpZ2h0IGNvbm5lY3Rpb25cbiAgICAgICAgIGcubXQobWFpblRyYWNrLnJhaWxzLmlubmVyLngsIG1haW5UcmFjay5yYWlscy5pbm5lci55KS5sdChzdHJhaWdodEJyYW5jaC5yYWlscy5pbm5lci54LCBzdHJhaWdodEJyYW5jaC5yYWlscy5pbm5lci55KTtcblxuICAgICAgICAgLy8gR3VhcmQgcmFpbFxuICAgICAgICAgZy5tdChmcm9nUG9pbnRzLmN1cnZlU3RhcnQueCwgZnJvZ1BvaW50cy5jdXJ2ZVN0YXJ0LnkpXG4gICAgICAgICAgICAubHQoZnJvZ1BvaW50cy5zdHJhaWdodFN0YXJ0LngsIGZyb2dQb2ludHMuc3RyYWlnaHRTdGFydC55KVxuICAgICAgICAgICAgLmx0KG1haW5UcmFjay5yYWlscy5vdXRlci54LCBtYWluVHJhY2sucmFpbHMub3V0ZXIueSArIDIgKiBmbGlwcGVkKTsgLy9UT0RPICB3ZSBjYW4gaW1wbGVtZW50IHN3aXRjaGluZyB0aGUgc3dpdGNoIGhlcmVcblxuICAgICAgICAgZy5lbmRTdHJva2UoKTtcbiAgICAgIH1cbiAgIH1cblxuICAgcmVuZGVyRm91cldheVN3aXRjaChzaGFwZSwgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyKSB7XG4gICAgICBjb25zdCB7IG1haW5UcmFjaywgc3RyYWlnaHRCcmFuY2gsIGN1cnZlZEJyYW5jaCwgY3VydmVkQnJhbmNoMiB9ID0gc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyO1xuXG4gICAgICBjb25zdCBkcmF3UmFpbCA9IChncmFwaGljcywgc3RhcnRUcmFjaywgZW5kVHJhY2ssIHJhaWxTaWRlKSA9PiB7XG4gICAgICAgICAvLyByYWlsU2lkZTogJ2lubmVyJyBvciAnb3V0ZXInXG5cbiAgICAgICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBzdGFydFRyYWNrLnJhaWxzW3JhaWxTaWRlXTtcbiAgICAgICAgIGNvbnN0IGVuZFBvaW50ID0gZW5kVHJhY2sucmFpbHNbcmFpbFNpZGVdO1xuXG4gICAgICAgICBjb25zdCBjcDEgPSBnZW9tZXRyeS5hZGQoc3RhcnRQb2ludCwgZ2VvbWV0cnkubXVsdGlwbHkoc3RhcnRUcmFjay51bml0LCB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5DVVJWQVRVUkVfNFdBWV9TV0lUQ0gpKTtcbiAgICAgICAgIGNvbnN0IGNwMiA9IGdlb21ldHJ5LmFkZChlbmRQb2ludCwgZ2VvbWV0cnkubXVsdGlwbHkoZW5kVHJhY2sudW5pdCwgLXRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLkNVUlZBVFVSRV80V0FZX1NXSVRDSCkpO1xuXG4gICAgICAgICBncmFwaGljcy5tdChzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSkuYmV6aWVyQ3VydmVUbyhjcDEueCwgY3AxLnksIGNwMi54LCBjcDIueSwgZW5kUG9pbnQueCwgZW5kUG9pbnQueSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBnID0gc2hhcGUuZ3JhcGhpY3M7XG5cbiAgICAgIC8vIERyYXcgYWxsIHJhaWxzIHdpdGggZGlmZmVyZW50IHRoaWNrbmVzc2VzXG4gICAgICBmb3IgKGNvbnN0IHJhaWwgb2YgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuUkFJTFMpIHtcbiAgICAgICAgIGcuc2V0U3Ryb2tlU3R5bGUocmFpbFswXSkuYmVnaW5TdHJva2UocmFpbFsxXSk7XG5cbiAgICAgICAgIC8vIERyYXcgdXNpbmcgdGhlIGhlbHBlciBtZXRob2QgZm9yIGNvbnNpc3RlbnQgY3VydmUgcmVuZGVyaW5nXG4gICAgICAgICBkcmF3UmFpbChnLCBzdHJhaWdodEJyYW5jaCwgY3VydmVkQnJhbmNoMiwgXCJvdXRlclwiKTtcbiAgICAgICAgIGRyYXdSYWlsKGcsIGN1cnZlZEJyYW5jaCwgbWFpblRyYWNrLCBcImlubmVyXCIpO1xuICAgICAgICAgZHJhd1JhaWwoZywgc3RyYWlnaHRCcmFuY2gsIGN1cnZlZEJyYW5jaDIsIFwiaW5uZXJcIik7XG4gICAgICAgICBkcmF3UmFpbChnLCBjdXJ2ZWRCcmFuY2gsIG1haW5UcmFjaywgXCJvdXRlclwiKTtcblxuICAgICAgICAgLy8gRHJhdyBzdHJhaWdodCBjb25uZWN0aW9uc1xuICAgICAgICAgZy5tdChtYWluVHJhY2sucmFpbHMuaW5uZXIueCwgbWFpblRyYWNrLnJhaWxzLmlubmVyLnkpLmx0KHN0cmFpZ2h0QnJhbmNoLnJhaWxzLmlubmVyLngsIHN0cmFpZ2h0QnJhbmNoLnJhaWxzLmlubmVyLnkpO1xuXG4gICAgICAgICBnLm10KG1haW5UcmFjay5yYWlscy5vdXRlci54LCBtYWluVHJhY2sucmFpbHMub3V0ZXIueSkubHQoc3RyYWlnaHRCcmFuY2gucmFpbHMub3V0ZXIueCwgc3RyYWlnaHRCcmFuY2gucmFpbHMub3V0ZXIueSk7XG5cbiAgICAgICAgIGcubXQoY3VydmVkQnJhbmNoLnJhaWxzLmlubmVyLngsIGN1cnZlZEJyYW5jaC5yYWlscy5pbm5lci55KS5sdChcbiAgICAgICAgICAgIGN1cnZlZEJyYW5jaDIucmFpbHMuaW5uZXIueCxcbiAgICAgICAgICAgIGN1cnZlZEJyYW5jaDIucmFpbHMuaW5uZXIueVxuICAgICAgICAgKTtcblxuICAgICAgICAgZy5tdChjdXJ2ZWRCcmFuY2gucmFpbHMub3V0ZXIueCwgY3VydmVkQnJhbmNoLnJhaWxzLm91dGVyLnkpLmx0KFxuICAgICAgICAgICAgY3VydmVkQnJhbmNoMi5yYWlscy5vdXRlci54LFxuICAgICAgICAgICAgY3VydmVkQnJhbmNoMi5yYWlscy5vdXRlci55XG4gICAgICAgICApO1xuXG4gICAgICAgICBnLmVuZFN0cm9rZSgpO1xuICAgICAgfVxuICAgfVxuXG4gICByZW5kZXJTd2l0Y2hVSShzdykgeyAgICAgIFxuXG4gICAgICBjb25zdCBkcmF3QXJyb3cgPSAoZ3JhcGhpY3MsIGxlbmd0aCwgc2l6ZSkgPT4ge1xuICAgICAgICAgZ3JhcGhpY3MubXQoMCwgMClcbiAgICAgICAgICAgIC5sdChsZW5ndGgsIDApXG4gICAgICAgICAgICAubXQobGVuZ3RoIC0gc2l6ZSwgLXNpemUgLyAyKVxuICAgICAgICAgICAgLmx0KGxlbmd0aCwgMClcbiAgICAgICAgICAgIC5sdChsZW5ndGggLSBzaXplLCBzaXplIC8gMik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGEgY29udGFpbmVyIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHN3aXRjaFxuICAgICAgbGV0IGNvbnRhaW5lciA9IHVpX2NvbnRhaW5lci5jaGlsZHJlbi5maW5kKChjKSA9PiBjLmRhdGEgPT09IHN3KTtcblxuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgLy8gSWYgY29udGFpbmVyIGV4aXN0cywgY2xlYXIgaXQgYnV0IGtlZXAgaXRcbiAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb250YWluZXIgaWYgbm9uZSBleGlzdHNcbiAgICAgICAgIGNvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgIGNvbnRhaW5lci5tb3VzZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICBjb250YWluZXIubmFtZSA9IFwic3dpdGNoXCI7XG4gICAgICAgICBjb250YWluZXIuZGF0YSA9IHN3O1xuICAgICAgICAgdWlfY29udGFpbmVyLmFkZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhcnJvd3MgZm9yIGJvdGggdHJhY2tzXG4gICAgICBbc3cuZnJvbSwgc3cuYnJhbmNoXS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICBjb25zdCBhcnJvdyA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKGFycm93KTtcblxuICAgICAgICAgYXJyb3cuZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUodHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuU1dJVENIX1VJX1NUUk9LRSwgXCJyb3VuZFwiKS5iZWdpblN0cm9rZShcIiMzMzNcIik7XG4gICAgICAgICBkcmF3QXJyb3coYXJyb3cuZ3JhcGhpY3MsIDIwLCA1KTtcbiAgICAgICAgIGFycm93LnggPSBzdy5sb2NhdGlvbi54O1xuICAgICAgICAgYXJyb3cueSA9IHN3LmxvY2F0aW9uLnk7XG4gICAgICAgICBhcnJvdy5yb3RhdGlvbiA9IFN3aXRjaC5maW5kQW5nbGUoc3cubG9jYXRpb24sIHQuZW5kLmVxdWFscyhzdy5sb2NhdGlvbikgPyB0LnN0YXJ0IDogdC5lbmQpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIFBvaW50VmlzaWJsZShwMSkge1xuICAgICAgaWYgKHRoaXMuX3JlbmRlcmluZz8uZG9udF9vcHRpbWl6ZSkgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBzY3JlZW5fcmVjdGFuZ2xlID0gdGhpcy5fcmVuZGVyaW5nLnNjcmVlbl9yZWN0YW5nbGU7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICBOdW1iZXJVdGlscy5iZXR3ZWVuKHAxLngsIHNjcmVlbl9yZWN0YW5nbGUubGVmdCwgc2NyZWVuX3JlY3RhbmdsZS5yaWdodCkgJiZcbiAgICAgICAgIE51bWJlclV0aWxzLmJldHdlZW4ocDEueSwgc2NyZWVuX3JlY3RhbmdsZS50b3AsIHNjcmVlbl9yZWN0YW5nbGUuYm90dG9tKVxuICAgICAgKTtcbiAgIH1cblxuICAgVHJhY2tWaXNpYmxlKHRyYWNrLCBzY3JlZW5fcmVjdGFuZ2xlID0gdGhpcy5fcmVuZGVyaW5nLnNjcmVlbl9yZWN0YW5nbGUpIHtcbiAgICAgIGlmICh0aGlzLl9yZW5kZXJpbmc/LmRvbnRfb3B0aW1pemUpIHJldHVybiB0cnVlO1xuXG4gICAgICBjb25zdCBpc0luc2lkZSA9IChwb2ludCwgcmVjdCkgPT5cbiAgICAgICAgIHBvaW50LnggPiByZWN0LmxlZnQgJiYgcG9pbnQueCA8IHJlY3QucmlnaHQgJiYgcG9pbnQueSA+IHJlY3QudG9wICYmIHBvaW50LnkgPCByZWN0LmJvdHRvbTtcblxuICAgICAgLy9maXJzdCB0aGUgZWFzeSBwYXJ0LCBpZiBlaXRoZXIgb24gb2YgaXRzIGVuZCBwb2ludHMgaXMgdmlzaWJsZVxuICAgICAgaWYgKGlzSW5zaWRlKHRyYWNrLnN0YXJ0LCBzY3JlZW5fcmVjdGFuZ2xlKSB8fCBpc0luc2lkZSh0cmFjay5lbmQsIHNjcmVlbl9yZWN0YW5nbGUpKSByZXR1cm4gdHJ1ZTsgLy9cblxuICAgICAgLy9ub3cgd2UgaGF2ZSB0byBtYWtlIHN1cmUsIGlmIHRoZSB0cmFjayBpcyBnb2luZyB0aHJvdWdoIHRoZSB3aG9sZSBzY3JlZW5cbiAgICAgIC8vd2UgY2hlY2ssIGlmIHRoZSB0cmFjayBpbnRlcnNlY3RzIG9uZSBvZiB0aGUgc2NyZWVuIGJvcmRlcnNcblxuICAgICAgLy9sZWZ0XG4gICAgICBsZXQgcDEgPSB7IHg6IHNjcmVlbl9yZWN0YW5nbGUubGVmdCwgeTogc2NyZWVuX3JlY3RhbmdsZS50b3AgfSxcbiAgICAgICAgIHAyID0geyB4OiBzY3JlZW5fcmVjdGFuZ2xlLmxlZnQsIHk6IHNjcmVlbl9yZWN0YW5nbGUuYm90dG9tIH07XG4gICAgICBpZiAoZ2VvbWV0cnkuZG9MaW5lU2VnbWVudHNJbnRlcnNlY3QocDEsIHAyLCB0cmFjay5zdGFydCwgdHJhY2suZW5kKSkgcmV0dXJuIHRydWU7XG4gICAgICAvL2JvdHRvbVxuICAgICAgcDEgPSBwMjtcbiAgICAgIHAyID0geyB4OiBzY3JlZW5fcmVjdGFuZ2xlLnJpZ2h0LCB5OiBzY3JlZW5fcmVjdGFuZ2xlLmJvdHRvbSB9O1xuICAgICAgaWYgKGdlb21ldHJ5LmRvTGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCkpIHJldHVybiB0cnVlO1xuICAgICAgLy9yaWdodFxuICAgICAgcDEgPSBwMjtcbiAgICAgIHAyID0geyB4OiBzY3JlZW5fcmVjdGFuZ2xlLnJpZ2h0LCB5OiBzY3JlZW5fcmVjdGFuZ2xlLnRvcCB9O1xuICAgICAgaWYgKGdlb21ldHJ5LmRvTGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCkpIHJldHVybiB0cnVlO1xuICAgICAgLy90b3Agd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgYWxsIGJvcmRlcnNcbiAgICAgIC8qIHAxID0gcDI7XG4gICAgICBwMiA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgaWYgKGdlb21ldHJ5LmRvTGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCkpIHJldHVybiB0cnVlOyAqL1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG5cbiAgIFN3aXRjaFZpc2libGUoc3cpIHtcbiAgICAgIGlmICh0aGlzLl9yZW5kZXJpbmc/LmRvbnRfb3B0aW1pemUpIHJldHVybiB0cnVlO1xuICAgICAgY29uc3Qgc2NyZWVuX3JlY3RhbmdsZSA9IHRoaXMuX3JlbmRlcmluZy5zY3JlZW5fcmVjdGFuZ2xlO1xuXG4gICAgICAvLyBDaGVjayBpZiBzd2l0Y2ggbG9jYXRpb24gaXMgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuUG9pbnRWaXNpYmxlKHN3LmxvY2F0aW9uKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgc3dpdGNoJ3MgdHJhY2tzIGFyZSB2aXNpYmxlXG4gICAgICBjb25zdCB0cmFja3MgPSBbc3cudHJhY2sxLCBzdy50cmFjazIsIHN3LnRyYWNrMywgc3cudHJhY2s0XS5maWx0ZXIodCA9PiB0KTtcbiAgICAgIHJldHVybiB0cmFja3Muc29tZSh0cmFjayA9PiB0aGlzLlRyYWNrVmlzaWJsZSh0cmFjaywgc2NyZWVuX3JlY3RhbmdsZSkpO1xuICAgfVxuXG4gICAvKipcbiAgICAqIFZpc3VhbGl6ZSB0cmFjayBib3VuZHMgZm9yIGRlYnVnZ2luZ1xuICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gdmlzdWFsaXplIGJvdW5kcyBmb3JcbiAgICAqL1xuICAgdmlzdWFsaXplVHJhY2tCb3VuZHMoY29udGFpbmVyKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSBjb250YWluZXIuZ2V0VHJhbnNmb3JtZWRCb3VuZHMoKTtcbiAgICAgIGNvbnN0IG9iamVjdCA9IGNvbnRhaW5lci5kYXRhO1xuXG4gICAgICBpZiAoYm91bmRzID09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkJvdW5kcyBhcmUgbnVsbFwiKTtcblxuICAgICAgLy8gQWRkIHBhZGRpbmcgdG8gYm91bmRzXG4gICAgICBjb25zdCBwYWRkaW5nID0gNTtcbiAgICAgIGJvdW5kcy54IC09IHBhZGRpbmc7XG4gICAgICBib3VuZHMueSAtPSBwYWRkaW5nO1xuICAgICAgYm91bmRzLndpZHRoICs9IHBhZGRpbmcgKiAyO1xuICAgICAgYm91bmRzLmhlaWdodCArPSBwYWRkaW5nICogMjtcblxuICAgICAgLy8gQ3JlYXRlIGEgc2hhcGUgZm9yIHRoZSBib3VuZHMgdmlzdWFsaXphdGlvblxuICAgICAgY29uc3QgYm91bmRzU2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIGJvdW5kc1NoYXBlLm5hbWUgPSBcInNlbGVjdGlvblwiO1xuICAgICAgYm91bmRzU2hhcGUubW91c2VFbmFibGVkID0gZmFsc2U7XG4gICAgICBib3VuZHNTaGFwZS5kYXRhID0gb2JqZWN0O1xuXG4gICAgICAvLyBEcmF3IHRoZSBib3VuZHMgcmVjdGFuZ2xlXG4gICAgICBib3VuZHNTaGFwZS5ncmFwaGljc1xuICAgICAgICAgLnNldFN0cm9rZVN0eWxlKDIpXG4gICAgICAgICAuc2V0U3Ryb2tlRGFzaChbNSwgNV0pXG4gICAgICAgICAuYmVnaW5TdHJva2UoXCJyZ2JhKDAsIDAsIDAsIDAuNylcIilcbiAgICAgICAgIC5kcmF3UmVjdChib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodClcbiAgICAgICAgIC5lbmRTdHJva2UoKTtcblxuICAgICAgc2VsZWN0aW9uX2NvbnRhaW5lci5hZGRDaGlsZChib3VuZHNTaGFwZSk7XG4gICB9XG59XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/trackRendering_textured.js\n\n}");

/***/ }),

/***/ "./www/code/train.js":
/*!***************************!*\
  !*** ./www/code/train.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Train: () => (/* binding */ Train)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\nclass Train {\n   static allTrains = [];\n   static nextId = 0;\n   static movingTrains = new Set(); // To track which trains are currently moving\n   static movementTimer = null; // Timer for automatic movement\n   static MOVEMENT_INTERVAL = 50; // Milliseconds between movement updates\n   static MOVEMENT_SPEED = 2; // Units to move per update\n\n   static CAR_TYPES = {\n      LOCOMOTIVE: \"locomotive\",\n      PASSENGER: \"passenger\",\n      MULTIPLE_UNIT_CAR: \"multiple_unit_car\",\n      MULTIPLE_UNIT_HEAD_FRONT: \"multiple_unit_head_front\",\n      MULTIPLE_UNIT_HEAD_BACK: \"multiple_unit_head_back\",\n   };\n\n   static getNextId() {\n      return Train.nextId++;\n   }\n\n   // Constants for different car types\n   static LOCO_LENGTH = 80;\n   static PASSENGER_LENGTH = 100;\n   static MULTIPLE_UNIT_CAR_LENGTH = 50;\n   static MULTIPLE_UNIT_HEAD_FRONT_LENGTH = 50;\n   static MULTIPLE_UNIT_HEAD_BACK_LENGTH = 50;\n\n   // Car spacing\n   static CAR_SPACING = 5;\n\n   static addTrain(track, km, color = \"#ff0000\", type = Train.CAR_TYPES.LOCOMOTIVE, number = \"\") {\n      const train = new Train();\n      train.track = track;\n      train.pos = km;\n      train._color = color;\n      train._type = type;\n      train._number = number;\n\n      Train.allTrains.push(train);\n      return train;\n   }\n\n   static initEditTrainMenu(train) {\n      $(\"#colorInputTrain\")\n         .off()\n         .val(train.color)\n         .on(\"change\", function (e) {\n            train.color = $(this).val();\n            window.renderer.renderAllTrains();\n            window.stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n         });\n\n      $(\"#inputZugnummer\")\n         .off()\n         .val(train.number)\n         .on(\"change\", function (e) {\n            train.number = $(this).val();\n            window.renderer.renderAllTrains();\n            window.stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n         });\n\n      $(\"#selectTrainType\")\n         .off()\n         .val(train.type)\n         .on(\"change\", function (e) {\n            train.type = $(this).val();\n            window.renderer.renderAllTrains();\n            window.stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n         });\n\n      $(\"#btnRemoveTrain\")\n         .off()\n         .click(() => Train.deleteTrain(train));\n\n      $(\"#btnCoupleTrain\")\n         .off()\n         .click(() => {\n            // Set global state for coupling mode\n            if (window.custom_mouse_mode === window.CUSTOM_MOUSE_ACTION.NONE) {\n               // First check if there are any coupling points available\n               if (Train.showCouplingPoints(train)) {\n                  // Add active class to button\n                  $(\"#btnCoupleTrain\").addClass(\"active\");\n\n                  window.custom_mouse_mode = window.CUSTOM_MOUSE_ACTION.TRAIN_COUPLE;\n\n                  // Show coupling message\n                  $(\"#couplingMessage\")\n                     .text(\"Klicke auf einen Kupplungspunkt um Züge zu kuppeln oder überall anders um abzubrechen\")\n                     .show();\n               } else {\n                  // Points are already cleared and message shown by showCouplingPoints\n               }\n            } else {\n               Train.exitCouplingMode();\n            }\n         });\n\n      $(\"#btnUncoupleTrain\")\n         .off()\n         .click(() => {\n            // Set global state for decoupling mode\n            if (window.custom_mouse_mode === window.CUSTOM_MOUSE_ACTION.NONE) {\n               // First check if there are any decoupling points available\n               if (Train.showDecouplingPoints(train)) {\n                  // Add active class to button\n                  $(\"#btnUncoupleTrain\").addClass(\"active\");\n\n                  window.custom_mouse_mode = window.CUSTOM_MOUSE_ACTION.TRAIN_DECOUPLE;\n\n                  // Show decoupling message\n                  $(\"#couplingMessage\")\n                     .text(\"Klicke zwischen Wagen um Züge zu entkuppeln oder überall anders um abzubrechen\")\n                     .show();\n               } else {\n                  // Points are already cleared and message shown by showDecouplingPoints\n               }\n            } else {\n               Train.exitDecouplingMode();\n            }\n         });\n         \n      // Only show movement controls for locomotives (first car of a train)\n      const isLocomotive = train.type === Train.CAR_TYPES.LOCOMOTIVE;\n      $(\"#trainMovementControls\").toggle(isLocomotive);\n      \n      if (isLocomotive) {\n         // Initialize movement direction buttons\n         if (!train.movementDirection) {\n            train.movementDirection = 1; // Default to forward\n         }\n         \n         // Update button states based on current direction\n         $(\"#btnDirectionForward\").toggleClass(\"active\", train.movementDirection > 0);\n         $(\"#btnDirectionBackward\").toggleClass(\"active\", train.movementDirection < 0);\n         \n         // Update start/stop button based on movement state\n         const isMoving = Train.movingTrains.has(train);\n         $(\"#btnStartStopTrain\")\n            .toggleClass(\"btn-success\", !isMoving)\n            .toggleClass(\"btn-danger\", isMoving)\n            .html(isMoving ? '<i class=\"bi bi-stop-fill\"></i> Stop' : '<i class=\"bi bi-play-fill\"></i> Start');\n         \n         // Set up direction button handlers\n         $(\"#btnDirectionForward\")\n            .off()\n            .click(() => {\n               train.movementDirection = 1;\n               $(\"#btnDirectionForward\").addClass(\"active\");\n               $(\"#btnDirectionBackward\").removeClass(\"active\");\n            });\n            \n         $(\"#btnDirectionBackward\")\n            .off()\n            .click(() => {\n               train.movementDirection = -1;\n               $(\"#btnDirectionBackward\").addClass(\"active\");\n               $(\"#btnDirectionForward\").removeClass(\"active\");\n            });\n            \n         // Set up start/stop button handler\n         $(\"#btnStartStopTrain\")\n            .off()\n            .click(() => {\n               if (Train.movingTrains.has(train)) {\n                  // Stop the train\n                  Train.stopTrain(train);\n               } else {\n                  // Start the train\n                  Train.startTrain(train);\n               }\n            });\n      }\n   }\n\n   static deleteTrain(train) {\n      // Stop the train if it's moving\n      if (Train.movingTrains.has(train)) {\n         Train.stopTrain(train);\n      }  \n\n      // Get the last car in the train that will be deleted\n      let currentCar = train;\n      while (currentCar.trainCoupledBack) {\n         currentCar = currentCar.trainCoupledBack;\n      }\n\n      // Remove all cars in this train from allTrains\n      while (currentCar) {\n         _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.remove(this.allTrains, currentCar);\n         //save the next car before removing all references to other objects\n         const nextCar = currentCar.trainCoupledFront;\n         currentCar.trainCoupledFront = null;\n         currentCar.trainCoupledBack = null;\n         currentCar.track = null;\n         currentCar = nextCar;\n      }\n\n      renderer.renderAllTrains();\n      stage.update();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n   }\n\n   static moveTrain(train, movementX) {\n      // Find the head of the train (first car with no front coupling)\n      let firstCar = train;\n      while (firstCar.trainCoupledFront != null) {\n         firstCar = firstCar.trainCoupledFront;\n      }\n\n      // Find the last car\n      let lastCar = firstCar;\n      while (lastCar.trainCoupledBack != null) {\n         lastCar = lastCar.trainCoupledBack;\n      }\n\n      if (!Train.movementPossible(firstCar, movementX) || !Train.movementPossible(lastCar, movementX)) return;\n\n      // Move each car starting from the first\n      let car = firstCar;\n      let new_pos;\n      let currentTrack;\n\n      currentTrack = car.track;\n\n\n      // Calculate new position using the node's unit vector\n      new_pos = car.pos + movementX / stage.scale / car.track.cos;\n\n      while (car) {\n         if (car != firstCar) {\n            // Calculate position based on previous car and car length\n            // Take into account the spacing between cars (5 units)\n            const prevCar = car.trainCoupledFront;\n            const spacing = 5; // Gap between cars\n            new_pos = prevCar.pos + prevCar.length / 2 + spacing + car.length / 2;\n         }\n\n         let newTrack;\n         if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.outoff(new_pos, 0, currentTrack.length)) {\n            const sw = new_pos <= 0 ? currentTrack.switchAtTheStart : currentTrack.switchAtTheEnd;\n\n            if (sw) {\n               if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_4__.type)(sw) == \"Track\") newTrack = sw;\n               else if (sw.from == currentTrack) newTrack = sw.branch;\n               else if (sw.branch == currentTrack) newTrack = sw.from;\n\n               if (newTrack) {\n                  car.track = newTrack;\n                  car.pos = new_pos <= 0 ? newTrack.length + new_pos : new_pos - currentTrack.length;\n                  currentTrack = newTrack;\n                  new_pos = car.pos;\n               }\n            }\n         } else {\n            car.track = currentTrack;\n            car.pos = new_pos;\n         }\n\n         car = car.trainCoupledBack;\n      }\n   }\n\n   static movementPossible(train, movementX) {\n      const currentTrack = train.track;\n\n      // Calculate new position using the node's unit vector\n      let new_pos = train.pos + movementX / stage.scale / train.track.cos;\n\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.outoff(new_pos, 0 + train.length / 2, currentTrack.length - train.length / 2)) {\n         const sw = new_pos <= 0 + train.length / 2 ? currentTrack.switchAtTheStart : currentTrack.switchAtTheEnd;\n\n         return sw != null && ((0,_tools_js__WEBPACK_IMPORTED_MODULE_4__.type)(sw) == \"Track\" || sw.from == currentTrack || sw.branch == currentTrack);\n      } else return true;\n   }\n\n   static FromObject(o) {\n      const train = new Train();\n      train._id = o._id;\n      Train.nextId = Math.max(Train.nextId, o._id + 1);\n      train._color = o.color;\n      train._coordinates = _tools_js__WEBPACK_IMPORTED_MODULE_4__.Point.fromPoint(o.coordinates);\n      train._type = o.type || Train.CAR_TYPES.LOCOMOTIVE;\n      train._number = o.number || \"\";\n      train.trainCoupledBackId = o.trainCoupledBackId;\n      train.trainCoupledFrontId = o.trainCoupledFrontId;\n      return train;\n   }\n\n   _id = Train.getNextId();\n   _track = null;\n   _pos = null;\n   _coordinates = null;\n   _color = \"#000000\";\n   _number = \"\";\n   _type = Train.CAR_TYPES.LOCOMOTIVE;\n   trainCoupledBack = null;\n   trainCoupledFront = null;\n\n   get track() {\n      return this._track;\n   }\n\n   set track(t) {\n      this._track = t;\n   }\n\n   get pos() {\n      return this._pos;\n   }\n\n   set pos(km) {\n      this._pos = km;\n      if (this._track) this._coordinates = this._track.getPointFromKm(km);\n   }\n\n   get color() {\n      return this._color;\n   }\n\n   set color(c) {\n      this._color = c;\n   }\n\n   get number() {\n      return this._number;\n   }\n\n   set number(n) {\n      this._number = n;\n   }\n\n   get type() {\n      return this._type;\n   }\n\n   set type(t) {\n      this._type = t;\n   }\n\n   get length() {\n      switch (this._type) {\n         case Train.CAR_TYPES.LOCOMOTIVE:\n            return Train.LOCO_LENGTH;\n         case Train.CAR_TYPES.PASSENGER:\n            return Train.PASSENGER_LENGTH;\n         case Train.CAR_TYPES.MULTIPLE_UNIT_CAR:\n            return Train.MULTIPLE_UNIT_CAR_LENGTH;\n         case Train.CAR_TYPES.MULTIPLE_UNIT_HEAD_FRONT:\n            return Train.MULTIPLE_UNIT_HEAD_FRONT_LENGTH;\n         case Train.CAR_TYPES.MULTIPLE_UNIT_HEAD_BACK:\n            return Train.MULTIPLE_UNIT_HEAD_BACK_LENGTH;\n         default:\n            return Train.PASSENGER_LENGTH; // Default to passenger length if type is unknown\n      }\n   }\n\n   coupleBack(train) {\n      if (train === this) return; // Can't couple to self\n\n      // First uncouple the train from any previous connections\n      if (train.trainCoupledFront) {\n         train.trainCoupledFront.trainCoupledBack = null;\n         train.trainCoupledFront = null;\n      }\n\n      this.trainCoupledBack = train;\n      train.trainCoupledFront = this;\n   }\n\n   uncouple() {\n      if (this.trainCoupledBack) {\n         this.trainCoupledBack.trainCoupledFront = null;\n         this.trainCoupledBack = null;\n      }\n   }\n\n   // Find the locomotive (head) of this train\n   getLocomotive() {\n      let loco = this;\n      while (loco.trainCoupledFront) {\n         loco = loco.trainCoupledFront;\n      }\n      return loco;\n   }\n\n   // Count all cars in this train\n   getCarCount() {\n      let count = 1;\n      let car = this.trainCoupledBack;\n      while (car) {\n         count++;\n         car = car.trainCoupledBack;\n      }\n      return count;\n   }\n\n   restore() {\n      const t = _track_js__WEBPACK_IMPORTED_MODULE_3__.Track.findTrackByPoint(this._coordinates);\n      if (t) {\n         this.track = t;\n         this.pos = t.getKmfromPoint(this._coordinates);\n      }\n\n      if (this.trainCoupledFrontId) {\n         const frontCar = Train.allTrains.find((t) => t._id === this.trainCoupledFrontId);\n         if (frontCar) {\n            this.trainCoupledFront = frontCar;\n         }\n\n         \n      }\n\n      if (this.trainCoupledBackId) {\n         const backCar = Train.allTrains.find((t) => t._id === this.trainCoupledBackId);\n         if (backCar) {\n            this.trainCoupledBack = backCar;\n         }\n\n         \n      }\n   }\n\n   stringify() {\n      return {\n         _class: \"Train\",\n         _id: this._id,\n         coordinates: this._coordinates,\n         color: this._color,\n         number: this._number,\n         type: this._type,\n         trainCoupledBackId: this.trainCoupledBack ? this.trainCoupledBack._id : null,\n         trainCoupledFrontId: this.trainCoupledFront ? this.trainCoupledFront._id : null,\n      };\n   }\n\n   static showDecouplingPoints(train) {\n      // Clear any existing overlay\n      overlay_container.removeAllChildren();\n\n      // Find the first car in the train\n      let firstCar = train;\n      while (firstCar.trainCoupledFront) {\n         firstCar = firstCar.trainCoupledFront;\n      }\n\n      // Start with the first car\n      let currentCar = firstCar;\n      let decouplingPointsFound = 0;\n\n      // Add decoupling points between each car\n      while (currentCar && currentCar.trainCoupledBack) {\n         const nextCar = currentCar.trainCoupledBack;\n\n         // Get positions of the two cars\n         const currentPos = currentCar.track.getPointFromKm(currentCar.pos);\n         const nextPos = nextCar.track.getPointFromKm(nextCar.pos);\n\n         // Calculate midpoint between cars for decoupling point\n         const midX = (currentPos.x + nextPos.x) / 2;\n         const midY = (currentPos.y + nextPos.y) / 2;\n\n         // Create a decoupling point (circle)\n         const decouplingPoint = new createjs.Shape();\n         decouplingPoint.graphics.beginFill(\"#ff0000\").drawCircle(0, 0, 6);\n         decouplingPoint.x = midX;\n         decouplingPoint.y = midY;\n         // Store the cars to decouple in the shape's data\n         decouplingPoint.data = {\n            carToDeCoupleFrom: currentCar,\n            carToDeCouple: nextCar,\n         };\n         decouplingPoint.name = \"decouplingPoint\";\n\n         // Add to overlay container\n         overlay_container.addChild(decouplingPoint);\n         decouplingPointsFound++;\n\n         // Move to the next car\n         currentCar = nextCar;\n      }\n\n      // If no decoupling points found, show a message\n      if (decouplingPointsFound === 0) {\n         // Show a message\n         _ui_js__WEBPACK_IMPORTED_MODULE_2__.ui.showInfoToast(\"Keine Wagen in der Nähe zum entkuppeln gefunden, dieser Zug hat nur einen Wagen\");\n         return false;\n      } else {\n         stage.update();\n         return true;\n      }\n   }\n\n   static handleDecouplingClick(data) {\n      if (!data) throw new Error(\"No train provided\");\n      // Decouple at this point\n      data.carToDeCoupleFrom.uncouple();\n\n      // Exit decoupling mode\n      Train.exitDecouplingMode();\n\n      // Update display\n      renderer.renderAllTrains();\n      stage.update();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n   }\n\n   static exitDecouplingMode() {\n      // Remove decoupling points\n      window.overlay_container.removeAllChildren();\n\n      // Reset custom action mode\n      window.custom_mouse_mode = window.CUSTOM_MOUSE_ACTION.NONE;\n\n      // Hide message with a small delay to ensure it's fully shown first\n      setTimeout(() => {\n         $(\"#couplingMessage\").hide();\n      }, 50);\n\n      // Deactivate any active buttons\n      $(\"#btnUncoupleTrain\").removeClass(\"active\");\n\n      window.stage.update();\n   }\n\n   static showCouplingPoints(train) {\n      // Clear any existing overlay\n      window.overlay_container.removeAllChildren();\n\n      // Get the head and tail of the train\n      let firstCar = train;\n      while (firstCar.trainCoupledFront) {\n         firstCar = firstCar.trainCoupledFront;\n      }\n\n      let lastCar = train;\n      while (lastCar.trainCoupledBack) {\n         lastCar = lastCar.trainCoupledBack;\n      }\n\n      // Get positions of the train ends\n      const firstCarPos = firstCar.pos;\n      const lastCarPos = lastCar.pos;\n      let distance = 0;\n      let couplingPointsFound = 0;\n\n      // Check all other trains for possible coupling points\n      Train.allTrains.forEach((otherCar) => {\n         // Skip cars in the same train\n         if (\n            otherCar === firstCar ||\n            otherCar === lastCar ||\n            (otherCar.trainCoupledFront != null && otherCar.trainCoupledBack != null) ||\n            otherCar.track != train.track\n         ) {\n            return;\n         }\n\n         // Get positions of the other train ends\n         const otherCarPos = otherCar.pos;\n\n         // Check distance between train ends (front to front)\n         const maxCouplingDistance = 80; // Maximum distance for coupling\n\n         // Check front of our train to back of other train\n         if (otherCar.trainCoupledBack == null) {\n            distance = firstCarPos - otherCarPos;\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.between(distance, 0, maxCouplingDistance)) {\n               addCouplingPoint(otherCar, firstCar);\n               couplingPointsFound++;\n            }\n         }\n\n         // Check back of our train to front of other train\n         if (otherCar.trainCoupledFront == null) {\n            distance = otherCarPos - lastCarPos;\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.between(distance, 0, maxCouplingDistance)) {\n               addCouplingPoint(lastCar, otherCar);\n               couplingPointsFound++;\n            }\n         }\n      });\n\n      // If no coupling points found, show a message\n      if (couplingPointsFound === 0) {\n         // Show a message\n         _ui_js__WEBPACK_IMPORTED_MODULE_2__.ui.showInfoToast(\"Keine Wagen in der Nähe zum kuppeln gefunden\");\n         return false;\n      } else {\n         window.stage.update();\n         return true;\n      }\n\n      // Helper function to add a coupling point\n      function addCouplingPoint(car1, car2) {\n         // Calculate midpoint between cars for coupling point\n         const car1Pos = car1.track.getPointFromKm(car1.pos);\n         const car2Pos = car2.track.getPointFromKm(car2.pos);\n         const midX = (car1Pos.x + car2Pos.x) / 2;\n         const midY = (car1Pos.y + car2Pos.y) / 2;\n\n         // Create a coupling point (circle)\n         const couplingPoint = new createjs.Shape();\n         couplingPoint.graphics.beginFill(\"#00ff00\").drawCircle(0, 0, 6);\n         couplingPoint.x = midX;\n         couplingPoint.y = midY;\n\n         // Store the cars to couple in the shape's data\n         couplingPoint.data = {\n            car1: car1,\n            car2: car2,\n         };\n         couplingPoint.name = \"couplingPoint\";\n\n         // Add to overlay container\n         window.overlay_container.addChild(couplingPoint);\n      }\n   }\n\n   static handleCouplingClick(data) {\n      if (!data) throw new Error(\"No train data provided\");\n\n      // Determine which cars to couple\n      data.car1.coupleBack(data.car2);\n\n      // Exit coupling mode\n      Train.exitCouplingMode();\n\n      // Update display\n      renderer.renderAllTrains();\n      stage.update();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n   }\n\n   static exitCouplingMode() {\n      // Remove coupling points\n      window.overlay_container.removeAllChildren();\n\n      // Reset custom action mode\n      window.custom_mouse_mode = window.CUSTOM_MOUSE_ACTION.NONE;\n\n      $(\"#couplingMessage\").hide();\n\n      // Deactivate any active buttons\n      $(\"#btnCoupleTrain\").removeClass(\"active\");\n\n      window.stage.update();\n   }\n\n   // Add new methods for automatic train movement\n\n   static startTrain(train) {\n      // Add train to the set of moving trains\n      Train.movingTrains.add(train);\n      \n      // Update button state\n      $(\"#btnStartStopTrain\")\n         .removeClass(\"btn-success\")\n         .addClass(\"btn-danger\")\n         .html('<i class=\"bi bi-stop-fill\"></i> Stop');\n      \n      // Start movement timer if not already running\n      if (!Train.movementTimer) {\n         Train.movementTimer = setInterval(Train.updateMovingTrains, Train.MOVEMENT_INTERVAL);\n      }\n   }\n   \n   static stopTrain(train) {\n      // Remove train from the set of moving trains\n      Train.movingTrains.delete(train);\n      \n      // Update button state\n      $(\"#btnStartStopTrain\")\n         .removeClass(\"btn-danger\")\n         .addClass(\"btn-success\")\n         .html('<i class=\"bi bi-play-fill\"></i> Start');\n      \n      // If no trains are moving, stop the timer\n      if (Train.movingTrains.size === 0 && Train.movementTimer) {\n         clearInterval(Train.movementTimer);\n         Train.movementTimer = null;\n      }\n   }\n   \n   static stopAllTrains() {\n      // Stop all moving trains\n      for (const train of Train.movingTrains) {\n         Train.stopTrain(train);\n      }\n      \n      // Clear the set of moving trains\n      Train.movingTrains.clear();\n      \n      // Stop the timer\n      if (Train.movementTimer) {\n         clearInterval(Train.movementTimer);\n         Train.movementTimer = null;\n      }\n   }\n   \n   static updateMovingTrains() {\n      let needsUpdate = false;\n      \n      // Move each train in the set of moving trains\n      for (const train of Train.movingTrains) {\n         // Calculate movement amount based on direction and speed\n         const movementAmount = train.movementDirection * Train.MOVEMENT_SPEED;\n         \n         // Check if movement is possible\n         const firstCar = train.getLocomotive();\n         const lastCar = Train.getLastCar(firstCar);\n         \n         if (Train.movementPossible(firstCar, movementAmount) && \n             Train.movementPossible(lastCar, movementAmount)) {\n            // Move the train\n            Train.moveTrain(firstCar, movementAmount);\n            needsUpdate = true;\n         } else {\n            // Stop the train if movement is not possible\n            Train.stopTrain(train);\n            _ui_js__WEBPACK_IMPORTED_MODULE_2__.ui.showInfoToast(\"Zug kann nicht weiter fahren\");\n         }\n      }\n      \n      // Update the display if any trains moved\n      if (needsUpdate) {\n         renderer.renderAllTrains();\n         stage.update();\n      }\n   }\n   \n   static getLastCar(train) {\n      let lastCar = train;\n      while (lastCar.trainCoupledBack) {\n         lastCar = lastCar.trainCoupledBack;\n      }\n      return lastCar;\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiw0Q0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBRTtBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnREFBTztBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNDQUFFO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0RBQU87QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxZQUFZLHNDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2xlaXNwbGFuZWRpdG9yLy4vd3d3L2NvZGUvdHJhaW4uanM/NGM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gRVM2IE1vZHVsZSBpbXBvcnRzXG5pbXBvcnQgeyBBcnJheVV0aWxzLCBOdW1iZXJVdGlscyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgU1RPUkFHRSB9IGZyb20gJy4vc3RvcmFnZS5qcyc7XG5pbXBvcnQgeyB1aSB9IGZyb20gJy4vdWkuanMnO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL3RyYWNrLmpzJztcbmltcG9ydCB7IFBvaW50LCB0eXBlIH0gZnJvbSAnLi90b29scy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFpbiB7XG4gICBzdGF0aWMgYWxsVHJhaW5zID0gW107XG4gICBzdGF0aWMgbmV4dElkID0gMDtcbiAgIHN0YXRpYyBtb3ZpbmdUcmFpbnMgPSBuZXcgU2V0KCk7IC8vIFRvIHRyYWNrIHdoaWNoIHRyYWlucyBhcmUgY3VycmVudGx5IG1vdmluZ1xuICAgc3RhdGljIG1vdmVtZW50VGltZXIgPSBudWxsOyAvLyBUaW1lciBmb3IgYXV0b21hdGljIG1vdmVtZW50XG4gICBzdGF0aWMgTU9WRU1FTlRfSU5URVJWQUwgPSA1MDsgLy8gTWlsbGlzZWNvbmRzIGJldHdlZW4gbW92ZW1lbnQgdXBkYXRlc1xuICAgc3RhdGljIE1PVkVNRU5UX1NQRUVEID0gMjsgLy8gVW5pdHMgdG8gbW92ZSBwZXIgdXBkYXRlXG5cbiAgIHN0YXRpYyBDQVJfVFlQRVMgPSB7XG4gICAgICBMT0NPTU9USVZFOiBcImxvY29tb3RpdmVcIixcbiAgICAgIFBBU1NFTkdFUjogXCJwYXNzZW5nZXJcIixcbiAgICAgIE1VTFRJUExFX1VOSVRfQ0FSOiBcIm11bHRpcGxlX3VuaXRfY2FyXCIsXG4gICAgICBNVUxUSVBMRV9VTklUX0hFQURfRlJPTlQ6IFwibXVsdGlwbGVfdW5pdF9oZWFkX2Zyb250XCIsXG4gICAgICBNVUxUSVBMRV9VTklUX0hFQURfQkFDSzogXCJtdWx0aXBsZV91bml0X2hlYWRfYmFja1wiLFxuICAgfTtcblxuICAgc3RhdGljIGdldE5leHRJZCgpIHtcbiAgICAgIHJldHVybiBUcmFpbi5uZXh0SWQrKztcbiAgIH1cblxuICAgLy8gQ29uc3RhbnRzIGZvciBkaWZmZXJlbnQgY2FyIHR5cGVzXG4gICBzdGF0aWMgTE9DT19MRU5HVEggPSA4MDtcbiAgIHN0YXRpYyBQQVNTRU5HRVJfTEVOR1RIID0gMTAwO1xuICAgc3RhdGljIE1VTFRJUExFX1VOSVRfQ0FSX0xFTkdUSCA9IDUwO1xuICAgc3RhdGljIE1VTFRJUExFX1VOSVRfSEVBRF9GUk9OVF9MRU5HVEggPSA1MDtcbiAgIHN0YXRpYyBNVUxUSVBMRV9VTklUX0hFQURfQkFDS19MRU5HVEggPSA1MDtcblxuICAgLy8gQ2FyIHNwYWNpbmdcbiAgIHN0YXRpYyBDQVJfU1BBQ0lORyA9IDU7XG5cbiAgIHN0YXRpYyBhZGRUcmFpbih0cmFjaywga20sIGNvbG9yID0gXCIjZmYwMDAwXCIsIHR5cGUgPSBUcmFpbi5DQVJfVFlQRVMuTE9DT01PVElWRSwgbnVtYmVyID0gXCJcIikge1xuICAgICAgY29uc3QgdHJhaW4gPSBuZXcgVHJhaW4oKTtcbiAgICAgIHRyYWluLnRyYWNrID0gdHJhY2s7XG4gICAgICB0cmFpbi5wb3MgPSBrbTtcbiAgICAgIHRyYWluLl9jb2xvciA9IGNvbG9yO1xuICAgICAgdHJhaW4uX3R5cGUgPSB0eXBlO1xuICAgICAgdHJhaW4uX251bWJlciA9IG51bWJlcjtcblxuICAgICAgVHJhaW4uYWxsVHJhaW5zLnB1c2godHJhaW4pO1xuICAgICAgcmV0dXJuIHRyYWluO1xuICAgfVxuXG4gICBzdGF0aWMgaW5pdEVkaXRUcmFpbk1lbnUodHJhaW4pIHtcbiAgICAgICQoXCIjY29sb3JJbnB1dFRyYWluXCIpXG4gICAgICAgICAub2ZmKClcbiAgICAgICAgIC52YWwodHJhaW4uY29sb3IpXG4gICAgICAgICAub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRyYWluLmNvbG9yID0gJCh0aGlzKS52YWwoKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW5kZXJlci5yZW5kZXJBbGxUcmFpbnMoKTtcbiAgICAgICAgICAgIHdpbmRvdy5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICQoXCIjaW5wdXRadWdudW1tZXJcIilcbiAgICAgICAgIC5vZmYoKVxuICAgICAgICAgLnZhbCh0cmFpbi5udW1iZXIpXG4gICAgICAgICAub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRyYWluLm51bWJlciA9ICQodGhpcykudmFsKCk7XG4gICAgICAgICAgICB3aW5kb3cucmVuZGVyZXIucmVuZGVyQWxsVHJhaW5zKCk7XG4gICAgICAgICAgICB3aW5kb3cuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgIH0pO1xuXG4gICAgICAkKFwiI3NlbGVjdFRyYWluVHlwZVwiKVxuICAgICAgICAgLm9mZigpXG4gICAgICAgICAudmFsKHRyYWluLnR5cGUpXG4gICAgICAgICAub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRyYWluLnR5cGUgPSAkKHRoaXMpLnZhbCgpO1xuICAgICAgICAgICAgd2luZG93LnJlbmRlcmVyLnJlbmRlckFsbFRyYWlucygpO1xuICAgICAgICAgICAgd2luZG93LnN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICAgICB9KTtcblxuICAgICAgJChcIiNidG5SZW1vdmVUcmFpblwiKVxuICAgICAgICAgLm9mZigpXG4gICAgICAgICAuY2xpY2soKCkgPT4gVHJhaW4uZGVsZXRlVHJhaW4odHJhaW4pKTtcblxuICAgICAgJChcIiNidG5Db3VwbGVUcmFpblwiKVxuICAgICAgICAgLm9mZigpXG4gICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0IGdsb2JhbCBzdGF0ZSBmb3IgY291cGxpbmcgbW9kZVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5jdXN0b21fbW91c2VfbW9kZSA9PT0gd2luZG93LkNVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORSkge1xuICAgICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBjb3VwbGluZyBwb2ludHMgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICBpZiAoVHJhaW4uc2hvd0NvdXBsaW5nUG9pbnRzKHRyYWluKSkge1xuICAgICAgICAgICAgICAgICAgLy8gQWRkIGFjdGl2ZSBjbGFzcyB0byBidXR0b25cbiAgICAgICAgICAgICAgICAgICQoXCIjYnRuQ291cGxlVHJhaW5cIikuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XG5cbiAgICAgICAgICAgICAgICAgIHdpbmRvdy5jdXN0b21fbW91c2VfbW9kZSA9IHdpbmRvdy5DVVNUT01fTU9VU0VfQUNUSU9OLlRSQUlOX0NPVVBMRTtcblxuICAgICAgICAgICAgICAgICAgLy8gU2hvdyBjb3VwbGluZyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAkKFwiI2NvdXBsaW5nTWVzc2FnZVwiKVxuICAgICAgICAgICAgICAgICAgICAgLnRleHQoXCJLbGlja2UgYXVmIGVpbmVuIEt1cHBsdW5nc3B1bmt0IHVtIFrDvGdlIHp1IGt1cHBlbG4gb2RlciDDvGJlcmFsbCBhbmRlcnMgdW0gYWJ6dWJyZWNoZW5cIilcbiAgICAgICAgICAgICAgICAgICAgIC5zaG93KCk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gUG9pbnRzIGFyZSBhbHJlYWR5IGNsZWFyZWQgYW5kIG1lc3NhZ2Ugc2hvd24gYnkgc2hvd0NvdXBsaW5nUG9pbnRzXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgVHJhaW4uZXhpdENvdXBsaW5nTW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG5cbiAgICAgICQoXCIjYnRuVW5jb3VwbGVUcmFpblwiKVxuICAgICAgICAgLm9mZigpXG4gICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0IGdsb2JhbCBzdGF0ZSBmb3IgZGVjb3VwbGluZyBtb2RlXG4gICAgICAgICAgICBpZiAod2luZG93LmN1c3RvbV9tb3VzZV9tb2RlID09PSB3aW5kb3cuQ1VTVE9NX01PVVNFX0FDVElPTi5OT05FKSB7XG4gICAgICAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGRlY291cGxpbmcgcG9pbnRzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgaWYgKFRyYWluLnNob3dEZWNvdXBsaW5nUG9pbnRzKHRyYWluKSkge1xuICAgICAgICAgICAgICAgICAgLy8gQWRkIGFjdGl2ZSBjbGFzcyB0byBidXR0b25cbiAgICAgICAgICAgICAgICAgICQoXCIjYnRuVW5jb3VwbGVUcmFpblwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcblxuICAgICAgICAgICAgICAgICAgd2luZG93LmN1c3RvbV9tb3VzZV9tb2RlID0gd2luZG93LkNVU1RPTV9NT1VTRV9BQ1RJT04uVFJBSU5fREVDT1VQTEU7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFNob3cgZGVjb3VwbGluZyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAkKFwiI2NvdXBsaW5nTWVzc2FnZVwiKVxuICAgICAgICAgICAgICAgICAgICAgLnRleHQoXCJLbGlja2Ugendpc2NoZW4gV2FnZW4gdW0gWsO8Z2UgenUgZW50a3VwcGVsbiBvZGVyIMO8YmVyYWxsIGFuZGVycyB1bSBhYnp1YnJlY2hlblwiKVxuICAgICAgICAgICAgICAgICAgICAgLnNob3coKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBQb2ludHMgYXJlIGFscmVhZHkgY2xlYXJlZCBhbmQgbWVzc2FnZSBzaG93biBieSBzaG93RGVjb3VwbGluZ1BvaW50c1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIFRyYWluLmV4aXREZWNvdXBsaW5nTW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG4gICAgICAgICBcbiAgICAgIC8vIE9ubHkgc2hvdyBtb3ZlbWVudCBjb250cm9scyBmb3IgbG9jb21vdGl2ZXMgKGZpcnN0IGNhciBvZiBhIHRyYWluKVxuICAgICAgY29uc3QgaXNMb2NvbW90aXZlID0gdHJhaW4udHlwZSA9PT0gVHJhaW4uQ0FSX1RZUEVTLkxPQ09NT1RJVkU7XG4gICAgICAkKFwiI3RyYWluTW92ZW1lbnRDb250cm9sc1wiKS50b2dnbGUoaXNMb2NvbW90aXZlKTtcbiAgICAgIFxuICAgICAgaWYgKGlzTG9jb21vdGl2ZSkge1xuICAgICAgICAgLy8gSW5pdGlhbGl6ZSBtb3ZlbWVudCBkaXJlY3Rpb24gYnV0dG9uc1xuICAgICAgICAgaWYgKCF0cmFpbi5tb3ZlbWVudERpcmVjdGlvbikge1xuICAgICAgICAgICAgdHJhaW4ubW92ZW1lbnREaXJlY3Rpb24gPSAxOyAvLyBEZWZhdWx0IHRvIGZvcndhcmRcbiAgICAgICAgIH1cbiAgICAgICAgIFxuICAgICAgICAgLy8gVXBkYXRlIGJ1dHRvbiBzdGF0ZXMgYmFzZWQgb24gY3VycmVudCBkaXJlY3Rpb25cbiAgICAgICAgICQoXCIjYnRuRGlyZWN0aW9uRm9yd2FyZFwiKS50b2dnbGVDbGFzcyhcImFjdGl2ZVwiLCB0cmFpbi5tb3ZlbWVudERpcmVjdGlvbiA+IDApO1xuICAgICAgICAgJChcIiNidG5EaXJlY3Rpb25CYWNrd2FyZFwiKS50b2dnbGVDbGFzcyhcImFjdGl2ZVwiLCB0cmFpbi5tb3ZlbWVudERpcmVjdGlvbiA8IDApO1xuICAgICAgICAgXG4gICAgICAgICAvLyBVcGRhdGUgc3RhcnQvc3RvcCBidXR0b24gYmFzZWQgb24gbW92ZW1lbnQgc3RhdGVcbiAgICAgICAgIGNvbnN0IGlzTW92aW5nID0gVHJhaW4ubW92aW5nVHJhaW5zLmhhcyh0cmFpbik7XG4gICAgICAgICAkKFwiI2J0blN0YXJ0U3RvcFRyYWluXCIpXG4gICAgICAgICAgICAudG9nZ2xlQ2xhc3MoXCJidG4tc3VjY2Vzc1wiLCAhaXNNb3ZpbmcpXG4gICAgICAgICAgICAudG9nZ2xlQ2xhc3MoXCJidG4tZGFuZ2VyXCIsIGlzTW92aW5nKVxuICAgICAgICAgICAgLmh0bWwoaXNNb3ZpbmcgPyAnPGkgY2xhc3M9XCJiaSBiaS1zdG9wLWZpbGxcIj48L2k+IFN0b3AnIDogJzxpIGNsYXNzPVwiYmkgYmktcGxheS1maWxsXCI+PC9pPiBTdGFydCcpO1xuICAgICAgICAgXG4gICAgICAgICAvLyBTZXQgdXAgZGlyZWN0aW9uIGJ1dHRvbiBoYW5kbGVyc1xuICAgICAgICAgJChcIiNidG5EaXJlY3Rpb25Gb3J3YXJkXCIpXG4gICAgICAgICAgICAub2ZmKClcbiAgICAgICAgICAgIC5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICB0cmFpbi5tb3ZlbWVudERpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAkKFwiI2J0bkRpcmVjdGlvbkZvcndhcmRcIikuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAkKFwiI2J0bkRpcmVjdGlvbkJhY2t3YXJkXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICQoXCIjYnRuRGlyZWN0aW9uQmFja3dhcmRcIilcbiAgICAgICAgICAgIC5vZmYoKVxuICAgICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgIHRyYWluLm1vdmVtZW50RGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAkKFwiI2J0bkRpcmVjdGlvbkJhY2t3YXJkXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgJChcIiNidG5EaXJlY3Rpb25Gb3J3YXJkXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgIC8vIFNldCB1cCBzdGFydC9zdG9wIGJ1dHRvbiBoYW5kbGVyXG4gICAgICAgICAkKFwiI2J0blN0YXJ0U3RvcFRyYWluXCIpXG4gICAgICAgICAgICAub2ZmKClcbiAgICAgICAgICAgIC5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICBpZiAoVHJhaW4ubW92aW5nVHJhaW5zLmhhcyh0cmFpbikpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN0b3AgdGhlIHRyYWluXG4gICAgICAgICAgICAgICAgICBUcmFpbi5zdG9wVHJhaW4odHJhaW4pO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSB0cmFpblxuICAgICAgICAgICAgICAgICAgVHJhaW4uc3RhcnRUcmFpbih0cmFpbik7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgIH1cblxuICAgc3RhdGljIGRlbGV0ZVRyYWluKHRyYWluKSB7XG4gICAgICAvLyBTdG9wIHRoZSB0cmFpbiBpZiBpdCdzIG1vdmluZ1xuICAgICAgaWYgKFRyYWluLm1vdmluZ1RyYWlucy5oYXModHJhaW4pKSB7XG4gICAgICAgICBUcmFpbi5zdG9wVHJhaW4odHJhaW4pO1xuICAgICAgfSAgXG5cbiAgICAgIC8vIEdldCB0aGUgbGFzdCBjYXIgaW4gdGhlIHRyYWluIHRoYXQgd2lsbCBiZSBkZWxldGVkXG4gICAgICBsZXQgY3VycmVudENhciA9IHRyYWluO1xuICAgICAgd2hpbGUgKGN1cnJlbnRDYXIudHJhaW5Db3VwbGVkQmFjaykge1xuICAgICAgICAgY3VycmVudENhciA9IGN1cnJlbnRDYXIudHJhaW5Db3VwbGVkQmFjaztcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGFsbCBjYXJzIGluIHRoaXMgdHJhaW4gZnJvbSBhbGxUcmFpbnNcbiAgICAgIHdoaWxlIChjdXJyZW50Q2FyKSB7XG4gICAgICAgICBBcnJheVV0aWxzLnJlbW92ZSh0aGlzLmFsbFRyYWlucywgY3VycmVudENhcik7XG4gICAgICAgICAvL3NhdmUgdGhlIG5leHQgY2FyIGJlZm9yZSByZW1vdmluZyBhbGwgcmVmZXJlbmNlcyB0byBvdGhlciBvYmplY3RzXG4gICAgICAgICBjb25zdCBuZXh0Q2FyID0gY3VycmVudENhci50cmFpbkNvdXBsZWRGcm9udDtcbiAgICAgICAgIGN1cnJlbnRDYXIudHJhaW5Db3VwbGVkRnJvbnQgPSBudWxsO1xuICAgICAgICAgY3VycmVudENhci50cmFpbkNvdXBsZWRCYWNrID0gbnVsbDtcbiAgICAgICAgIGN1cnJlbnRDYXIudHJhY2sgPSBudWxsO1xuICAgICAgICAgY3VycmVudENhciA9IG5leHRDYXI7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLnJlbmRlckFsbFRyYWlucygpO1xuICAgICAgc3RhZ2UudXBkYXRlKCk7XG4gICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgIH1cblxuICAgc3RhdGljIG1vdmVUcmFpbih0cmFpbiwgbW92ZW1lbnRYKSB7XG4gICAgICAvLyBGaW5kIHRoZSBoZWFkIG9mIHRoZSB0cmFpbiAoZmlyc3QgY2FyIHdpdGggbm8gZnJvbnQgY291cGxpbmcpXG4gICAgICBsZXQgZmlyc3RDYXIgPSB0cmFpbjtcbiAgICAgIHdoaWxlIChmaXJzdENhci50cmFpbkNvdXBsZWRGcm9udCAhPSBudWxsKSB7XG4gICAgICAgICBmaXJzdENhciA9IGZpcnN0Q2FyLnRyYWluQ291cGxlZEZyb250O1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBsYXN0IGNhclxuICAgICAgbGV0IGxhc3RDYXIgPSBmaXJzdENhcjtcbiAgICAgIHdoaWxlIChsYXN0Q2FyLnRyYWluQ291cGxlZEJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgbGFzdENhciA9IGxhc3RDYXIudHJhaW5Db3VwbGVkQmFjaztcbiAgICAgIH1cblxuICAgICAgaWYgKCFUcmFpbi5tb3ZlbWVudFBvc3NpYmxlKGZpcnN0Q2FyLCBtb3ZlbWVudFgpIHx8ICFUcmFpbi5tb3ZlbWVudFBvc3NpYmxlKGxhc3RDYXIsIG1vdmVtZW50WCkpIHJldHVybjtcblxuICAgICAgLy8gTW92ZSBlYWNoIGNhciBzdGFydGluZyBmcm9tIHRoZSBmaXJzdFxuICAgICAgbGV0IGNhciA9IGZpcnN0Q2FyO1xuICAgICAgbGV0IG5ld19wb3M7XG4gICAgICBsZXQgY3VycmVudFRyYWNrO1xuXG4gICAgICBjdXJyZW50VHJhY2sgPSBjYXIudHJhY2s7XG5cblxuICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBwb3NpdGlvbiB1c2luZyB0aGUgbm9kZSdzIHVuaXQgdmVjdG9yXG4gICAgICBuZXdfcG9zID0gY2FyLnBvcyArIG1vdmVtZW50WCAvIHN0YWdlLnNjYWxlIC8gY2FyLnRyYWNrLmNvcztcblxuICAgICAgd2hpbGUgKGNhcikge1xuICAgICAgICAgaWYgKGNhciAhPSBmaXJzdENhcikge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGJhc2VkIG9uIHByZXZpb3VzIGNhciBhbmQgY2FyIGxlbmd0aFxuICAgICAgICAgICAgLy8gVGFrZSBpbnRvIGFjY291bnQgdGhlIHNwYWNpbmcgYmV0d2VlbiBjYXJzICg1IHVuaXRzKVxuICAgICAgICAgICAgY29uc3QgcHJldkNhciA9IGNhci50cmFpbkNvdXBsZWRGcm9udDtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNpbmcgPSA1OyAvLyBHYXAgYmV0d2VlbiBjYXJzXG4gICAgICAgICAgICBuZXdfcG9zID0gcHJldkNhci5wb3MgKyBwcmV2Q2FyLmxlbmd0aCAvIDIgKyBzcGFjaW5nICsgY2FyLmxlbmd0aCAvIDI7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGxldCBuZXdUcmFjaztcbiAgICAgICAgIGlmIChOdW1iZXJVdGlscy5vdXRvZmYobmV3X3BvcywgMCwgY3VycmVudFRyYWNrLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN3ID0gbmV3X3BvcyA8PSAwID8gY3VycmVudFRyYWNrLnN3aXRjaEF0VGhlU3RhcnQgOiBjdXJyZW50VHJhY2suc3dpdGNoQXRUaGVFbmQ7XG5cbiAgICAgICAgICAgIGlmIChzdykge1xuICAgICAgICAgICAgICAgaWYgKHR5cGUoc3cpID09IFwiVHJhY2tcIikgbmV3VHJhY2sgPSBzdztcbiAgICAgICAgICAgICAgIGVsc2UgaWYgKHN3LmZyb20gPT0gY3VycmVudFRyYWNrKSBuZXdUcmFjayA9IHN3LmJyYW5jaDtcbiAgICAgICAgICAgICAgIGVsc2UgaWYgKHN3LmJyYW5jaCA9PSBjdXJyZW50VHJhY2spIG5ld1RyYWNrID0gc3cuZnJvbTtcblxuICAgICAgICAgICAgICAgaWYgKG5ld1RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICBjYXIudHJhY2sgPSBuZXdUcmFjaztcbiAgICAgICAgICAgICAgICAgIGNhci5wb3MgPSBuZXdfcG9zIDw9IDAgPyBuZXdUcmFjay5sZW5ndGggKyBuZXdfcG9zIDogbmV3X3BvcyAtIGN1cnJlbnRUcmFjay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VHJhY2sgPSBuZXdUcmFjaztcbiAgICAgICAgICAgICAgICAgIG5ld19wb3MgPSBjYXIucG9zO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhci50cmFjayA9IGN1cnJlbnRUcmFjaztcbiAgICAgICAgICAgIGNhci5wb3MgPSBuZXdfcG9zO1xuICAgICAgICAgfVxuXG4gICAgICAgICBjYXIgPSBjYXIudHJhaW5Db3VwbGVkQmFjaztcbiAgICAgIH1cbiAgIH1cblxuICAgc3RhdGljIG1vdmVtZW50UG9zc2libGUodHJhaW4sIG1vdmVtZW50WCkge1xuICAgICAgY29uc3QgY3VycmVudFRyYWNrID0gdHJhaW4udHJhY2s7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBuZXcgcG9zaXRpb24gdXNpbmcgdGhlIG5vZGUncyB1bml0IHZlY3RvclxuICAgICAgbGV0IG5ld19wb3MgPSB0cmFpbi5wb3MgKyBtb3ZlbWVudFggLyBzdGFnZS5zY2FsZSAvIHRyYWluLnRyYWNrLmNvcztcblxuICAgICAgaWYgKE51bWJlclV0aWxzLm91dG9mZihuZXdfcG9zLCAwICsgdHJhaW4ubGVuZ3RoIC8gMiwgY3VycmVudFRyYWNrLmxlbmd0aCAtIHRyYWluLmxlbmd0aCAvIDIpKSB7XG4gICAgICAgICBjb25zdCBzdyA9IG5ld19wb3MgPD0gMCArIHRyYWluLmxlbmd0aCAvIDIgPyBjdXJyZW50VHJhY2suc3dpdGNoQXRUaGVTdGFydCA6IGN1cnJlbnRUcmFjay5zd2l0Y2hBdFRoZUVuZDtcblxuICAgICAgICAgcmV0dXJuIHN3ICE9IG51bGwgJiYgKHR5cGUoc3cpID09IFwiVHJhY2tcIiB8fCBzdy5mcm9tID09IGN1cnJlbnRUcmFjayB8fCBzdy5icmFuY2ggPT0gY3VycmVudFRyYWNrKTtcbiAgICAgIH0gZWxzZSByZXR1cm4gdHJ1ZTtcbiAgIH1cblxuICAgc3RhdGljIEZyb21PYmplY3Qobykge1xuICAgICAgY29uc3QgdHJhaW4gPSBuZXcgVHJhaW4oKTtcbiAgICAgIHRyYWluLl9pZCA9IG8uX2lkO1xuICAgICAgVHJhaW4ubmV4dElkID0gTWF0aC5tYXgoVHJhaW4ubmV4dElkLCBvLl9pZCArIDEpO1xuICAgICAgdHJhaW4uX2NvbG9yID0gby5jb2xvcjtcbiAgICAgIHRyYWluLl9jb29yZGluYXRlcyA9IFBvaW50LmZyb21Qb2ludChvLmNvb3JkaW5hdGVzKTtcbiAgICAgIHRyYWluLl90eXBlID0gby50eXBlIHx8IFRyYWluLkNBUl9UWVBFUy5MT0NPTU9USVZFO1xuICAgICAgdHJhaW4uX251bWJlciA9IG8ubnVtYmVyIHx8IFwiXCI7XG4gICAgICB0cmFpbi50cmFpbkNvdXBsZWRCYWNrSWQgPSBvLnRyYWluQ291cGxlZEJhY2tJZDtcbiAgICAgIHRyYWluLnRyYWluQ291cGxlZEZyb250SWQgPSBvLnRyYWluQ291cGxlZEZyb250SWQ7XG4gICAgICByZXR1cm4gdHJhaW47XG4gICB9XG5cbiAgIF9pZCA9IFRyYWluLmdldE5leHRJZCgpO1xuICAgX3RyYWNrID0gbnVsbDtcbiAgIF9wb3MgPSBudWxsO1xuICAgX2Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgIF9jb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgX251bWJlciA9IFwiXCI7XG4gICBfdHlwZSA9IFRyYWluLkNBUl9UWVBFUy5MT0NPTU9USVZFO1xuICAgdHJhaW5Db3VwbGVkQmFjayA9IG51bGw7XG4gICB0cmFpbkNvdXBsZWRGcm9udCA9IG51bGw7XG5cbiAgIGdldCB0cmFjaygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFjaztcbiAgIH1cblxuICAgc2V0IHRyYWNrKHQpIHtcbiAgICAgIHRoaXMuX3RyYWNrID0gdDtcbiAgIH1cblxuICAgZ2V0IHBvcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3M7XG4gICB9XG5cbiAgIHNldCBwb3Moa20pIHtcbiAgICAgIHRoaXMuX3BvcyA9IGttO1xuICAgICAgaWYgKHRoaXMuX3RyYWNrKSB0aGlzLl9jb29yZGluYXRlcyA9IHRoaXMuX3RyYWNrLmdldFBvaW50RnJvbUttKGttKTtcbiAgIH1cblxuICAgZ2V0IGNvbG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgfVxuXG4gICBzZXQgY29sb3IoYykge1xuICAgICAgdGhpcy5fY29sb3IgPSBjO1xuICAgfVxuXG4gICBnZXQgbnVtYmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX251bWJlcjtcbiAgIH1cblxuICAgc2V0IG51bWJlcihuKSB7XG4gICAgICB0aGlzLl9udW1iZXIgPSBuO1xuICAgfVxuXG4gICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgfVxuXG4gICBzZXQgdHlwZSh0KSB7XG4gICAgICB0aGlzLl90eXBlID0gdDtcbiAgIH1cblxuICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fdHlwZSkge1xuICAgICAgICAgY2FzZSBUcmFpbi5DQVJfVFlQRVMuTE9DT01PVElWRTpcbiAgICAgICAgICAgIHJldHVybiBUcmFpbi5MT0NPX0xFTkdUSDtcbiAgICAgICAgIGNhc2UgVHJhaW4uQ0FSX1RZUEVTLlBBU1NFTkdFUjpcbiAgICAgICAgICAgIHJldHVybiBUcmFpbi5QQVNTRU5HRVJfTEVOR1RIO1xuICAgICAgICAgY2FzZSBUcmFpbi5DQVJfVFlQRVMuTVVMVElQTEVfVU5JVF9DQVI6XG4gICAgICAgICAgICByZXR1cm4gVHJhaW4uTVVMVElQTEVfVU5JVF9DQVJfTEVOR1RIO1xuICAgICAgICAgY2FzZSBUcmFpbi5DQVJfVFlQRVMuTVVMVElQTEVfVU5JVF9IRUFEX0ZST05UOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWluLk1VTFRJUExFX1VOSVRfSEVBRF9GUk9OVF9MRU5HVEg7XG4gICAgICAgICBjYXNlIFRyYWluLkNBUl9UWVBFUy5NVUxUSVBMRV9VTklUX0hFQURfQkFDSzpcbiAgICAgICAgICAgIHJldHVybiBUcmFpbi5NVUxUSVBMRV9VTklUX0hFQURfQkFDS19MRU5HVEg7XG4gICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFRyYWluLlBBU1NFTkdFUl9MRU5HVEg7IC8vIERlZmF1bHQgdG8gcGFzc2VuZ2VyIGxlbmd0aCBpZiB0eXBlIGlzIHVua25vd25cbiAgICAgIH1cbiAgIH1cblxuICAgY291cGxlQmFjayh0cmFpbikge1xuICAgICAgaWYgKHRyYWluID09PSB0aGlzKSByZXR1cm47IC8vIENhbid0IGNvdXBsZSB0byBzZWxmXG5cbiAgICAgIC8vIEZpcnN0IHVuY291cGxlIHRoZSB0cmFpbiBmcm9tIGFueSBwcmV2aW91cyBjb25uZWN0aW9uc1xuICAgICAgaWYgKHRyYWluLnRyYWluQ291cGxlZEZyb250KSB7XG4gICAgICAgICB0cmFpbi50cmFpbkNvdXBsZWRGcm9udC50cmFpbkNvdXBsZWRCYWNrID0gbnVsbDtcbiAgICAgICAgIHRyYWluLnRyYWluQ291cGxlZEZyb250ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFpbkNvdXBsZWRCYWNrID0gdHJhaW47XG4gICAgICB0cmFpbi50cmFpbkNvdXBsZWRGcm9udCA9IHRoaXM7XG4gICB9XG5cbiAgIHVuY291cGxlKCkge1xuICAgICAgaWYgKHRoaXMudHJhaW5Db3VwbGVkQmFjaykge1xuICAgICAgICAgdGhpcy50cmFpbkNvdXBsZWRCYWNrLnRyYWluQ291cGxlZEZyb250ID0gbnVsbDtcbiAgICAgICAgIHRoaXMudHJhaW5Db3VwbGVkQmFjayA9IG51bGw7XG4gICAgICB9XG4gICB9XG5cbiAgIC8vIEZpbmQgdGhlIGxvY29tb3RpdmUgKGhlYWQpIG9mIHRoaXMgdHJhaW5cbiAgIGdldExvY29tb3RpdmUoKSB7XG4gICAgICBsZXQgbG9jbyA9IHRoaXM7XG4gICAgICB3aGlsZSAobG9jby50cmFpbkNvdXBsZWRGcm9udCkge1xuICAgICAgICAgbG9jbyA9IGxvY28udHJhaW5Db3VwbGVkRnJvbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jbztcbiAgIH1cblxuICAgLy8gQ291bnQgYWxsIGNhcnMgaW4gdGhpcyB0cmFpblxuICAgZ2V0Q2FyQ291bnQoKSB7XG4gICAgICBsZXQgY291bnQgPSAxO1xuICAgICAgbGV0IGNhciA9IHRoaXMudHJhaW5Db3VwbGVkQmFjaztcbiAgICAgIHdoaWxlIChjYXIpIHtcbiAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICBjYXIgPSBjYXIudHJhaW5Db3VwbGVkQmFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgIH1cblxuICAgcmVzdG9yZSgpIHtcbiAgICAgIGNvbnN0IHQgPSBUcmFjay5maW5kVHJhY2tCeVBvaW50KHRoaXMuX2Nvb3JkaW5hdGVzKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgICB0aGlzLnRyYWNrID0gdDtcbiAgICAgICAgIHRoaXMucG9zID0gdC5nZXRLbWZyb21Qb2ludCh0aGlzLl9jb29yZGluYXRlcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRyYWluQ291cGxlZEZyb250SWQpIHtcbiAgICAgICAgIGNvbnN0IGZyb250Q2FyID0gVHJhaW4uYWxsVHJhaW5zLmZpbmQoKHQpID0+IHQuX2lkID09PSB0aGlzLnRyYWluQ291cGxlZEZyb250SWQpO1xuICAgICAgICAgaWYgKGZyb250Q2FyKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWluQ291cGxlZEZyb250ID0gZnJvbnRDYXI7XG4gICAgICAgICB9XG5cbiAgICAgICAgIFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50cmFpbkNvdXBsZWRCYWNrSWQpIHtcbiAgICAgICAgIGNvbnN0IGJhY2tDYXIgPSBUcmFpbi5hbGxUcmFpbnMuZmluZCgodCkgPT4gdC5faWQgPT09IHRoaXMudHJhaW5Db3VwbGVkQmFja0lkKTtcbiAgICAgICAgIGlmIChiYWNrQ2FyKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWluQ291cGxlZEJhY2sgPSBiYWNrQ2FyO1xuICAgICAgICAgfVxuXG4gICAgICAgICBcbiAgICAgIH1cbiAgIH1cblxuICAgc3RyaW5naWZ5KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIF9jbGFzczogXCJUcmFpblwiLFxuICAgICAgICAgX2lkOiB0aGlzLl9pZCxcbiAgICAgICAgIGNvb3JkaW5hdGVzOiB0aGlzLl9jb29yZGluYXRlcyxcbiAgICAgICAgIGNvbG9yOiB0aGlzLl9jb2xvcixcbiAgICAgICAgIG51bWJlcjogdGhpcy5fbnVtYmVyLFxuICAgICAgICAgdHlwZTogdGhpcy5fdHlwZSxcbiAgICAgICAgIHRyYWluQ291cGxlZEJhY2tJZDogdGhpcy50cmFpbkNvdXBsZWRCYWNrID8gdGhpcy50cmFpbkNvdXBsZWRCYWNrLl9pZCA6IG51bGwsXG4gICAgICAgICB0cmFpbkNvdXBsZWRGcm9udElkOiB0aGlzLnRyYWluQ291cGxlZEZyb250ID8gdGhpcy50cmFpbkNvdXBsZWRGcm9udC5faWQgOiBudWxsLFxuICAgICAgfTtcbiAgIH1cblxuICAgc3RhdGljIHNob3dEZWNvdXBsaW5nUG9pbnRzKHRyYWluKSB7XG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3Rpbmcgb3ZlcmxheVxuICAgICAgb3ZlcmxheV9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblxuICAgICAgLy8gRmluZCB0aGUgZmlyc3QgY2FyIGluIHRoZSB0cmFpblxuICAgICAgbGV0IGZpcnN0Q2FyID0gdHJhaW47XG4gICAgICB3aGlsZSAoZmlyc3RDYXIudHJhaW5Db3VwbGVkRnJvbnQpIHtcbiAgICAgICAgIGZpcnN0Q2FyID0gZmlyc3RDYXIudHJhaW5Db3VwbGVkRnJvbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIGZpcnN0IGNhclxuICAgICAgbGV0IGN1cnJlbnRDYXIgPSBmaXJzdENhcjtcbiAgICAgIGxldCBkZWNvdXBsaW5nUG9pbnRzRm91bmQgPSAwO1xuXG4gICAgICAvLyBBZGQgZGVjb3VwbGluZyBwb2ludHMgYmV0d2VlbiBlYWNoIGNhclxuICAgICAgd2hpbGUgKGN1cnJlbnRDYXIgJiYgY3VycmVudENhci50cmFpbkNvdXBsZWRCYWNrKSB7XG4gICAgICAgICBjb25zdCBuZXh0Q2FyID0gY3VycmVudENhci50cmFpbkNvdXBsZWRCYWNrO1xuXG4gICAgICAgICAvLyBHZXQgcG9zaXRpb25zIG9mIHRoZSB0d28gY2Fyc1xuICAgICAgICAgY29uc3QgY3VycmVudFBvcyA9IGN1cnJlbnRDYXIudHJhY2suZ2V0UG9pbnRGcm9tS20oY3VycmVudENhci5wb3MpO1xuICAgICAgICAgY29uc3QgbmV4dFBvcyA9IG5leHRDYXIudHJhY2suZ2V0UG9pbnRGcm9tS20obmV4dENhci5wb3MpO1xuXG4gICAgICAgICAvLyBDYWxjdWxhdGUgbWlkcG9pbnQgYmV0d2VlbiBjYXJzIGZvciBkZWNvdXBsaW5nIHBvaW50XG4gICAgICAgICBjb25zdCBtaWRYID0gKGN1cnJlbnRQb3MueCArIG5leHRQb3MueCkgLyAyO1xuICAgICAgICAgY29uc3QgbWlkWSA9IChjdXJyZW50UG9zLnkgKyBuZXh0UG9zLnkpIC8gMjtcblxuICAgICAgICAgLy8gQ3JlYXRlIGEgZGVjb3VwbGluZyBwb2ludCAoY2lyY2xlKVxuICAgICAgICAgY29uc3QgZGVjb3VwbGluZ1BvaW50ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICAgICBkZWNvdXBsaW5nUG9pbnQuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDYpO1xuICAgICAgICAgZGVjb3VwbGluZ1BvaW50LnggPSBtaWRYO1xuICAgICAgICAgZGVjb3VwbGluZ1BvaW50LnkgPSBtaWRZO1xuICAgICAgICAgLy8gU3RvcmUgdGhlIGNhcnMgdG8gZGVjb3VwbGUgaW4gdGhlIHNoYXBlJ3MgZGF0YVxuICAgICAgICAgZGVjb3VwbGluZ1BvaW50LmRhdGEgPSB7XG4gICAgICAgICAgICBjYXJUb0RlQ291cGxlRnJvbTogY3VycmVudENhcixcbiAgICAgICAgICAgIGNhclRvRGVDb3VwbGU6IG5leHRDYXIsXG4gICAgICAgICB9O1xuICAgICAgICAgZGVjb3VwbGluZ1BvaW50Lm5hbWUgPSBcImRlY291cGxpbmdQb2ludFwiO1xuXG4gICAgICAgICAvLyBBZGQgdG8gb3ZlcmxheSBjb250YWluZXJcbiAgICAgICAgIG92ZXJsYXlfY29udGFpbmVyLmFkZENoaWxkKGRlY291cGxpbmdQb2ludCk7XG4gICAgICAgICBkZWNvdXBsaW5nUG9pbnRzRm91bmQrKztcblxuICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBjYXJcbiAgICAgICAgIGN1cnJlbnRDYXIgPSBuZXh0Q2FyO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBkZWNvdXBsaW5nIHBvaW50cyBmb3VuZCwgc2hvdyBhIG1lc3NhZ2VcbiAgICAgIGlmIChkZWNvdXBsaW5nUG9pbnRzRm91bmQgPT09IDApIHtcbiAgICAgICAgIC8vIFNob3cgYSBtZXNzYWdlXG4gICAgICAgICB1aS5zaG93SW5mb1RvYXN0KFwiS2VpbmUgV2FnZW4gaW4gZGVyIE7DpGhlIHp1bSBlbnRrdXBwZWxuIGdlZnVuZGVuLCBkaWVzZXIgWnVnIGhhdCBudXIgZWluZW4gV2FnZW5cIik7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgIH1cblxuICAgc3RhdGljIGhhbmRsZURlY291cGxpbmdDbGljayhkYXRhKSB7XG4gICAgICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcihcIk5vIHRyYWluIHByb3ZpZGVkXCIpO1xuICAgICAgLy8gRGVjb3VwbGUgYXQgdGhpcyBwb2ludFxuICAgICAgZGF0YS5jYXJUb0RlQ291cGxlRnJvbS51bmNvdXBsZSgpO1xuXG4gICAgICAvLyBFeGl0IGRlY291cGxpbmcgbW9kZVxuICAgICAgVHJhaW4uZXhpdERlY291cGxpbmdNb2RlKCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBkaXNwbGF5XG4gICAgICByZW5kZXJlci5yZW5kZXJBbGxUcmFpbnMoKTtcbiAgICAgIHN0YWdlLnVwZGF0ZSgpO1xuICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICB9XG5cbiAgIHN0YXRpYyBleGl0RGVjb3VwbGluZ01vZGUoKSB7XG4gICAgICAvLyBSZW1vdmUgZGVjb3VwbGluZyBwb2ludHNcbiAgICAgIHdpbmRvdy5vdmVybGF5X2NvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICAvLyBSZXNldCBjdXN0b20gYWN0aW9uIG1vZGVcbiAgICAgIHdpbmRvdy5jdXN0b21fbW91c2VfbW9kZSA9IHdpbmRvdy5DVVNUT01fTU9VU0VfQUNUSU9OLk5PTkU7XG5cbiAgICAgIC8vIEhpZGUgbWVzc2FnZSB3aXRoIGEgc21hbGwgZGVsYXkgdG8gZW5zdXJlIGl0J3MgZnVsbHkgc2hvd24gZmlyc3RcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgJChcIiNjb3VwbGluZ01lc3NhZ2VcIikuaGlkZSgpO1xuICAgICAgfSwgNTApO1xuXG4gICAgICAvLyBEZWFjdGl2YXRlIGFueSBhY3RpdmUgYnV0dG9uc1xuICAgICAgJChcIiNidG5VbmNvdXBsZVRyYWluXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xuXG4gICAgICB3aW5kb3cuc3RhZ2UudXBkYXRlKCk7XG4gICB9XG5cbiAgIHN0YXRpYyBzaG93Q291cGxpbmdQb2ludHModHJhaW4pIHtcbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBvdmVybGF5XG4gICAgICB3aW5kb3cub3ZlcmxheV9jb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblxuICAgICAgLy8gR2V0IHRoZSBoZWFkIGFuZCB0YWlsIG9mIHRoZSB0cmFpblxuICAgICAgbGV0IGZpcnN0Q2FyID0gdHJhaW47XG4gICAgICB3aGlsZSAoZmlyc3RDYXIudHJhaW5Db3VwbGVkRnJvbnQpIHtcbiAgICAgICAgIGZpcnN0Q2FyID0gZmlyc3RDYXIudHJhaW5Db3VwbGVkRnJvbnQ7XG4gICAgICB9XG5cbiAgICAgIGxldCBsYXN0Q2FyID0gdHJhaW47XG4gICAgICB3aGlsZSAobGFzdENhci50cmFpbkNvdXBsZWRCYWNrKSB7XG4gICAgICAgICBsYXN0Q2FyID0gbGFzdENhci50cmFpbkNvdXBsZWRCYWNrO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgcG9zaXRpb25zIG9mIHRoZSB0cmFpbiBlbmRzXG4gICAgICBjb25zdCBmaXJzdENhclBvcyA9IGZpcnN0Q2FyLnBvcztcbiAgICAgIGNvbnN0IGxhc3RDYXJQb3MgPSBsYXN0Q2FyLnBvcztcbiAgICAgIGxldCBkaXN0YW5jZSA9IDA7XG4gICAgICBsZXQgY291cGxpbmdQb2ludHNGb3VuZCA9IDA7XG5cbiAgICAgIC8vIENoZWNrIGFsbCBvdGhlciB0cmFpbnMgZm9yIHBvc3NpYmxlIGNvdXBsaW5nIHBvaW50c1xuICAgICAgVHJhaW4uYWxsVHJhaW5zLmZvckVhY2goKG90aGVyQ2FyKSA9PiB7XG4gICAgICAgICAvLyBTa2lwIGNhcnMgaW4gdGhlIHNhbWUgdHJhaW5cbiAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG90aGVyQ2FyID09PSBmaXJzdENhciB8fFxuICAgICAgICAgICAgb3RoZXJDYXIgPT09IGxhc3RDYXIgfHxcbiAgICAgICAgICAgIChvdGhlckNhci50cmFpbkNvdXBsZWRGcm9udCAhPSBudWxsICYmIG90aGVyQ2FyLnRyYWluQ291cGxlZEJhY2sgIT0gbnVsbCkgfHxcbiAgICAgICAgICAgIG90aGVyQ2FyLnRyYWNrICE9IHRyYWluLnRyYWNrXG4gICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgIH1cblxuICAgICAgICAgLy8gR2V0IHBvc2l0aW9ucyBvZiB0aGUgb3RoZXIgdHJhaW4gZW5kc1xuICAgICAgICAgY29uc3Qgb3RoZXJDYXJQb3MgPSBvdGhlckNhci5wb3M7XG5cbiAgICAgICAgIC8vIENoZWNrIGRpc3RhbmNlIGJldHdlZW4gdHJhaW4gZW5kcyAoZnJvbnQgdG8gZnJvbnQpXG4gICAgICAgICBjb25zdCBtYXhDb3VwbGluZ0Rpc3RhbmNlID0gODA7IC8vIE1heGltdW0gZGlzdGFuY2UgZm9yIGNvdXBsaW5nXG5cbiAgICAgICAgIC8vIENoZWNrIGZyb250IG9mIG91ciB0cmFpbiB0byBiYWNrIG9mIG90aGVyIHRyYWluXG4gICAgICAgICBpZiAob3RoZXJDYXIudHJhaW5Db3VwbGVkQmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IGZpcnN0Q2FyUG9zIC0gb3RoZXJDYXJQb3M7XG4gICAgICAgICAgICBpZiAoTnVtYmVyVXRpbHMuYmV0d2VlbihkaXN0YW5jZSwgMCwgbWF4Q291cGxpbmdEaXN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgIGFkZENvdXBsaW5nUG9pbnQob3RoZXJDYXIsIGZpcnN0Q2FyKTtcbiAgICAgICAgICAgICAgIGNvdXBsaW5nUG9pbnRzRm91bmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgLy8gQ2hlY2sgYmFjayBvZiBvdXIgdHJhaW4gdG8gZnJvbnQgb2Ygb3RoZXIgdHJhaW5cbiAgICAgICAgIGlmIChvdGhlckNhci50cmFpbkNvdXBsZWRGcm9udCA9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IG90aGVyQ2FyUG9zIC0gbGFzdENhclBvcztcbiAgICAgICAgICAgIGlmIChOdW1iZXJVdGlscy5iZXR3ZWVuKGRpc3RhbmNlLCAwLCBtYXhDb3VwbGluZ0Rpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgYWRkQ291cGxpbmdQb2ludChsYXN0Q2FyLCBvdGhlckNhcik7XG4gICAgICAgICAgICAgICBjb3VwbGluZ1BvaW50c0ZvdW5kKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgbm8gY291cGxpbmcgcG9pbnRzIGZvdW5kLCBzaG93IGEgbWVzc2FnZVxuICAgICAgaWYgKGNvdXBsaW5nUG9pbnRzRm91bmQgPT09IDApIHtcbiAgICAgICAgIC8vIFNob3cgYSBtZXNzYWdlXG4gICAgICAgICB1aS5zaG93SW5mb1RvYXN0KFwiS2VpbmUgV2FnZW4gaW4gZGVyIE7DpGhlIHp1bSBrdXBwZWxuIGdlZnVuZGVuXCIpO1xuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHdpbmRvdy5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWRkIGEgY291cGxpbmcgcG9pbnRcbiAgICAgIGZ1bmN0aW9uIGFkZENvdXBsaW5nUG9pbnQoY2FyMSwgY2FyMikge1xuICAgICAgICAgLy8gQ2FsY3VsYXRlIG1pZHBvaW50IGJldHdlZW4gY2FycyBmb3IgY291cGxpbmcgcG9pbnRcbiAgICAgICAgIGNvbnN0IGNhcjFQb3MgPSBjYXIxLnRyYWNrLmdldFBvaW50RnJvbUttKGNhcjEucG9zKTtcbiAgICAgICAgIGNvbnN0IGNhcjJQb3MgPSBjYXIyLnRyYWNrLmdldFBvaW50RnJvbUttKGNhcjIucG9zKTtcbiAgICAgICAgIGNvbnN0IG1pZFggPSAoY2FyMVBvcy54ICsgY2FyMlBvcy54KSAvIDI7XG4gICAgICAgICBjb25zdCBtaWRZID0gKGNhcjFQb3MueSArIGNhcjJQb3MueSkgLyAyO1xuXG4gICAgICAgICAvLyBDcmVhdGUgYSBjb3VwbGluZyBwb2ludCAoY2lyY2xlKVxuICAgICAgICAgY29uc3QgY291cGxpbmdQb2ludCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICAgY291cGxpbmdQb2ludC5ncmFwaGljcy5iZWdpbkZpbGwoXCIjMDBmZjAwXCIpLmRyYXdDaXJjbGUoMCwgMCwgNik7XG4gICAgICAgICBjb3VwbGluZ1BvaW50LnggPSBtaWRYO1xuICAgICAgICAgY291cGxpbmdQb2ludC55ID0gbWlkWTtcblxuICAgICAgICAgLy8gU3RvcmUgdGhlIGNhcnMgdG8gY291cGxlIGluIHRoZSBzaGFwZSdzIGRhdGFcbiAgICAgICAgIGNvdXBsaW5nUG9pbnQuZGF0YSA9IHtcbiAgICAgICAgICAgIGNhcjE6IGNhcjEsXG4gICAgICAgICAgICBjYXIyOiBjYXIyLFxuICAgICAgICAgfTtcbiAgICAgICAgIGNvdXBsaW5nUG9pbnQubmFtZSA9IFwiY291cGxpbmdQb2ludFwiO1xuXG4gICAgICAgICAvLyBBZGQgdG8gb3ZlcmxheSBjb250YWluZXJcbiAgICAgICAgIHdpbmRvdy5vdmVybGF5X2NvbnRhaW5lci5hZGRDaGlsZChjb3VwbGluZ1BvaW50KTtcbiAgICAgIH1cbiAgIH1cblxuICAgc3RhdGljIGhhbmRsZUNvdXBsaW5nQ2xpY2soZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB0cmFpbiBkYXRhIHByb3ZpZGVkXCIpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY2FycyB0byBjb3VwbGVcbiAgICAgIGRhdGEuY2FyMS5jb3VwbGVCYWNrKGRhdGEuY2FyMik7XG5cbiAgICAgIC8vIEV4aXQgY291cGxpbmcgbW9kZVxuICAgICAgVHJhaW4uZXhpdENvdXBsaW5nTW9kZSgpO1xuXG4gICAgICAvLyBVcGRhdGUgZGlzcGxheVxuICAgICAgcmVuZGVyZXIucmVuZGVyQWxsVHJhaW5zKCk7XG4gICAgICBzdGFnZS51cGRhdGUoKTtcbiAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgfVxuXG4gICBzdGF0aWMgZXhpdENvdXBsaW5nTW9kZSgpIHtcbiAgICAgIC8vIFJlbW92ZSBjb3VwbGluZyBwb2ludHNcbiAgICAgIHdpbmRvdy5vdmVybGF5X2NvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICAvLyBSZXNldCBjdXN0b20gYWN0aW9uIG1vZGVcbiAgICAgIHdpbmRvdy5jdXN0b21fbW91c2VfbW9kZSA9IHdpbmRvdy5DVVNUT01fTU9VU0VfQUNUSU9OLk5PTkU7XG5cbiAgICAgICQoXCIjY291cGxpbmdNZXNzYWdlXCIpLmhpZGUoKTtcblxuICAgICAgLy8gRGVhY3RpdmF0ZSBhbnkgYWN0aXZlIGJ1dHRvbnNcbiAgICAgICQoXCIjYnRuQ291cGxlVHJhaW5cIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG5cbiAgICAgIHdpbmRvdy5zdGFnZS51cGRhdGUoKTtcbiAgIH1cblxuICAgLy8gQWRkIG5ldyBtZXRob2RzIGZvciBhdXRvbWF0aWMgdHJhaW4gbW92ZW1lbnRcblxuICAgc3RhdGljIHN0YXJ0VHJhaW4odHJhaW4pIHtcbiAgICAgIC8vIEFkZCB0cmFpbiB0byB0aGUgc2V0IG9mIG1vdmluZyB0cmFpbnNcbiAgICAgIFRyYWluLm1vdmluZ1RyYWlucy5hZGQodHJhaW4pO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgYnV0dG9uIHN0YXRlXG4gICAgICAkKFwiI2J0blN0YXJ0U3RvcFRyYWluXCIpXG4gICAgICAgICAucmVtb3ZlQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKVxuICAgICAgICAgLmFkZENsYXNzKFwiYnRuLWRhbmdlclwiKVxuICAgICAgICAgLmh0bWwoJzxpIGNsYXNzPVwiYmkgYmktc3RvcC1maWxsXCI+PC9pPiBTdG9wJyk7XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IG1vdmVtZW50IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHJ1bm5pbmdcbiAgICAgIGlmICghVHJhaW4ubW92ZW1lbnRUaW1lcikge1xuICAgICAgICAgVHJhaW4ubW92ZW1lbnRUaW1lciA9IHNldEludGVydmFsKFRyYWluLnVwZGF0ZU1vdmluZ1RyYWlucywgVHJhaW4uTU9WRU1FTlRfSU5URVJWQUwpO1xuICAgICAgfVxuICAgfVxuICAgXG4gICBzdGF0aWMgc3RvcFRyYWluKHRyYWluKSB7XG4gICAgICAvLyBSZW1vdmUgdHJhaW4gZnJvbSB0aGUgc2V0IG9mIG1vdmluZyB0cmFpbnNcbiAgICAgIFRyYWluLm1vdmluZ1RyYWlucy5kZWxldGUodHJhaW4pO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgYnV0dG9uIHN0YXRlXG4gICAgICAkKFwiI2J0blN0YXJ0U3RvcFRyYWluXCIpXG4gICAgICAgICAucmVtb3ZlQ2xhc3MoXCJidG4tZGFuZ2VyXCIpXG4gICAgICAgICAuYWRkQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKVxuICAgICAgICAgLmh0bWwoJzxpIGNsYXNzPVwiYmkgYmktcGxheS1maWxsXCI+PC9pPiBTdGFydCcpO1xuICAgICAgXG4gICAgICAvLyBJZiBubyB0cmFpbnMgYXJlIG1vdmluZywgc3RvcCB0aGUgdGltZXJcbiAgICAgIGlmIChUcmFpbi5tb3ZpbmdUcmFpbnMuc2l6ZSA9PT0gMCAmJiBUcmFpbi5tb3ZlbWVudFRpbWVyKSB7XG4gICAgICAgICBjbGVhckludGVydmFsKFRyYWluLm1vdmVtZW50VGltZXIpO1xuICAgICAgICAgVHJhaW4ubW92ZW1lbnRUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICB9XG4gICBcbiAgIHN0YXRpYyBzdG9wQWxsVHJhaW5zKCkge1xuICAgICAgLy8gU3RvcCBhbGwgbW92aW5nIHRyYWluc1xuICAgICAgZm9yIChjb25zdCB0cmFpbiBvZiBUcmFpbi5tb3ZpbmdUcmFpbnMpIHtcbiAgICAgICAgIFRyYWluLnN0b3BUcmFpbih0cmFpbik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHRoZSBzZXQgb2YgbW92aW5nIHRyYWluc1xuICAgICAgVHJhaW4ubW92aW5nVHJhaW5zLmNsZWFyKCk7XG4gICAgICBcbiAgICAgIC8vIFN0b3AgdGhlIHRpbWVyXG4gICAgICBpZiAoVHJhaW4ubW92ZW1lbnRUaW1lcikge1xuICAgICAgICAgY2xlYXJJbnRlcnZhbChUcmFpbi5tb3ZlbWVudFRpbWVyKTtcbiAgICAgICAgIFRyYWluLm1vdmVtZW50VGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgfVxuICAgXG4gICBzdGF0aWMgdXBkYXRlTW92aW5nVHJhaW5zKCkge1xuICAgICAgbGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICBcbiAgICAgIC8vIE1vdmUgZWFjaCB0cmFpbiBpbiB0aGUgc2V0IG9mIG1vdmluZyB0cmFpbnNcbiAgICAgIGZvciAoY29uc3QgdHJhaW4gb2YgVHJhaW4ubW92aW5nVHJhaW5zKSB7XG4gICAgICAgICAvLyBDYWxjdWxhdGUgbW92ZW1lbnQgYW1vdW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgc3BlZWRcbiAgICAgICAgIGNvbnN0IG1vdmVtZW50QW1vdW50ID0gdHJhaW4ubW92ZW1lbnREaXJlY3Rpb24gKiBUcmFpbi5NT1ZFTUVOVF9TUEVFRDtcbiAgICAgICAgIFxuICAgICAgICAgLy8gQ2hlY2sgaWYgbW92ZW1lbnQgaXMgcG9zc2libGVcbiAgICAgICAgIGNvbnN0IGZpcnN0Q2FyID0gdHJhaW4uZ2V0TG9jb21vdGl2ZSgpO1xuICAgICAgICAgY29uc3QgbGFzdENhciA9IFRyYWluLmdldExhc3RDYXIoZmlyc3RDYXIpO1xuICAgICAgICAgXG4gICAgICAgICBpZiAoVHJhaW4ubW92ZW1lbnRQb3NzaWJsZShmaXJzdENhciwgbW92ZW1lbnRBbW91bnQpICYmIFxuICAgICAgICAgICAgIFRyYWluLm1vdmVtZW50UG9zc2libGUobGFzdENhciwgbW92ZW1lbnRBbW91bnQpKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSB0cmFpblxuICAgICAgICAgICAgVHJhaW4ubW92ZVRyYWluKGZpcnN0Q2FyLCBtb3ZlbWVudEFtb3VudCk7XG4gICAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3RvcCB0aGUgdHJhaW4gaWYgbW92ZW1lbnQgaXMgbm90IHBvc3NpYmxlXG4gICAgICAgICAgICBUcmFpbi5zdG9wVHJhaW4odHJhaW4pO1xuICAgICAgICAgICAgdWkuc2hvd0luZm9Ub2FzdChcIlp1ZyBrYW5uIG5pY2h0IHdlaXRlciBmYWhyZW5cIik7XG4gICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGlzcGxheSBpZiBhbnkgdHJhaW5zIG1vdmVkXG4gICAgICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICAgICAgIHJlbmRlcmVyLnJlbmRlckFsbFRyYWlucygpO1xuICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG4gICAgICB9XG4gICB9XG4gICBcbiAgIHN0YXRpYyBnZXRMYXN0Q2FyKHRyYWluKSB7XG4gICAgICBsZXQgbGFzdENhciA9IHRyYWluO1xuICAgICAgd2hpbGUgKGxhc3RDYXIudHJhaW5Db3VwbGVkQmFjaykge1xuICAgICAgICAgbGFzdENhciA9IGxhc3RDYXIudHJhaW5Db3VwbGVkQmFjaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0Q2FyO1xuICAgfVxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/train.js\n\n}");

/***/ }),

/***/ "./www/code/ui.js":
/*!************************!*\
  !*** ./www/code/ui.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ui: () => (/* binding */ ui)\n/* harmony export */ });\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n\n\n\n\nconst ui = {\n    create_toggleButton: function (text) {\n       return $(\"<button>\", {\n          type: \"button\",\n          id: \"btn_\" + text.replace(\" \", \"_\"),\n          class: \"btn btn-primary btn-sm\",\n       }).html(text);\n    },\n    \n    create_buttonGroup: function (items) {\n       return $(\"<div>\", { class: \"btn-group\", role: \"group\" }).append(items);\n    },\n\n    create_buttonToolbar: function (items) {\n        return ui.div(\"btn-toolbar\", items).attr(\"role\", \"toolbar\");\n     },\n    \n    div: function (c, i) {\n       return $(\"<div>\", { class: c }).append(i);\n    },\n \n    showModalDialog: function (content, ok_function) {\n       // Create modal div\n       let modal_div = $(\"<div/>\", {\n          id: \"myModal\",\n          class: \"modal fade\",\n          role: \"dialog\",\n       }).append(\n          ui.div(\"modal-dialog  modal-xl modal-dialog-centered\").append(\n             ui.div(\"modal-content\").append([\n                ui.div(\"modal-header\").append([\n                   $(\"<h4/>\", {\n                      class: \"modal-title\",\n                      text: \"Als Bild speichern\",\n                   }),\n                   $(\"<button/>\", {\n                      type: \"button\",\n                      class: \"btn-close\",\n                      \"data-bs-dismiss\": \"modal\",\n                   }),\n                ]),\n                ui.div(\"modal-body\").append(content),\n                ui.div(\"modal-footer\").append(\n                   $(\"<button/>\", {\n                      type: \"button\",\n                      class: \"btn btn-default\",\n                      \"data-dismiss\": \"modal\",\n                      text: \"Herunterladen\",\n                      click: ok_function,\n                   })\n                ),\n             ])\n          )\n       );\n       modal_div.appendTo(\"body\");\n \n       let modal = new bootstrap.Modal(modal_div[0]);\n       modal.show();\n       return modal;\n    },// Function to create a toast element\n    createToast: function (title, txt) {   \n       return ui\n          .div(\"toast\")\n          .attr({ role: \"alert\", \"aria-live\": \"assertive\", \"aria-atomic\": \"true\" })\n          .append([\n             $(\"<div>\")\n                .addClass(\"toast-header\")\n                .append([\n                   $(\"<strong>\").addClass(\"me-auto\").text(title),\n                   $(\"<button>\").attr({ type: \"button\", \"data-bs-dismiss\": \"toast\", \"aria-label\": \"Close\" }).addClass(\"btn-close\"),\n                ]),\n             $(\"<div>\")\n                .addClass(\"toast-body\")\n                .append([$(\"<p>\", { text: txt })]),\n          ]);\n    },\n    \n    getToastContainer: function () {\n       let container = $(\"#toast-container\");\n       if (container.length === 0) {\n          container = ui.div(\"toast-container\").attr(\"id\", \"toast-container\").css({ position: \"fixed\", bottom: \"0\", right: \"0\" });\n          $(\"body\").append(container);\n       }\n       return container;\n    },\n    \n    // Function to show the toast\n    showErrorToast: function (error) {\n       console.error(error);\n       const toast = ui.createToast(\"Ups, Da gabs einen Fehler\", error.message);\n       ui.getToastContainer().prepend(ui.div(\"p-3\").append(toast));\n       $(toast).toast({ autohide: true, delay: 10000 }).toast(\"show\");\n       $(toast).on(\"hidden.bs.toast\", function () {\n          $(this).parent().remove();\n       });\n    },\n    \n    showInfoToast: function (txt) {\n       console.info(txt);\n       const toast = ui.createToast(\"Information:\", txt);\n       ui.getToastContainer().prepend(ui.div(\"p-3\").append(toast));\n       $(toast).toast({ autohide: true, delay: 10000 }).toast(\"show\");\n       $(toast).on(\"hidden.bs.toast\", function () {\n          $(this).parent().remove();\n       });\n    },\n    create_DropDownItem(text, value) {\n        return $(\"<a>\", {\n           class: \"dropdown-item\",\n           text: text,\n           href: \"#\",\n           value: value ?? text,\n        });\n     },\n  \n     createAccordionItem(title, parent, items, open = false) {\n        let id = (0,_tools_js__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();\n        return ui.div(\"accordion-item\", [\n           $(\"<h2>\", { class: \"accordion-header\" }).append(\n              $(\"<button>\", { class: \"accordion-button  user-select-none\", type: \"button\" })\n                 .attr(\"data-bs-toggle\", \"collapse\")\n                 .attr(\"data-bs-target\", \"#\" + id)\n                 .text(title)\n                 .toggleClass(\"collapsed\", !open)\n           ),\n           ui\n              .div(\"accordion-collapse collapse\", ui.div(\"accordion-body\", items))\n              .attr(\"id\", id)\n              .attr(\"data-bs-parent\", parent)\n              .toggleClass(\"show\", open),\n        ]);\n     },\n  \n     create_DropDown(items, text, onChange) {\n        return ui\n           .div(\"dropdown d-grid\", [\n              $(\"<button>\", {\n                 class: \"btn btn-primary dropdown-toggle btn-sm\",\n                 type: \"button\",\n                 text: text,\n                 id: \"btn_\" + text.replace(\" \", \"_\"),\n              }).attr(\"data-bs-toggle\", \"dropdown\"),\n              ui.div(\n                 \"dropdown-menu\",\n                 items.map((item) => ui.create_DropDownItem(...item.split(\"|\")))\n              ),\n           ])\n           .on(\"hide.bs.dropdown\", (e) => {\n              if (e.clickEvent?.target && e.clickEvent?.target.nodeName == \"A\") {\n                 const value = $(e.clickEvent.target).attr(\"value\");\n                 $(e.currentTarget).attr(\"value\", value);\n                 if (onChange) onChange(value);\n              }\n           })\n           .on(\"show.bs.dropdown\", (e) => {\n              const targetValue = $(e.currentTarget).attr(\"value\");\n              if (!targetValue) return;\n              $(\".dropdown-item\", e.currentTarget)\n                 .removeClass(\"active\")\n                 .each(function () {\n                    if ($(this).attr(\"value\") === targetValue) {\n                       $(this).addClass(\"active\");\n                    }\n                 });\n           });\n     },\n  \n     createSwitchStructure(mainLabel, subLabels, onchange) {\n        let [text, value, enabled] = mainLabel;\n        if (!enabled && subLabels.length == 0) return null;\n        let $mainDiv;\n        $mainDiv = ui.div(\"\", [\n           enabled == null || enabled\n              ? ui.div(\"form-check form-switch\", [\n                   $(\"<input/>\", {\n                      class: \"form-check-input\",\n                      type: \"checkbox\",\n                      role: \"switch\",\n                      id: \"switch_\" + text,\n                   })\n                      .on(\"change\", function () {\n                         const isChecked = $(this).is(\":checked\");\n                         /* $(\"input\", $mainDiv.children()[1]).prop(\"disabled\", !isChecked); */\n                         if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                      })\n                      .attr(\"value\", value ?? text)\n                      .attr(\"data-master_switch\", \"\"),\n  \n                   $(\"<label/>\", {\n                      class: \"form-check-label\",\n                      for: \"switch_\" + text,\n                      text: text,\n                   }),\n                ])\n              : $(\"<label/>\", {\n                   text: text,\n                }),\n  \n           ui.div(\n              \"ps-3\",\n              subLabels\n                 .filter((x) => x[2] == null || x[2] == true)\n                 .map(function (label) {\n                    [text, value, enabled] = label;\n                    return ui.div(\"form-check form-switch\", [\n                       $(\"<input/>\", {\n                          class: \"form-check-input\",\n                          type: \"checkbox\",\n                          role: \"switch\",\n                          id: \"switch_\" + text,\n                          checked: true, // Default to checked as per your example\n                       })\n                          .on(\"change\", function () {\n                             const isChecked = $(this).is(\":checked\");\n                             if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                          })\n                          .attr(\"value\", value ?? text),\n                       $(\"<label/>\", {\n                          class: \"form-check-label\",\n                          for: \"switch_\" + text,\n                          text: text,\n                       }),\n                    ]);\n                 })\n           ),\n        ]);\n        return $mainDiv;\n     },\n     createOptionGroup(header, options, inputType = \"radio\", onchange) {\n        return ui.div(\"\", [\n           $(\"<label>\").text(header),\n           ui.div(\n              \"ps-3\",\n              options.map(function (option) {\n                 let [text, value, enabled] = option;\n                 let id = \"input_\" + text;\n                 // Create the div for each form-check-inline\n                 return ui.div(\"form-check form-check-inline\", [\n                    $(\"<input>\")\n                       .addClass(\"form-check-input\")\n                       .attr(\"id\", id)\n                       .attr(\"name\", \"OptionGroup_\" + header)\n                       .attr(\"type\", inputType)\n                       .attr(\"value\", value ?? text)\n                       .attr(\"disabled\", enabled != null && !enabled)\n                       .on(\"change\", function () {\n                          const isChecked = $(this).is(\":checked\");\n                          if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                       }),\n                    $(\"<label>\").addClass(\"form-check-label\").attr(\"for\", id).text(text),\n                 ]);\n              })\n           ),\n        ]);\n     },\n };\n\n // Backward compatibility: Still expose utilities on window during transition\n// TODO: Remove this once all files are converted to modules\nif (typeof window !== 'undefined') {\n    window.ui = ui;\n }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d3d3L2NvZGUvdWkuanM/OTE3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgdXVpZHY0IH0gZnJvbSAnLi90b29scy5qcyc7XG5cbmV4cG9ydCBjb25zdCB1aSA9IHtcbiAgICBjcmVhdGVfdG9nZ2xlQnV0dG9uOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgIHJldHVybiAkKFwiPGJ1dHRvbj5cIiwge1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgaWQ6IFwiYnRuX1wiICsgdGV4dC5yZXBsYWNlKFwiIFwiLCBcIl9cIiksXG4gICAgICAgICAgY2xhc3M6IFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1zbVwiLFxuICAgICAgIH0pLmh0bWwodGV4dCk7XG4gICAgfSxcbiAgICBcbiAgICBjcmVhdGVfYnV0dG9uR3JvdXA6IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgIHJldHVybiAkKFwiPGRpdj5cIiwgeyBjbGFzczogXCJidG4tZ3JvdXBcIiwgcm9sZTogXCJncm91cFwiIH0pLmFwcGVuZChpdGVtcyk7XG4gICAgfSxcblxuICAgIGNyZWF0ZV9idXR0b25Ub29sYmFyOiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIHVpLmRpdihcImJ0bi10b29sYmFyXCIsIGl0ZW1zKS5hdHRyKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgIH0sXG4gICAgXG4gICAgZGl2OiBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgIHJldHVybiAkKFwiPGRpdj5cIiwgeyBjbGFzczogYyB9KS5hcHBlbmQoaSk7XG4gICAgfSxcbiBcbiAgICBzaG93TW9kYWxEaWFsb2c6IGZ1bmN0aW9uIChjb250ZW50LCBva19mdW5jdGlvbikge1xuICAgICAgIC8vIENyZWF0ZSBtb2RhbCBkaXZcbiAgICAgICBsZXQgbW9kYWxfZGl2ID0gJChcIjxkaXYvPlwiLCB7XG4gICAgICAgICAgaWQ6IFwibXlNb2RhbFwiLFxuICAgICAgICAgIGNsYXNzOiBcIm1vZGFsIGZhZGVcIixcbiAgICAgICAgICByb2xlOiBcImRpYWxvZ1wiLFxuICAgICAgIH0pLmFwcGVuZChcbiAgICAgICAgICB1aS5kaXYoXCJtb2RhbC1kaWFsb2cgIG1vZGFsLXhsIG1vZGFsLWRpYWxvZy1jZW50ZXJlZFwiKS5hcHBlbmQoXG4gICAgICAgICAgICAgdWkuZGl2KFwibW9kYWwtY29udGVudFwiKS5hcHBlbmQoW1xuICAgICAgICAgICAgICAgIHVpLmRpdihcIm1vZGFsLWhlYWRlclwiKS5hcHBlbmQoW1xuICAgICAgICAgICAgICAgICAgICQoXCI8aDQvPlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwibW9kYWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIkFscyBCaWxkIHNwZWljaGVyblwiLFxuICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICQoXCI8YnV0dG9uLz5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiYnRuLWNsb3NlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJkYXRhLWJzLWRpc21pc3NcIjogXCJtb2RhbFwiLFxuICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIHVpLmRpdihcIm1vZGFsLWJvZHlcIikuYXBwZW5kKGNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIHVpLmRpdihcIm1vZGFsLWZvb3RlclwiKS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgJChcIjxidXR0b24vPlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJidG4gYnRuLWRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImRhdGEtZGlzbWlzc1wiOiBcIm1vZGFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJIZXJ1bnRlcmxhZGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IG9rX2Z1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICBdKVxuICAgICAgICAgIClcbiAgICAgICApO1xuICAgICAgIG1vZGFsX2Rpdi5hcHBlbmRUbyhcImJvZHlcIik7XG4gXG4gICAgICAgbGV0IG1vZGFsID0gbmV3IGJvb3RzdHJhcC5Nb2RhbChtb2RhbF9kaXZbMF0pO1xuICAgICAgIG1vZGFsLnNob3coKTtcbiAgICAgICByZXR1cm4gbW9kYWw7XG4gICAgfSwvLyBGdW5jdGlvbiB0byBjcmVhdGUgYSB0b2FzdCBlbGVtZW50XG4gICAgY3JlYXRlVG9hc3Q6IGZ1bmN0aW9uICh0aXRsZSwgdHh0KSB7ICAgXG4gICAgICAgcmV0dXJuIHVpXG4gICAgICAgICAgLmRpdihcInRvYXN0XCIpXG4gICAgICAgICAgLmF0dHIoeyByb2xlOiBcImFsZXJ0XCIsIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIgfSlcbiAgICAgICAgICAuYXBwZW5kKFtcbiAgICAgICAgICAgICAkKFwiPGRpdj5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJ0b2FzdC1oZWFkZXJcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFtcbiAgICAgICAgICAgICAgICAgICAkKFwiPHN0cm9uZz5cIikuYWRkQ2xhc3MoXCJtZS1hdXRvXCIpLnRleHQodGl0bGUpLFxuICAgICAgICAgICAgICAgICAgICQoXCI8YnV0dG9uPlwiKS5hdHRyKHsgdHlwZTogXCJidXR0b25cIiwgXCJkYXRhLWJzLWRpc21pc3NcIjogXCJ0b2FzdFwiLCBcImFyaWEtbGFiZWxcIjogXCJDbG9zZVwiIH0pLmFkZENsYXNzKFwiYnRuLWNsb3NlXCIpLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICQoXCI8ZGl2PlwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInRvYXN0LWJvZHlcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFskKFwiPHA+XCIsIHsgdGV4dDogdHh0IH0pXSksXG4gICAgICAgICAgXSk7XG4gICAgfSxcbiAgICBcbiAgICBnZXRUb2FzdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgIGxldCBjb250YWluZXIgPSAkKFwiI3RvYXN0LWNvbnRhaW5lclwiKTtcbiAgICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRhaW5lciA9IHVpLmRpdihcInRvYXN0LWNvbnRhaW5lclwiKS5hdHRyKFwiaWRcIiwgXCJ0b2FzdC1jb250YWluZXJcIikuY3NzKHsgcG9zaXRpb246IFwiZml4ZWRcIiwgYm90dG9tOiBcIjBcIiwgcmlnaHQ6IFwiMFwiIH0pO1xuICAgICAgICAgICQoXCJib2R5XCIpLmFwcGVuZChjb250YWluZXIpO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG4gICAgXG4gICAgLy8gRnVuY3Rpb24gdG8gc2hvdyB0aGUgdG9hc3RcbiAgICBzaG93RXJyb3JUb2FzdDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgY29uc3QgdG9hc3QgPSB1aS5jcmVhdGVUb2FzdChcIlVwcywgRGEgZ2FicyBlaW5lbiBGZWhsZXJcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgdWkuZ2V0VG9hc3RDb250YWluZXIoKS5wcmVwZW5kKHVpLmRpdihcInAtM1wiKS5hcHBlbmQodG9hc3QpKTtcbiAgICAgICAkKHRvYXN0KS50b2FzdCh7IGF1dG9oaWRlOiB0cnVlLCBkZWxheTogMTAwMDAgfSkudG9hc3QoXCJzaG93XCIpO1xuICAgICAgICQodG9hc3QpLm9uKFwiaGlkZGVuLmJzLnRvYXN0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLnJlbW92ZSgpO1xuICAgICAgIH0pO1xuICAgIH0sXG4gICAgXG4gICAgc2hvd0luZm9Ub2FzdDogZnVuY3Rpb24gKHR4dCkge1xuICAgICAgIGNvbnNvbGUuaW5mbyh0eHQpO1xuICAgICAgIGNvbnN0IHRvYXN0ID0gdWkuY3JlYXRlVG9hc3QoXCJJbmZvcm1hdGlvbjpcIiwgdHh0KTtcbiAgICAgICB1aS5nZXRUb2FzdENvbnRhaW5lcigpLnByZXBlbmQodWkuZGl2KFwicC0zXCIpLmFwcGVuZCh0b2FzdCkpO1xuICAgICAgICQodG9hc3QpLnRvYXN0KHsgYXV0b2hpZGU6IHRydWUsIGRlbGF5OiAxMDAwMCB9KS50b2FzdChcInNob3dcIik7XG4gICAgICAgJCh0b2FzdCkub24oXCJoaWRkZW4uYnMudG9hc3RcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQodGhpcykucGFyZW50KCkucmVtb3ZlKCk7XG4gICAgICAgfSk7XG4gICAgfSxcbiAgICBjcmVhdGVfRHJvcERvd25JdGVtKHRleHQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAkKFwiPGE+XCIsIHtcbiAgICAgICAgICAgY2xhc3M6IFwiZHJvcGRvd24taXRlbVwiLFxuICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICBocmVmOiBcIiNcIixcbiAgICAgICAgICAgdmFsdWU6IHZhbHVlID8/IHRleHQsXG4gICAgICAgIH0pO1xuICAgICB9LFxuICBcbiAgICAgY3JlYXRlQWNjb3JkaW9uSXRlbSh0aXRsZSwgcGFyZW50LCBpdGVtcywgb3BlbiA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpZCA9IHV1aWR2NCgpO1xuICAgICAgICByZXR1cm4gdWkuZGl2KFwiYWNjb3JkaW9uLWl0ZW1cIiwgW1xuICAgICAgICAgICAkKFwiPGgyPlwiLCB7IGNsYXNzOiBcImFjY29yZGlvbi1oZWFkZXJcIiB9KS5hcHBlbmQoXG4gICAgICAgICAgICAgICQoXCI8YnV0dG9uPlwiLCB7IGNsYXNzOiBcImFjY29yZGlvbi1idXR0b24gIHVzZXItc2VsZWN0LW5vbmVcIiwgdHlwZTogXCJidXR0b25cIiB9KVxuICAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtYnMtdG9nZ2xlXCIsIFwiY29sbGFwc2VcIilcbiAgICAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLWJzLXRhcmdldFwiLCBcIiNcIiArIGlkKVxuICAgICAgICAgICAgICAgICAudGV4dCh0aXRsZSlcbiAgICAgICAgICAgICAgICAgLnRvZ2dsZUNsYXNzKFwiY29sbGFwc2VkXCIsICFvcGVuKVxuICAgICAgICAgICApLFxuICAgICAgICAgICB1aVxuICAgICAgICAgICAgICAuZGl2KFwiYWNjb3JkaW9uLWNvbGxhcHNlIGNvbGxhcHNlXCIsIHVpLmRpdihcImFjY29yZGlvbi1ib2R5XCIsIGl0ZW1zKSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBpZClcbiAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLWJzLXBhcmVudFwiLCBwYXJlbnQpXG4gICAgICAgICAgICAgIC50b2dnbGVDbGFzcyhcInNob3dcIiwgb3BlbiksXG4gICAgICAgIF0pO1xuICAgICB9LFxuICBcbiAgICAgY3JlYXRlX0Ryb3BEb3duKGl0ZW1zLCB0ZXh0LCBvbkNoYW5nZSkge1xuICAgICAgICByZXR1cm4gdWlcbiAgICAgICAgICAgLmRpdihcImRyb3Bkb3duIGQtZ3JpZFwiLCBbXG4gICAgICAgICAgICAgICQoXCI8YnV0dG9uPlwiLCB7XG4gICAgICAgICAgICAgICAgIGNsYXNzOiBcImJ0biBidG4tcHJpbWFyeSBkcm9wZG93bi10b2dnbGUgYnRuLXNtXCIsXG4gICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgIGlkOiBcImJ0bl9cIiArIHRleHQucmVwbGFjZShcIiBcIiwgXCJfXCIpLFxuICAgICAgICAgICAgICB9KS5hdHRyKFwiZGF0YS1icy10b2dnbGVcIiwgXCJkcm9wZG93blwiKSxcbiAgICAgICAgICAgICAgdWkuZGl2KFxuICAgICAgICAgICAgICAgICBcImRyb3Bkb3duLW1lbnVcIixcbiAgICAgICAgICAgICAgICAgaXRlbXMubWFwKChpdGVtKSA9PiB1aS5jcmVhdGVfRHJvcERvd25JdGVtKC4uLml0ZW0uc3BsaXQoXCJ8XCIpKSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgXSlcbiAgICAgICAgICAgLm9uKFwiaGlkZS5icy5kcm9wZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZS5jbGlja0V2ZW50Py50YXJnZXQgJiYgZS5jbGlja0V2ZW50Py50YXJnZXQubm9kZU5hbWUgPT0gXCJBXCIpIHtcbiAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAkKGUuY2xpY2tFdmVudC50YXJnZXQpLmF0dHIoXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmF0dHIoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgIGlmIChvbkNoYW5nZSkgb25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pXG4gICAgICAgICAgIC5vbihcInNob3cuYnMuZHJvcGRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSAkKGUuY3VycmVudFRhcmdldCkuYXR0cihcInZhbHVlXCIpO1xuICAgICAgICAgICAgICBpZiAoIXRhcmdldFZhbHVlKSByZXR1cm47XG4gICAgICAgICAgICAgICQoXCIuZHJvcGRvd24taXRlbVwiLCBlLmN1cnJlbnRUYXJnZXQpXG4gICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKVxuICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmF0dHIoXCJ2YWx1ZVwiKSA9PT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSk7XG4gICAgIH0sXG4gIFxuICAgICBjcmVhdGVTd2l0Y2hTdHJ1Y3R1cmUobWFpbkxhYmVsLCBzdWJMYWJlbHMsIG9uY2hhbmdlKSB7XG4gICAgICAgIGxldCBbdGV4dCwgdmFsdWUsIGVuYWJsZWRdID0gbWFpbkxhYmVsO1xuICAgICAgICBpZiAoIWVuYWJsZWQgJiYgc3ViTGFiZWxzLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0ICRtYWluRGl2O1xuICAgICAgICAkbWFpbkRpdiA9IHVpLmRpdihcIlwiLCBbXG4gICAgICAgICAgIGVuYWJsZWQgPT0gbnVsbCB8fCBlbmFibGVkXG4gICAgICAgICAgICAgID8gdWkuZGl2KFwiZm9ybS1jaGVjayBmb3JtLXN3aXRjaFwiLCBbXG4gICAgICAgICAgICAgICAgICAgJChcIjxpbnB1dC8+XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJmb3JtLWNoZWNrLWlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwic3dpdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IFwic3dpdGNoX1wiICsgdGV4dCxcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDaGVja2VkID0gJCh0aGlzKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8qICQoXCJpbnB1dFwiLCAkbWFpbkRpdi5jaGlsZHJlbigpWzFdKS5wcm9wKFwiZGlzYWJsZWRcIiwgIWlzQ2hlY2tlZCk7ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uY2hhbmdlKSBvbmNoYW5nZSgkKHRoaXMpLmF0dHIoXCJ2YWx1ZVwiKSwgaXNDaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidmFsdWVcIiwgdmFsdWUgPz8gdGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtbWFzdGVyX3N3aXRjaFwiLCBcIlwiKSxcbiAgXG4gICAgICAgICAgICAgICAgICAgJChcIjxsYWJlbC8+XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJmb3JtLWNoZWNrLWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZm9yOiBcInN3aXRjaF9cIiArIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICA6ICQoXCI8bGFiZWwvPlwiLCB7XG4gICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgXG4gICAgICAgICAgIHVpLmRpdihcbiAgICAgICAgICAgICAgXCJwcy0zXCIsXG4gICAgICAgICAgICAgIHN1YkxhYmVsc1xuICAgICAgICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiB4WzJdID09IG51bGwgfHwgeFsyXSA9PSB0cnVlKVxuICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBbdGV4dCwgdmFsdWUsIGVuYWJsZWRdID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1aS5kaXYoXCJmb3JtLWNoZWNrIGZvcm0tc3dpdGNoXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgJChcIjxpbnB1dC8+XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiZm9ybS1jaGVjay1pbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwic3dpdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInN3aXRjaF9cIiArIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRydWUsIC8vIERlZmF1bHQgdG8gY2hlY2tlZCBhcyBwZXIgeW91ciBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hlY2tlZCA9ICQodGhpcykuaXMoXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uY2hhbmdlKSBvbmNoYW5nZSgkKHRoaXMpLmF0dHIoXCJ2YWx1ZVwiKSwgaXNDaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCB2YWx1ZSA/PyB0ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgJChcIjxsYWJlbC8+XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiZm9ybS1jaGVjay1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3I6IFwic3dpdGNoX1wiICsgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICApLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuICRtYWluRGl2O1xuICAgICB9LFxuICAgICBjcmVhdGVPcHRpb25Hcm91cChoZWFkZXIsIG9wdGlvbnMsIGlucHV0VHlwZSA9IFwicmFkaW9cIiwgb25jaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHVpLmRpdihcIlwiLCBbXG4gICAgICAgICAgICQoXCI8bGFiZWw+XCIpLnRleHQoaGVhZGVyKSxcbiAgICAgICAgICAgdWkuZGl2KFxuICAgICAgICAgICAgICBcInBzLTNcIixcbiAgICAgICAgICAgICAgb3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICBsZXQgW3RleHQsIHZhbHVlLCBlbmFibGVkXSA9IG9wdGlvbjtcbiAgICAgICAgICAgICAgICAgbGV0IGlkID0gXCJpbnB1dF9cIiArIHRleHQ7XG4gICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZGl2IGZvciBlYWNoIGZvcm0tY2hlY2staW5saW5lXG4gICAgICAgICAgICAgICAgIHJldHVybiB1aS5kaXYoXCJmb3JtLWNoZWNrIGZvcm0tY2hlY2staW5saW5lXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgJChcIjxpbnB1dD5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZm9ybS1jaGVjay1pbnB1dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIGlkKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIm5hbWVcIiwgXCJPcHRpb25Hcm91cF9cIiArIGhlYWRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0eXBlXCIsIGlucHV0VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCB2YWx1ZSA/PyB0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRpc2FibGVkXCIsIGVuYWJsZWQgIT0gbnVsbCAmJiAhZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDaGVja2VkID0gJCh0aGlzKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25jaGFuZ2UpIG9uY2hhbmdlKCQodGhpcykuYXR0cihcInZhbHVlXCIpLCBpc0NoZWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgJChcIjxsYWJlbD5cIikuYWRkQ2xhc3MoXCJmb3JtLWNoZWNrLWxhYmVsXCIpLmF0dHIoXCJmb3JcIiwgaWQpLnRleHQodGV4dCksXG4gICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICApLFxuICAgICAgICBdKTtcbiAgICAgfSxcbiB9O1xuXG4gLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogU3RpbGwgZXhwb3NlIHV0aWxpdGllcyBvbiB3aW5kb3cgZHVyaW5nIHRyYW5zaXRpb25cbi8vIFRPRE86IFJlbW92ZSB0aGlzIG9uY2UgYWxsIGZpbGVzIGFyZSBjb252ZXJ0ZWQgdG8gbW9kdWxlc1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnVpID0gdWk7XG4gfSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/ui.js\n\n}");

/***/ }),

/***/ "./www/code/utils.js":
/*!***************************!*\
  !*** ./www/code/utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayUtils: () => (/* binding */ ArrayUtils),\n/* harmony export */   NumberUtils: () => (/* binding */ NumberUtils)\n/* harmony export */ });\n\n\n// Number utilities\nconst NumberUtils = {\n   /**\n    * Check if a value is between two other values (inclusive)\n    * @param {number} value - The value to check\n    * @param {number} a - First boundary\n    * @param {number} b - Second boundary  \n    * @returns {boolean} True if value is between a and b\n    */\n   between(value, a, b) {\n      const min = Math.min(a, b);\n      const max = Math.max(a, b);\n      return value >= min && value <= max;\n   },\n\n   /**\n    * Check if a value is outside the range of two other values\n    * @param {number} value - The value to check\n    * @param {number} a - First boundary\n    * @param {number} b - Second boundary\n    * @returns {boolean} True if value is outside the range\n    */\n   outoff(value, a, b) {\n      return !this.between(value, a, b);\n   },\n\n   /**\n    * Check if a value equals any of the provided arguments\n    * @param {number} value - The value to check\n    * @param {...number} args - Values to compare against\n    * @returns {boolean} True if value matches any argument\n    */\n   is(value, ...args) {\n      return args.includes(value);\n   },\n\n   /**\n    * Round a number to specified decimal places\n    * @param {number} value - The number to round\n    * @param {number} places - Number of decimal places\n    * @returns {number} Rounded number\n    */\n   round(value, places) {\n      return Number(Math.round(value + \"e\" + places) + \"e-\" + places);\n   },\n\n   /**\n    * Check if a value is close to a multiple of another value within tolerance\n    * @param {number} value - The value to check\n    * @param {number} multiple - The multiple to check against\n    * @param {number} tolerance - Allowed tolerance\n    * @returns {boolean} True if value is close to a multiple\n    */\n   closeToBy(value, multiple, tolerance) {\n      const mod = value % multiple;\n      return Math.min(mod, multiple - mod) < tolerance;\n   },\n\n   /**\n    * Constrain a value between min and max\n    * @param {number} min - Minimum value\n    * @param {number} value - Value to constrain\n    * @param {number} max - Maximum value\n    * @returns {number} Constrained value\n    */\n   minmax(min, value, max) {\n      return Math.max(min, Math.min(max, value));\n   },\n\n   /**\n    * Generate random integer between 0 and max (inclusive)\n    * @param {number} max - Maximum value\n    * @returns {number} Random integer\n    */\n   randomInt(max) {\n      return Math.floor(Math.random() * (max + 1));\n   }\n};\n\n// Array utilities\nconst ArrayUtils = {\n   /**\n    * Remove an item from an array\n    * @param {Array} array - The array to modify\n    * @param {*} item - The item to remove\n    * @returns {boolean} True if item was found and removed\n    */\n   remove(array, item) {\n      const index = array.indexOf(item);\n      if (index !== -1) {\n         array.splice(index, 1);\n         return true;\n      }\n      return false;\n   },\n\n\n\n   /**\n    * Get the last element of an array\n    * @param {Array} array - The array\n    * @returns {*} Last element or undefined if empty\n    */\n   last(array) {\n      return array[array.length - 1];\n   },\n\n   /**\n    * Get the first element of an array\n    * @param {Array} array - The array\n    * @returns {*} First element or undefined if empty\n    */\n   first(array) {\n      return array[0];\n   },\n\n   /**\n    * Remove all null and undefined values from array\n    * @param {Array} array - The array to clean\n    * @returns {Array} Array with null/undefined values removed\n    */\n   cleanUp(array) {\n      return array.filter(item => item != null);\n   },\n\n   /**\n    * Get a random element from the array\n    * @param {Array} array - The array\n    * @returns {*} Random element or undefined if empty\n    */\n   random(array) {\n      return array[Math.floor(Math.random() * array.length)];\n   },\n\n   /**\n    * Count elements that appear more than once\n    * @param {Array} array - The array to analyze\n    * @returns {number} Count of non-unique elements\n    */\n   countNonUnique(array) {\n      const counts = {};\n      let nonUniqueCount = 0;\n      \n      for (const item of array) {\n         if (counts[item] === 1) {\n            nonUniqueCount++; // Only increment on second occurrence\n         }\n         counts[item] = (counts[item] || 0) + 1;\n      }\n      return nonUniqueCount;\n   },\n\n   /**\n    * Add element to array only if it doesn't already exist\n    * @param {Array} array - The array to modify\n    * @param {*} element - The element to add\n    * @returns {boolean} True if element was added, false if it already existed\n    */\n   pushUnique(array, element) {\n      if (array.indexOf(element) === -1) {\n         array.push(element);\n         return true;\n      }\n      return false;\n   },\n\n   /**\n    * Group array items by a property path\n    * @param {Array} array - The array to group\n    * @param {string} propertyPath - Dot-separated property path\n    * @returns {Array} Array of grouped arrays, sorted by group size descending\n    */\n   groupBy(array, propertyPath) {\n      const groups = array.reduce((storage, item) => {\n         const property = propertyPath.split('.').reduce((acc, key) => acc[key], item);\n         const group = property;\n         \n         storage[group] = storage[group] || [];\n         storage[group].push(item);\n         return storage;\n      }, {});\n\n      return Object.keys(groups)\n         .map(key => groups[key])\n         .sort((a, b) => b.length - a.length);\n   },\n\n   /**\n    * Return a copy of the array without the specified item\n    * @param {Array} array - The source array\n    * @param {*} item - The item to exclude\n    * @returns {Array} New array without the item\n    */\n   without(array, item) {\n      return array.filter(element => element !== item);\n   }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhOztBQUViO0FBQ087QUFDUDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFdBQVc7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsR0FBRztBQUNqQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7OztBQUlKO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsR0FBRztBQUNqQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLEdBQUc7QUFDakIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3V0aWxzLmpzP2E0MjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE51bWJlciB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBOdW1iZXJVdGlscyA9IHtcbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBiZXR3ZWVuIHR3byBvdGhlciB2YWx1ZXMgKGluY2x1c2l2ZSlcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGEgLSBGaXJzdCBib3VuZGFyeVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBTZWNvbmQgYm91bmRhcnkgIFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYmV0d2VlbiBhIGFuZCBiXG4gICAgKi9cbiAgIGJldHdlZW4odmFsdWUsIGEsIGIpIHtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKGEsIGIpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoYSwgYik7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBvdXRzaWRlIHRoZSByYW5nZSBvZiB0d28gb3RoZXIgdmFsdWVzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gRmlyc3QgYm91bmRhcnlcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gU2Vjb25kIGJvdW5kYXJ5XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBvdXRzaWRlIHRoZSByYW5nZVxuICAgICovXG4gICBvdXRvZmYodmFsdWUsIGEsIGIpIHtcbiAgICAgIHJldHVybiAhdGhpcy5iZXR3ZWVuKHZhbHVlLCBhLCBiKTtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBlcXVhbHMgYW55IG9mIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICogQHBhcmFtIHsuLi5udW1iZXJ9IGFyZ3MgLSBWYWx1ZXMgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBtYXRjaGVzIGFueSBhcmd1bWVudFxuICAgICovXG4gICBpcyh2YWx1ZSwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIGFyZ3MuaW5jbHVkZXModmFsdWUpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBSb3VuZCBhIG51bWJlciB0byBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gcm91bmRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwbGFjZXMgLSBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJvdW5kZWQgbnVtYmVyXG4gICAgKi9cbiAgIHJvdW5kKHZhbHVlLCBwbGFjZXMpIHtcbiAgICAgIHJldHVybiBOdW1iZXIoTWF0aC5yb3VuZCh2YWx1ZSArIFwiZVwiICsgcGxhY2VzKSArIFwiZS1cIiArIHBsYWNlcyk7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZSBvZiBhbm90aGVyIHZhbHVlIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxlIC0gVGhlIG11bHRpcGxlIHRvIGNoZWNrIGFnYWluc3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgLSBBbGxvd2VkIHRvbGVyYW5jZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZVxuICAgICovXG4gICBjbG9zZVRvQnkodmFsdWUsIG11bHRpcGxlLCB0b2xlcmFuY2UpIHtcbiAgICAgIGNvbnN0IG1vZCA9IHZhbHVlICUgbXVsdGlwbGU7XG4gICAgICByZXR1cm4gTWF0aC5taW4obW9kLCBtdWx0aXBsZSAtIG1vZCkgPCB0b2xlcmFuY2U7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIENvbnN0cmFpbiBhIHZhbHVlIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBNaW5pbXVtIHZhbHVlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBWYWx1ZSB0byBjb25zdHJhaW5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBNYXhpbXVtIHZhbHVlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDb25zdHJhaW5lZCB2YWx1ZVxuICAgICovXG4gICBtaW5tYXgobWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIEdlbmVyYXRlIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgbWF4IChpbmNsdXNpdmUpXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gTWF4aW11bSB2YWx1ZVxuICAgICogQHJldHVybnMge251bWJlcn0gUmFuZG9tIGludGVnZXJcbiAgICAqL1xuICAgcmFuZG9tSW50KG1heCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggKyAxKSk7XG4gICB9XG59O1xuXG4vLyBBcnJheSB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBBcnJheVV0aWxzID0ge1xuICAgLyoqXG4gICAgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBtb2RpZnlcbiAgICAqIEBwYXJhbSB7Kn0gaXRlbSAtIFRoZSBpdGVtIHRvIHJlbW92ZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWRcbiAgICAqL1xuICAgcmVtb3ZlKGFycmF5LCBpdGVtKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9LFxuXG5cblxuICAgLyoqXG4gICAgKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheVxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXlcbiAgICAqIEByZXR1cm5zIHsqfSBMYXN0IGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIGVtcHR5XG4gICAgKi9cbiAgIGxhc3QoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5XG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheVxuICAgICogQHJldHVybnMgeyp9IEZpcnN0IGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIGVtcHR5XG4gICAgKi9cbiAgIGZpcnN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXlbMF07XG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJlbW92ZSBhbGwgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIGFycmF5XG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBjbGVhblxuICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlcyByZW1vdmVkXG4gICAgKi9cbiAgIGNsZWFuVXAoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoaXRlbSA9PiBpdGVtICE9IG51bGwpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBHZXQgYSByYW5kb20gZWxlbWVudCBmcm9tIHRoZSBhcnJheVxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXlcbiAgICAqIEByZXR1cm5zIHsqfSBSYW5kb20gZWxlbWVudCBvciB1bmRlZmluZWQgaWYgZW1wdHlcbiAgICAqL1xuICAgcmFuZG9tKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXlbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyYXkubGVuZ3RoKV07XG4gICB9LFxuXG4gICAvKipcbiAgICAqIENvdW50IGVsZW1lbnRzIHRoYXQgYXBwZWFyIG1vcmUgdGhhbiBvbmNlXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBhbmFseXplXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDb3VudCBvZiBub24tdW5pcXVlIGVsZW1lbnRzXG4gICAgKi9cbiAgIGNvdW50Tm9uVW5pcXVlKGFycmF5KSB7XG4gICAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICAgIGxldCBub25VbmlxdWVDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnJheSkge1xuICAgICAgICAgaWYgKGNvdW50c1tpdGVtXSA9PT0gMSkge1xuICAgICAgICAgICAgbm9uVW5pcXVlQ291bnQrKzsgLy8gT25seSBpbmNyZW1lbnQgb24gc2Vjb25kIG9jY3VycmVuY2VcbiAgICAgICAgIH1cbiAgICAgICAgIGNvdW50c1tpdGVtXSA9IChjb3VudHNbaXRlbV0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vblVuaXF1ZUNvdW50O1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBBZGQgZWxlbWVudCB0byBhcnJheSBvbmx5IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gbW9kaWZ5XG4gICAgKiBAcGFyYW0geyp9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBhZGRcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGVsZW1lbnQgd2FzIGFkZGVkLCBmYWxzZSBpZiBpdCBhbHJlYWR5IGV4aXN0ZWRcbiAgICAqL1xuICAgcHVzaFVuaXF1ZShhcnJheSwgZWxlbWVudCkge1xuICAgICAgaWYgKGFycmF5LmluZGV4T2YoZWxlbWVudCkgPT09IC0xKSB7XG4gICAgICAgICBhcnJheS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIEdyb3VwIGFycmF5IGl0ZW1zIGJ5IGEgcHJvcGVydHkgcGF0aFxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gZ3JvdXBcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVBhdGggLSBEb3Qtc2VwYXJhdGVkIHByb3BlcnR5IHBhdGhcbiAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZ3JvdXBlZCBhcnJheXMsIHNvcnRlZCBieSBncm91cCBzaXplIGRlc2NlbmRpbmdcbiAgICAqL1xuICAgZ3JvdXBCeShhcnJheSwgcHJvcGVydHlQYXRoKSB7XG4gICAgICBjb25zdCBncm91cHMgPSBhcnJheS5yZWR1Y2UoKHN0b3JhZ2UsIGl0ZW0pID0+IHtcbiAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcGVydHlQYXRoLnNwbGl0KCcuJykucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGl0ZW0pO1xuICAgICAgICAgY29uc3QgZ3JvdXAgPSBwcm9wZXJ0eTtcbiAgICAgICAgIFxuICAgICAgICAgc3RvcmFnZVtncm91cF0gPSBzdG9yYWdlW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgIHN0b3JhZ2VbZ3JvdXBdLnB1c2goaXRlbSk7XG4gICAgICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGdyb3VwcylcbiAgICAgICAgIC5tYXAoa2V5ID0+IGdyb3Vwc1trZXldKVxuICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBhcnJheSB3aXRob3V0IHRoZSBzcGVjaWZpZWQgaXRlbVxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgc291cmNlIGFycmF5XG4gICAgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgaXRlbSB0byBleGNsdWRlXG4gICAgKiBAcmV0dXJucyB7QXJyYXl9IE5ldyBhcnJheSB3aXRob3V0IHRoZSBpdGVtXG4gICAgKi9cbiAgIHdpdGhvdXQoYXJyYXksIGl0ZW0pIHtcbiAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoZWxlbWVudCA9PiBlbGVtZW50ICE9PSBpdGVtKTtcbiAgIH1cbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/utils.js\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./www/code/start.js");
/******/ 	
/******/ })()
;
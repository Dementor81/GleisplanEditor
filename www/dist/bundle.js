/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./www/code/application.js":
/*!*********************************!*\
  !*** ./www/code/application.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Application: () => (/* binding */ Application)\n/* harmony export */ });\n/* harmony import */ var _preLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./preLoader.js */ \"./www/code/preLoader.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n/* harmony import */ var _trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./trackRendering_basic.js */ \"./www/code/trackRendering_basic.js\");\n/* harmony import */ var _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./trackRendering_textured.js */ \"./www/code/trackRendering_textured.js\");\n/* harmony import */ var _signal_library_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./signal_library.js */ \"./www/code/signal_library.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./config.js */ \"./www/code/config.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Main Application class that manages the entire application lifecycle\n * This class follows the singleton pattern and serves as the central coordinator\n */\nclass Application {\n   static #instance = null;\n   \n   // Core application state\n   #stage = null;\n   #containers = {};\n   #renderer = null;\n   #preLoader = null;\n   #signalTemplates = {};\n   #undoHistory = [];\n   #selection = {\n      type: \"\",\n      object: null,\n      isSelectedObject: function (test) {\n         if (!test || !this.object || this.type != (0,_tools_js__WEBPACK_IMPORTED_MODULE_10__.type)(test)) return false;\n         if (Array.isArray(this.object)) return this.object.includes(test);\n         else return this.object === test;\n      },\n   };\n   \n   // Application state\n   #editMode = true;\n   #showGrid = true;\n   #customMouseMode = _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.NONE;\n   #mouseAction = null;\n   \n   /**\n    * Get the singleton instance of the Application\n    * @returns {Application} The application instance\n    */\n   static getInstance() {\n      if (!Application.#instance) {\n         Application.#instance = new Application();\n      }\n      return Application.#instance;\n   }\n   \n   /**\n    * Private constructor to enforce singleton pattern\n    */\n   constructor() {\n      if (Application.#instance) {\n         throw new Error(\"Application is a singleton. Use Application.getInstance() instead.\");\n      }\n   }\n   \n   /**\n    * Initialize the application\n    * @returns {Promise} Promise that resolves when initialization is complete\n    */\n   async initialize() {\n      try {\n         await this.#initializePreLoader();\n         this.#initializeStage();\n         this.#initializeContainers();\n         this.#initializeEventListeners();\n         this.#initializeUI();\n         this.#exposeGlobalReferences();\n         \n         console.log(\"Application initialized successfully\");\n         return Promise.resolve();\n      } catch (error) {\n         console.error(\"Failed to initialize application:\", error);\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showErrorToast(error);\n         return Promise.reject(error);\n      }\n   }\n   \n   /**\n    * Initialize the preloader and signal templates\n    * @private\n    */\n   async #initializePreLoader() {\n      this.#preLoader = new _preLoader_js__WEBPACK_IMPORTED_MODULE_0__.preLoader(_config_js__WEBPACK_IMPORTED_MODULE_13__.PATHS.IMAGES);\n      (0,_signal_library_js__WEBPACK_IMPORTED_MODULE_9__.initSignals)(this.#signalTemplates);\n      \n      // Add basic images\n      this.#preLoader.addImage(\"schwellen.png\", \"schwellen\");      \n      this.#preLoader.addImage(\"bumper1.svg\", \"bumper\");\n      \n      // Start preloading\n      await this.#preLoader.start();\n      console.log(`Preloader completed: ${this.#preLoader._loadedItems}/${this.#preLoader._totalItems}`);\n   }\n   \n   /**\n    * Initialize the CreateJS stage\n    * @private\n    */\n   #initializeStage() {\n      this.#stage = new createjs.Stage(myCanvas);\n      this.#stage.autoClear = true;\n      this.#stage.enableDOMEvents(true);\n      createjs.Ticker.framerate = _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.TICKER_FRAMERATE;\n      createjs.Ticker.addEventListener(\"tick\", this.#stage);\n   }\n   \n   /**\n    * Initialize all containers\n    * @private\n    */\n   #initializeContainers() {\n      const createContainer = (name) => {\n         const container = new createjs.Container();\n         container.name = name;\n         container.mouseChildren = true;\n         return container;\n      };\n      \n      // Create all containers\n      this.#containers.main = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.MAIN);\n      this.#containers.debug = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.DEBUG);\n      this.#containers.tracks = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.TRACKS);\n      this.#containers.objects = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.objects);\n      this.#containers.trains = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.TRAINS);\n      this.#containers.signals = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.SIGNALS);\n      this.#containers.ui = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.UI);\n      this.#containers.selection = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.SELECTION);\n      this.#containers.overlay = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.OVERLAY);\n      this.#containers.drawing = createContainer(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONTAINERS.DRAWING);\n      \n      // Build container hierarchy\n      this.#stage.addChild(this.#containers.main);\n      this.#stage.addChild(this.#containers.debug);\n      this.#containers.main.addChild(this.#containers.tracks);\n      this.#containers.main.addChild(this.#containers.objectss);\n      this.#containers.main.addChild(this.#containers.trains);\n      this.#containers.main.addChild(this.#containers.signals);\n      this.#stage.addChild(this.#containers.ui);\n      this.#stage.addChild(this.#containers.selection);\n      this.#stage.addChild(this.#containers.overlay);\n      this.#stage.addChild(this.#containers.drawing);\n   }\n   \n   /**\n    * Initialize event listeners\n    * @private\n    */\n   #initializeEventListeners() {\n      // Note: Event handlers are still in start.js and will be moved in later phases\n      // This method is a placeholder for future event listener organization\n   }\n   \n   /**\n    * Initialize UI components\n    * @private\n    */\n   #initializeUI() {\n      // Initialize signal menu\n      const accordionId = \"#newItemMenuAccordination\";\n      $(accordionId).append([\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\n            \"Hauptsignale\",\n            accordionId,\n            this.#createNewItemButtons(this.#signalTemplates.hv_hp, this.#signalTemplates.ks, this.#signalTemplates.ls, this.#signalTemplates.zusatzSignal),\n            true\n         ),\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\"Vorsignale\", accordionId, this.#createNewItemButtons(this.#signalTemplates.hv_vr, this.#signalTemplates.ks_vr)),\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\"Lf-Signale\", accordionId, this.#createNewItemButtons(this.#signalTemplates.lf6, this.#signalTemplates.lf7)),\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\n            \"Ne-Signale\",\n            accordionId,\n            this.#createNewItemButtons(this.#signalTemplates.ne4, this.#signalTemplates.ne1, this.#signalTemplates.ne2)\n         ),\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.createAccordionItem(\n            \"Weitere\",\n            accordionId,\n            this.#createNewItemButtons(this.#signalTemplates.zs3, this.#signalTemplates.zs6, this.#signalTemplates.zs10, this.#signalTemplates.ra10)\n         ),\n      ]);\n      \n      // Initialize renderer\n      this.selectRenderer(!_config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.DEFAULT_SIMPLIFIED_VIEW);\n      this.updateUndoButtonState();\n   }\n   \n   /**\n    * Create new item buttons for UI\n    * @private\n    */\n   #createNewItemButtons(...templates) {\n      return templates.map((template) => {\n         if (!template) return null;\n         \n         return _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui\n            .div(\"d-flex newSignalItem align-items-center user-select-none\", [\n               _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui\n                  .div(\"flex-shrink-0 newItem_image\")\n                  .css(\"background-image\", \"url(\" + this.#getDataURLFromTemplate(template) + \")\")\n                  .css(\"background-size\", template.previewsize ?? 45),\n               _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.div(\"flex-grow-5 ms-2\", template.title),\n            ])\n            .on(\"mousedown\", (e) => {\n               // This will be handled by the original event system for now\n               this.#mouseAction = {\n                  action: _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.DND_SIGNAL,\n                  template: template,\n               };\n               \n               document.addEventListener(\"mouseup\", (e) => window.handleStageMouseUp({ nativeEvent: e }), {\n                  once: true,\n               });\n               this.stage.addEventListener(\"stagemousemove\", window.handleMouseMove);\n               window.startDragAndDropSignal(e.offsetX, e.offsetY);\n            });\n      }).filter(Boolean);\n   }\n   \n   /**\n    * Generate data URL from signal template for preview\n    * @private\n    */\n   #getDataURLFromTemplate(template) {\n      const tmpStage = new createjs.Stage($(\"<canvas>\").attr({ width: 450, height: 450 })[0]);\n      tmpStage.scale = template.scale;\n      \n      _signal_js__WEBPACK_IMPORTED_MODULE_1__.SignalRenderer.drawPreview(template, tmpStage);\n      tmpStage.update();\n      \n      const sig_bounds = tmpStage.getBounds();\n      if (sig_bounds == null) throw Error(template.title + \" has no visual Element visible\");\n      tmpStage.cache(sig_bounds.x, sig_bounds.y, sig_bounds.width, sig_bounds.height, 0.5);\n      return tmpStage.bitmapCache.getCacheDataURL();\n   }\n   \n   /**\n    * Expose global references for backward compatibility\n    * @private\n    */\n   #exposeGlobalReferences() {\n      // Expose core objects globally for backward compatibility\n      window.renderer = this.#renderer;\n      window.mouseAction = this.#mouseAction;\n      window.signalTemplates = this.#signalTemplates;\n      window.selection = this.#selection;\n      window.undoHistory = this.#undoHistory;\n      \n      // Expose configuration\n      window.DIRECTION = _config_js__WEBPACK_IMPORTED_MODULE_13__.DIRECTION;\n      window.CUSTOM_MOUSE_ACTION = _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION;\n      window.MOST_UNDO = _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.MOST_UNDO;\n      \n      // Expose utility functions\n      window.updateUndoButtonState = this.updateUndoButtonState.bind(this);\n      window.selectObject = this.selectObject.bind(this);\n      window.selectRenderer = this.selectRenderer.bind(this);\n      window.deleteSelectedObject = this.deleteSelectedObject.bind(this);\n      window.alignSignalContainerWithTrack = this.alignSignalContainerWithTrack.bind(this);\n      window.trackRendering_basic = _trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__.trackRendering_basic;\n      window.trackRendering_textured = _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_8__.trackRendering_textured;\n   }\n   \n   /**\n    * Select renderer type\n    * @param {boolean} textured - Whether to use textured renderer\n    */\n   selectRenderer(textured) {\n      if (textured) {\n         this.#renderer = new _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_8__.trackRendering_textured();\n         $(\"#switch_renderer\").prop(\"checked\", false);\n      } else {\n         this.#renderer = new _trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__.trackRendering_basic();\n         $(\"#switch_renderer\").prop(\"checked\", true);\n      }\n      window.renderer = this.#renderer;\n      this.#renderer.reDrawEverything(true);\n      this.#stage.update();\n   }\n   \n   /**\n    * Update undo button state\n    */\n   updateUndoButtonState() {\n      $(\"#btnUndo\").prop(\"disabled\", this.#undoHistory.length <= 1);\n   }\n   \n   /**\n    * Select object\n    * @param {*} object - Object to select\n    * @param {Event} e - Event object\n    */\n   selectObject(object, e) {\n      if (!object) {\n         this.#selection.object = null;\n         this.#selection.type = \"\";\n         this.#renderer?.updateSelection();\n         // UI.showMenu() will be called from original code\n         return;\n      }\n      \n      const t = (0,_tools_js__WEBPACK_IMPORTED_MODULE_10__.type)(object);\n      if (object) console.log(object);\n      \n      if (t != this.#selection.type) {\n         this.#selection.object = object;\n         this.#selection.type = t;\n      } else {\n         if (e?.nativeEvent?.ctrlKey)\n            this.#selection.object = Array.isArray(this.#selection.object) ? [...this.#selection.object, object] : [this.#selection.object, object];\n         else this.#selection.object = object;\n      }\n      this.#renderer?.updateSelection();\n      \n      // Menu handling will be done by original code for now\n   }\n   \n   /**\n    * Delete selected object\n    */\n   deleteSelectedObject() {\n      if (this.#selection.object) {\n         if (this.#selection.type == \"Track\") {\n            const removedTracks = [].concat(this.#selection.object);\n            removedTracks.forEach((t) => _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.removeTrack(t));\n            for (const track of removedTracks) {\n               const trainsOnTrack = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.allTrains.filter((train) => train.track === track);\n               for (const train of trainsOnTrack) {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.deleteTrain(train);\n               }\n            }\n            _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.createRailNetwork();\n         }\n         if (this.#selection.type == \"Signal\") [].concat(this.#selection.object).forEach((s) => _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal.removeSignal(s, null));\n         _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n         _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n         this.#renderer.reDrawEverything(true);\n         this.#stage.update();\n         this.selectObject();\n      }\n   }\n   \n   /**\n    * Align signal container with track\n    * @param {*} container - Signal container\n    * @param {*} pos - Position information\n    */\n   alignSignalContainerWithTrack(container, pos) {\n      const point = pos.track.getPointFromKm(pos.km);\n      \n      let p;\n      if (pos.above) {\n         container.rotation = 270 + pos.track.deg;\n         p = point.add(\n            _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry\n               .perpendicular(pos.track.unit)\n               .multiply(-this.#renderer.SIGNAL_DISTANCE_FROM_TRACK - container.data._template.distance_from_track)\n         );\n      } else {\n         container.rotation = 90 + pos.track.deg;\n         p = point.add(\n            _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry\n               .perpendicular(pos.track.unit)\n               .multiply(this.#renderer.SIGNAL_DISTANCE_FROM_TRACK + container.data._template.distance_from_track)\n         );\n      }\n      if (pos.flipped) container.rotation += 180;\n      \n      container.x = p.x;\n      container.y = p.y;\n   }\n   \n   // Getters for accessing internal state\n   get stage() { return this.#stage; }\n   get containers() { return this.#containers; }\n   get renderer() { return this.#renderer; }\n   get preLoader() { return this.#preLoader; }\n   get signalTemplates() { return this.#signalTemplates; }\n   get selection() { return this.#selection; }\n   get undoHistory() { return this.#undoHistory; }\n   get editMode() { return this.#editMode; }\n   get showGrid() { return this.#showGrid; }\n   get customMouseMode() { return this.#customMouseMode; }\n   get mouseAction() { return this.#mouseAction; }\n   \n   // Setters for controlled state changes\n   set editMode(mode) { this.#editMode = mode; }\n   set showGrid(show) { this.#showGrid = show; }\n   set customMouseMode(mode) { \n      this.#customMouseMode = mode;\n   }\n   set mouseAction(action) { \n      this.#mouseAction = action; \n   }\n   set renderer(renderer) {\n      this.#renderer = renderer;\n   }\n} //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UjtBQUNBO0FBQ0EsWUFBWSxnREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL2FwcGxpY2F0aW9uLmpzPzA4NjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgcHJlTG9hZGVyIH0gZnJvbSAnLi9wcmVMb2FkZXIuanMnO1xuaW1wb3J0IHsgU2lnbmFsUmVuZGVyZXIsIFNpZ25hbCwgU2lnX1VJIH0gZnJvbSAnLi9zaWduYWwuanMnO1xuaW1wb3J0IHsgVHJhaW4gfSBmcm9tICcuL3RyYWluLmpzJztcbmltcG9ydCB7IFN3aXRjaCB9IGZyb20gJy4vc3dpdGNoLmpzJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay5qcyc7XG5pbXBvcnQgeyBHZW5lcmljT2JqZWN0IH0gZnJvbSAnLi9nZW5lcmljX29iamVjdC5qcyc7XG5pbXBvcnQgeyBTVE9SQUdFIH0gZnJvbSAnLi9zdG9yYWdlLmpzJztcbmltcG9ydCB7IHRyYWNrUmVuZGVyaW5nX2Jhc2ljIH0gZnJvbSAnLi90cmFja1JlbmRlcmluZ19iYXNpYy5qcyc7XG5pbXBvcnQgeyB0cmFja1JlbmRlcmluZ190ZXh0dXJlZCB9IGZyb20gJy4vdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuanMnO1xuaW1wb3J0IHsgaW5pdFNpZ25hbHMgfSBmcm9tICcuL3NpZ25hbF9saWJyYXJ5LmpzJztcbmltcG9ydCB7IFxuICAgdHlwZSwgXG4gICBUT09MUywgXG4gICBnZW9tZXRyeSwgXG4gICBQb2ludCwgXG59IGZyb20gJy4vdG9vbHMuanMnO1xuaW1wb3J0IHsgTnVtYmVyVXRpbHMsIEFycmF5VXRpbHMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHVpIH0gZnJvbSAnLi91aS5qcyc7XG5pbXBvcnQgeyBcbiAgIENPTkZJRywgXG4gICBESVJFQ1RJT04sIFxuICAgTU9VU0VfRE9XTl9BQ1RJT04sIFxuICAgQ1VTVE9NX01PVVNFX0FDVElPTiwgXG4gICBNRU5VLFxuICAgQ09MT1JTLFxuICAgQ09OVEFJTkVSUyxcbiAgIElOUFVULFxuICAgUEFUSFMgXG59IGZyb20gJy4vY29uZmlnLmpzJztcblxuLyoqXG4gKiBNYWluIEFwcGxpY2F0aW9uIGNsYXNzIHRoYXQgbWFuYWdlcyB0aGUgZW50aXJlIGFwcGxpY2F0aW9uIGxpZmVjeWNsZVxuICogVGhpcyBjbGFzcyBmb2xsb3dzIHRoZSBzaW5nbGV0b24gcGF0dGVybiBhbmQgc2VydmVzIGFzIHRoZSBjZW50cmFsIGNvb3JkaW5hdG9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBcHBsaWNhdGlvbiB7XG4gICBzdGF0aWMgI2luc3RhbmNlID0gbnVsbDtcbiAgIFxuICAgLy8gQ29yZSBhcHBsaWNhdGlvbiBzdGF0ZVxuICAgI3N0YWdlID0gbnVsbDtcbiAgICNjb250YWluZXJzID0ge307XG4gICAjcmVuZGVyZXIgPSBudWxsO1xuICAgI3ByZUxvYWRlciA9IG51bGw7XG4gICAjc2lnbmFsVGVtcGxhdGVzID0ge307XG4gICAjdW5kb0hpc3RvcnkgPSBbXTtcbiAgICNzZWxlY3Rpb24gPSB7XG4gICAgICB0eXBlOiBcIlwiLFxuICAgICAgb2JqZWN0OiBudWxsLFxuICAgICAgaXNTZWxlY3RlZE9iamVjdDogZnVuY3Rpb24gKHRlc3QpIHtcbiAgICAgICAgIGlmICghdGVzdCB8fCAhdGhpcy5vYmplY3QgfHwgdGhpcy50eXBlICE9IHR5cGUodGVzdCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub2JqZWN0KSkgcmV0dXJuIHRoaXMub2JqZWN0LmluY2x1ZGVzKHRlc3QpO1xuICAgICAgICAgZWxzZSByZXR1cm4gdGhpcy5vYmplY3QgPT09IHRlc3Q7XG4gICAgICB9LFxuICAgfTtcbiAgIFxuICAgLy8gQXBwbGljYXRpb24gc3RhdGVcbiAgICNlZGl0TW9kZSA9IHRydWU7XG4gICAjc2hvd0dyaWQgPSB0cnVlO1xuICAgI2N1c3RvbU1vdXNlTW9kZSA9IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORTtcbiAgICNtb3VzZUFjdGlvbiA9IG51bGw7XG4gICBcbiAgIC8qKlxuICAgICogR2V0IHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIEFwcGxpY2F0aW9uXG4gICAgKiBAcmV0dXJucyB7QXBwbGljYXRpb259IFRoZSBhcHBsaWNhdGlvbiBpbnN0YW5jZVxuICAgICovXG4gICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICBpZiAoIUFwcGxpY2F0aW9uLiNpbnN0YW5jZSkge1xuICAgICAgICAgQXBwbGljYXRpb24uI2luc3RhbmNlID0gbmV3IEFwcGxpY2F0aW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQXBwbGljYXRpb24uI2luc3RhbmNlO1xuICAgfVxuICAgXG4gICAvKipcbiAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgdG8gZW5mb3JjZSBzaW5nbGV0b24gcGF0dGVyblxuICAgICovXG4gICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIGlmIChBcHBsaWNhdGlvbi4jaW5zdGFuY2UpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFwcGxpY2F0aW9uIGlzIGEgc2luZ2xldG9uLiBVc2UgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKSBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgIH1cbiAgIFxuICAgLyoqXG4gICAgKiBJbml0aWFsaXplIHRoZSBhcHBsaWNhdGlvblxuICAgICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlXG4gICAgKi9cbiAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgYXdhaXQgdGhpcy4jaW5pdGlhbGl6ZVByZUxvYWRlcigpO1xuICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVN0YWdlKCk7XG4gICAgICAgICB0aGlzLiNpbml0aWFsaXplQ29udGFpbmVycygpO1xuICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICB0aGlzLiNpbml0aWFsaXplVUkoKTtcbiAgICAgICAgIHRoaXMuI2V4cG9zZUdsb2JhbFJlZmVyZW5jZXMoKTtcbiAgICAgICAgIFxuICAgICAgICAgY29uc29sZS5sb2coXCJBcHBsaWNhdGlvbiBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIGFwcGxpY2F0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgICB1aS5zaG93RXJyb3JUb2FzdChlcnJvcik7XG4gICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgfVxuICAgXG4gICAvKipcbiAgICAqIEluaXRpYWxpemUgdGhlIHByZWxvYWRlciBhbmQgc2lnbmFsIHRlbXBsYXRlc1xuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgYXN5bmMgI2luaXRpYWxpemVQcmVMb2FkZXIoKSB7XG4gICAgICB0aGlzLiNwcmVMb2FkZXIgPSBuZXcgcHJlTG9hZGVyKFBBVEhTLklNQUdFUyk7XG4gICAgICBpbml0U2lnbmFscyh0aGlzLiNzaWduYWxUZW1wbGF0ZXMpO1xuICAgICAgXG4gICAgICAvLyBBZGQgYmFzaWMgaW1hZ2VzXG4gICAgICB0aGlzLiNwcmVMb2FkZXIuYWRkSW1hZ2UoXCJzY2h3ZWxsZW4ucG5nXCIsIFwic2Nod2VsbGVuXCIpOyAgICAgIFxuICAgICAgdGhpcy4jcHJlTG9hZGVyLmFkZEltYWdlKFwiYnVtcGVyMS5zdmdcIiwgXCJidW1wZXJcIik7XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IHByZWxvYWRpbmdcbiAgICAgIGF3YWl0IHRoaXMuI3ByZUxvYWRlci5zdGFydCgpO1xuICAgICAgY29uc29sZS5sb2coYFByZWxvYWRlciBjb21wbGV0ZWQ6ICR7dGhpcy4jcHJlTG9hZGVyLl9sb2FkZWRJdGVtc30vJHt0aGlzLiNwcmVMb2FkZXIuX3RvdGFsSXRlbXN9YCk7XG4gICB9XG4gICBcbiAgIC8qKlxuICAgICogSW5pdGlhbGl6ZSB0aGUgQ3JlYXRlSlMgc3RhZ2VcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICNpbml0aWFsaXplU3RhZ2UoKSB7XG4gICAgICB0aGlzLiNzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShteUNhbnZhcyk7XG4gICAgICB0aGlzLiNzdGFnZS5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgICAgdGhpcy4jc3RhZ2UuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuICAgICAgY3JlYXRlanMuVGlja2VyLmZyYW1lcmF0ZSA9IENPTkZJRy5USUNLRVJfRlJBTUVSQVRFO1xuICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIHRoaXMuI3N0YWdlKTtcbiAgIH1cbiAgIFxuICAgLyoqXG4gICAgKiBJbml0aWFsaXplIGFsbCBjb250YWluZXJzXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAjaW5pdGlhbGl6ZUNvbnRhaW5lcnMoKSB7XG4gICAgICBjb25zdCBjcmVhdGVDb250YWluZXIgPSAobmFtZSkgPT4ge1xuICAgICAgICAgY29uc3QgY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgY29udGFpbmVyLm5hbWUgPSBuYW1lO1xuICAgICAgICAgY29udGFpbmVyLm1vdXNlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhbGwgY29udGFpbmVyc1xuICAgICAgdGhpcy4jY29udGFpbmVycy5tYWluID0gY3JlYXRlQ29udGFpbmVyKENPTlRBSU5FUlMuTUFJTik7XG4gICAgICB0aGlzLiNjb250YWluZXJzLmRlYnVnID0gY3JlYXRlQ29udGFpbmVyKENPTlRBSU5FUlMuREVCVUcpO1xuICAgICAgdGhpcy4jY29udGFpbmVycy50cmFja3MgPSBjcmVhdGVDb250YWluZXIoQ09OVEFJTkVSUy5UUkFDS1MpO1xuICAgICAgdGhpcy4jY29udGFpbmVycy5vYmplY3RzID0gY3JlYXRlQ29udGFpbmVyKENPTlRBSU5FUlMub2JqZWN0cyk7XG4gICAgICB0aGlzLiNjb250YWluZXJzLnRyYWlucyA9IGNyZWF0ZUNvbnRhaW5lcihDT05UQUlORVJTLlRSQUlOUyk7XG4gICAgICB0aGlzLiNjb250YWluZXJzLnNpZ25hbHMgPSBjcmVhdGVDb250YWluZXIoQ09OVEFJTkVSUy5TSUdOQUxTKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lcnMudWkgPSBjcmVhdGVDb250YWluZXIoQ09OVEFJTkVSUy5VSSk7XG4gICAgICB0aGlzLiNjb250YWluZXJzLnNlbGVjdGlvbiA9IGNyZWF0ZUNvbnRhaW5lcihDT05UQUlORVJTLlNFTEVDVElPTik7XG4gICAgICB0aGlzLiNjb250YWluZXJzLm92ZXJsYXkgPSBjcmVhdGVDb250YWluZXIoQ09OVEFJTkVSUy5PVkVSTEFZKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lcnMuZHJhd2luZyA9IGNyZWF0ZUNvbnRhaW5lcihDT05UQUlORVJTLkRSQVdJTkcpO1xuICAgICAgXG4gICAgICAvLyBCdWlsZCBjb250YWluZXIgaGllcmFyY2h5XG4gICAgICB0aGlzLiNzdGFnZS5hZGRDaGlsZCh0aGlzLiNjb250YWluZXJzLm1haW4pO1xuICAgICAgdGhpcy4jc3RhZ2UuYWRkQ2hpbGQodGhpcy4jY29udGFpbmVycy5kZWJ1Zyk7XG4gICAgICB0aGlzLiNjb250YWluZXJzLm1haW4uYWRkQ2hpbGQodGhpcy4jY29udGFpbmVycy50cmFja3MpO1xuICAgICAgdGhpcy4jY29udGFpbmVycy5tYWluLmFkZENoaWxkKHRoaXMuI2NvbnRhaW5lcnMub2JqZWN0c3MpO1xuICAgICAgdGhpcy4jY29udGFpbmVycy5tYWluLmFkZENoaWxkKHRoaXMuI2NvbnRhaW5lcnMudHJhaW5zKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lcnMubWFpbi5hZGRDaGlsZCh0aGlzLiNjb250YWluZXJzLnNpZ25hbHMpO1xuICAgICAgdGhpcy4jc3RhZ2UuYWRkQ2hpbGQodGhpcy4jY29udGFpbmVycy51aSk7XG4gICAgICB0aGlzLiNzdGFnZS5hZGRDaGlsZCh0aGlzLiNjb250YWluZXJzLnNlbGVjdGlvbik7XG4gICAgICB0aGlzLiNzdGFnZS5hZGRDaGlsZCh0aGlzLiNjb250YWluZXJzLm92ZXJsYXkpO1xuICAgICAgdGhpcy4jc3RhZ2UuYWRkQ2hpbGQodGhpcy4jY29udGFpbmVycy5kcmF3aW5nKTtcbiAgIH1cbiAgIFxuICAgLyoqXG4gICAgKiBJbml0aWFsaXplIGV2ZW50IGxpc3RlbmVyc1xuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgI2luaXRpYWxpemVFdmVudExpc3RlbmVycygpIHtcbiAgICAgIC8vIE5vdGU6IEV2ZW50IGhhbmRsZXJzIGFyZSBzdGlsbCBpbiBzdGFydC5qcyBhbmQgd2lsbCBiZSBtb3ZlZCBpbiBsYXRlciBwaGFzZXNcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSBldmVudCBsaXN0ZW5lciBvcmdhbml6YXRpb25cbiAgIH1cbiAgIFxuICAgLyoqXG4gICAgKiBJbml0aWFsaXplIFVJIGNvbXBvbmVudHNcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICNpbml0aWFsaXplVUkoKSB7XG4gICAgICAvLyBJbml0aWFsaXplIHNpZ25hbCBtZW51XG4gICAgICBjb25zdCBhY2NvcmRpb25JZCA9IFwiI25ld0l0ZW1NZW51QWNjb3JkaW5hdGlvblwiO1xuICAgICAgJChhY2NvcmRpb25JZCkuYXBwZW5kKFtcbiAgICAgICAgIHVpLmNyZWF0ZUFjY29yZGlvbkl0ZW0oXG4gICAgICAgICAgICBcIkhhdXB0c2lnbmFsZVwiLFxuICAgICAgICAgICAgYWNjb3JkaW9uSWQsXG4gICAgICAgICAgICB0aGlzLiNjcmVhdGVOZXdJdGVtQnV0dG9ucyh0aGlzLiNzaWduYWxUZW1wbGF0ZXMuaHZfaHAsIHRoaXMuI3NpZ25hbFRlbXBsYXRlcy5rcywgdGhpcy4jc2lnbmFsVGVtcGxhdGVzLmxzLCB0aGlzLiNzaWduYWxUZW1wbGF0ZXMuenVzYXR6U2lnbmFsKSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICksXG4gICAgICAgICB1aS5jcmVhdGVBY2NvcmRpb25JdGVtKFwiVm9yc2lnbmFsZVwiLCBhY2NvcmRpb25JZCwgdGhpcy4jY3JlYXRlTmV3SXRlbUJ1dHRvbnModGhpcy4jc2lnbmFsVGVtcGxhdGVzLmh2X3ZyLCB0aGlzLiNzaWduYWxUZW1wbGF0ZXMua3NfdnIpKSxcbiAgICAgICAgIHVpLmNyZWF0ZUFjY29yZGlvbkl0ZW0oXCJMZi1TaWduYWxlXCIsIGFjY29yZGlvbklkLCB0aGlzLiNjcmVhdGVOZXdJdGVtQnV0dG9ucyh0aGlzLiNzaWduYWxUZW1wbGF0ZXMubGY2LCB0aGlzLiNzaWduYWxUZW1wbGF0ZXMubGY3KSksXG4gICAgICAgICB1aS5jcmVhdGVBY2NvcmRpb25JdGVtKFxuICAgICAgICAgICAgXCJOZS1TaWduYWxlXCIsXG4gICAgICAgICAgICBhY2NvcmRpb25JZCxcbiAgICAgICAgICAgIHRoaXMuI2NyZWF0ZU5ld0l0ZW1CdXR0b25zKHRoaXMuI3NpZ25hbFRlbXBsYXRlcy5uZTQsIHRoaXMuI3NpZ25hbFRlbXBsYXRlcy5uZTEsIHRoaXMuI3NpZ25hbFRlbXBsYXRlcy5uZTIpXG4gICAgICAgICApLFxuICAgICAgICAgdWkuY3JlYXRlQWNjb3JkaW9uSXRlbShcbiAgICAgICAgICAgIFwiV2VpdGVyZVwiLFxuICAgICAgICAgICAgYWNjb3JkaW9uSWQsXG4gICAgICAgICAgICB0aGlzLiNjcmVhdGVOZXdJdGVtQnV0dG9ucyh0aGlzLiNzaWduYWxUZW1wbGF0ZXMuenMzLCB0aGlzLiNzaWduYWxUZW1wbGF0ZXMuenM2LCB0aGlzLiNzaWduYWxUZW1wbGF0ZXMuenMxMCwgdGhpcy4jc2lnbmFsVGVtcGxhdGVzLnJhMTApXG4gICAgICAgICApLFxuICAgICAgXSk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgcmVuZGVyZXJcbiAgICAgIHRoaXMuc2VsZWN0UmVuZGVyZXIoIUNPTkZJRy5ERUZBVUxUX1NJTVBMSUZJRURfVklFVyk7XG4gICAgICB0aGlzLnVwZGF0ZVVuZG9CdXR0b25TdGF0ZSgpO1xuICAgfVxuICAgXG4gICAvKipcbiAgICAqIENyZWF0ZSBuZXcgaXRlbSBidXR0b25zIGZvciBVSVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgI2NyZWF0ZU5ld0l0ZW1CdXR0b25zKC4uLnRlbXBsYXRlcykge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlcy5tYXAoKHRlbXBsYXRlKSA9PiB7XG4gICAgICAgICBpZiAoIXRlbXBsYXRlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgIFxuICAgICAgICAgcmV0dXJuIHVpXG4gICAgICAgICAgICAuZGl2KFwiZC1mbGV4IG5ld1NpZ25hbEl0ZW0gYWxpZ24taXRlbXMtY2VudGVyIHVzZXItc2VsZWN0LW5vbmVcIiwgW1xuICAgICAgICAgICAgICAgdWlcbiAgICAgICAgICAgICAgICAgIC5kaXYoXCJmbGV4LXNocmluay0wIG5ld0l0ZW1faW1hZ2VcIilcbiAgICAgICAgICAgICAgICAgIC5jc3MoXCJiYWNrZ3JvdW5kLWltYWdlXCIsIFwidXJsKFwiICsgdGhpcy4jZ2V0RGF0YVVSTEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSkgKyBcIilcIilcbiAgICAgICAgICAgICAgICAgIC5jc3MoXCJiYWNrZ3JvdW5kLXNpemVcIiwgdGVtcGxhdGUucHJldmlld3NpemUgPz8gNDUpLFxuICAgICAgICAgICAgICAgdWkuZGl2KFwiZmxleC1ncm93LTUgbXMtMlwiLCB0ZW1wbGF0ZS50aXRsZSksXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgLm9uKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgb3JpZ2luYWwgZXZlbnQgc3lzdGVtIGZvciBub3dcbiAgICAgICAgICAgICAgIHRoaXMuI21vdXNlQWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBNT1VTRV9ET1dOX0FDVElPTi5ETkRfU0lHTkFMLFxuICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgKGUpID0+IHdpbmRvdy5oYW5kbGVTdGFnZU1vdXNlVXAoeyBuYXRpdmVFdmVudDogZSB9KSwge1xuICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZW1vdmVcIiwgd2luZG93LmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgICAgICAgICB3aW5kb3cuc3RhcnREcmFnQW5kRHJvcFNpZ25hbChlLm9mZnNldFgsIGUub2Zmc2V0WSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgIH1cbiAgIFxuICAgLyoqXG4gICAgKiBHZW5lcmF0ZSBkYXRhIFVSTCBmcm9tIHNpZ25hbCB0ZW1wbGF0ZSBmb3IgcHJldmlld1xuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgI2dldERhdGFVUkxGcm9tVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIGNvbnN0IHRtcFN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKCQoXCI8Y2FudmFzPlwiKS5hdHRyKHsgd2lkdGg6IDQ1MCwgaGVpZ2h0OiA0NTAgfSlbMF0pO1xuICAgICAgdG1wU3RhZ2Uuc2NhbGUgPSB0ZW1wbGF0ZS5zY2FsZTtcbiAgICAgIFxuICAgICAgU2lnbmFsUmVuZGVyZXIuZHJhd1ByZXZpZXcodGVtcGxhdGUsIHRtcFN0YWdlKTtcbiAgICAgIHRtcFN0YWdlLnVwZGF0ZSgpO1xuICAgICAgXG4gICAgICBjb25zdCBzaWdfYm91bmRzID0gdG1wU3RhZ2UuZ2V0Qm91bmRzKCk7XG4gICAgICBpZiAoc2lnX2JvdW5kcyA9PSBudWxsKSB0aHJvdyBFcnJvcih0ZW1wbGF0ZS50aXRsZSArIFwiIGhhcyBubyB2aXN1YWwgRWxlbWVudCB2aXNpYmxlXCIpO1xuICAgICAgdG1wU3RhZ2UuY2FjaGUoc2lnX2JvdW5kcy54LCBzaWdfYm91bmRzLnksIHNpZ19ib3VuZHMud2lkdGgsIHNpZ19ib3VuZHMuaGVpZ2h0LCAwLjUpO1xuICAgICAgcmV0dXJuIHRtcFN0YWdlLmJpdG1hcENhY2hlLmdldENhY2hlRGF0YVVSTCgpO1xuICAgfVxuICAgXG4gICAvKipcbiAgICAqIEV4cG9zZSBnbG9iYWwgcmVmZXJlbmNlcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgI2V4cG9zZUdsb2JhbFJlZmVyZW5jZXMoKSB7XG4gICAgICAvLyBFeHBvc2UgY29yZSBvYmplY3RzIGdsb2JhbGx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICB3aW5kb3cucmVuZGVyZXIgPSB0aGlzLiNyZW5kZXJlcjtcbiAgICAgIHdpbmRvdy5tb3VzZUFjdGlvbiA9IHRoaXMuI21vdXNlQWN0aW9uO1xuICAgICAgd2luZG93LnNpZ25hbFRlbXBsYXRlcyA9IHRoaXMuI3NpZ25hbFRlbXBsYXRlcztcbiAgICAgIHdpbmRvdy5zZWxlY3Rpb24gPSB0aGlzLiNzZWxlY3Rpb247XG4gICAgICB3aW5kb3cudW5kb0hpc3RvcnkgPSB0aGlzLiN1bmRvSGlzdG9yeTtcbiAgICAgIFxuICAgICAgLy8gRXhwb3NlIGNvbmZpZ3VyYXRpb25cbiAgICAgIHdpbmRvdy5ESVJFQ1RJT04gPSBESVJFQ1RJT047XG4gICAgICB3aW5kb3cuQ1VTVE9NX01PVVNFX0FDVElPTiA9IENVU1RPTV9NT1VTRV9BQ1RJT047XG4gICAgICB3aW5kb3cuTU9TVF9VTkRPID0gQ09ORklHLk1PU1RfVU5ETztcbiAgICAgIFxuICAgICAgLy8gRXhwb3NlIHV0aWxpdHkgZnVuY3Rpb25zXG4gICAgICB3aW5kb3cudXBkYXRlVW5kb0J1dHRvblN0YXRlID0gdGhpcy51cGRhdGVVbmRvQnV0dG9uU3RhdGUuYmluZCh0aGlzKTtcbiAgICAgIHdpbmRvdy5zZWxlY3RPYmplY3QgPSB0aGlzLnNlbGVjdE9iamVjdC5iaW5kKHRoaXMpO1xuICAgICAgd2luZG93LnNlbGVjdFJlbmRlcmVyID0gdGhpcy5zZWxlY3RSZW5kZXJlci5iaW5kKHRoaXMpO1xuICAgICAgd2luZG93LmRlbGV0ZVNlbGVjdGVkT2JqZWN0ID0gdGhpcy5kZWxldGVTZWxlY3RlZE9iamVjdC5iaW5kKHRoaXMpO1xuICAgICAgd2luZG93LmFsaWduU2lnbmFsQ29udGFpbmVyV2l0aFRyYWNrID0gdGhpcy5hbGlnblNpZ25hbENvbnRhaW5lcldpdGhUcmFjay5iaW5kKHRoaXMpO1xuICAgICAgd2luZG93LnRyYWNrUmVuZGVyaW5nX2Jhc2ljID0gdHJhY2tSZW5kZXJpbmdfYmFzaWM7XG4gICAgICB3aW5kb3cudHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQgPSB0cmFja1JlbmRlcmluZ190ZXh0dXJlZDtcbiAgIH1cbiAgIFxuICAgLyoqXG4gICAgKiBTZWxlY3QgcmVuZGVyZXIgdHlwZVxuICAgICogQHBhcmFtIHtib29sZWFufSB0ZXh0dXJlZCAtIFdoZXRoZXIgdG8gdXNlIHRleHR1cmVkIHJlbmRlcmVyXG4gICAgKi9cbiAgIHNlbGVjdFJlbmRlcmVyKHRleHR1cmVkKSB7XG4gICAgICBpZiAodGV4dHVyZWQpIHtcbiAgICAgICAgIHRoaXMuI3JlbmRlcmVyID0gbmV3IHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkKCk7XG4gICAgICAgICAkKFwiI3N3aXRjaF9yZW5kZXJlclwiKS5wcm9wKFwiY2hlY2tlZFwiLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgdGhpcy4jcmVuZGVyZXIgPSBuZXcgdHJhY2tSZW5kZXJpbmdfYmFzaWMoKTtcbiAgICAgICAgICQoXCIjc3dpdGNoX3JlbmRlcmVyXCIpLnByb3AoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgfVxuICAgICAgd2luZG93LnJlbmRlcmVyID0gdGhpcy4jcmVuZGVyZXI7XG4gICAgICB0aGlzLiNyZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgdGhpcy4jc3RhZ2UudXBkYXRlKCk7XG4gICB9XG4gICBcbiAgIC8qKlxuICAgICogVXBkYXRlIHVuZG8gYnV0dG9uIHN0YXRlXG4gICAgKi9cbiAgIHVwZGF0ZVVuZG9CdXR0b25TdGF0ZSgpIHtcbiAgICAgICQoXCIjYnRuVW5kb1wiKS5wcm9wKFwiZGlzYWJsZWRcIiwgdGhpcy4jdW5kb0hpc3RvcnkubGVuZ3RoIDw9IDEpO1xuICAgfVxuICAgXG4gICAvKipcbiAgICAqIFNlbGVjdCBvYmplY3RcbiAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IC0gT2JqZWN0IHRvIHNlbGVjdFxuICAgICogQHBhcmFtIHtFdmVudH0gZSAtIEV2ZW50IG9iamVjdFxuICAgICovXG4gICBzZWxlY3RPYmplY3Qob2JqZWN0LCBlKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICAgdGhpcy4jc2VsZWN0aW9uLm9iamVjdCA9IG51bGw7XG4gICAgICAgICB0aGlzLiNzZWxlY3Rpb24udHlwZSA9IFwiXCI7XG4gICAgICAgICB0aGlzLiNyZW5kZXJlcj8udXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAvLyBVSS5zaG93TWVudSgpIHdpbGwgYmUgY2FsbGVkIGZyb20gb3JpZ2luYWwgY29kZVxuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB0ID0gdHlwZShvYmplY3QpO1xuICAgICAgaWYgKG9iamVjdCkgY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgIFxuICAgICAgaWYgKHQgIT0gdGhpcy4jc2VsZWN0aW9uLnR5cGUpIHtcbiAgICAgICAgIHRoaXMuI3NlbGVjdGlvbi5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICB0aGlzLiNzZWxlY3Rpb24udHlwZSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgaWYgKGU/Lm5hdGl2ZUV2ZW50Py5jdHJsS2V5KVxuICAgICAgICAgICAgdGhpcy4jc2VsZWN0aW9uLm9iamVjdCA9IEFycmF5LmlzQXJyYXkodGhpcy4jc2VsZWN0aW9uLm9iamVjdCkgPyBbLi4udGhpcy4jc2VsZWN0aW9uLm9iamVjdCwgb2JqZWN0XSA6IFt0aGlzLiNzZWxlY3Rpb24ub2JqZWN0LCBvYmplY3RdO1xuICAgICAgICAgZWxzZSB0aGlzLiNzZWxlY3Rpb24ub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdGhpcy4jcmVuZGVyZXI/LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgXG4gICAgICAvLyBNZW51IGhhbmRsaW5nIHdpbGwgYmUgZG9uZSBieSBvcmlnaW5hbCBjb2RlIGZvciBub3dcbiAgIH1cbiAgIFxuICAgLyoqXG4gICAgKiBEZWxldGUgc2VsZWN0ZWQgb2JqZWN0XG4gICAgKi9cbiAgIGRlbGV0ZVNlbGVjdGVkT2JqZWN0KCkge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGlvbi5vYmplY3QpIHtcbiAgICAgICAgIGlmICh0aGlzLiNzZWxlY3Rpb24udHlwZSA9PSBcIlRyYWNrXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRUcmFja3MgPSBbXS5jb25jYXQodGhpcy4jc2VsZWN0aW9uLm9iamVjdCk7XG4gICAgICAgICAgICByZW1vdmVkVHJhY2tzLmZvckVhY2goKHQpID0+IFRyYWNrLnJlbW92ZVRyYWNrKHQpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgcmVtb3ZlZFRyYWNrcykge1xuICAgICAgICAgICAgICAgY29uc3QgdHJhaW5zT25UcmFjayA9IFRyYWluLmFsbFRyYWlucy5maWx0ZXIoKHRyYWluKSA9PiB0cmFpbi50cmFjayA9PT0gdHJhY2spO1xuICAgICAgICAgICAgICAgZm9yIChjb25zdCB0cmFpbiBvZiB0cmFpbnNPblRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICBUcmFpbi5kZWxldGVUcmFpbih0cmFpbik7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUcmFjay5jcmVhdGVSYWlsTmV0d29yaygpO1xuICAgICAgICAgfVxuICAgICAgICAgaWYgKHRoaXMuI3NlbGVjdGlvbi50eXBlID09IFwiU2lnbmFsXCIpIFtdLmNvbmNhdCh0aGlzLiNzZWxlY3Rpb24ub2JqZWN0KS5mb3JFYWNoKChzKSA9PiBTaWduYWwucmVtb3ZlU2lnbmFsKHMsIG51bGwpKTtcbiAgICAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgIHRoaXMuI3JlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICAgICAgICB0aGlzLiNzdGFnZS51cGRhdGUoKTtcbiAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KCk7XG4gICAgICB9XG4gICB9XG4gICBcbiAgIC8qKlxuICAgICogQWxpZ24gc2lnbmFsIGNvbnRhaW5lciB3aXRoIHRyYWNrXG4gICAgKiBAcGFyYW0geyp9IGNvbnRhaW5lciAtIFNpZ25hbCBjb250YWluZXJcbiAgICAqIEBwYXJhbSB7Kn0gcG9zIC0gUG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAqL1xuICAgYWxpZ25TaWduYWxDb250YWluZXJXaXRoVHJhY2soY29udGFpbmVyLCBwb3MpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9zLnRyYWNrLmdldFBvaW50RnJvbUttKHBvcy5rbSk7XG4gICAgICBcbiAgICAgIGxldCBwO1xuICAgICAgaWYgKHBvcy5hYm92ZSkge1xuICAgICAgICAgY29udGFpbmVyLnJvdGF0aW9uID0gMjcwICsgcG9zLnRyYWNrLmRlZztcbiAgICAgICAgIHAgPSBwb2ludC5hZGQoXG4gICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICAgICAgLnBlcnBlbmRpY3VsYXIocG9zLnRyYWNrLnVuaXQpXG4gICAgICAgICAgICAgICAubXVsdGlwbHkoLXRoaXMuI3JlbmRlcmVyLlNJR05BTF9ESVNUQU5DRV9GUk9NX1RSQUNLIC0gY29udGFpbmVyLmRhdGEuX3RlbXBsYXRlLmRpc3RhbmNlX2Zyb21fdHJhY2spXG4gICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGNvbnRhaW5lci5yb3RhdGlvbiA9IDkwICsgcG9zLnRyYWNrLmRlZztcbiAgICAgICAgIHAgPSBwb2ludC5hZGQoXG4gICAgICAgICAgICBnZW9tZXRyeVxuICAgICAgICAgICAgICAgLnBlcnBlbmRpY3VsYXIocG9zLnRyYWNrLnVuaXQpXG4gICAgICAgICAgICAgICAubXVsdGlwbHkodGhpcy4jcmVuZGVyZXIuU0lHTkFMX0RJU1RBTkNFX0ZST01fVFJBQ0sgKyBjb250YWluZXIuZGF0YS5fdGVtcGxhdGUuZGlzdGFuY2VfZnJvbV90cmFjaylcbiAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocG9zLmZsaXBwZWQpIGNvbnRhaW5lci5yb3RhdGlvbiArPSAxODA7XG4gICAgICBcbiAgICAgIGNvbnRhaW5lci54ID0gcC54O1xuICAgICAgY29udGFpbmVyLnkgPSBwLnk7XG4gICB9XG4gICBcbiAgIC8vIEdldHRlcnMgZm9yIGFjY2Vzc2luZyBpbnRlcm5hbCBzdGF0ZVxuICAgZ2V0IHN0YWdlKCkgeyByZXR1cm4gdGhpcy4jc3RhZ2U7IH1cbiAgIGdldCBjb250YWluZXJzKCkgeyByZXR1cm4gdGhpcy4jY29udGFpbmVyczsgfVxuICAgZ2V0IHJlbmRlcmVyKCkgeyByZXR1cm4gdGhpcy4jcmVuZGVyZXI7IH1cbiAgIGdldCBwcmVMb2FkZXIoKSB7IHJldHVybiB0aGlzLiNwcmVMb2FkZXI7IH1cbiAgIGdldCBzaWduYWxUZW1wbGF0ZXMoKSB7IHJldHVybiB0aGlzLiNzaWduYWxUZW1wbGF0ZXM7IH1cbiAgIGdldCBzZWxlY3Rpb24oKSB7IHJldHVybiB0aGlzLiNzZWxlY3Rpb247IH1cbiAgIGdldCB1bmRvSGlzdG9yeSgpIHsgcmV0dXJuIHRoaXMuI3VuZG9IaXN0b3J5OyB9XG4gICBnZXQgZWRpdE1vZGUoKSB7IHJldHVybiB0aGlzLiNlZGl0TW9kZTsgfVxuICAgZ2V0IHNob3dHcmlkKCkgeyByZXR1cm4gdGhpcy4jc2hvd0dyaWQ7IH1cbiAgIGdldCBjdXN0b21Nb3VzZU1vZGUoKSB7IHJldHVybiB0aGlzLiNjdXN0b21Nb3VzZU1vZGU7IH1cbiAgIGdldCBtb3VzZUFjdGlvbigpIHsgcmV0dXJuIHRoaXMuI21vdXNlQWN0aW9uOyB9XG4gICBcbiAgIC8vIFNldHRlcnMgZm9yIGNvbnRyb2xsZWQgc3RhdGUgY2hhbmdlc1xuICAgc2V0IGVkaXRNb2RlKG1vZGUpIHsgdGhpcy4jZWRpdE1vZGUgPSBtb2RlOyB9XG4gICBzZXQgc2hvd0dyaWQoc2hvdykgeyB0aGlzLiNzaG93R3JpZCA9IHNob3c7IH1cbiAgIHNldCBjdXN0b21Nb3VzZU1vZGUobW9kZSkgeyBcbiAgICAgIHRoaXMuI2N1c3RvbU1vdXNlTW9kZSA9IG1vZGU7XG4gICB9XG4gICBzZXQgbW91c2VBY3Rpb24oYWN0aW9uKSB7IFxuICAgICAgdGhpcy4jbW91c2VBY3Rpb24gPSBhY3Rpb247IFxuICAgfVxuICAgc2V0IHJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgICB0aGlzLiNyZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgfVxufSAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/code/application.js\n\n}");

/***/ }),

/***/ "./www/code/config.js":
/*!****************************!*\
  !*** ./www/code/config.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   COLORS: () => (/* binding */ COLORS),\n/* harmony export */   COMPUTED: () => (/* binding */ COMPUTED),\n/* harmony export */   CONFIG: () => (/* binding */ CONFIG),\n/* harmony export */   CONTAINERS: () => (/* binding */ CONTAINERS),\n/* harmony export */   CUSTOM_MOUSE_ACTION: () => (/* binding */ CUSTOM_MOUSE_ACTION),\n/* harmony export */   DIRECTION: () => (/* binding */ DIRECTION),\n/* harmony export */   INPUT: () => (/* binding */ INPUT),\n/* harmony export */   MENU: () => (/* binding */ MENU),\n/* harmony export */   MOUSE_DOWN_ACTION: () => (/* binding */ MOUSE_DOWN_ACTION),\n/* harmony export */   PATHS: () => (/* binding */ PATHS),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n\n/**\n * Application Configuration and Constants\n * This file contains all configuration values and constants used throughout the application\n */\n\nconst CONFIG = {\n    // Application metadata\n    VERSION: \"0.5\",\n    \n    // Default settings\n    DEFAULT_SIMPLIFIED_VIEW: true,\n    \n    // Grid and layout settings\n    GRID_SIZE: 100,\n    SNAP_TO_GRID: 10,\n    \n    // Zoom and scaling\n    MAX_SCALE: 8,\n    MIN_SCALE: 0.2,\n    \n    // History and undo\n    MOST_UNDO: 20,    \n    \n    // Canvas settings\n    CANVAS_AUTO_CLEAR: true,\n    CANVAS_ENABLE_DOM_EVENTS: true,\n    TICKER_FRAMERATE: 1,\n};\n\n// Computed values based on CONFIG\nconst COMPUTED = {\n    GRID_SIZE_2: CONFIG.GRID_SIZE / 2,\n};\n\n// Direction constants\nconst DIRECTION = {\n    LEFT_2_RIGHT: 1,\n    RIGHT_2_LEFT: -1,\n};\n\n// Mouse action constants\nconst MOUSE_DOWN_ACTION = {\n    NONE: 0,\n    SCROLL: 1,\n    BUILD_TRACK: 2,\n    MOVE_ITEM: 3,\n    DND_SIGNAL: 4,\n    ADD_TRAIN: 5,\n    MOVE_TRAIN: 6,\n    MOVE_OBJECT: 7,\n    DND_TRACK: 8,\n    CUSTOM: 9,\n};\n\n// Custom mouse action constants\nconst CUSTOM_MOUSE_ACTION = {\n    NONE: 0,\n    DRAWING: 1,\n    TEXT: 2,\n    PLATTFORM: 3,\n    TRAIN_COUPLE: 4,\n    TRAIN_DECOUPLE: 5,\n};\n\n// Menu constants\nconst MENU = {\n    EDIT_SIGNAL: 0,\n    NEW_SIGNAL: 1,\n    EDIT_TRAIN: 2,\n    NEW_TRAIN: 3,\n    NEW_OBJECT: 4,\n    EDIT_OBJECT: 5,\n};\n\n\n\n// Default colors\nconst COLORS = {\n    GRID: \"#ccc\",\n    SIGNAL_POSITION_LINE: \"#e00\",\n    DRAWING_BLUEPRINT: \"blue\",\n    DRAWING_ACTIVE: \"red\",\n    TRANSPARENT: \"#00000000\",\n    \n    // Train colors\n    TRAIN_COLORS: [\"#ff0000\", \"#ffff00\", \"#00ff00\", \"#0000ff\"],\n};\n\n// File paths and resource locations\nconst PATHS = {\n    IMAGES: \"images\",\n    PREBUILDS: \"prebuilds.xml\",\n    FONTS: {\n        CONDENSED: \"condenced\",\n        ARIAL: \"Arial\",\n        DOT: \"DOT\",\n    },\n};\n\n// Input settings\nconst INPUT = {\n    MOUSE_MOVEMENT_THRESHOLD: 4, // pixels\n    TOUCH_SUPPORTED: true,\n    CONTEXT_MENU_ENABLED: false,\n    ZOOM_STEP_DIVISOR: 1000,\n};\n\n// Container names for CreateJS\nconst CONTAINERS = {\n    MAIN: \"main\",\n    DEBUG: \"debug\",\n    TRACKS: \"tracks\",\n    OBJECTS: \"objects\",\n    TRAINS: \"trains\",\n    SIGNALS: \"signals\",\n    UI: \"ui\",\n    SELECTION: \"selection\",\n    OVERLAY: \"overlay\",\n    DRAWING: \"drawing_container\",\n};\n\n// Default export for convenience\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    CONFIG,\n    COMPUTED,\n    DIRECTION,\n    MOUSE_DOWN_ACTION,\n    CUSTOM_MOUSE_ACTION,\n    MENU,\n    COLORS,\n    PATHS,\n    INPUT,\n    CONTAINERS,\n}); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nbGVpc3BsYW5lZGl0b3IvLi93d3cvY29kZS9jb25maWcuanM/MTcxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBBcHBsaWNhdGlvbiBDb25maWd1cmF0aW9uIGFuZCBDb25zdGFudHNcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhbGwgY29uZmlndXJhdGlvbiB2YWx1ZXMgYW5kIGNvbnN0YW50cyB1c2VkIHRocm91Z2hvdXQgdGhlIGFwcGxpY2F0aW9uXG4gKi9cblxuZXhwb3J0IGNvbnN0IENPTkZJRyA9IHtcbiAgICAvLyBBcHBsaWNhdGlvbiBtZXRhZGF0YVxuICAgIFZFUlNJT046IFwiMC41XCIsXG4gICAgXG4gICAgLy8gRGVmYXVsdCBzZXR0aW5nc1xuICAgIERFRkFVTFRfU0lNUExJRklFRF9WSUVXOiB0cnVlLFxuICAgIFxuICAgIC8vIEdyaWQgYW5kIGxheW91dCBzZXR0aW5nc1xuICAgIEdSSURfU0laRTogMTAwLFxuICAgIFNOQVBfVE9fR1JJRDogMTAsXG4gICAgXG4gICAgLy8gWm9vbSBhbmQgc2NhbGluZ1xuICAgIE1BWF9TQ0FMRTogOCxcbiAgICBNSU5fU0NBTEU6IDAuMixcbiAgICBcbiAgICAvLyBIaXN0b3J5IGFuZCB1bmRvXG4gICAgTU9TVF9VTkRPOiAyMCwgICAgXG4gICAgXG4gICAgLy8gQ2FudmFzIHNldHRpbmdzXG4gICAgQ0FOVkFTX0FVVE9fQ0xFQVI6IHRydWUsXG4gICAgQ0FOVkFTX0VOQUJMRV9ET01fRVZFTlRTOiB0cnVlLFxuICAgIFRJQ0tFUl9GUkFNRVJBVEU6IDEsXG59O1xuXG4vLyBDb21wdXRlZCB2YWx1ZXMgYmFzZWQgb24gQ09ORklHXG5leHBvcnQgY29uc3QgQ09NUFVURUQgPSB7XG4gICAgR1JJRF9TSVpFXzI6IENPTkZJRy5HUklEX1NJWkUgLyAyLFxufTtcblxuLy8gRGlyZWN0aW9uIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IERJUkVDVElPTiA9IHtcbiAgICBMRUZUXzJfUklHSFQ6IDEsXG4gICAgUklHSFRfMl9MRUZUOiAtMSxcbn07XG5cbi8vIE1vdXNlIGFjdGlvbiBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBNT1VTRV9ET1dOX0FDVElPTiA9IHtcbiAgICBOT05FOiAwLFxuICAgIFNDUk9MTDogMSxcbiAgICBCVUlMRF9UUkFDSzogMixcbiAgICBNT1ZFX0lURU06IDMsXG4gICAgRE5EX1NJR05BTDogNCxcbiAgICBBRERfVFJBSU46IDUsXG4gICAgTU9WRV9UUkFJTjogNixcbiAgICBNT1ZFX09CSkVDVDogNyxcbiAgICBETkRfVFJBQ0s6IDgsXG4gICAgQ1VTVE9NOiA5LFxufTtcblxuLy8gQ3VzdG9tIG1vdXNlIGFjdGlvbiBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBDVVNUT01fTU9VU0VfQUNUSU9OID0ge1xuICAgIE5PTkU6IDAsXG4gICAgRFJBV0lORzogMSxcbiAgICBURVhUOiAyLFxuICAgIFBMQVRURk9STTogMyxcbiAgICBUUkFJTl9DT1VQTEU6IDQsXG4gICAgVFJBSU5fREVDT1VQTEU6IDUsXG59O1xuXG4vLyBNZW51IGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IE1FTlUgPSB7XG4gICAgRURJVF9TSUdOQUw6IDAsXG4gICAgTkVXX1NJR05BTDogMSxcbiAgICBFRElUX1RSQUlOOiAyLFxuICAgIE5FV19UUkFJTjogMyxcbiAgICBORVdfT0JKRUNUOiA0LFxuICAgIEVESVRfT0JKRUNUOiA1LFxufTtcblxuXG5cbi8vIERlZmF1bHQgY29sb3JzXG5leHBvcnQgY29uc3QgQ09MT1JTID0ge1xuICAgIEdSSUQ6IFwiI2NjY1wiLFxuICAgIFNJR05BTF9QT1NJVElPTl9MSU5FOiBcIiNlMDBcIixcbiAgICBEUkFXSU5HX0JMVUVQUklOVDogXCJibHVlXCIsXG4gICAgRFJBV0lOR19BQ1RJVkU6IFwicmVkXCIsXG4gICAgVFJBTlNQQVJFTlQ6IFwiIzAwMDAwMDAwXCIsXG4gICAgXG4gICAgLy8gVHJhaW4gY29sb3JzXG4gICAgVFJBSU5fQ09MT1JTOiBbXCIjZmYwMDAwXCIsIFwiI2ZmZmYwMFwiLCBcIiMwMGZmMDBcIiwgXCIjMDAwMGZmXCJdLFxufTtcblxuLy8gRmlsZSBwYXRocyBhbmQgcmVzb3VyY2UgbG9jYXRpb25zXG5leHBvcnQgY29uc3QgUEFUSFMgPSB7XG4gICAgSU1BR0VTOiBcImltYWdlc1wiLFxuICAgIFBSRUJVSUxEUzogXCJwcmVidWlsZHMueG1sXCIsXG4gICAgRk9OVFM6IHtcbiAgICAgICAgQ09OREVOU0VEOiBcImNvbmRlbmNlZFwiLFxuICAgICAgICBBUklBTDogXCJBcmlhbFwiLFxuICAgICAgICBET1Q6IFwiRE9UXCIsXG4gICAgfSxcbn07XG5cbi8vIElucHV0IHNldHRpbmdzXG5leHBvcnQgY29uc3QgSU5QVVQgPSB7XG4gICAgTU9VU0VfTU9WRU1FTlRfVEhSRVNIT0xEOiA0LCAvLyBwaXhlbHNcbiAgICBUT1VDSF9TVVBQT1JURUQ6IHRydWUsXG4gICAgQ09OVEVYVF9NRU5VX0VOQUJMRUQ6IGZhbHNlLFxuICAgIFpPT01fU1RFUF9ESVZJU09SOiAxMDAwLFxufTtcblxuLy8gQ29udGFpbmVyIG5hbWVzIGZvciBDcmVhdGVKU1xuZXhwb3J0IGNvbnN0IENPTlRBSU5FUlMgPSB7XG4gICAgTUFJTjogXCJtYWluXCIsXG4gICAgREVCVUc6IFwiZGVidWdcIixcbiAgICBUUkFDS1M6IFwidHJhY2tzXCIsXG4gICAgT0JKRUNUUzogXCJvYmplY3RzXCIsXG4gICAgVFJBSU5TOiBcInRyYWluc1wiLFxuICAgIFNJR05BTFM6IFwic2lnbmFsc1wiLFxuICAgIFVJOiBcInVpXCIsXG4gICAgU0VMRUNUSU9OOiBcInNlbGVjdGlvblwiLFxuICAgIE9WRVJMQVk6IFwib3ZlcmxheVwiLFxuICAgIERSQVdJTkc6IFwiZHJhd2luZ19jb250YWluZXJcIixcbn07XG5cbi8vIERlZmF1bHQgZXhwb3J0IGZvciBjb252ZW5pZW5jZVxuZXhwb3J0IGRlZmF1bHQge1xuICAgIENPTkZJRyxcbiAgICBDT01QVVRFRCxcbiAgICBESVJFQ1RJT04sXG4gICAgTU9VU0VfRE9XTl9BQ1RJT04sXG4gICAgQ1VTVE9NX01PVVNFX0FDVElPTixcbiAgICBNRU5VLFxuICAgIENPTE9SUyxcbiAgICBQQVRIUyxcbiAgICBJTlBVVCxcbiAgICBDT05UQUlORVJTLFxufTsgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/config.js\n\n}");

/***/ }),

/***/ "./www/code/generic_object.js":
/*!************************************!*\
  !*** ./www/code/generic_object.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GenericObject: () => (/* binding */ GenericObject)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n/* harmony import */ var _application_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./application.js */ \"./www/code/application.js\");\n\n\n// ES6 Module imports\n\n\n\n\nclass GenericObject {\n   static OBJECT_TYPE = {\n      none: 0,\n      text: 1,\n      plattform: 2,\n   };\n\n   static all_objects = [];\n\n   static FromObject(o) {\n      return new GenericObject().pos(o.pos).size(o.size.width,o.size.height).type(o.type).content(o.content);\n   }\n\n   static removeObject(o) {\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.remove(this.all_objects, o);\n      _application_js__WEBPACK_IMPORTED_MODULE_2__.Application.getInstance().renderer.renderAllGenericObjects();\n      _application_js__WEBPACK_IMPORTED_MODULE_2__.Application.getInstance().stage.update();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.saveUndoHistory();\n   }\n\n   static initEditMenu(o) {\n      let header_text;\n      switch (o.type()) {\n         case GenericObject.OBJECT_TYPE.text:\n            header_text = \"Text\";\n            break;\n            case GenericObject.OBJECT_TYPE.plattform:\n               header_text = \"Bahnsteig\";\n               break;\n         default:\n            break;\n      }\n      $(\"#editObjectMenu h5\").text(header_text);\n\n      \n      $(\"#inputContent\")\n         .off()\n         .val(o.content())\n         .on(\"input\", function (e) {\n            o.content($(this).val());\n            _application_js__WEBPACK_IMPORTED_MODULE_2__.Application.getInstance().renderer.renderAllGenericObjects();\n            _application_js__WEBPACK_IMPORTED_MODULE_2__.Application.getInstance().renderer.updateSelection();\n            _application_js__WEBPACK_IMPORTED_MODULE_2__.Application.getInstance().stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n         });\n\n      $(\"#btnRemoveObject\")\n         .off()\n         .click(() => {\n            this.removeObject(o);\n            _application_js__WEBPACK_IMPORTED_MODULE_2__.Application.getInstance().selectObject()\n         });\n\n      setTimeout(() => {\n         $(\"#inputContent\").focus();\n      }, 50);\n   }\n\n   #_pos = { x: 0, y: 0 };\n   #_size = { width: 0, height: 0 };\n   #_type = GenericObject.OBJECT_TYPE.none;\n   #_content = \"\";\n\n   constructor(t = GenericObject.OBJECT_TYPE.none) {\n      this.#_type = t;\n   }\n\n   pos(p) {\n      if (p === undefined) return this.#_pos;\n      this.#_pos = p;\n      return this;\n   }\n\n   size(w,h) {\n      if (w === undefined) return this.#_size;\n      this.#_size.width = w;\n      this.#_size.height = h;\n      return this;\n   }\n\n   type(t) {\n      if (t === undefined) return this.#_type;\n      this.#_type = t;\n      return this;\n   }\n\n   content(c) {\n      if (c === undefined) return this.#_content;\n      this.#_content = c;\n      return this;\n   }\n\n   stringify() {\n      return { _class: \"GenericObject\", pos: this.#_pos, size: this.#_size, type: this.#_type, content: this.#_content };\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9nZW5lcmljX29iamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWE7O0FBRWI7QUFDd0M7QUFDRDtBQUNROztBQUV4QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxpREFBVTtBQUNoQixNQUFNLHdEQUFXO0FBQ2pCLE1BQU0sd0RBQVc7QUFDakIsTUFBTSxnREFBTztBQUNiLE1BQU0sZ0RBQU87QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCLFlBQVksd0RBQVc7QUFDdkIsWUFBWSx3REFBVztBQUN2QixZQUFZLGdEQUFPO0FBQ25CLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFXO0FBQ3ZCLFVBQVU7O0FBRVY7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxhQUFhO0FBQ2IsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2xlaXNwbGFuZWRpdG9yLy4vd3d3L2NvZGUvZ2VuZXJpY19vYmplY3QuanM/MjlmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gRVM2IE1vZHVsZSBpbXBvcnRzXG5pbXBvcnQgeyBBcnJheVV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBTVE9SQUdFIH0gZnJvbSAnLi9zdG9yYWdlLmpzJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSAnLi9hcHBsaWNhdGlvbi5qcyc7XG5cbmV4cG9ydCBjbGFzcyBHZW5lcmljT2JqZWN0IHtcbiAgIHN0YXRpYyBPQkpFQ1RfVFlQRSA9IHtcbiAgICAgIG5vbmU6IDAsXG4gICAgICB0ZXh0OiAxLFxuICAgICAgcGxhdHRmb3JtOiAyLFxuICAgfTtcblxuICAgc3RhdGljIGFsbF9vYmplY3RzID0gW107XG5cbiAgIHN0YXRpYyBGcm9tT2JqZWN0KG8pIHtcbiAgICAgIHJldHVybiBuZXcgR2VuZXJpY09iamVjdCgpLnBvcyhvLnBvcykuc2l6ZShvLnNpemUud2lkdGgsby5zaXplLmhlaWdodCkudHlwZShvLnR5cGUpLmNvbnRlbnQoby5jb250ZW50KTtcbiAgIH1cblxuICAgc3RhdGljIHJlbW92ZU9iamVjdChvKSB7XG4gICAgICBBcnJheVV0aWxzLnJlbW92ZSh0aGlzLmFsbF9vYmplY3RzLCBvKTtcbiAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkucmVuZGVyZXIucmVuZGVyQWxsR2VuZXJpY09iamVjdHMoKTtcbiAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuc3RhZ2UudXBkYXRlKCk7XG4gICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICB9XG5cbiAgIHN0YXRpYyBpbml0RWRpdE1lbnUobykge1xuICAgICAgbGV0IGhlYWRlcl90ZXh0O1xuICAgICAgc3dpdGNoIChvLnR5cGUoKSkge1xuICAgICAgICAgY2FzZSBHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLnRleHQ6XG4gICAgICAgICAgICBoZWFkZXJfdGV4dCA9IFwiVGV4dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEdlbmVyaWNPYmplY3QuT0JKRUNUX1RZUEUucGxhdHRmb3JtOlxuICAgICAgICAgICAgICAgaGVhZGVyX3RleHQgPSBcIkJhaG5zdGVpZ1wiO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAkKFwiI2VkaXRPYmplY3RNZW51IGg1XCIpLnRleHQoaGVhZGVyX3RleHQpO1xuXG4gICAgICBcbiAgICAgICQoXCIjaW5wdXRDb250ZW50XCIpXG4gICAgICAgICAub2ZmKClcbiAgICAgICAgIC52YWwoby5jb250ZW50KCkpXG4gICAgICAgICAub24oXCJpbnB1dFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgby5jb250ZW50KCQodGhpcykudmFsKCkpO1xuICAgICAgICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5yZW5kZXJlci5yZW5kZXJBbGxHZW5lcmljT2JqZWN0cygpO1xuICAgICAgICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5yZW5kZXJlci51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgIH0pO1xuXG4gICAgICAkKFwiI2J0blJlbW92ZU9iamVjdFwiKVxuICAgICAgICAgLm9mZigpXG4gICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVPYmplY3Qobyk7XG4gICAgICAgICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnNlbGVjdE9iamVjdCgpXG4gICAgICAgICB9KTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAkKFwiI2lucHV0Q29udGVudFwiKS5mb2N1cygpO1xuICAgICAgfSwgNTApO1xuICAgfVxuXG4gICAjX3BvcyA9IHsgeDogMCwgeTogMCB9O1xuICAgI19zaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAjX3R5cGUgPSBHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLm5vbmU7XG4gICAjX2NvbnRlbnQgPSBcIlwiO1xuXG4gICBjb25zdHJ1Y3Rvcih0ID0gR2VuZXJpY09iamVjdC5PQkpFQ1RfVFlQRS5ub25lKSB7XG4gICAgICB0aGlzLiNfdHlwZSA9IHQ7XG4gICB9XG5cbiAgIHBvcyhwKSB7XG4gICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy4jX3BvcztcbiAgICAgIHRoaXMuI19wb3MgPSBwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHNpemUodyxoKSB7XG4gICAgICBpZiAodyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy4jX3NpemU7XG4gICAgICB0aGlzLiNfc2l6ZS53aWR0aCA9IHc7XG4gICAgICB0aGlzLiNfc2l6ZS5oZWlnaHQgPSBoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHR5cGUodCkge1xuICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuI190eXBlO1xuICAgICAgdGhpcy4jX3R5cGUgPSB0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIGNvbnRlbnQoYykge1xuICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuI19jb250ZW50O1xuICAgICAgdGhpcy4jX2NvbnRlbnQgPSBjO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHN0cmluZ2lmeSgpIHtcbiAgICAgIHJldHVybiB7IF9jbGFzczogXCJHZW5lcmljT2JqZWN0XCIsIHBvczogdGhpcy4jX3Bvcywgc2l6ZTogdGhpcy4jX3NpemUsIHR5cGU6IHRoaXMuI190eXBlLCBjb250ZW50OiB0aGlzLiNfY29udGVudCB9O1xuICAgfVxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/generic_object.js\n\n}");

/***/ }),

/***/ "./www/code/preLoader.js":
/*!*******************************!*\
  !*** ./www/code/preLoader.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   preLoader: () => (/* binding */ preLoader)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n\n\n// ES6 Module imports\n\n\n\nclass preLoader {\n    constructor(basefolder) {\n        this._promises = [];\n        this._basefolder = basefolder;\n        if (basefolder.length > 0) this._basefolder += \"/\";\n        this._jsonFiles = [];\n        this._loadedItems = 0;\n        this._totalItems = 0;\n        this.onProgress = (progress) => {};\n        this._loadQueue = new createjs.LoadQueue(false, basefolder, false);\n        this._loadQueue.setMaxConnections(99);\n        /* this._loadQueue.on(\"fileload\", (e) => {\n            this._loadedItems++;\n            this.onProgress(this._loadedItems / this._totalItems);\n        }); */\n    }\n\n    get loaded() {\n        return this._loadQueue.loaded;\n    }\n\n    addSpriteSheet(json_file) {\n        if(!_utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.pushUnique(this._jsonFiles, json_file))return null;\n        \n        let p = new Promise((resolve, reject) => {\n            preLoader.getJson(this._basefolder + json_file + \".json\" + \"?\" + window.VERSION).then((imgCatalog) => {\n                let i = 0;\n                let img;\n                while (i < imgCatalog.length) {\n                    img = imgCatalog[i];\n                    img.src = json_file + \".png\" + \"?\" + window.VERSION;\n                    img.id = json_file + img.signal;\n                    i++;\n                }\n                this._totalItems+=imgCatalog.length;\n                this._loadQueue.loadManifest(imgCatalog, false, this._basefolder);\n                resolve();\n            });\n        });\n        this._promises.push(p);\n        return p;\n    }\n\n    addImage(src, id) {\n        this._totalItems++;\n        this._loadQueue.loadFile({ id: id, src: src, type: createjs.LoadQueue.IMAGE }, false, this._basefolder);\n    }\n\n    start() {\n        return new Promise((resolve, reject) => {\n            Promise.all(this._promises).then(() => {\n                this._loadQueue.addEventListener(\"error\", (e) => {\n                    _ui_js__WEBPACK_IMPORTED_MODULE_1__.ui.showInfoToast(e.title + \":\" + e.data.id);\n                });\n                this._loadQueue.addEventListener(\"fileload\", () => { this._loadedItems++; });\n                this._loadQueue.addEventListener(\"complete\", () => {\n                    resolve();\n                });\n\n                this._loadQueue.setPaused(false);\n            });\n        });\n    }\n\n    getSprite(json_file, texture_name) {\n        if (texture_name == null || texture_name == \"\") throw \"kein texture_name übergeben\";\n        if (json_file == null || json_file == \"\") throw \"kein signal_name übergeben\";\n        const id = json_file + texture_name;\n        const img = this._loadQueue.getResult(id);\n        if (img != null) {\n            let item = this._loadQueue._loadItemsById[id];\n            return new createjs.Bitmap(img).set({\n                name:texture_name,\n                y: item.pos.top,\n                x: item.pos.left,\n                sourceRect: new createjs.Rectangle(item.sourceRect.x, item.sourceRect.y, item.sourceRect.width, item.sourceRect.height),\n            });\n        } else console.log(id + \" nicht gefunden, nicht vom preLoader geladen\");\n\n        return null;\n    }\n\n    getImage(id) {\n        return this._loadQueue.getResult(id);\n    }\n\n    static getJson(file) {\n        return new Promise((resolve, reject) => {\n            $.getJSON(file, (data) => resolve(data));\n        });\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9wcmVMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7O0FBRWI7QUFDd0M7QUFDWDs7QUFFdEI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksaURBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsa0RBQWtEO0FBQ3JGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFFO0FBQ3RCLGlCQUFpQjtBQUNqQixxRUFBcUUsc0JBQXNCO0FBQzNGO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nbGVpc3BsYW5lZGl0b3IvLi93d3cvY29kZS9wcmVMb2FkZXIuanM/NzZhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gRVM2IE1vZHVsZSBpbXBvcnRzXG5pbXBvcnQgeyBBcnJheVV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB1aSB9IGZyb20gJy4vdWkuanMnO1xuXG5leHBvcnQgY2xhc3MgcHJlTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlZm9sZGVyKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2VzID0gW107XG4gICAgICAgIHRoaXMuX2Jhc2Vmb2xkZXIgPSBiYXNlZm9sZGVyO1xuICAgICAgICBpZiAoYmFzZWZvbGRlci5sZW5ndGggPiAwKSB0aGlzLl9iYXNlZm9sZGVyICs9IFwiL1wiO1xuICAgICAgICB0aGlzLl9qc29uRmlsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9hZGVkSXRlbXMgPSAwO1xuICAgICAgICB0aGlzLl90b3RhbEl0ZW1zID0gMDtcbiAgICAgICAgdGhpcy5vblByb2dyZXNzID0gKHByb2dyZXNzKSA9PiB7fTtcbiAgICAgICAgdGhpcy5fbG9hZFF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZShmYWxzZSwgYmFzZWZvbGRlciwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9sb2FkUXVldWUuc2V0TWF4Q29ubmVjdGlvbnMoOTkpO1xuICAgICAgICAvKiB0aGlzLl9sb2FkUXVldWUub24oXCJmaWxlbG9hZFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkSXRlbXMrKztcbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh0aGlzLl9sb2FkZWRJdGVtcyAvIHRoaXMuX3RvdGFsSXRlbXMpO1xuICAgICAgICB9KTsgKi9cbiAgICB9XG5cbiAgICBnZXQgbG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFF1ZXVlLmxvYWRlZDtcbiAgICB9XG5cbiAgICBhZGRTcHJpdGVTaGVldChqc29uX2ZpbGUpIHtcbiAgICAgICAgaWYoIUFycmF5VXRpbHMucHVzaFVuaXF1ZSh0aGlzLl9qc29uRmlsZXMsIGpzb25fZmlsZSkpcmV0dXJuIG51bGw7XG4gICAgICAgIFxuICAgICAgICBsZXQgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHByZUxvYWRlci5nZXRKc29uKHRoaXMuX2Jhc2Vmb2xkZXIgKyBqc29uX2ZpbGUgKyBcIi5qc29uXCIgKyBcIj9cIiArIHdpbmRvdy5WRVJTSU9OKS50aGVuKChpbWdDYXRhbG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBpbWc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpbWdDYXRhbG9nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbWcgPSBpbWdDYXRhbG9nW2ldO1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0ganNvbl9maWxlICsgXCIucG5nXCIgKyBcIj9cIiArIHdpbmRvdy5WRVJTSU9OO1xuICAgICAgICAgICAgICAgICAgICBpbWcuaWQgPSBqc29uX2ZpbGUgKyBpbWcuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdGFsSXRlbXMrPWltZ0NhdGFsb2cubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRRdWV1ZS5sb2FkTWFuaWZlc3QoaW1nQ2F0YWxvZywgZmFsc2UsIHRoaXMuX2Jhc2Vmb2xkZXIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZXMucHVzaChwKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgYWRkSW1hZ2Uoc3JjLCBpZCkge1xuICAgICAgICB0aGlzLl90b3RhbEl0ZW1zKys7XG4gICAgICAgIHRoaXMuX2xvYWRRdWV1ZS5sb2FkRmlsZSh7IGlkOiBpZCwgc3JjOiBzcmMsIHR5cGU6IGNyZWF0ZWpzLkxvYWRRdWV1ZS5JTUFHRSB9LCBmYWxzZSwgdGhpcy5fYmFzZWZvbGRlcik7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbCh0aGlzLl9wcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFF1ZXVlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1aS5zaG93SW5mb1RvYXN0KGUudGl0bGUgKyBcIjpcIiArIGUuZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFF1ZXVlLmFkZEV2ZW50TGlzdGVuZXIoXCJmaWxlbG9hZFwiLCAoKSA9PiB7IHRoaXMuX2xvYWRlZEl0ZW1zKys7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRRdWV1ZS5hZGRFdmVudExpc3RlbmVyKFwiY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkUXVldWUuc2V0UGF1c2VkKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRTcHJpdGUoanNvbl9maWxlLCB0ZXh0dXJlX25hbWUpIHtcbiAgICAgICAgaWYgKHRleHR1cmVfbmFtZSA9PSBudWxsIHx8IHRleHR1cmVfbmFtZSA9PSBcIlwiKSB0aHJvdyBcImtlaW4gdGV4dHVyZV9uYW1lIMO8YmVyZ2ViZW5cIjtcbiAgICAgICAgaWYgKGpzb25fZmlsZSA9PSBudWxsIHx8IGpzb25fZmlsZSA9PSBcIlwiKSB0aHJvdyBcImtlaW4gc2lnbmFsX25hbWUgw7xiZXJnZWJlblwiO1xuICAgICAgICBjb25zdCBpZCA9IGpzb25fZmlsZSArIHRleHR1cmVfbmFtZTtcbiAgICAgICAgY29uc3QgaW1nID0gdGhpcy5fbG9hZFF1ZXVlLmdldFJlc3VsdChpZCk7XG4gICAgICAgIGlmIChpbWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLl9sb2FkUXVldWUuX2xvYWRJdGVtc0J5SWRbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjcmVhdGVqcy5CaXRtYXAoaW1nKS5zZXQoe1xuICAgICAgICAgICAgICAgIG5hbWU6dGV4dHVyZV9uYW1lLFxuICAgICAgICAgICAgICAgIHk6IGl0ZW0ucG9zLnRvcCxcbiAgICAgICAgICAgICAgICB4OiBpdGVtLnBvcy5sZWZ0LFxuICAgICAgICAgICAgICAgIHNvdXJjZVJlY3Q6IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoaXRlbS5zb3VyY2VSZWN0LngsIGl0ZW0uc291cmNlUmVjdC55LCBpdGVtLnNvdXJjZVJlY3Qud2lkdGgsIGl0ZW0uc291cmNlUmVjdC5oZWlnaHQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBjb25zb2xlLmxvZyhpZCArIFwiIG5pY2h0IGdlZnVuZGVuLCBuaWNodCB2b20gcHJlTG9hZGVyIGdlbGFkZW5cIik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0SW1hZ2UoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRRdWV1ZS5nZXRSZXN1bHQoaWQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRKc29uKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICQuZ2V0SlNPTihmaWxlLCAoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/preLoader.js\n\n}");

/***/ }),

/***/ "./www/code/signal.js":
/*!****************************!*\
  !*** ./www/code/signal.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sig_UI: () => (/* binding */ Sig_UI),\n/* harmony export */   Signal: () => (/* binding */ Signal),\n/* harmony export */   SignalRenderer: () => (/* binding */ SignalRenderer)\n/* harmony export */ });\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _signaling_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./signaling.js */ \"./www/code/signaling.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config.js */ \"./www/code/config.js\");\n/* harmony import */ var _application_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./application.js */ \"./www/code/application.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\n\nclass SignalRenderer {\n   static #renderingState = new WeakMap();\n\n   static draw(signal, container, force = false) {\n      if (!SignalRenderer.#renderingState.has(signal) && (force || signal._changed)) {\n         SignalRenderer.#renderingState.set(signal, { container });\n\n         container.removeAllChildren();\n\n         signal._dontCache = false;\n         signal._template.elements.forEach((ve) => this.drawVisualElement(signal, ve));\n         signal._changed = false;\n         SignalRenderer.#renderingState.delete(signal);\n      }\n   }\n\n   static createSignalContainer(signal) {\n      let c = new createjs.Container();\n      c.name = \"signal\";\n      c.data = signal;\n      c.mouseChildren = false;\n      c.snapToPixel = true;\n      c.scale = signal._template.scale;\n   \n      signal.draw(c, true);\n      let sig_bounds = c.getBounds();\n      if (sig_bounds) {\n         // schläft fehl, wenn nichts gezeichnet wurde\n         let hit = new createjs.Shape();\n         hit.graphics.beginFill(\"#000\").drawRect(sig_bounds.x, sig_bounds.y, sig_bounds.width, sig_bounds.height);\n         c.hitArea = hit;\n   \n         c.regX = sig_bounds.width / 2 + sig_bounds.x;\n         c.regY = sig_bounds.height + sig_bounds.y;\n      } else console.error(\"Wahrscheinlich fehler beim Zeichen des Signals!\");\n   \n      return c;\n   }\n\n   static drawVisualElement(signal, ve) {\n      if (Array.isArray(ve)) ve.forEach((e) => this.drawVisualElement(signal, e));\n      else if (typeof ve == \"string\") {\n         this.addImageElement(signal, ve);\n      } else if (ve instanceof _signaling_js__WEBPACK_IMPORTED_MODULE_3__.TextElement) {\n         this.drawTextElement(signal, ve);\n      } else if (ve instanceof _signaling_js__WEBPACK_IMPORTED_MODULE_3__.VisualElement) {\n         if (ve.isAllowed(signal) && ve.isEnabled(signal)) {\n            if (ve.image) this.addImageElement(signal, ve, ve.blinkt());\n            ve.childs()?.forEach((c) => this.drawVisualElement(signal, c));\n         }\n      } else console.log(\"unknown type of VisualElement: \" + ve);\n      return false;\n   }\n\n   static drawTextElement(signal, ve) {\n      if (!ve.pos()) throw new Error(\"TextElement doesnt have a position\");\n      if (ve.isAllowed(signal) && ve.isEnabled(signal)) {\n         const formatString = (f) => `${f[2] ? \"bold\" : \"\"} ${f[0]}px ${f[1]}`;\n\n         let txt = ve.getText(signal);\n         if (txt == null) return false;\n         if (typeof txt == \"string\") txt = txt.replace(\"-\", \"\\n\");\n         let ar = (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.clone)(ve.format);\n         const displayObject = new createjs.Text(txt, formatString(ar), ve.color);\n         [displayObject.x, displayObject.y] = ve.pos();\n         displayObject.textAlign = \"center\";\n\n         let current_bounds, max_bounds;\n         do {\n            current_bounds = displayObject.getBounds();\n            max_bounds = ve.bounds();\n            if (max_bounds && (current_bounds.width > max_bounds[0] || current_bounds.height > max_bounds[1])) {\n               ar[0] -= 5;\n               displayObject.font = formatString(ar);\n               displayObject.lineHeight = ar[0];\n            } else break;\n         } while (true);\n         const state = SignalRenderer.#renderingState.get(signal);\n         state.container.addChild(displayObject);\n      }\n   }\n\n   static addImageElement(signal, ve, blinkt = false) {\n      const textureName = typeof ve == \"string\" ? ve : ve.image;\n\n      if (textureName == null || textureName == \"\") return;\n\n      if (textureName.includes(\",\", 1)) textureName.split(\",\").forEach((x) => this.addImageElement(signal, x));\n      else {\n         const state = SignalRenderer.#renderingState.get(signal);\n         if (!state.container.getChildByName(textureName)) {\n            //check if this texture was already drawn. Some texture are the same for different signals like Zs1 and Zs8\n            let bmp = _application_js__WEBPACK_IMPORTED_MODULE_7__.Application.getInstance().preLoader.getSprite(signal._template.json_file, textureName);\n            if (bmp != null) {\n               state.container.addChild(bmp);\n\n               if (blinkt) {\n                  signal._dontCache = true;\n                  createjs.Tween.get(bmp, { loop: true }).wait(1000).to({ alpha: 0 }, 200).wait(800).to({ alpha: 1 }, 50);\n               }\n\n               return bmp;\n            } else console.log(textureName + \" nicht gezeichnet, da sprite für \" + textureName + \" nicht erstellt wurde\");\n         }\n      }\n   }\n\n   static drawPreview(template, container) {\n      container.removeAllChildren();\n      // Create a minimal context for preview rendering\n      const previewContext = {\n         _template: template,\n         _signalStellung: {},\n         check: () => true, // For preview, always show all elements\n         get: () => null\n      };\n      \n      SignalRenderer.#renderingState.set(previewContext, { container });\n      // Use existing drawVisualElement but with our preview context\n      template.elements.forEach(ve => \n         this.drawVisualElement(previewContext, ve)\n      );\n      SignalRenderer.#renderingState.delete(previewContext);\n   }\n}\n\nclass Signal {\n   static allSignals = new Set();\n\n   static removeSignal(s) {\n      const track = _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.allTracks.find((t) => t.signals.includes(s));\n      if (track) {\n         track.removeSignal(s);\n      }\n      Signal.allSignals.delete(s);\n   }\n\n   \n\n   _template = null;\n   _signalStellung = {};\n   _positioning = {\n      track: null,\n      km: 0,\n      above: false,\n      flipped: false,\n   };\n   _changed = false;\n   _dontCache = false;\n\n   \n\n   constructor(template) {\n      this._template = template;\n      this._positioning = {\n         track: null,\n         km: 0,\n         above: false,\n         flipped: false\n      };\n      Signal.allSignals.add(this);\n      if (template.initialSignalStellung) template.initialSignalStellung.forEach((i) => this.set_stellung(i, true, false));\n   }\n\n   get title() {\n      let title = \"\";\n      if (this.check(\"HPsig\"))\n         switch (this.get(\"verw\")) {\n            case \"zsig\":\n               title += \"Zsig\";\n               break;\n            case \"esig\":\n               title += \"Esig\";\n               break;\n            case \"asig\":\n               title += \"Asig\";\n               break;\n            case \"bksig\":\n               title += \"Bk\";\n               break;\n            case \"sbk\":\n               title += \"Sbk\";\n               break;\n\n            default:\n               break;\n         }\n\n      const bez = this.get(\"bez\");\n      if (bez) title += (\" \" + bez).replace(\"-\", \" \");\n\n      return title;\n   }\n\n   //Setzt die Signalstellung, 2 Möglichkeiten:\n   //set(\"zs3\",60)\n   //set(\"hp\",1)\n   //oder\n   //set(\"hp=0\")\n   //set(\"ersatz=zs7\")\n   //set(\"hp=0,1\") der Value hat vorrang vor dem in stellung enthaltenen Value\n   //value=false schaltet die Signalstellung auf -1, also aus. Wird vom Menü zum ausschalten einer Signalstellung verwendet\n   //chain=false verhindert, dass das Signal versucht das davor und dahinterliegende Signal zu informieren\n   set_stellung(command, overideValue = true, chain = true) {\n      /* if (subkey == undefined) [command, subkey] = command.split(\"=\");\n      else [command] = command.split(\"=\"); */\n      let setting, value;\n      [setting, value] = command.split(\"=\");\n      if (overideValue === false) value = null; //false would be better but in javascript hp=0 and hp=false is the same\n      else if (value == undefined) value = overideValue;\n\n      if (this.get(setting) != value) {\n         if (value == null) this._signalStellung[setting] = null;\n         else if (!isNaN(value)) this._signalStellung[setting] = Number(value);\n         else this._signalStellung[setting] = value;\n\n         this._changed = true;\n      }\n\n      //Signal is actual positioned at a track (e.g. When Signal is created, there isnt a track yet)\n      //and the signal indication actualy changed\n      if (this._positioning.track && this._changed && chain) {\n         let stop = false;\n         if (this.check([\"HPsig||master\"])) {\n            let prevSignal = this;\n            do {\n               prevSignal = this.search4Signal(prevSignal, _config_js__WEBPACK_IMPORTED_MODULE_6__.DIRECTION.RIGHT_2_LEFT);\n               if (prevSignal && prevSignal._template.checkSignalDependency)\n                  stop = prevSignal._template.checkSignalDependency(prevSignal, this);\n            } while (!stop && prevSignal);\n         }\n         if (this.check([\"VRsig||slave\"]) && this._template.checkSignalDependency) {\n            let nextSignal = this;\n            do {\n               nextSignal = this.search4Signal(nextSignal, _config_js__WEBPACK_IMPORTED_MODULE_6__.DIRECTION.LEFT_2_RIGHT);\n               if (nextSignal && nextSignal._template.checkSignalDependency)\n                  stop = nextSignal._template.checkSignalDependency(this, nextSignal, [\"HPsig||master\"]);\n            } while (!stop && nextSignal);\n         }\n      }\n\n      if (this._changed)\n         this._template.rules.forEach(\n            function (rule) {\n               let trigger = rule[0];\n               let signal_aspect = rule[1];\n               if (!this.check(signal_aspect) && this.check(trigger)) this.set_stellung(signal_aspect);\n            }.bind(this)\n         );\n   }\n\n   //get value for a specific Stellung\n   //e.g. get(\"hp\") returns 0 for Hp 0\n   //can be used like this: get(\"hp\") > 0\n   get(stellung) {\n      let value = this._signalStellung[stellung];\n      if (value != undefined) return value;\n      else return null;\n   }\n\n   static _splitEquation(equation) {\n      const ret = {};\n      //the order is important, otherwise it would find '=' before '!='\n      //and OR ist prioritised before AND\n      const operators = [\"||\", \"&&\", \"!=\", \"<=\", \">=\", \"=\", \">\", \"<\"];\n      let parts;\n      for (let op of operators) {\n         parts = equation.split(op);\n         if (parts.length > 1) {\n            ret.operands = parts;\n            ret.operator = op;\n            break;\n         }\n      }\n\n      if (!ret.operator) return null;\n\n      return ret;\n   }\n\n   //checks if a specific Stellung is set\n   //e.g. get(\"hp=0\") returns true for Hp 0\n   check(stellung) {\n      if (stellung == null) return true;\n\n      if (Array.isArray(stellung)) return stellung.every(this.check.bind(this));\n\n      const equation = Signal._splitEquation(stellung);\n      if (equation == null) return this.get(stellung) != null;\n\n      switch (equation.operator) {\n         case \"&&\":\n            return equation.operands.every(this.check, this);\n         case \"||\":\n            return equation.operands.some(this.check, this);\n      }\n\n      let data = this.get(equation.operands[0].trim());\n      if (data === null) data = \"null\";\n      if (equation.operator == \"=\") return data == equation.operands[1].trim();\n      else {\n         const right = Number.parseInt(equation.operands[1].trim());\n         if (equation.operator == \"<\") return data < right;\n         else if (equation.operator == \"<=\") return data <= right;\n         else if (equation.operator == \">=\") return data >= right;\n         else if (equation.operator == \">\") return data > right;\n         else if (equation.operator == \"!=\") return data != right;\n      }\n   }\n\n   draw(c, force = false) {\n      SignalRenderer.draw(this, c, force);\n   }\n\n   search4Signal(signal, dir, feature) {\n      if (signal._positioning.above != signal._positioning.flipped) dir *= -1;\n\n      let track = signal._positioning.track;\n      let index = track.signals.indexOf(signal) + dir;\n      let sw = null;\n\n      //function checks, if this signal and the given signal belong together\n      /* above flipped above flipped result\n        0   \t0\t    0   \t0   \t1\n        0\t    1\t    0   \t0   \t0\n        0   \t0   \t0   \t1   \t0\n        0   \t1\t    0   \t1\t    1\n        1   \t0   \t0   \t0   \t0\n        0   \t0   \t1   \t0   \t0\n        1   \t0   \t1   \t0   \t1\n        0   \t0   \t1\t    1   \t1\n        1   \t1   \t0\t    0\t    1\n        0   \t1   \t1\t    0   \t1\n        1   \t0   \t0   \t1\t    1\n        1   \t1   \t1   \t0   \t0\n        0   \t1\t    1   \t1\t    0\n        1   \t1\t    1   \t1\t    1 \n        the hack is, that wehen all above and flipped are added, the number is even if they belong together*/\n      const check = function (pos) {\n         return (\n            (Number(signal._positioning.above) + Number(signal._positioning.flipped) + Number(pos.flipped) + Number(pos.above)) %\n               2 ==\n            0\n         );\n      };\n\n      const getTrackAtBranch = function (sw, track) {\n         if (track == sw.from) return sw.branch;\n         if (track == sw.branch) return sw.from;\n\n         return null;\n      };\n\n      while (track) {\n         while (dir == 1 ? index >= 0 && index < track.signals.length : index >= 0) {\n            let nextSignal = track.signals[index];\n            if (nextSignal.check(feature) && check(nextSignal._positioning)) {\n               return nextSignal; //hauptsignal gefunden\n            } else index = index + dir;\n         }\n\n         if ((sw = track.switches[dir == 1 ? 1 : 0])) {\n            if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.type)(sw) == \"Track\") track = sw;\n            else track = getTrackAtBranch(sw, track);\n\n            if (track) {\n               index = track.signals.length - 1;\n               if (dir == _config_js__WEBPACK_IMPORTED_MODULE_6__.DIRECTION.LEFT_2_RIGTH) index = Math.min(0, index);\n            }\n         } else track = null;\n      }\n   }\n\n   setTrack(track,km) {\n      if (this._positioning.track) {\n         _utils_js__WEBPACK_IMPORTED_MODULE_1__.ArrayUtils.remove(this._positioning.track.signals, this);\n      }\n      this._positioning.track = track;\n      this._positioning.km = km;\n      if (track) {\n         track.signals.push(this);\n      }\n   }\n\n   stringify() {\n      return {\n         _class: \"Signal\",\n         _template: (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.findFieldNameForObject)(window.signalTemplates, this._template),\n         _signalStellung: this._signalStellung,\n         _positioning: {\n            km: this._positioning.km,\n            above: this._positioning.above,\n            flipped: this._positioning.flipped,\n         },\n      };\n   }\n\n   static FromObject(o) {\n      let s = new Signal(window.signalTemplates[o._template]);      \n      s._signalStellung = o._signalStellung;\n      s._positioning = o._positioning;\n      return s;\n   }\n}\n\nconst Sig_UI = {\n   create_SpeedDropDown(signal, text, onChange) {\n      const items = Array.from({ length: 10 }, (_, i) => `${i}0|${signal}=${i}`);\n      items[0] = `aus|${signal}=-1`;\n      return _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.create_DropDown(items, text, onChange);\n   },\n   initSignalMenu() {\n      const conditions = window.selection.object._template.getAllVisualElementConditions();\n      const update = function (command, isOn) {\n         window.selection.object.set_stellung(command, isOn);\n         Sig_UI.syncSignalMenu(window.selection.object);\n         window.renderer.reDrawEverything();\n         _storage_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.save();\n      };\n      $(\"#btnRemoveSignal\").click((e) => window.deleteSelectedObject());\n      $(\"#navFeatures\").empty();\n               if (window.selection.object.check(\"HPsig\"))\n         $(\"#navFeatures\").append(\n            _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.div(\n               \"p-3 border-bottom\",\n               _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.create_DropDown(\n                  \"Esig,Asig,Zsig,Bksig,Sbk\".split(\",\").map((x) => x + \"|verw=\" + x.toLowerCase()),\n                  \"Verwendung\",\n                  update\n               )\n            )\n         );\n      $(\"#navFeatures\").append(\n         _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.createSwitchStructure(\n            [\"Vorsignalfunktion\", \"VRsig\", conditions.includes(\"VRsig\")],\n            [\n               ...(conditions.includes(\"vr_op=verk\") ? [[\"verkürzt\", \"vr_op=verk\"]] : []),\n               ...(conditions.includes(\"vr_op=wdh\") ? [[\"wiederholer\", \"vr_op=wdh\"]] : []),\n            ],\n            update\n         )?.addClass(\"p-3 border-bottom\")\n      );\n      if (conditions.includes(\"mastschild=wrw\") && conditions.includes(\"mastschild=wgwgw\"))\n         $(\"#navFeatures\").append(\n            _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.createOptionGroup(\n               \"Mastschild\",\n               [\n                  [\"W-R-W\", \"mastschild=wrw\"],\n                  [\"W-G-W-G-W\", \"mastschild=wgwgw\"],\n               ],\n               \"radio\",\n               update\n            ).addClass(\"p-3 border-bottom\")\n         );\n      if (conditions.includes(\"zusatz_unten\") || conditions.includes(\"zusatz_oben\")) {\n         const a = [\n            [\"unten\", \"zusatz_unten\"],\n            [\"oben\", \"zusatz_oben\"],\n         ];\n         a.forEach((x) => x.push(conditions.includes(x[1])));\n\n         $(\"#navFeatures\").append(_ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.createOptionGroup(\"Zusatzanzeiger\", a, \"checkbox\", update).addClass(\"p-3 border-bottom\"));\n      }\n   },\n   syncSignalMenu(signal) {\n      //header\n      $(\"#signalEditMenuHeader .card-title\").text(signal._template.title);\n      $(\"#signalEditMenuHeader .card-text>span\").text(signal.title);\n      //feature Menu\n      $(\"#navFeatures>div a\").each(function () {\n         const $a = $(this);\n         $a.toggleClass(\"active\", signal.check($a.attr(\"value\")));\n      });\n\n      $(\"#navFeatures>div input\").each(function () {\n         const input = $(this);\n         const v = signal.check(input.attr(\"value\"));\n         input.prop(\"checked\", v ? \"checked\" : null);\n         if (input.attr(\"data-master_switch\") != null) $(\"input\", input.parent().next()).prop(\"disabled\", !v);\n      });\n   },\n\n   getHTML(signal) {\n      if (signal._template.signalMenu?.length) {\n         const ul = _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.div(\"d-flex flex-column bd-highlight mb-3\");\n\n         const updateFunc = function (command, active) {\n            signal.set_stellung(command, !active);\n            window.renderer.reDrawEverything();\n            window.stage.update();\n            Sig_UI.checkBootstrapMenu(signal, signal._template.signalMenu, ul);\n            _storage_js__WEBPACK_IMPORTED_MODULE_5__.STORAGE.save();\n         };\n\n         ul.append(signal._template.signalMenu.map((data) => Sig_UI.createBootstrapMenuItems(signal, data, updateFunc)));\n\n         Sig_UI.checkBootstrapMenu(signal, signal._template.signalMenu, ul);\n\n         return ul;\n      }\n      return \"\";\n   },\n\n   createBootstrapMenuItems(signal, menu_item, update) {\n      if (menu_item) {\n         if (Array.isArray(menu_item)) {\n            let items = _utils_js__WEBPACK_IMPORTED_MODULE_1__.ArrayUtils.cleanUp(menu_item.map((item) => Sig_UI.createBootstrapMenuItems(signal, item, update)));\n            if (items) {\n               return _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.div(\"p-3 border-bottom\", _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.create_buttonToolbar(items));\n            } else return null;\n         } else if (menu_item.type == \"buttonGroup\" || menu_item.type == \"btn\") {\n            let buttons = menu_item.type == \"buttonGroup\" ? menu_item.items : [menu_item];\n            buttons = buttons\n               .filter(\n                  (mi) =>\n                     mi.visual_elements?.length > 0 &&\n                     mi.visual_elements.every((ve) => {\n                        let on = ve.on();\n                        if (Array.isArray(on)) {\n                           if (on.includes(mi.command)) on = on.toSpliced(on.indexOf(mi.command), 1);\n                        } else if (on == mi.command) return true;\n\n                        return signal.check(on);\n                     })\n               )\n               .map((item) =>\n                  _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui\n                     .create_toggleButton(item.text, item.command)\n                     .on(\"click\", (e) => update.bind(signal)(item.command, $(e.target).hasClass(\"active\")))\n               )\n            buttons = _utils_js__WEBPACK_IMPORTED_MODULE_1__.ArrayUtils.cleanUp(buttons);\n            if (buttons) return _ui_js__WEBPACK_IMPORTED_MODULE_0__.ui.create_buttonGroup(buttons);\n            else return null;\n         } else if (menu_item.type == \"dropdown\") {\n            return Sig_UI.create_SpeedDropDown(menu_item.command, menu_item.text, update.bind(signal));\n         }\n      }\n   },\n\n   checkBootstrapMenu(signal, data, popup) {\n      if (data) {\n         if (Array.isArray(data)) {\n            data.forEach((item) => Sig_UI.checkBootstrapMenu(signal, item, popup));\n         } else if (data.type == \"buttonGroup\") {\n            data.items.forEach((item) => {\n               let button = $(\"#btn_\" + item.text.replace(\" \", \"_\"), popup);\n               if (button.length == 1) {\n                  button.toggleClass(\"active\", signal.check(item.command));\n                  if (item.visual_elements.every((ve) => ve.isAllowed(signal))) button.removeAttr(\"disabled\");\n                  else button.attr(\"disabled\", \"disabled\");\n               }\n            });\n         } else if (data.type == \"dropdown\") {\n            let button = $(\"#btn_\" + data.text.replace(\" \", \"_\"), popup);\n            if (button.length == 1) {\n               const v = signal.get(data.command);\n               button.text(data.text + (v > 0 ? \" Kz \" + v : \" aus\"));\n            }\n         } else if (data.type == \"btn\") {\n            let button = $(\"#btn_\" + data.text.replace(\" \", \"_\"), popup);\n            if (button.length == 1) {\n               button.toggleClass(\"active\", signal.check(data.command));\n               if (data.visual_elements.every((ve) => ve.isAllowed(signal))) button.removeAttr(\"disabled\");\n               else button.attr(\"disabled\", \"disabled\");\n            }\n         }\n      }\n   },\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBLGtDQUFrQyxzQ0FBRTtBQUNwQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUk7O0FBRUo7QUFDQTtBQUNBLG9CQUFvQixzQ0FBRTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQU87QUFDbkI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQVU7QUFDbEM7QUFDQSxzQkFBc0Isc0NBQUUsMEJBQTBCLHNDQUFFO0FBQ3BELGNBQWM7QUFDZCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpREFBVTtBQUNoQyxnQ0FBZ0Msc0NBQUU7QUFDbEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2xlaXNwbGFuZWRpdG9yLy4vd3d3L2NvZGUvc2lnbmFsLmpzPzE2NDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgdWkgfSBmcm9tICcuL3VpLmpzJztcbmltcG9ydCB7IEFycmF5VXRpbHMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGNsb25lLCBmaW5kRmllbGROYW1lRm9yT2JqZWN0LCB0eXBlIH0gZnJvbSAnLi90b29scy5qcyc7XG5pbXBvcnQgeyBWaXN1YWxFbGVtZW50LCBUZXh0RWxlbWVudCB9IGZyb20gJy4vc2lnbmFsaW5nLmpzJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay5qcyc7XG5pbXBvcnQgeyBTVE9SQUdFIH0gZnJvbSAnLi9zdG9yYWdlLmpzJztcbmltcG9ydCB7IERJUkVDVElPTiB9IGZyb20gJy4vY29uZmlnLmpzJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSAnLi9hcHBsaWNhdGlvbi5qcyc7XG5cbmV4cG9ydCBjbGFzcyBTaWduYWxSZW5kZXJlciB7XG4gICBzdGF0aWMgI3JlbmRlcmluZ1N0YXRlID0gbmV3IFdlYWtNYXAoKTtcblxuICAgc3RhdGljIGRyYXcoc2lnbmFsLCBjb250YWluZXIsIGZvcmNlID0gZmFsc2UpIHtcbiAgICAgIGlmICghU2lnbmFsUmVuZGVyZXIuI3JlbmRlcmluZ1N0YXRlLmhhcyhzaWduYWwpICYmIChmb3JjZSB8fCBzaWduYWwuX2NoYW5nZWQpKSB7XG4gICAgICAgICBTaWduYWxSZW5kZXJlci4jcmVuZGVyaW5nU3RhdGUuc2V0KHNpZ25hbCwgeyBjb250YWluZXIgfSk7XG5cbiAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICAgICBzaWduYWwuX2RvbnRDYWNoZSA9IGZhbHNlO1xuICAgICAgICAgc2lnbmFsLl90ZW1wbGF0ZS5lbGVtZW50cy5mb3JFYWNoKCh2ZSkgPT4gdGhpcy5kcmF3VmlzdWFsRWxlbWVudChzaWduYWwsIHZlKSk7XG4gICAgICAgICBzaWduYWwuX2NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgIFNpZ25hbFJlbmRlcmVyLiNyZW5kZXJpbmdTdGF0ZS5kZWxldGUoc2lnbmFsKTtcbiAgICAgIH1cbiAgIH1cblxuICAgc3RhdGljIGNyZWF0ZVNpZ25hbENvbnRhaW5lcihzaWduYWwpIHtcbiAgICAgIGxldCBjID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgYy5uYW1lID0gXCJzaWduYWxcIjtcbiAgICAgIGMuZGF0YSA9IHNpZ25hbDtcbiAgICAgIGMubW91c2VDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgYy5zbmFwVG9QaXhlbCA9IHRydWU7XG4gICAgICBjLnNjYWxlID0gc2lnbmFsLl90ZW1wbGF0ZS5zY2FsZTtcbiAgIFxuICAgICAgc2lnbmFsLmRyYXcoYywgdHJ1ZSk7XG4gICAgICBsZXQgc2lnX2JvdW5kcyA9IGMuZ2V0Qm91bmRzKCk7XG4gICAgICBpZiAoc2lnX2JvdW5kcykge1xuICAgICAgICAgLy8gc2NobMOkZnQgZmVobCwgd2VubiBuaWNodHMgZ2V6ZWljaG5ldCB3dXJkZVxuICAgICAgICAgbGV0IGhpdCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICAgaGl0LmdyYXBoaWNzLmJlZ2luRmlsbChcIiMwMDBcIikuZHJhd1JlY3Qoc2lnX2JvdW5kcy54LCBzaWdfYm91bmRzLnksIHNpZ19ib3VuZHMud2lkdGgsIHNpZ19ib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgIGMuaGl0QXJlYSA9IGhpdDtcbiAgIFxuICAgICAgICAgYy5yZWdYID0gc2lnX2JvdW5kcy53aWR0aCAvIDIgKyBzaWdfYm91bmRzLng7XG4gICAgICAgICBjLnJlZ1kgPSBzaWdfYm91bmRzLmhlaWdodCArIHNpZ19ib3VuZHMueTtcbiAgICAgIH0gZWxzZSBjb25zb2xlLmVycm9yKFwiV2FocnNjaGVpbmxpY2ggZmVobGVyIGJlaW0gWmVpY2hlbiBkZXMgU2lnbmFscyFcIik7XG4gICBcbiAgICAgIHJldHVybiBjO1xuICAgfVxuXG4gICBzdGF0aWMgZHJhd1Zpc3VhbEVsZW1lbnQoc2lnbmFsLCB2ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmUpKSB2ZS5mb3JFYWNoKChlKSA9PiB0aGlzLmRyYXdWaXN1YWxFbGVtZW50KHNpZ25hbCwgZSkpO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIHZlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgIHRoaXMuYWRkSW1hZ2VFbGVtZW50KHNpZ25hbCwgdmUpO1xuICAgICAgfSBlbHNlIGlmICh2ZSBpbnN0YW5jZW9mIFRleHRFbGVtZW50KSB7XG4gICAgICAgICB0aGlzLmRyYXdUZXh0RWxlbWVudChzaWduYWwsIHZlKTtcbiAgICAgIH0gZWxzZSBpZiAodmUgaW5zdGFuY2VvZiBWaXN1YWxFbGVtZW50KSB7XG4gICAgICAgICBpZiAodmUuaXNBbGxvd2VkKHNpZ25hbCkgJiYgdmUuaXNFbmFibGVkKHNpZ25hbCkpIHtcbiAgICAgICAgICAgIGlmICh2ZS5pbWFnZSkgdGhpcy5hZGRJbWFnZUVsZW1lbnQoc2lnbmFsLCB2ZSwgdmUuYmxpbmt0KCkpO1xuICAgICAgICAgICAgdmUuY2hpbGRzKCk/LmZvckVhY2goKGMpID0+IHRoaXMuZHJhd1Zpc3VhbEVsZW1lbnQoc2lnbmFsLCBjKSk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2UgY29uc29sZS5sb2coXCJ1bmtub3duIHR5cGUgb2YgVmlzdWFsRWxlbWVudDogXCIgKyB2ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG5cbiAgIHN0YXRpYyBkcmF3VGV4dEVsZW1lbnQoc2lnbmFsLCB2ZSkge1xuICAgICAgaWYgKCF2ZS5wb3MoKSkgdGhyb3cgbmV3IEVycm9yKFwiVGV4dEVsZW1lbnQgZG9lc250IGhhdmUgYSBwb3NpdGlvblwiKTtcbiAgICAgIGlmICh2ZS5pc0FsbG93ZWQoc2lnbmFsKSAmJiB2ZS5pc0VuYWJsZWQoc2lnbmFsKSkge1xuICAgICAgICAgY29uc3QgZm9ybWF0U3RyaW5nID0gKGYpID0+IGAke2ZbMl0gPyBcImJvbGRcIiA6IFwiXCJ9ICR7ZlswXX1weCAke2ZbMV19YDtcblxuICAgICAgICAgbGV0IHR4dCA9IHZlLmdldFRleHQoc2lnbmFsKTtcbiAgICAgICAgIGlmICh0eHQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgaWYgKHR5cGVvZiB0eHQgPT0gXCJzdHJpbmdcIikgdHh0ID0gdHh0LnJlcGxhY2UoXCItXCIsIFwiXFxuXCIpO1xuICAgICAgICAgbGV0IGFyID0gY2xvbmUodmUuZm9ybWF0KTtcbiAgICAgICAgIGNvbnN0IGRpc3BsYXlPYmplY3QgPSBuZXcgY3JlYXRlanMuVGV4dCh0eHQsIGZvcm1hdFN0cmluZyhhciksIHZlLmNvbG9yKTtcbiAgICAgICAgIFtkaXNwbGF5T2JqZWN0LngsIGRpc3BsYXlPYmplY3QueV0gPSB2ZS5wb3MoKTtcbiAgICAgICAgIGRpc3BsYXlPYmplY3QudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcblxuICAgICAgICAgbGV0IGN1cnJlbnRfYm91bmRzLCBtYXhfYm91bmRzO1xuICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY3VycmVudF9ib3VuZHMgPSBkaXNwbGF5T2JqZWN0LmdldEJvdW5kcygpO1xuICAgICAgICAgICAgbWF4X2JvdW5kcyA9IHZlLmJvdW5kcygpO1xuICAgICAgICAgICAgaWYgKG1heF9ib3VuZHMgJiYgKGN1cnJlbnRfYm91bmRzLndpZHRoID4gbWF4X2JvdW5kc1swXSB8fCBjdXJyZW50X2JvdW5kcy5oZWlnaHQgPiBtYXhfYm91bmRzWzFdKSkge1xuICAgICAgICAgICAgICAgYXJbMF0gLT0gNTtcbiAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZm9udCA9IGZvcm1hdFN0cmluZyhhcik7XG4gICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmxpbmVIZWlnaHQgPSBhclswXTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgY29uc3Qgc3RhdGUgPSBTaWduYWxSZW5kZXJlci4jcmVuZGVyaW5nU3RhdGUuZ2V0KHNpZ25hbCk7XG4gICAgICAgICBzdGF0ZS5jb250YWluZXIuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XG4gICAgICB9XG4gICB9XG5cbiAgIHN0YXRpYyBhZGRJbWFnZUVsZW1lbnQoc2lnbmFsLCB2ZSwgYmxpbmt0ID0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHRleHR1cmVOYW1lID0gdHlwZW9mIHZlID09IFwic3RyaW5nXCIgPyB2ZSA6IHZlLmltYWdlO1xuXG4gICAgICBpZiAodGV4dHVyZU5hbWUgPT0gbnVsbCB8fCB0ZXh0dXJlTmFtZSA9PSBcIlwiKSByZXR1cm47XG5cbiAgICAgIGlmICh0ZXh0dXJlTmFtZS5pbmNsdWRlcyhcIixcIiwgMSkpIHRleHR1cmVOYW1lLnNwbGl0KFwiLFwiKS5mb3JFYWNoKCh4KSA9PiB0aGlzLmFkZEltYWdlRWxlbWVudChzaWduYWwsIHgpKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAgY29uc3Qgc3RhdGUgPSBTaWduYWxSZW5kZXJlci4jcmVuZGVyaW5nU3RhdGUuZ2V0KHNpZ25hbCk7XG4gICAgICAgICBpZiAoIXN0YXRlLmNvbnRhaW5lci5nZXRDaGlsZEJ5TmFtZSh0ZXh0dXJlTmFtZSkpIHtcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhpcyB0ZXh0dXJlIHdhcyBhbHJlYWR5IGRyYXduLiBTb21lIHRleHR1cmUgYXJlIHRoZSBzYW1lIGZvciBkaWZmZXJlbnQgc2lnbmFscyBsaWtlIFpzMSBhbmQgWnM4XG4gICAgICAgICAgICBsZXQgYm1wID0gQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5wcmVMb2FkZXIuZ2V0U3ByaXRlKHNpZ25hbC5fdGVtcGxhdGUuanNvbl9maWxlLCB0ZXh0dXJlTmFtZSk7XG4gICAgICAgICAgICBpZiAoYm1wICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgIHN0YXRlLmNvbnRhaW5lci5hZGRDaGlsZChibXApO1xuXG4gICAgICAgICAgICAgICBpZiAoYmxpbmt0KSB7XG4gICAgICAgICAgICAgICAgICBzaWduYWwuX2RvbnRDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQoYm1wLCB7IGxvb3A6IHRydWUgfSkud2FpdCgxMDAwKS50byh7IGFscGhhOiAwIH0sIDIwMCkud2FpdCg4MDApLnRvKHsgYWxwaGE6IDEgfSwgNTApO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICByZXR1cm4gYm1wO1xuICAgICAgICAgICAgfSBlbHNlIGNvbnNvbGUubG9nKHRleHR1cmVOYW1lICsgXCIgbmljaHQgZ2V6ZWljaG5ldCwgZGEgc3ByaXRlIGbDvHIgXCIgKyB0ZXh0dXJlTmFtZSArIFwiIG5pY2h0IGVyc3RlbGx0IHd1cmRlXCIpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuXG4gICBzdGF0aWMgZHJhd1ByZXZpZXcodGVtcGxhdGUsIGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAvLyBDcmVhdGUgYSBtaW5pbWFsIGNvbnRleHQgZm9yIHByZXZpZXcgcmVuZGVyaW5nXG4gICAgICBjb25zdCBwcmV2aWV3Q29udGV4dCA9IHtcbiAgICAgICAgIF90ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgICBfc2lnbmFsU3RlbGx1bmc6IHt9LFxuICAgICAgICAgY2hlY2s6ICgpID0+IHRydWUsIC8vIEZvciBwcmV2aWV3LCBhbHdheXMgc2hvdyBhbGwgZWxlbWVudHNcbiAgICAgICAgIGdldDogKCkgPT4gbnVsbFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgU2lnbmFsUmVuZGVyZXIuI3JlbmRlcmluZ1N0YXRlLnNldChwcmV2aWV3Q29udGV4dCwgeyBjb250YWluZXIgfSk7XG4gICAgICAvLyBVc2UgZXhpc3RpbmcgZHJhd1Zpc3VhbEVsZW1lbnQgYnV0IHdpdGggb3VyIHByZXZpZXcgY29udGV4dFxuICAgICAgdGVtcGxhdGUuZWxlbWVudHMuZm9yRWFjaCh2ZSA9PiBcbiAgICAgICAgIHRoaXMuZHJhd1Zpc3VhbEVsZW1lbnQocHJldmlld0NvbnRleHQsIHZlKVxuICAgICAgKTtcbiAgICAgIFNpZ25hbFJlbmRlcmVyLiNyZW5kZXJpbmdTdGF0ZS5kZWxldGUocHJldmlld0NvbnRleHQpO1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2lnbmFsIHtcbiAgIHN0YXRpYyBhbGxTaWduYWxzID0gbmV3IFNldCgpO1xuXG4gICBzdGF0aWMgcmVtb3ZlU2lnbmFsKHMpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gVHJhY2suYWxsVHJhY2tzLmZpbmQoKHQpID0+IHQuc2lnbmFscy5pbmNsdWRlcyhzKSk7XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgIHRyYWNrLnJlbW92ZVNpZ25hbChzKTtcbiAgICAgIH1cbiAgICAgIFNpZ25hbC5hbGxTaWduYWxzLmRlbGV0ZShzKTtcbiAgIH1cblxuICAgXG5cbiAgIF90ZW1wbGF0ZSA9IG51bGw7XG4gICBfc2lnbmFsU3RlbGx1bmcgPSB7fTtcbiAgIF9wb3NpdGlvbmluZyA9IHtcbiAgICAgIHRyYWNrOiBudWxsLFxuICAgICAga206IDAsXG4gICAgICBhYm92ZTogZmFsc2UsXG4gICAgICBmbGlwcGVkOiBmYWxzZSxcbiAgIH07XG4gICBfY2hhbmdlZCA9IGZhbHNlO1xuICAgX2RvbnRDYWNoZSA9IGZhbHNlO1xuXG4gICBcblxuICAgY29uc3RydWN0b3IodGVtcGxhdGUpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICB0aGlzLl9wb3NpdGlvbmluZyA9IHtcbiAgICAgICAgIHRyYWNrOiBudWxsLFxuICAgICAgICAga206IDAsXG4gICAgICAgICBhYm92ZTogZmFsc2UsXG4gICAgICAgICBmbGlwcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIFNpZ25hbC5hbGxTaWduYWxzLmFkZCh0aGlzKTtcbiAgICAgIGlmICh0ZW1wbGF0ZS5pbml0aWFsU2lnbmFsU3RlbGx1bmcpIHRlbXBsYXRlLmluaXRpYWxTaWduYWxTdGVsbHVuZy5mb3JFYWNoKChpKSA9PiB0aGlzLnNldF9zdGVsbHVuZyhpLCB0cnVlLCBmYWxzZSkpO1xuICAgfVxuXG4gICBnZXQgdGl0bGUoKSB7XG4gICAgICBsZXQgdGl0bGUgPSBcIlwiO1xuICAgICAgaWYgKHRoaXMuY2hlY2soXCJIUHNpZ1wiKSlcbiAgICAgICAgIHN3aXRjaCAodGhpcy5nZXQoXCJ2ZXJ3XCIpKSB7XG4gICAgICAgICAgICBjYXNlIFwienNpZ1wiOlxuICAgICAgICAgICAgICAgdGl0bGUgKz0gXCJac2lnXCI7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlc2lnXCI6XG4gICAgICAgICAgICAgICB0aXRsZSArPSBcIkVzaWdcIjtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFzaWdcIjpcbiAgICAgICAgICAgICAgIHRpdGxlICs9IFwiQXNpZ1wiO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYmtzaWdcIjpcbiAgICAgICAgICAgICAgIHRpdGxlICs9IFwiQmtcIjtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNia1wiOlxuICAgICAgICAgICAgICAgdGl0bGUgKz0gXCJTYmtcIjtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG5cbiAgICAgIGNvbnN0IGJleiA9IHRoaXMuZ2V0KFwiYmV6XCIpO1xuICAgICAgaWYgKGJleikgdGl0bGUgKz0gKFwiIFwiICsgYmV6KS5yZXBsYWNlKFwiLVwiLCBcIiBcIik7XG5cbiAgICAgIHJldHVybiB0aXRsZTtcbiAgIH1cblxuICAgLy9TZXR6dCBkaWUgU2lnbmFsc3RlbGx1bmcsIDIgTcO2Z2xpY2hrZWl0ZW46XG4gICAvL3NldChcInpzM1wiLDYwKVxuICAgLy9zZXQoXCJocFwiLDEpXG4gICAvL29kZXJcbiAgIC8vc2V0KFwiaHA9MFwiKVxuICAgLy9zZXQoXCJlcnNhdHo9enM3XCIpXG4gICAvL3NldChcImhwPTAsMVwiKSBkZXIgVmFsdWUgaGF0IHZvcnJhbmcgdm9yIGRlbSBpbiBzdGVsbHVuZyBlbnRoYWx0ZW5lbiBWYWx1ZVxuICAgLy92YWx1ZT1mYWxzZSBzY2hhbHRldCBkaWUgU2lnbmFsc3RlbGx1bmcgYXVmIC0xLCBhbHNvIGF1cy4gV2lyZCB2b20gTWVuw7wgenVtIGF1c3NjaGFsdGVuIGVpbmVyIFNpZ25hbHN0ZWxsdW5nIHZlcndlbmRldFxuICAgLy9jaGFpbj1mYWxzZSB2ZXJoaW5kZXJ0LCBkYXNzIGRhcyBTaWduYWwgdmVyc3VjaHQgZGFzIGRhdm9yIHVuZCBkYWhpbnRlcmxpZWdlbmRlIFNpZ25hbCB6dSBpbmZvcm1pZXJlblxuICAgc2V0X3N0ZWxsdW5nKGNvbW1hbmQsIG92ZXJpZGVWYWx1ZSA9IHRydWUsIGNoYWluID0gdHJ1ZSkge1xuICAgICAgLyogaWYgKHN1YmtleSA9PSB1bmRlZmluZWQpIFtjb21tYW5kLCBzdWJrZXldID0gY29tbWFuZC5zcGxpdChcIj1cIik7XG4gICAgICBlbHNlIFtjb21tYW5kXSA9IGNvbW1hbmQuc3BsaXQoXCI9XCIpOyAqL1xuICAgICAgbGV0IHNldHRpbmcsIHZhbHVlO1xuICAgICAgW3NldHRpbmcsIHZhbHVlXSA9IGNvbW1hbmQuc3BsaXQoXCI9XCIpO1xuICAgICAgaWYgKG92ZXJpZGVWYWx1ZSA9PT0gZmFsc2UpIHZhbHVlID0gbnVsbDsgLy9mYWxzZSB3b3VsZCBiZSBiZXR0ZXIgYnV0IGluIGphdmFzY3JpcHQgaHA9MCBhbmQgaHA9ZmFsc2UgaXMgdGhlIHNhbWVcbiAgICAgIGVsc2UgaWYgKHZhbHVlID09IHVuZGVmaW5lZCkgdmFsdWUgPSBvdmVyaWRlVmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLmdldChzZXR0aW5nKSAhPSB2YWx1ZSkge1xuICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHRoaXMuX3NpZ25hbFN0ZWxsdW5nW3NldHRpbmddID0gbnVsbDtcbiAgICAgICAgIGVsc2UgaWYgKCFpc05hTih2YWx1ZSkpIHRoaXMuX3NpZ25hbFN0ZWxsdW5nW3NldHRpbmddID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgIGVsc2UgdGhpcy5fc2lnbmFsU3RlbGx1bmdbc2V0dGluZ10gPSB2YWx1ZTtcblxuICAgICAgICAgdGhpcy5fY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vU2lnbmFsIGlzIGFjdHVhbCBwb3NpdGlvbmVkIGF0IGEgdHJhY2sgKGUuZy4gV2hlbiBTaWduYWwgaXMgY3JlYXRlZCwgdGhlcmUgaXNudCBhIHRyYWNrIHlldClcbiAgICAgIC8vYW5kIHRoZSBzaWduYWwgaW5kaWNhdGlvbiBhY3R1YWx5IGNoYW5nZWRcbiAgICAgIGlmICh0aGlzLl9wb3NpdGlvbmluZy50cmFjayAmJiB0aGlzLl9jaGFuZ2VkICYmIGNoYWluKSB7XG4gICAgICAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgaWYgKHRoaXMuY2hlY2soW1wiSFBzaWd8fG1hc3RlclwiXSkpIHtcbiAgICAgICAgICAgIGxldCBwcmV2U2lnbmFsID0gdGhpcztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgIHByZXZTaWduYWwgPSB0aGlzLnNlYXJjaDRTaWduYWwocHJldlNpZ25hbCwgRElSRUNUSU9OLlJJR0hUXzJfTEVGVCk7XG4gICAgICAgICAgICAgICBpZiAocHJldlNpZ25hbCAmJiBwcmV2U2lnbmFsLl90ZW1wbGF0ZS5jaGVja1NpZ25hbERlcGVuZGVuY3kpXG4gICAgICAgICAgICAgICAgICBzdG9wID0gcHJldlNpZ25hbC5fdGVtcGxhdGUuY2hlY2tTaWduYWxEZXBlbmRlbmN5KHByZXZTaWduYWwsIHRoaXMpO1xuICAgICAgICAgICAgfSB3aGlsZSAoIXN0b3AgJiYgcHJldlNpZ25hbCk7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAodGhpcy5jaGVjayhbXCJWUnNpZ3x8c2xhdmVcIl0pICYmIHRoaXMuX3RlbXBsYXRlLmNoZWNrU2lnbmFsRGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgbGV0IG5leHRTaWduYWwgPSB0aGlzO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgbmV4dFNpZ25hbCA9IHRoaXMuc2VhcmNoNFNpZ25hbChuZXh0U2lnbmFsLCBESVJFQ1RJT04uTEVGVF8yX1JJR0hUKTtcbiAgICAgICAgICAgICAgIGlmIChuZXh0U2lnbmFsICYmIG5leHRTaWduYWwuX3RlbXBsYXRlLmNoZWNrU2lnbmFsRGVwZW5kZW5jeSlcbiAgICAgICAgICAgICAgICAgIHN0b3AgPSBuZXh0U2lnbmFsLl90ZW1wbGF0ZS5jaGVja1NpZ25hbERlcGVuZGVuY3kodGhpcywgbmV4dFNpZ25hbCwgW1wiSFBzaWd8fG1hc3RlclwiXSk7XG4gICAgICAgICAgICB9IHdoaWxlICghc3RvcCAmJiBuZXh0U2lnbmFsKTtcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NoYW5nZWQpXG4gICAgICAgICB0aGlzLl90ZW1wbGF0ZS5ydWxlcy5mb3JFYWNoKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgICAgIGxldCB0cmlnZ2VyID0gcnVsZVswXTtcbiAgICAgICAgICAgICAgIGxldCBzaWduYWxfYXNwZWN0ID0gcnVsZVsxXTtcbiAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVjayhzaWduYWxfYXNwZWN0KSAmJiB0aGlzLmNoZWNrKHRyaWdnZXIpKSB0aGlzLnNldF9zdGVsbHVuZyhzaWduYWxfYXNwZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgKTtcbiAgIH1cblxuICAgLy9nZXQgdmFsdWUgZm9yIGEgc3BlY2lmaWMgU3RlbGx1bmdcbiAgIC8vZS5nLiBnZXQoXCJocFwiKSByZXR1cm5zIDAgZm9yIEhwIDBcbiAgIC8vY2FuIGJlIHVzZWQgbGlrZSB0aGlzOiBnZXQoXCJocFwiKSA+IDBcbiAgIGdldChzdGVsbHVuZykge1xuICAgICAgbGV0IHZhbHVlID0gdGhpcy5fc2lnbmFsU3RlbGx1bmdbc3RlbGx1bmddO1xuICAgICAgaWYgKHZhbHVlICE9IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xuICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgIH1cblxuICAgc3RhdGljIF9zcGxpdEVxdWF0aW9uKGVxdWF0aW9uKSB7XG4gICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgIC8vdGhlIG9yZGVyIGlzIGltcG9ydGFudCwgb3RoZXJ3aXNlIGl0IHdvdWxkIGZpbmQgJz0nIGJlZm9yZSAnIT0nXG4gICAgICAvL2FuZCBPUiBpc3QgcHJpb3JpdGlzZWQgYmVmb3JlIEFORFxuICAgICAgY29uc3Qgb3BlcmF0b3JzID0gW1wifHxcIiwgXCImJlwiLCBcIiE9XCIsIFwiPD1cIiwgXCI+PVwiLCBcIj1cIiwgXCI+XCIsIFwiPFwiXTtcbiAgICAgIGxldCBwYXJ0cztcbiAgICAgIGZvciAobGV0IG9wIG9mIG9wZXJhdG9ycykge1xuICAgICAgICAgcGFydHMgPSBlcXVhdGlvbi5zcGxpdChvcCk7XG4gICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0Lm9wZXJhbmRzID0gcGFydHM7XG4gICAgICAgICAgICByZXQub3BlcmF0b3IgPSBvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJldC5vcGVyYXRvcikgcmV0dXJuIG51bGw7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICB9XG5cbiAgIC8vY2hlY2tzIGlmIGEgc3BlY2lmaWMgU3RlbGx1bmcgaXMgc2V0XG4gICAvL2UuZy4gZ2V0KFwiaHA9MFwiKSByZXR1cm5zIHRydWUgZm9yIEhwIDBcbiAgIGNoZWNrKHN0ZWxsdW5nKSB7XG4gICAgICBpZiAoc3RlbGx1bmcgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0ZWxsdW5nKSkgcmV0dXJuIHN0ZWxsdW5nLmV2ZXJ5KHRoaXMuY2hlY2suYmluZCh0aGlzKSk7XG5cbiAgICAgIGNvbnN0IGVxdWF0aW9uID0gU2lnbmFsLl9zcGxpdEVxdWF0aW9uKHN0ZWxsdW5nKTtcbiAgICAgIGlmIChlcXVhdGlvbiA9PSBudWxsKSByZXR1cm4gdGhpcy5nZXQoc3RlbGx1bmcpICE9IG51bGw7XG5cbiAgICAgIHN3aXRjaCAoZXF1YXRpb24ub3BlcmF0b3IpIHtcbiAgICAgICAgIGNhc2UgXCImJlwiOlxuICAgICAgICAgICAgcmV0dXJuIGVxdWF0aW9uLm9wZXJhbmRzLmV2ZXJ5KHRoaXMuY2hlY2ssIHRoaXMpO1xuICAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgICByZXR1cm4gZXF1YXRpb24ub3BlcmFuZHMuc29tZSh0aGlzLmNoZWNrLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSB0aGlzLmdldChlcXVhdGlvbi5vcGVyYW5kc1swXS50cmltKCkpO1xuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIGRhdGEgPSBcIm51bGxcIjtcbiAgICAgIGlmIChlcXVhdGlvbi5vcGVyYXRvciA9PSBcIj1cIikgcmV0dXJuIGRhdGEgPT0gZXF1YXRpb24ub3BlcmFuZHNbMV0udHJpbSgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgICBjb25zdCByaWdodCA9IE51bWJlci5wYXJzZUludChlcXVhdGlvbi5vcGVyYW5kc1sxXS50cmltKCkpO1xuICAgICAgICAgaWYgKGVxdWF0aW9uLm9wZXJhdG9yID09IFwiPFwiKSByZXR1cm4gZGF0YSA8IHJpZ2h0O1xuICAgICAgICAgZWxzZSBpZiAoZXF1YXRpb24ub3BlcmF0b3IgPT0gXCI8PVwiKSByZXR1cm4gZGF0YSA8PSByaWdodDtcbiAgICAgICAgIGVsc2UgaWYgKGVxdWF0aW9uLm9wZXJhdG9yID09IFwiPj1cIikgcmV0dXJuIGRhdGEgPj0gcmlnaHQ7XG4gICAgICAgICBlbHNlIGlmIChlcXVhdGlvbi5vcGVyYXRvciA9PSBcIj5cIikgcmV0dXJuIGRhdGEgPiByaWdodDtcbiAgICAgICAgIGVsc2UgaWYgKGVxdWF0aW9uLm9wZXJhdG9yID09IFwiIT1cIikgcmV0dXJuIGRhdGEgIT0gcmlnaHQ7XG4gICAgICB9XG4gICB9XG5cbiAgIGRyYXcoYywgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgU2lnbmFsUmVuZGVyZXIuZHJhdyh0aGlzLCBjLCBmb3JjZSk7XG4gICB9XG5cbiAgIHNlYXJjaDRTaWduYWwoc2lnbmFsLCBkaXIsIGZlYXR1cmUpIHtcbiAgICAgIGlmIChzaWduYWwuX3Bvc2l0aW9uaW5nLmFib3ZlICE9IHNpZ25hbC5fcG9zaXRpb25pbmcuZmxpcHBlZCkgZGlyICo9IC0xO1xuXG4gICAgICBsZXQgdHJhY2sgPSBzaWduYWwuX3Bvc2l0aW9uaW5nLnRyYWNrO1xuICAgICAgbGV0IGluZGV4ID0gdHJhY2suc2lnbmFscy5pbmRleE9mKHNpZ25hbCkgKyBkaXI7XG4gICAgICBsZXQgc3cgPSBudWxsO1xuXG4gICAgICAvL2Z1bmN0aW9uIGNoZWNrcywgaWYgdGhpcyBzaWduYWwgYW5kIHRoZSBnaXZlbiBzaWduYWwgYmVsb25nIHRvZ2V0aGVyXG4gICAgICAvKiBhYm92ZSBmbGlwcGVkIGFib3ZlIGZsaXBwZWQgcmVzdWx0XG4gICAgICAgIDAgICBcdDBcdCAgICAwICAgXHQwICAgXHQxXG4gICAgICAgIDBcdCAgICAxXHQgICAgMCAgIFx0MCAgIFx0MFxuICAgICAgICAwICAgXHQwICAgXHQwICAgXHQxICAgXHQwXG4gICAgICAgIDAgICBcdDFcdCAgICAwICAgXHQxXHQgICAgMVxuICAgICAgICAxICAgXHQwICAgXHQwICAgXHQwICAgXHQwXG4gICAgICAgIDAgICBcdDAgICBcdDEgICBcdDAgICBcdDBcbiAgICAgICAgMSAgIFx0MCAgIFx0MSAgIFx0MCAgIFx0MVxuICAgICAgICAwICAgXHQwICAgXHQxXHQgICAgMSAgIFx0MVxuICAgICAgICAxICAgXHQxICAgXHQwXHQgICAgMFx0ICAgIDFcbiAgICAgICAgMCAgIFx0MSAgIFx0MVx0ICAgIDAgICBcdDFcbiAgICAgICAgMSAgIFx0MCAgIFx0MCAgIFx0MVx0ICAgIDFcbiAgICAgICAgMSAgIFx0MSAgIFx0MSAgIFx0MCAgIFx0MFxuICAgICAgICAwICAgXHQxXHQgICAgMSAgIFx0MVx0ICAgIDBcbiAgICAgICAgMSAgIFx0MVx0ICAgIDEgICBcdDFcdCAgICAxIFxuICAgICAgICB0aGUgaGFjayBpcywgdGhhdCB3ZWhlbiBhbGwgYWJvdmUgYW5kIGZsaXBwZWQgYXJlIGFkZGVkLCB0aGUgbnVtYmVyIGlzIGV2ZW4gaWYgdGhleSBiZWxvbmcgdG9nZXRoZXIqL1xuICAgICAgY29uc3QgY2hlY2sgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKE51bWJlcihzaWduYWwuX3Bvc2l0aW9uaW5nLmFib3ZlKSArIE51bWJlcihzaWduYWwuX3Bvc2l0aW9uaW5nLmZsaXBwZWQpICsgTnVtYmVyKHBvcy5mbGlwcGVkKSArIE51bWJlcihwb3MuYWJvdmUpKSAlXG4gICAgICAgICAgICAgICAyID09XG4gICAgICAgICAgICAwXG4gICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZ2V0VHJhY2tBdEJyYW5jaCA9IGZ1bmN0aW9uIChzdywgdHJhY2spIHtcbiAgICAgICAgIGlmICh0cmFjayA9PSBzdy5mcm9tKSByZXR1cm4gc3cuYnJhbmNoO1xuICAgICAgICAgaWYgKHRyYWNrID09IHN3LmJyYW5jaCkgcmV0dXJuIHN3LmZyb207XG5cbiAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHRyYWNrKSB7XG4gICAgICAgICB3aGlsZSAoZGlyID09IDEgPyBpbmRleCA+PSAwICYmIGluZGV4IDwgdHJhY2suc2lnbmFscy5sZW5ndGggOiBpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgbmV4dFNpZ25hbCA9IHRyYWNrLnNpZ25hbHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5leHRTaWduYWwuY2hlY2soZmVhdHVyZSkgJiYgY2hlY2sobmV4dFNpZ25hbC5fcG9zaXRpb25pbmcpKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpZ25hbDsgLy9oYXVwdHNpZ25hbCBnZWZ1bmRlblxuICAgICAgICAgICAgfSBlbHNlIGluZGV4ID0gaW5kZXggKyBkaXI7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICgoc3cgPSB0cmFjay5zd2l0Y2hlc1tkaXIgPT0gMSA/IDEgOiAwXSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlKHN3KSA9PSBcIlRyYWNrXCIpIHRyYWNrID0gc3c7XG4gICAgICAgICAgICBlbHNlIHRyYWNrID0gZ2V0VHJhY2tBdEJyYW5jaChzdywgdHJhY2spO1xuXG4gICAgICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgICAgIGluZGV4ID0gdHJhY2suc2lnbmFscy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgaWYgKGRpciA9PSBESVJFQ1RJT04uTEVGVF8yX1JJR1RIKSBpbmRleCA9IE1hdGgubWluKDAsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSB0cmFjayA9IG51bGw7XG4gICAgICB9XG4gICB9XG5cbiAgIHNldFRyYWNrKHRyYWNrLGttKSB7XG4gICAgICBpZiAodGhpcy5fcG9zaXRpb25pbmcudHJhY2spIHtcbiAgICAgICAgIEFycmF5VXRpbHMucmVtb3ZlKHRoaXMuX3Bvc2l0aW9uaW5nLnRyYWNrLnNpZ25hbHMsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcG9zaXRpb25pbmcudHJhY2sgPSB0cmFjaztcbiAgICAgIHRoaXMuX3Bvc2l0aW9uaW5nLmttID0ga207XG4gICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgIHRyYWNrLnNpZ25hbHMucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgIH1cblxuICAgc3RyaW5naWZ5KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIF9jbGFzczogXCJTaWduYWxcIixcbiAgICAgICAgIF90ZW1wbGF0ZTogZmluZEZpZWxkTmFtZUZvck9iamVjdCh3aW5kb3cuc2lnbmFsVGVtcGxhdGVzLCB0aGlzLl90ZW1wbGF0ZSksXG4gICAgICAgICBfc2lnbmFsU3RlbGx1bmc6IHRoaXMuX3NpZ25hbFN0ZWxsdW5nLFxuICAgICAgICAgX3Bvc2l0aW9uaW5nOiB7XG4gICAgICAgICAgICBrbTogdGhpcy5fcG9zaXRpb25pbmcua20sXG4gICAgICAgICAgICBhYm92ZTogdGhpcy5fcG9zaXRpb25pbmcuYWJvdmUsXG4gICAgICAgICAgICBmbGlwcGVkOiB0aGlzLl9wb3NpdGlvbmluZy5mbGlwcGVkLFxuICAgICAgICAgfSxcbiAgICAgIH07XG4gICB9XG5cbiAgIHN0YXRpYyBGcm9tT2JqZWN0KG8pIHtcbiAgICAgIGxldCBzID0gbmV3IFNpZ25hbCh3aW5kb3cuc2lnbmFsVGVtcGxhdGVzW28uX3RlbXBsYXRlXSk7ICAgICAgXG4gICAgICBzLl9zaWduYWxTdGVsbHVuZyA9IG8uX3NpZ25hbFN0ZWxsdW5nO1xuICAgICAgcy5fcG9zaXRpb25pbmcgPSBvLl9wb3NpdGlvbmluZztcbiAgICAgIHJldHVybiBzO1xuICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2lnX1VJID0ge1xuICAgY3JlYXRlX1NwZWVkRHJvcERvd24oc2lnbmFsLCB0ZXh0LCBvbkNoYW5nZSkge1xuICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMCB9LCAoXywgaSkgPT4gYCR7aX0wfCR7c2lnbmFsfT0ke2l9YCk7XG4gICAgICBpdGVtc1swXSA9IGBhdXN8JHtzaWduYWx9PS0xYDtcbiAgICAgIHJldHVybiB1aS5jcmVhdGVfRHJvcERvd24oaXRlbXMsIHRleHQsIG9uQ2hhbmdlKTtcbiAgIH0sXG4gICBpbml0U2lnbmFsTWVudSgpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB3aW5kb3cuc2VsZWN0aW9uLm9iamVjdC5fdGVtcGxhdGUuZ2V0QWxsVmlzdWFsRWxlbWVudENvbmRpdGlvbnMoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IGZ1bmN0aW9uIChjb21tYW5kLCBpc09uKSB7XG4gICAgICAgICB3aW5kb3cuc2VsZWN0aW9uLm9iamVjdC5zZXRfc3RlbGx1bmcoY29tbWFuZCwgaXNPbik7XG4gICAgICAgICBTaWdfVUkuc3luY1NpZ25hbE1lbnUod2luZG93LnNlbGVjdGlvbi5vYmplY3QpO1xuICAgICAgICAgd2luZG93LnJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcoKTtcbiAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgfTtcbiAgICAgICQoXCIjYnRuUmVtb3ZlU2lnbmFsXCIpLmNsaWNrKChlKSA9PiB3aW5kb3cuZGVsZXRlU2VsZWN0ZWRPYmplY3QoKSk7XG4gICAgICAkKFwiI25hdkZlYXR1cmVzXCIpLmVtcHR5KCk7XG4gICAgICAgICAgICAgICBpZiAod2luZG93LnNlbGVjdGlvbi5vYmplY3QuY2hlY2soXCJIUHNpZ1wiKSlcbiAgICAgICAgICQoXCIjbmF2RmVhdHVyZXNcIikuYXBwZW5kKFxuICAgICAgICAgICAgdWkuZGl2KFxuICAgICAgICAgICAgICAgXCJwLTMgYm9yZGVyLWJvdHRvbVwiLFxuICAgICAgICAgICAgICAgdWkuY3JlYXRlX0Ryb3BEb3duKFxuICAgICAgICAgICAgICAgICAgXCJFc2lnLEFzaWcsWnNpZyxCa3NpZyxTYmtcIi5zcGxpdChcIixcIikubWFwKCh4KSA9PiB4ICsgXCJ8dmVydz1cIiArIHgudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICAgICAgICBcIlZlcndlbmR1bmdcIixcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVxuICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgKTtcbiAgICAgICQoXCIjbmF2RmVhdHVyZXNcIikuYXBwZW5kKFxuICAgICAgICAgdWkuY3JlYXRlU3dpdGNoU3RydWN0dXJlKFxuICAgICAgICAgICAgW1wiVm9yc2lnbmFsZnVua3Rpb25cIiwgXCJWUnNpZ1wiLCBjb25kaXRpb25zLmluY2x1ZGVzKFwiVlJzaWdcIildLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgLi4uKGNvbmRpdGlvbnMuaW5jbHVkZXMoXCJ2cl9vcD12ZXJrXCIpID8gW1tcInZlcmvDvHJ6dFwiLCBcInZyX29wPXZlcmtcIl1dIDogW10pLFxuICAgICAgICAgICAgICAgLi4uKGNvbmRpdGlvbnMuaW5jbHVkZXMoXCJ2cl9vcD13ZGhcIikgPyBbW1wid2llZGVyaG9sZXJcIiwgXCJ2cl9vcD13ZGhcIl1dIDogW10pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHVwZGF0ZVxuICAgICAgICAgKT8uYWRkQ2xhc3MoXCJwLTMgYm9yZGVyLWJvdHRvbVwiKVxuICAgICAgKTtcbiAgICAgIGlmIChjb25kaXRpb25zLmluY2x1ZGVzKFwibWFzdHNjaGlsZD13cndcIikgJiYgY29uZGl0aW9ucy5pbmNsdWRlcyhcIm1hc3RzY2hpbGQ9d2d3Z3dcIikpXG4gICAgICAgICAkKFwiI25hdkZlYXR1cmVzXCIpLmFwcGVuZChcbiAgICAgICAgICAgIHVpLmNyZWF0ZU9wdGlvbkdyb3VwKFxuICAgICAgICAgICAgICAgXCJNYXN0c2NoaWxkXCIsXG4gICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBbXCJXLVItV1wiLCBcIm1hc3RzY2hpbGQ9d3J3XCJdLFxuICAgICAgICAgICAgICAgICAgW1wiVy1HLVctRy1XXCIsIFwibWFzdHNjaGlsZD13Z3dnd1wiXSxcbiAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICBcInJhZGlvXCIsXG4gICAgICAgICAgICAgICB1cGRhdGVcbiAgICAgICAgICAgICkuYWRkQ2xhc3MoXCJwLTMgYm9yZGVyLWJvdHRvbVwiKVxuICAgICAgICAgKTtcbiAgICAgIGlmIChjb25kaXRpb25zLmluY2x1ZGVzKFwienVzYXR6X3VudGVuXCIpIHx8IGNvbmRpdGlvbnMuaW5jbHVkZXMoXCJ6dXNhdHpfb2JlblwiKSkge1xuICAgICAgICAgY29uc3QgYSA9IFtcbiAgICAgICAgICAgIFtcInVudGVuXCIsIFwienVzYXR6X3VudGVuXCJdLFxuICAgICAgICAgICAgW1wib2JlblwiLCBcInp1c2F0el9vYmVuXCJdLFxuICAgICAgICAgXTtcbiAgICAgICAgIGEuZm9yRWFjaCgoeCkgPT4geC5wdXNoKGNvbmRpdGlvbnMuaW5jbHVkZXMoeFsxXSkpKTtcblxuICAgICAgICAgJChcIiNuYXZGZWF0dXJlc1wiKS5hcHBlbmQodWkuY3JlYXRlT3B0aW9uR3JvdXAoXCJadXNhdHphbnplaWdlclwiLCBhLCBcImNoZWNrYm94XCIsIHVwZGF0ZSkuYWRkQ2xhc3MoXCJwLTMgYm9yZGVyLWJvdHRvbVwiKSk7XG4gICAgICB9XG4gICB9LFxuICAgc3luY1NpZ25hbE1lbnUoc2lnbmFsKSB7XG4gICAgICAvL2hlYWRlclxuICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciAuY2FyZC10aXRsZVwiKS50ZXh0KHNpZ25hbC5fdGVtcGxhdGUudGl0bGUpO1xuICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciAuY2FyZC10ZXh0PnNwYW5cIikudGV4dChzaWduYWwudGl0bGUpO1xuICAgICAgLy9mZWF0dXJlIE1lbnVcbiAgICAgICQoXCIjbmF2RmVhdHVyZXM+ZGl2IGFcIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICBjb25zdCAkYSA9ICQodGhpcyk7XG4gICAgICAgICAkYS50b2dnbGVDbGFzcyhcImFjdGl2ZVwiLCBzaWduYWwuY2hlY2soJGEuYXR0cihcInZhbHVlXCIpKSk7XG4gICAgICB9KTtcblxuICAgICAgJChcIiNuYXZGZWF0dXJlcz5kaXYgaW5wdXRcIikuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICBjb25zdCBpbnB1dCA9ICQodGhpcyk7XG4gICAgICAgICBjb25zdCB2ID0gc2lnbmFsLmNoZWNrKGlucHV0LmF0dHIoXCJ2YWx1ZVwiKSk7XG4gICAgICAgICBpbnB1dC5wcm9wKFwiY2hlY2tlZFwiLCB2ID8gXCJjaGVja2VkXCIgOiBudWxsKTtcbiAgICAgICAgIGlmIChpbnB1dC5hdHRyKFwiZGF0YS1tYXN0ZXJfc3dpdGNoXCIpICE9IG51bGwpICQoXCJpbnB1dFwiLCBpbnB1dC5wYXJlbnQoKS5uZXh0KCkpLnByb3AoXCJkaXNhYmxlZFwiLCAhdik7XG4gICAgICB9KTtcbiAgIH0sXG5cbiAgIGdldEhUTUwoc2lnbmFsKSB7XG4gICAgICBpZiAoc2lnbmFsLl90ZW1wbGF0ZS5zaWduYWxNZW51Py5sZW5ndGgpIHtcbiAgICAgICAgIGNvbnN0IHVsID0gdWkuZGl2KFwiZC1mbGV4IGZsZXgtY29sdW1uIGJkLWhpZ2hsaWdodCBtYi0zXCIpO1xuXG4gICAgICAgICBjb25zdCB1cGRhdGVGdW5jID0gZnVuY3Rpb24gKGNvbW1hbmQsIGFjdGl2ZSkge1xuICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhjb21tYW5kLCAhYWN0aXZlKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKCk7XG4gICAgICAgICAgICB3aW5kb3cuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICBTaWdfVUkuY2hlY2tCb290c3RyYXBNZW51KHNpZ25hbCwgc2lnbmFsLl90ZW1wbGF0ZS5zaWduYWxNZW51LCB1bCk7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgIH07XG5cbiAgICAgICAgIHVsLmFwcGVuZChzaWduYWwuX3RlbXBsYXRlLnNpZ25hbE1lbnUubWFwKChkYXRhKSA9PiBTaWdfVUkuY3JlYXRlQm9vdHN0cmFwTWVudUl0ZW1zKHNpZ25hbCwgZGF0YSwgdXBkYXRlRnVuYykpKTtcblxuICAgICAgICAgU2lnX1VJLmNoZWNrQm9vdHN0cmFwTWVudShzaWduYWwsIHNpZ25hbC5fdGVtcGxhdGUuc2lnbmFsTWVudSwgdWwpO1xuXG4gICAgICAgICByZXR1cm4gdWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgIH0sXG5cbiAgIGNyZWF0ZUJvb3RzdHJhcE1lbnVJdGVtcyhzaWduYWwsIG1lbnVfaXRlbSwgdXBkYXRlKSB7XG4gICAgICBpZiAobWVudV9pdGVtKSB7XG4gICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtZW51X2l0ZW0pKSB7XG4gICAgICAgICAgICBsZXQgaXRlbXMgPSBBcnJheVV0aWxzLmNsZWFuVXAobWVudV9pdGVtLm1hcCgoaXRlbSkgPT4gU2lnX1VJLmNyZWF0ZUJvb3RzdHJhcE1lbnVJdGVtcyhzaWduYWwsIGl0ZW0sIHVwZGF0ZSkpKTtcbiAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgcmV0dXJuIHVpLmRpdihcInAtMyBib3JkZXItYm90dG9tXCIsIHVpLmNyZWF0ZV9idXR0b25Ub29sYmFyKGl0ZW1zKSk7XG4gICAgICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICAgICB9IGVsc2UgaWYgKG1lbnVfaXRlbS50eXBlID09IFwiYnV0dG9uR3JvdXBcIiB8fCBtZW51X2l0ZW0udHlwZSA9PSBcImJ0blwiKSB7XG4gICAgICAgICAgICBsZXQgYnV0dG9ucyA9IG1lbnVfaXRlbS50eXBlID09IFwiYnV0dG9uR3JvdXBcIiA/IG1lbnVfaXRlbS5pdGVtcyA6IFttZW51X2l0ZW1dO1xuICAgICAgICAgICAgYnV0dG9ucyA9IGJ1dHRvbnNcbiAgICAgICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAobWkpID0+XG4gICAgICAgICAgICAgICAgICAgICBtaS52aXN1YWxfZWxlbWVudHM/Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIG1pLnZpc3VhbF9lbGVtZW50cy5ldmVyeSgodmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbiA9IHZlLm9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbi5pbmNsdWRlcyhtaS5jb21tYW5kKSkgb24gPSBvbi50b1NwbGljZWQob24uaW5kZXhPZihtaS5jb21tYW5kKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9uID09IG1pLmNvbW1hbmQpIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsLmNoZWNrKG9uKTtcbiAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PlxuICAgICAgICAgICAgICAgICAgdWlcbiAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVfdG9nZ2xlQnV0dG9uKGl0ZW0udGV4dCwgaXRlbS5jb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgKGUpID0+IHVwZGF0ZS5iaW5kKHNpZ25hbCkoaXRlbS5jb21tYW5kLCAkKGUudGFyZ2V0KS5oYXNDbGFzcyhcImFjdGl2ZVwiKSkpXG4gICAgICAgICAgICAgICApXG4gICAgICAgICAgICBidXR0b25zID0gQXJyYXlVdGlscy5jbGVhblVwKGJ1dHRvbnMpO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbnMpIHJldHVybiB1aS5jcmVhdGVfYnV0dG9uR3JvdXAoYnV0dG9ucyk7XG4gICAgICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICAgfSBlbHNlIGlmIChtZW51X2l0ZW0udHlwZSA9PSBcImRyb3Bkb3duXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBTaWdfVUkuY3JlYXRlX1NwZWVkRHJvcERvd24obWVudV9pdGVtLmNvbW1hbmQsIG1lbnVfaXRlbS50ZXh0LCB1cGRhdGUuYmluZChzaWduYWwpKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH0sXG5cbiAgIGNoZWNrQm9vdHN0cmFwTWVudShzaWduYWwsIGRhdGEsIHBvcHVwKSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaCgoaXRlbSkgPT4gU2lnX1VJLmNoZWNrQm9vdHN0cmFwTWVudShzaWduYWwsIGl0ZW0sIHBvcHVwKSk7XG4gICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PSBcImJ1dHRvbkdyb3VwXCIpIHtcbiAgICAgICAgICAgIGRhdGEuaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgbGV0IGJ1dHRvbiA9ICQoXCIjYnRuX1wiICsgaXRlbS50ZXh0LnJlcGxhY2UoXCIgXCIsIFwiX1wiKSwgcG9wdXApO1xuICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgYnV0dG9uLnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIsIHNpZ25hbC5jaGVjayhpdGVtLmNvbW1hbmQpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnZpc3VhbF9lbGVtZW50cy5ldmVyeSgodmUpID0+IHZlLmlzQWxsb3dlZChzaWduYWwpKSkgYnV0dG9uLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgYnV0dG9uLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PSBcImRyb3Bkb3duXCIpIHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSAkKFwiI2J0bl9cIiArIGRhdGEudGV4dC5yZXBsYWNlKFwiIFwiLCBcIl9cIiksIHBvcHVwKTtcbiAgICAgICAgICAgIGlmIChidXR0b24ubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzaWduYWwuZ2V0KGRhdGEuY29tbWFuZCk7XG4gICAgICAgICAgICAgICBidXR0b24udGV4dChkYXRhLnRleHQgKyAodiA+IDAgPyBcIiBLeiBcIiArIHYgOiBcIiBhdXNcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT0gXCJidG5cIikge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9ICQoXCIjYnRuX1wiICsgZGF0YS50ZXh0LnJlcGxhY2UoXCIgXCIsIFwiX1wiKSwgcG9wdXApO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbi5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgYnV0dG9uLnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIsIHNpZ25hbC5jaGVjayhkYXRhLmNvbW1hbmQpKTtcbiAgICAgICAgICAgICAgIGlmIChkYXRhLnZpc3VhbF9lbGVtZW50cy5ldmVyeSgodmUpID0+IHZlLmlzQWxsb3dlZChzaWduYWwpKSkgYnV0dG9uLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgIGVsc2UgYnV0dG9uLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfSxcbn07XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/signal.js\n\n}");

/***/ }),

/***/ "./www/code/signal_library.js":
/*!************************************!*\
  !*** ./www/code/signal_library.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONDITIONS: () => (/* binding */ CONDITIONS),\n/* harmony export */   initSignals: () => (/* binding */ initSignals)\n/* harmony export */ });\n/* harmony import */ var _signaling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signaling.js */ \"./www/code/signaling.js\");\n\n\n// ES6 Module imports\n\n\nconst CONDITIONS = (function () {\n   const BKsig = \"verw=bksig\",\n      SBK = \"verw=sbk\",\n      Esig = \"verw=esig\",\n      Asig = \"verw=asig\",\n      Zsig = \"verw=zsig\",\n      STRECKE = [BKsig, SBK, Esig],\n      GRENZEN = [BKsig, Esig],\n      BAHNHOF = [Asig, Zsig];\n   return { BKsig, SBK, Esig, Asig, Zsig, STRECKE, GRENZEN, BAHNHOF };\n})();\n\nfunction initSignals(signalTemplatesRef) {\n   // Use the passed signalTemplates reference instead of a module-level variable\n   const signalTemplates = signalTemplatesRef;\n   const lightMenu = [\n      [\"hp=0,hp=1,hp=2\", \"zs3\"],\n      [\"vr=0,vr=1,vr=2\", \"verk=1(verk)\", \"zs3v\"],\n      \"ersatz=zs1,ersatz=zs7,ersatz=zs8,ersatz=sh1,ersatz=kennlicht\",\n      \"zs6=1(Zs 6)\",\n   ];\n\n   //signal: ist das signal, dessen Stellung wir gerade setzen\n   //hp: ist das signal, dessen Stellung wir vorsignalisieren wollen\n   const checkSignalDependencyFunction4HV = function (signal, hp) {\n      //make sure we only handle main signals\n      if (!hp.check(\"HPsig\") || !signal.check(\"VRsig\")) return;\n      let stop_propagation = false;\n\n      //-1 heißt, die Vorsignalfunktion ist vom User ausgeschaltet\n      if (signal.get(\"vr\") != -1) {\n         //Das Hauptsignal zeigt nicht Hp 0 oder es ist ein alleinstehndes Vorsignal\n         if (!signal.check(\"HPsig\") || signal.get(\"hp\") != 0) {\n            switch (hp._template.id) {\n               case \"Hv77\":\n               case \"hv_hp\":\n               case \"hv_vr\":\n                  {\n                     signal.set_stellung(\"vr\", hp.get(\"hp\") >= 0 ? hp.get(\"hp\") : 0, false);\n                     if (!signal.check(\"vr_op=wdh\")) stop_propagation = true;\n                  }\n                  break;\n               case \"Hl\":\n               case \"ks\":\n               case \"ks_vr\":\n                  {\n                     signal.set_stellung(\"vr\", hp.get(\"hp\") <= 0 ? 0 : 1, false);\n                     if (!signal.check(\"vr_op=wdh\")) stop_propagation = true;\n                  }\n                  break;\n            }\n\n            if (hp.get(\"zs3\") == 4) {\n               signal.set_stellung(\"zs3v\", 0, false);\n\n               if (signal.get(\"vr\") > 0) signal.set_stellung(\"vr\", 2, false);\n            } else signal.set_stellung(\"zs3v\", hp.get(\"zs3\"), false);\n\n            //if (hp.get(\"zs3\").between(1,6) && hp.get(\"hp\") > 0) signal.set_stellung(\"vr\", 2, false);\n         }\n      }\n\n      return stop_propagation;\n   };\n\n   let t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"hv_hp\",\n      \"Hv Hauptsignal\",\n      \"hv\",\n      [\n         \"mast,hp_schirm\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"wrw\").on(\"mastschild=wrw\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"wgwgw\").on(\"mastschild=wgwgw\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_lichtp\").on(CONDITIONS.BAHNHOF),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_lichtp_unten\").on(CONDITIONS.STRECKE),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_lichtp_oben\").on(CONDITIONS.GRENZEN),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=0\")\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_rot_re\").on(CONDITIONS.BAHNHOF).off(\"ersatz=sh1\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_rot_li\").on(CONDITIONS.BAHNHOF),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_rot_unten_li\").on(CONDITIONS.STRECKE),\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=1\")\n            .off(\"zs3<=6 && zs3>0\") //used by UI to disable the corospoding button\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_gr\").on(CONDITIONS.BAHNHOF),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_gr_unten_re\").on(CONDITIONS.SBK),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_gr_oben_re\").on(CONDITIONS.GRENZEN),\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=2\")\n            .off(\"zs3>6\") //used by UI to disable the corospoding button\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_gelb,hp_asig_gr\").on(CONDITIONS.BAHNHOF),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_gelb_unten_re,hp_bk_gr_oben_re\").on(CONDITIONS.GRENZEN),\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_schuten\").on(CONDITIONS.BAHNHOF),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_schute_unten\").on(CONDITIONS.STRECKE),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_bk_schute_oben\").on(CONDITIONS.GRENZEN),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"VRsig\")\n            .childs([\n               \"vr_schirm\",\n               \"vr_lichtp\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_schirm,vr_zusatz_lichtp\").on(\"vr_op=verk\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_licht\").on(\"vr_op=verk\").on(\"verk=1\").off(\"hp=0\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n                  .off(\"hp=0\")\n                  .childs([\n                     new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_gelb_oben,vr_gelb_unten\").on(\"vr=0\"),\n                     new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_grün_oben,vr_grün_unten\").on(\"vr=1\"),\n                     new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_gelb_unten,vr_grün_oben\").on(\"vr=2\"),\n                  ]),\n               \"vr_schuten\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_schute\").on(\"vr_op=verk\"),\n            ]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(CONDITIONS.BAHNHOF)\n            .childs([\n               \"hp_asig_kennlicht_lichtp\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_kennlicht_licht\").on(\"ersatz=kennlicht\").off(\"hp>=0\"),\n               \"hp_asig_kennlicht_schute\",\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(CONDITIONS.BAHNHOF)\n            .childs([\n               \"hp_asig_sh1_lichtp\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_asig_sh1_licht\").on(\"ersatz=sh1\").off(\"hp>0\"),\n               \"hp_asig_sh1_schute\",\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Asig, CONDITIONS.Zsig, CONDITIONS.SBK])\n            .childs([\"hp_zs1_lichtp\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_zs1_licht\").on(\"ersatz=zs1\").off(\"hp>0\"), \"hp_zs1_schuten\"]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Esig, CONDITIONS.Zsig])\n            .childs([\"hp_zs7_lichtp\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_zs7_licht\").on(\"ersatz=zs7\").off(\"hp>0\"), \"hp_zs7_schuten\"]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Asig, CONDITIONS.BKsig])\n            .childs([\n               \"hp_zs1_lichtp\",\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp_zs1_licht\").on(\"ersatz=zs8\").off(\"hp>0\").blinkt(true),\n               \"hp_zs1_schuten\",\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3>0\")\n            .off(\"zs3=40||zusatz_oben\")\n            .childs([\"zs3\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [80, \"Arial\", 1]).pos([115, 80])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3v>0\")\n            .off(\"zusatz_unten\")\n            .childs([\"zs3v\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [80, \"Arial\", 1], \"#ffde36\").pos([115, 890])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3_licht\")\n            .on(\"zusatz_oben\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [60,\"DOT\"]).pos([120, 78]).on(\"zs3>0\").off(\"hp<=0\")]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3v_licht\")\n            .on(\"zusatz_unten\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [60,\"DOT\"], \"#ffde36\").pos([120, 885]).on(\"zs3v>0\").off(\"hp<=0\")]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Asig, CONDITIONS.BKsig])\n            .on(\"zs6=1\")\n            .off(\"zs3v>0\")\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs6_blech_unten\").off(\"zusatz_unten\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs6_licht_unten\").on(\"zusatz_unten\").on(\"hp>0\"),\n            ]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"schild\").on(\"bez\").childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"bez\", [55,\"condenced\",1], \"#333\").pos([116, 1033]).bounds([52,63])]),\n         ,\n      ],\n      [\"hp=0\", \"vr=0\", \"HPsig\", \"verw=asig\", \"mastschild=wrw\"]\n   );\n   t.scale = 0.15;\n   t.previewsize = 20;\n   t.distance_from_track = 5;\n   t.checkSignalDependency = checkSignalDependencyFunction4HV;\n   t.addRule(\"hp>0 && zs3>6\", \"hp=1\");\n   t.addRule(\"hp>0 && zs3<=6 && zs3>0\", \"hp=2\");\n   t.createSignalCommandMenu(lightMenu);\n   signalTemplates.hv_hp = t;\n\n   t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"hv_vr\",\n      \"Hv Vorsignal\",\n      \"hv\",\n      [\n         \"mast,vr_schirm,vr_lichtp\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ne2\").off(\"vr_op=wdh\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_schirm,vr_zusatz_lichtp\").on([\"vr_op=verk\", \"vr_op=wdh\"]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_licht\").on(\"vr_op=verk\").on(\"verk=1\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_licht\").on(\"vr_op=wdh\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement().childs([\n            new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_gelb_oben,vr_gelb_unten\").on(\"vr=0\"),\n            new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_grün_oben,vr_grün_unten\").on(\"vr=1\"),\n            new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_gelb_unten,vr_grün_oben\").on(\"vr=2\"),\n         ]),\n         \"vr_schuten\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"vr_zusatz_schute\").on(\"vr_op=verk\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3v>0\")\n            .off(\"zusatz_unten\")\n            .childs([\"zs3v\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [80, \"Arial\", 1], \"#ffde36\").pos([115, 890])]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3v_licht\")\n            .on(\"zusatz_unten\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [60,\"DOT\"], \"#ffde36\").pos([120, 885]).on(\"zs3v>0\")]),\n      ],\n      [\"vr=0\", \"VRsig\"]\n   );\n   t.scale = 0.15;\n   t.distance_from_track = 4;\n   t.checkSignalDependency = checkSignalDependencyFunction4HV;\n   t.createSignalCommandMenu([\"vr=0,vr=1,vr=2\", \"verk=1(verk)\", \"zs3v\"]);\n   signalTemplates.hv_vr = t;\n\n   //KS Hauptsignal\n   t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"ks\",\n      \"Ks Hauptsignal\",\n      \"ks\",\n      [\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3_licht\")\n            .on(\"zusatz_oben\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [85,\"DOT\"]).pos([90, 40]).on(\"zs3>0\").off(\"hp<=0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3>0\")\n            .off(\"!zusatz_oben\")\n            .childs([\"zs3\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [80, \"Arial\", 1]).pos([85, 80])]),\n         \"mast\",\n         \"schirm_hp\",\n         \"wrw\",\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement().on(\"VRsig\").childs([\"ks1_2_optik_hpvr\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks2\").on(\"hp=2\")]),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_optik_hp\").off(\"VRsig\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=1\")\n            .childs([\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_hpvr\").on(\"VRsig\").on(\"zs3v>0\").blinkt(true),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_hpvr\").on(\"VRsig\").off(\"zs3v>0\"),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_hp\").off(\"VRsig\").on(\"zs3v>0\").blinkt(true),\n               new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_hp\").off(\"VRsig||zs3v>0\"),\n            ]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"möhre\").on(\"VRsig\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"hp0\").on(\"hp=0\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Asig, CONDITIONS.BKsig, CONDITIONS.SBK])\n            .childs([\"zs1_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs1\").on(\"ersatz=zs1\").off(\"hp>0\").blinkt(true)]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on([CONDITIONS.Esig, CONDITIONS.Zsig])\n            .childs([\"zs7_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs7\").on(\"ersatz=zs7\").off(\"hp>0\")]),\n         ,\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(CONDITIONS.BAHNHOF)\n            .childs([\"sh1_optik\", \"zs1_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs1,sh1\").on(\"ersatz=sh1\").off(\"hp>0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"vr_op=verk&&VRsig\")\n            .childs([\"kennlicht_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"kennlicht\").on(\"verk=1\").off(\"hp=0||hp=1&&zs3v<=0\")]),\n         ,\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(CONDITIONS.BAHNHOF)\n            .childs([\"kennlicht_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"kennlicht\").on(\"ersatz=kennlicht\").off(\"hp>=0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3v>0\")\n            .off(\"zusatz_unten\")\n            .childs([\"zs3v\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [80, \"Arial\", 1], \"#ffde36\").pos([85, 490])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs6_licht\").on(\"zs6=1\").on(\"zusatz_oben\").off(\"hp<=0||zs3>0\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3v_licht\")\n            .on(\"zusatz_unten\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [85,\"DOT\"], \"#ffde36\").on(\"zs3v>0\").off(\"hp<=0\").pos([90, 520])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"schild\").on(\"bez\").childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"bez\", [55,\"condenced\",1], \"#333\").pos([85, 634])]),\n      ],\n      [\"HPsig\", CONDITIONS.Asig, \"hp=0\"]\n   );\n   t.scale = 0.15;\n   t.distance_from_track = 15;\n   t.createSignalCommandMenu([\n      [\"hp=0,hp=1(Ks 1),hp=2(Ks 2)\", \"zs3\"],\n      \"zs3v\",\n      \"ersatz=zs1,ersatz=zs7,ersatz=zs8,ersatz=sh1,ersatz=kennlicht\",\n      \"verk=1(Verk)\",\n      \"zs6=1(Zs 6)\",\n   ]);\n\n   //signal: ist das signal, dessen Stellung wir gerade setzen\n   //hp: ist das signal, dessen Stellung wir vorsignalisieren wollen\n   t.checkSignalDependency = function (signal, hp) {\n      //make sure we only handle main signals\n      if (!hp.check(\"HPsig\") || !signal.check(\"VRsig\")) return;\n      let stop_propagation = false;\n      //-1 heißt, das Signal ist vom User ausgeschaltet\n      if (signal.get(\"hp\") != -1) {\n         //Das Hauptsignal zeigt nicht Hp 0 oder es ist ein alleinstehndes Vorsignal\n         let anderes_zs3 = hp.get(\"zs3\");\n         let eigenes_zs3 = signal.get(\"zs3\");\n         if (!signal.check(\"HPsig\") || signal.get(\"hp\") != 0) {\n            let x = hp.get(\"hp\");\n\n            switch (hp._template.id) {\n               case \"Hv77\":\n               case \"hv_hp\":\n               case \"hv_vr\":\n                  {\n                     signal.set_stellung(\"hp\", x >= 1 ? 1 : 2, false);\n                     if (x == 2 && anderes_zs3 <= 0) anderes_zs3 = 4;\n\n                     if (!signal.check(\"vr_op=wdh\")) stop_propagation = true;\n                  }\n                  break;\n               case \"Hl\":\n               case \"ks\":\n               case \"ks_vr\":\n                  {\n                     signal.set_stellung(\"hp\", x <= 0 ? 2 : 1, false);\n\n                     if (!signal.check(\"vr_op=wdh\")) stop_propagation = true;\n                  }\n                  break;\n            }\n         }\n         if (eigenes_zs3 <= anderes_zs3 && eigenes_zs3 > 0) anderes_zs3 = -1;\n         signal.set_stellung(\"zs3v\", anderes_zs3, false);\n      }\n\n      return stop_propagation;\n   };\n\n   signalTemplates.ks = t;\n\n   t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"ks_vr\",\n      \"Ks Vorsignal\",\n      \"ks\",\n      [\n         \"mast\",\n         \"schirm_vr\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks2_vr\").on(\"hp=2\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"hp=1\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_vr\").on(\"zs3v>0\").blinkt(true), new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ks1_vr\").off(\"zs3v>0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement().on(\"vr_op.wdh\").childs([\"sh1_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"verk\").off(\"hp=0||hp=1&&zs3v<=0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"ne2\").off(\"vr_op.wdh\"),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement().on(\"vr_op.verk\").childs([\"verk_optik\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"verk\").off(\"hp=0||hp=1&&zs3v<=0\")]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement()\n            .on(\"zs3v>0\")\n            .off(\"zusatz_unten\")\n            .childs([\"zs3v\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [80, \"Arial\", 1], \"#ffde36\").pos([85, 490])]),\n\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs3v_licht\")\n            .on(\"zusatz_unten\")\n            .childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3v\", [85,\"DOT\"], \"#ffde36\").on(\"zs3v>0\").off(\"hp<=0\").pos([90, 520])]),\n      ],\n      [\"VRsig\", \"hp=2\"]\n   );\n   t.scale = 0.13;\n   t.distance_from_track = 15;\n   t.createSignalCommandMenu([\"hp=1(Ks 1),hp=2(Ks 2)\", \"zs3v\", \"ersatz=kennlicht\"]);\n\n   t.checkSignalDependency = signalTemplates.ks.checkSignalDependency;\n   signalTemplates.ks_vr = t;\n\n   //ls\n   t = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"ls\",\n      \"Lichtsperrsignal\",\n      \"ls\",\n      [\n         \"basis\",\n         \"wrw\",\n         \"lp_r_links\",\n         \"lp_r_rechts\",\n         \"lp_w_oben\",\n         \"lp_w_unten\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"r_links,r_rechts\").on(\"hp=0\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"w_oben,w_unten\").on(\"hp=1\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"w_oben\").on(\"ersatz=kennlicht\"),\n         \"schute_r_links\",\n         \"schute_r_rechts\",\n         \"schute_w_oben\",\n         \"schute_w_unten\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"schild\").on(\"bez\").childs([new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"bez\", [55,\"condenced\",1], \"#333\").pos([210, 125])]),\n      ],\n      \"hp=0\"\n   );\n   t.scale = 0.07;\n   t.createSignalCommandMenu([\"hp=0,hp=1(Sh 1)\", \"ersatz=kennlicht(Kennlicht)\"]);\n   signalTemplates.ls = t;\n\n   signalTemplates.ne4 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"ne4\", \"Ne 4\", \"basis\");\n   signalTemplates.ne4.scale = 0.2;\n   signalTemplates.ne4.previewsize = 10;\n\n   signalTemplates.ne1 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"ne1\", \"Ne 1\", \"basis\", [\n      \"ne1\",\n      new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"ne1\", [20, \"Arial\", 1]).pos([100, 105]),\n   ]);\n   signalTemplates.ne1.scale = 0.15;\n   signalTemplates.ne1.distance_from_track = 5;\n   signalTemplates.ne2 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"ne2\", \"Ne 2\", \"basis\");\n   signalTemplates.ne2.scale = 0.25;\n   signalTemplates.ne2.previewsize = 20;\n\n   signalTemplates.lf6 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"lf6\",\n      \"Lf 6\",\n      \"basis\",\n      [\"lf6\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"geschw\", [110, \"Arial\", 1], \"#333\").pos([98, 8])],\n      [\"slave\", \"geschw=9\"]\n   );\n   signalTemplates.lf6.createSignalCommandMenu([\"geschw()\"]);\n   signalTemplates.lf6.scale = 0.12;\n\n   signalTemplates.lf7 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"lf7\",\n      \"Lf 7\",\n      \"basis\",\n      [\"lf7\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"geschw\", [130, \"Arial\", 1], \"#333\").pos([55, 20])],\n      [\"master\", \"geschw=9\"]\n   );\n   signalTemplates.lf7.createSignalCommandMenu([\"geschw()\"]);\n   signalTemplates.lf7.scale = 0.15;\n   signalTemplates.lf7.previewsize = 30;\n\n   signalTemplates.lf7.checkSignalDependency = signalTemplates.lf6.checkSignalDependency = function (signal, hp) {\n      if (signal._template.id == \"lf6\" && hp._template.id == \"lf7\") {\n         signal.set_stellung(\"geschw\", hp.get(\"geschw\"), false);\n         return true;\n      }\n      return false;\n   };\n\n   signalTemplates.zs3 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"zs3\",\n      \"Zs 3 (alleinst.)\",\n      \"basis\",\n      [\"zs3\", new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"geschw\",[120, \"Arial\", 1]).pos([90, 60])],\n      \"geschw=9\"\n   );\n\n   signalTemplates.zs3.createSignalCommandMenu([\"geschw()\"]);\n   signalTemplates.zs3.scale = 0.15;\n\n   signalTemplates.zs10 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"zs10\", \"Zs 10\", \"basis\");\n   signalTemplates.zs10.scale = 0.2;\n   signalTemplates.zs10.previewsize = 15;\n\n   signalTemplates.ra10 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"ra10\", \"Ra 10\", \"basis\");\n   signalTemplates.ra10.scale = 0.15;\n\n   signalTemplates.zs6 = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\"zs6\", \"Zs 6\", \"basis\", [\"zs6_blech_mast\", \"zs6_blech\"]);\n   signalTemplates.zs6.scale = 0.2;\n   signalTemplates.zs6.previewsize = 30;\n\n   signalTemplates.zusatzSignal = new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.SignalTemplate(\n      \"zusatz\",\n      \"Zusatzanzeiger\",\n      \"basis\",\n      [\n         \"zusatzanzeiger\",\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.VisualElement(\"zs6_licht\").on(\"zs6=1\"),\n         new _signaling_js__WEBPACK_IMPORTED_MODULE_0__.TextElement(\"zs3\", [85,\"DOT\"]).pos([70, 40]).off(\"zs6=1\").on(\"zs3>0\"),\n      ],\n      \"zs6=1\"\n   );\n   signalTemplates.zusatzSignal.scale = 0.15;\n   signalTemplates.zusatzSignal.createSignalCommandMenu([[\"zs6=1(Zs 6)\"], \"zs3()\"]);\n   signalTemplates.zusatzSignal.previewsize = 30;\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUE2Qix5REFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLHlEQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qix5REFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4Qix5REFBYztBQUM1QztBQUNBOztBQUVBLDhCQUE4Qix5REFBYztBQUM1Qzs7QUFFQSw2QkFBNkIseURBQWM7QUFDM0M7QUFDQTs7QUFFQSxzQ0FBc0MseURBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQWE7QUFDMUIsYUFBYSxzREFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3NpZ25hbF9saWJyYXJ5LmpzPzc4YzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgVmlzdWFsRWxlbWVudCwgVGV4dEVsZW1lbnQsIFNpZ25hbFRlbXBsYXRlIH0gZnJvbSAnLi9zaWduYWxpbmcuanMnO1xuXG5leHBvcnQgY29uc3QgQ09ORElUSU9OUyA9IChmdW5jdGlvbiAoKSB7XG4gICBjb25zdCBCS3NpZyA9IFwidmVydz1ia3NpZ1wiLFxuICAgICAgU0JLID0gXCJ2ZXJ3PXNia1wiLFxuICAgICAgRXNpZyA9IFwidmVydz1lc2lnXCIsXG4gICAgICBBc2lnID0gXCJ2ZXJ3PWFzaWdcIixcbiAgICAgIFpzaWcgPSBcInZlcnc9enNpZ1wiLFxuICAgICAgU1RSRUNLRSA9IFtCS3NpZywgU0JLLCBFc2lnXSxcbiAgICAgIEdSRU5aRU4gPSBbQktzaWcsIEVzaWddLFxuICAgICAgQkFITkhPRiA9IFtBc2lnLCBac2lnXTtcbiAgIHJldHVybiB7IEJLc2lnLCBTQkssIEVzaWcsIEFzaWcsIFpzaWcsIFNUUkVDS0UsIEdSRU5aRU4sIEJBSE5IT0YgfTtcbn0pKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0U2lnbmFscyhzaWduYWxUZW1wbGF0ZXNSZWYpIHtcbiAgIC8vIFVzZSB0aGUgcGFzc2VkIHNpZ25hbFRlbXBsYXRlcyByZWZlcmVuY2UgaW5zdGVhZCBvZiBhIG1vZHVsZS1sZXZlbCB2YXJpYWJsZVxuICAgY29uc3Qgc2lnbmFsVGVtcGxhdGVzID0gc2lnbmFsVGVtcGxhdGVzUmVmO1xuICAgY29uc3QgbGlnaHRNZW51ID0gW1xuICAgICAgW1wiaHA9MCxocD0xLGhwPTJcIiwgXCJ6czNcIl0sXG4gICAgICBbXCJ2cj0wLHZyPTEsdnI9MlwiLCBcInZlcms9MSh2ZXJrKVwiLCBcInpzM3ZcIl0sXG4gICAgICBcImVyc2F0ej16czEsZXJzYXR6PXpzNyxlcnNhdHo9enM4LGVyc2F0ej1zaDEsZXJzYXR6PWtlbm5saWNodFwiLFxuICAgICAgXCJ6czY9MShacyA2KVwiLFxuICAgXTtcblxuICAgLy9zaWduYWw6IGlzdCBkYXMgc2lnbmFsLCBkZXNzZW4gU3RlbGx1bmcgd2lyIGdlcmFkZSBzZXR6ZW5cbiAgIC8vaHA6IGlzdCBkYXMgc2lnbmFsLCBkZXNzZW4gU3RlbGx1bmcgd2lyIHZvcnNpZ25hbGlzaWVyZW4gd29sbGVuXG4gICBjb25zdCBjaGVja1NpZ25hbERlcGVuZGVuY3lGdW5jdGlvbjRIViA9IGZ1bmN0aW9uIChzaWduYWwsIGhwKSB7XG4gICAgICAvL21ha2Ugc3VyZSB3ZSBvbmx5IGhhbmRsZSBtYWluIHNpZ25hbHNcbiAgICAgIGlmICghaHAuY2hlY2soXCJIUHNpZ1wiKSB8fCAhc2lnbmFsLmNoZWNrKFwiVlJzaWdcIikpIHJldHVybjtcbiAgICAgIGxldCBzdG9wX3Byb3BhZ2F0aW9uID0gZmFsc2U7XG5cbiAgICAgIC8vLTEgaGVpw590LCBkaWUgVm9yc2lnbmFsZnVua3Rpb24gaXN0IHZvbSBVc2VyIGF1c2dlc2NoYWx0ZXRcbiAgICAgIGlmIChzaWduYWwuZ2V0KFwidnJcIikgIT0gLTEpIHtcbiAgICAgICAgIC8vRGFzIEhhdXB0c2lnbmFsIHplaWd0IG5pY2h0IEhwIDAgb2RlciBlcyBpc3QgZWluIGFsbGVpbnN0ZWhuZGVzIFZvcnNpZ25hbFxuICAgICAgICAgaWYgKCFzaWduYWwuY2hlY2soXCJIUHNpZ1wiKSB8fCBzaWduYWwuZ2V0KFwiaHBcIikgIT0gMCkge1xuICAgICAgICAgICAgc3dpdGNoIChocC5fdGVtcGxhdGUuaWQpIHtcbiAgICAgICAgICAgICAgIGNhc2UgXCJIdjc3XCI6XG4gICAgICAgICAgICAgICBjYXNlIFwiaHZfaHBcIjpcbiAgICAgICAgICAgICAgIGNhc2UgXCJodl92clwiOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhcInZyXCIsIGhwLmdldChcImhwXCIpID49IDAgPyBocC5nZXQoXCJocFwiKSA6IDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmFsLmNoZWNrKFwidnJfb3A9d2RoXCIpKSBzdG9wX3Byb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgY2FzZSBcIkhsXCI6XG4gICAgICAgICAgICAgICBjYXNlIFwia3NcIjpcbiAgICAgICAgICAgICAgIGNhc2UgXCJrc192clwiOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhcInZyXCIsIGhwLmdldChcImhwXCIpIDw9IDAgPyAwIDogMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWduYWwuY2hlY2soXCJ2cl9vcD13ZGhcIikpIHN0b3BfcHJvcGFnYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChocC5nZXQoXCJ6czNcIikgPT0gNCkge1xuICAgICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhcInpzM3ZcIiwgMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICBpZiAoc2lnbmFsLmdldChcInZyXCIpID4gMCkgc2lnbmFsLnNldF9zdGVsbHVuZyhcInZyXCIsIDIsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBzaWduYWwuc2V0X3N0ZWxsdW5nKFwienMzdlwiLCBocC5nZXQoXCJ6czNcIiksIGZhbHNlKTtcblxuICAgICAgICAgICAgLy9pZiAoaHAuZ2V0KFwienMzXCIpLmJldHdlZW4oMSw2KSAmJiBocC5nZXQoXCJocFwiKSA+IDApIHNpZ25hbC5zZXRfc3RlbGx1bmcoXCJ2clwiLCAyLCBmYWxzZSk7XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9wX3Byb3BhZ2F0aW9uO1xuICAgfTtcblxuICAgbGV0IHQgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXG4gICAgICBcImh2X2hwXCIsXG4gICAgICBcIkh2IEhhdXB0c2lnbmFsXCIsXG4gICAgICBcImh2XCIsXG4gICAgICBbXG4gICAgICAgICBcIm1hc3QsaHBfc2NoaXJtXCIsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcIndyd1wiKS5vbihcIm1hc3RzY2hpbGQ9d3J3XCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ3Z3dnd1wiKS5vbihcIm1hc3RzY2hpbGQ9d2d3Z3dcIiksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwiaHBfYXNpZ19saWNodHBcIikub24oQ09ORElUSU9OUy5CQUhOSE9GKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwiaHBfYmtfbGljaHRwX3VudGVuXCIpLm9uKENPTkRJVElPTlMuU1RSRUNLRSksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2JrX2xpY2h0cF9vYmVuXCIpLm9uKENPTkRJVElPTlMuR1JFTlpFTiksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcImhwPTBcIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9hc2lnX3JvdF9yZVwiKS5vbihDT05ESVRJT05TLkJBSE5IT0YpLm9mZihcImVyc2F0ej1zaDFcIiksXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2FzaWdfcm90X2xpXCIpLm9uKENPTkRJVElPTlMuQkFITkhPRiksXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2JrX3JvdF91bnRlbl9saVwiKS5vbihDT05ESVRJT05TLlNUUkVDS0UpLFxuICAgICAgICAgICAgXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcImhwPTFcIilcbiAgICAgICAgICAgIC5vZmYoXCJ6czM8PTYgJiYgenMzPjBcIikgLy91c2VkIGJ5IFVJIHRvIGRpc2FibGUgdGhlIGNvcm9zcG9kaW5nIGJ1dHRvblxuICAgICAgICAgICAgLmNoaWxkcyhbXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2FzaWdfZ3JcIikub24oQ09ORElUSU9OUy5CQUhOSE9GKSxcbiAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwiaHBfYmtfZ3JfdW50ZW5fcmVcIikub24oQ09ORElUSU9OUy5TQkspLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9ia19ncl9vYmVuX3JlXCIpLm9uKENPTkRJVElPTlMuR1JFTlpFTiksXG4gICAgICAgICAgICBdKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwiaHA9MlwiKVxuICAgICAgICAgICAgLm9mZihcInpzMz42XCIpIC8vdXNlZCBieSBVSSB0byBkaXNhYmxlIHRoZSBjb3Jvc3BvZGluZyBidXR0b25cbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9hc2lnX2dlbGIsaHBfYXNpZ19nclwiKS5vbihDT05ESVRJT05TLkJBSE5IT0YpLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9ia19nZWxiX3VudGVuX3JlLGhwX2JrX2dyX29iZW5fcmVcIikub24oQ09ORElUSU9OUy5HUkVOWkVOKSxcbiAgICAgICAgICAgIF0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2FzaWdfc2NodXRlblwiKS5vbihDT05ESVRJT05TLkJBSE5IT0YpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9ia19zY2h1dGVfdW50ZW5cIikub24oQ09ORElUSU9OUy5TVFJFQ0tFKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwiaHBfYmtfc2NodXRlX29iZW5cIikub24oQ09ORElUSU9OUy5HUkVOWkVOKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwiVlJzaWdcIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgXCJ2cl9zY2hpcm1cIixcbiAgICAgICAgICAgICAgIFwidnJfbGljaHRwXCIsXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9zY2hpcm0sdnJfenVzYXR6X2xpY2h0cFwiKS5vbihcInZyX29wPXZlcmtcIiksXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9saWNodFwiKS5vbihcInZyX29wPXZlcmtcIikub24oXCJ2ZXJrPTFcIikub2ZmKFwiaHA9MFwiKSxcbiAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgICAgICAgIC5vZmYoXCJocD0wXCIpXG4gICAgICAgICAgICAgICAgICAuY2hpbGRzKFtcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwidnJfZ2VsYl9vYmVuLHZyX2dlbGJfdW50ZW5cIikub24oXCJ2cj0wXCIpLFxuICAgICAgICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ2cl9ncsO8bl9vYmVuLHZyX2dyw7xuX3VudGVuXCIpLm9uKFwidnI9MVwiKSxcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwidnJfZ2VsYl91bnRlbix2cl9ncsO8bl9vYmVuXCIpLm9uKFwidnI9MlwiKSxcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgXCJ2cl9zY2h1dGVuXCIsXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9zY2h1dGVcIikub24oXCJ2cl9vcD12ZXJrXCIpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oQ09ORElUSU9OUy5CQUhOSE9GKVxuICAgICAgICAgICAgLmNoaWxkcyhbXG4gICAgICAgICAgICAgICBcImhwX2FzaWdfa2VubmxpY2h0X2xpY2h0cFwiLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF9hc2lnX2tlbm5saWNodF9saWNodFwiKS5vbihcImVyc2F0ej1rZW5ubGljaHRcIikub2ZmKFwiaHA+PTBcIiksXG4gICAgICAgICAgICAgICBcImhwX2FzaWdfa2VubmxpY2h0X3NjaHV0ZVwiLFxuICAgICAgICAgICAgXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihDT05ESVRJT05TLkJBSE5IT0YpXG4gICAgICAgICAgICAuY2hpbGRzKFtcbiAgICAgICAgICAgICAgIFwiaHBfYXNpZ19zaDFfbGljaHRwXCIsXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX2FzaWdfc2gxX2xpY2h0XCIpLm9uKFwiZXJzYXR6PXNoMVwiKS5vZmYoXCJocD4wXCIpLFxuICAgICAgICAgICAgICAgXCJocF9hc2lnX3NoMV9zY2h1dGVcIixcbiAgICAgICAgICAgIF0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oW0NPTkRJVElPTlMuQXNpZywgQ09ORElUSU9OUy5ac2lnLCBDT05ESVRJT05TLlNCS10pXG4gICAgICAgICAgICAuY2hpbGRzKFtcImhwX3pzMV9saWNodHBcIiwgbmV3IFZpc3VhbEVsZW1lbnQoXCJocF96czFfbGljaHRcIikub24oXCJlcnNhdHo9enMxXCIpLm9mZihcImhwPjBcIiksIFwiaHBfenMxX3NjaHV0ZW5cIl0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oW0NPTkRJVElPTlMuRXNpZywgQ09ORElUSU9OUy5ac2lnXSlcbiAgICAgICAgICAgIC5jaGlsZHMoW1wiaHBfenM3X2xpY2h0cFwiLCBuZXcgVmlzdWFsRWxlbWVudChcImhwX3pzN19saWNodFwiKS5vbihcImVyc2F0ej16czdcIikub2ZmKFwiaHA+MFwiKSwgXCJocF96czdfc2NodXRlblwiXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihbQ09ORElUSU9OUy5Bc2lnLCBDT05ESVRJT05TLkJLc2lnXSlcbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgXCJocF96czFfbGljaHRwXCIsXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImhwX3pzMV9saWNodFwiKS5vbihcImVyc2F0ej16czhcIikub2ZmKFwiaHA+MFwiKS5ibGlua3QodHJ1ZSksXG4gICAgICAgICAgICAgICBcImhwX3pzMV9zY2h1dGVuXCIsXG4gICAgICAgICAgICBdKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwienMzPjBcIilcbiAgICAgICAgICAgIC5vZmYoXCJ6czM9NDB8fHp1c2F0el9vYmVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtcInpzM1wiLCBuZXcgVGV4dEVsZW1lbnQoXCJ6czNcIiwgWzgwLCBcIkFyaWFsXCIsIDFdKS5wb3MoWzExNSwgODBdKV0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oXCJ6czN2PjBcIilcbiAgICAgICAgICAgIC5vZmYoXCJ6dXNhdHpfdW50ZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1wienMzdlwiLCBuZXcgVGV4dEVsZW1lbnQoXCJ6czN2XCIsIFs4MCwgXCJBcmlhbFwiLCAxXSwgXCIjZmZkZTM2XCIpLnBvcyhbMTE1LCA4OTBdKV0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInpzM19saWNodFwiKVxuICAgICAgICAgICAgLm9uKFwienVzYXR6X29iZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW25ldyBUZXh0RWxlbWVudChcInpzM1wiLCBbNjAsXCJET1RcIl0pLnBvcyhbMTIwLCA3OF0pLm9uKFwienMzPjBcIikub2ZmKFwiaHA8PTBcIildKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwienMzdl9saWNodFwiKVxuICAgICAgICAgICAgLm9uKFwienVzYXR6X3VudGVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtuZXcgVGV4dEVsZW1lbnQoXCJ6czN2XCIsIFs2MCxcIkRPVFwiXSwgXCIjZmZkZTM2XCIpLnBvcyhbMTIwLCA4ODVdKS5vbihcInpzM3Y+MFwiKS5vZmYoXCJocDw9MFwiKV0pLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFtDT05ESVRJT05TLkFzaWcsIENPTkRJVElPTlMuQktzaWddKVxuICAgICAgICAgICAgLm9uKFwienM2PTFcIilcbiAgICAgICAgICAgIC5vZmYoXCJ6czN2PjBcIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1xuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czZfYmxlY2hfdW50ZW5cIikub2ZmKFwienVzYXR6X3VudGVuXCIpLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czZfbGljaHRfdW50ZW5cIikub24oXCJ6dXNhdHpfdW50ZW5cIikub24oXCJocD4wXCIpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInNjaGlsZFwiKS5vbihcImJlelwiKS5jaGlsZHMoW25ldyBUZXh0RWxlbWVudChcImJlelwiLCBbNTUsXCJjb25kZW5jZWRcIiwxXSwgXCIjMzMzXCIpLnBvcyhbMTE2LCAxMDMzXSkuYm91bmRzKFs1Miw2M10pXSksXG4gICAgICAgICAsXG4gICAgICBdLFxuICAgICAgW1wiaHA9MFwiLCBcInZyPTBcIiwgXCJIUHNpZ1wiLCBcInZlcnc9YXNpZ1wiLCBcIm1hc3RzY2hpbGQ9d3J3XCJdXG4gICApO1xuICAgdC5zY2FsZSA9IDAuMTU7XG4gICB0LnByZXZpZXdzaXplID0gMjA7XG4gICB0LmRpc3RhbmNlX2Zyb21fdHJhY2sgPSA1O1xuICAgdC5jaGVja1NpZ25hbERlcGVuZGVuY3kgPSBjaGVja1NpZ25hbERlcGVuZGVuY3lGdW5jdGlvbjRIVjtcbiAgIHQuYWRkUnVsZShcImhwPjAgJiYgenMzPjZcIiwgXCJocD0xXCIpO1xuICAgdC5hZGRSdWxlKFwiaHA+MCAmJiB6czM8PTYgJiYgenMzPjBcIiwgXCJocD0yXCIpO1xuICAgdC5jcmVhdGVTaWduYWxDb21tYW5kTWVudShsaWdodE1lbnUpO1xuICAgc2lnbmFsVGVtcGxhdGVzLmh2X2hwID0gdDtcblxuICAgdCA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwiaHZfdnJcIixcbiAgICAgIFwiSHYgVm9yc2lnbmFsXCIsXG4gICAgICBcImh2XCIsXG4gICAgICBbXG4gICAgICAgICBcIm1hc3QsdnJfc2NoaXJtLHZyX2xpY2h0cFwiLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJuZTJcIikub2ZmKFwidnJfb3A9d2RoXCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ2cl96dXNhdHpfc2NoaXJtLHZyX3p1c2F0el9saWNodHBcIikub24oW1widnJfb3A9dmVya1wiLCBcInZyX29wPXdkaFwiXSksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9saWNodFwiKS5vbihcInZyX29wPXZlcmtcIikub24oXCJ2ZXJrPTFcIiksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9saWNodFwiKS5vbihcInZyX29wPXdkaFwiKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KCkuY2hpbGRzKFtcbiAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwidnJfZ2VsYl9vYmVuLHZyX2dlbGJfdW50ZW5cIikub24oXCJ2cj0wXCIpLFxuICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ2cl9ncsO8bl9vYmVuLHZyX2dyw7xuX3VudGVuXCIpLm9uKFwidnI9MVwiKSxcbiAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwidnJfZ2VsYl91bnRlbix2cl9ncsO8bl9vYmVuXCIpLm9uKFwidnI9MlwiKSxcbiAgICAgICAgIF0pLFxuICAgICAgICAgXCJ2cl9zY2h1dGVuXCIsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInZyX3p1c2F0el9zY2h1dGVcIikub24oXCJ2cl9vcD12ZXJrXCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwienMzdj4wXCIpXG4gICAgICAgICAgICAub2ZmKFwienVzYXR6X3VudGVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtcInpzM3ZcIiwgbmV3IFRleHRFbGVtZW50KFwienMzdlwiLCBbODAsIFwiQXJpYWxcIiwgMV0sIFwiI2ZmZGUzNlwiKS5wb3MoWzExNSwgODkwXSldKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwienMzdl9saWNodFwiKVxuICAgICAgICAgICAgLm9uKFwienVzYXR6X3VudGVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtuZXcgVGV4dEVsZW1lbnQoXCJ6czN2XCIsIFs2MCxcIkRPVFwiXSwgXCIjZmZkZTM2XCIpLnBvcyhbMTIwLCA4ODVdKS5vbihcInpzM3Y+MFwiKV0pLFxuICAgICAgXSxcbiAgICAgIFtcInZyPTBcIiwgXCJWUnNpZ1wiXVxuICAgKTtcbiAgIHQuc2NhbGUgPSAwLjE1O1xuICAgdC5kaXN0YW5jZV9mcm9tX3RyYWNrID0gNDtcbiAgIHQuY2hlY2tTaWduYWxEZXBlbmRlbmN5ID0gY2hlY2tTaWduYWxEZXBlbmRlbmN5RnVuY3Rpb240SFY7XG4gICB0LmNyZWF0ZVNpZ25hbENvbW1hbmRNZW51KFtcInZyPTAsdnI9MSx2cj0yXCIsIFwidmVyaz0xKHZlcmspXCIsIFwienMzdlwiXSk7XG4gICBzaWduYWxUZW1wbGF0ZXMuaHZfdnIgPSB0O1xuXG4gICAvL0tTIEhhdXB0c2lnbmFsXG4gICB0ID0gbmV3IFNpZ25hbFRlbXBsYXRlKFxuICAgICAgXCJrc1wiLFxuICAgICAgXCJLcyBIYXVwdHNpZ25hbFwiLFxuICAgICAgXCJrc1wiLFxuICAgICAgW1xuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czNfbGljaHRcIilcbiAgICAgICAgICAgIC5vbihcInp1c2F0el9vYmVuXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtuZXcgVGV4dEVsZW1lbnQoXCJ6czNcIiwgWzg1LFwiRE9UXCJdKS5wb3MoWzkwLCA0MF0pLm9uKFwienMzPjBcIikub2ZmKFwiaHA8PTBcIildKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFwienMzPjBcIilcbiAgICAgICAgICAgIC5vZmYoXCIhenVzYXR6X29iZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW1wienMzXCIsIG5ldyBUZXh0RWxlbWVudChcInpzM1wiLCBbODAsIFwiQXJpYWxcIiwgMV0pLnBvcyhbODUsIDgwXSldKSxcbiAgICAgICAgIFwibWFzdFwiLFxuICAgICAgICAgXCJzY2hpcm1faHBcIixcbiAgICAgICAgIFwid3J3XCIsXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KCkub24oXCJWUnNpZ1wiKS5jaGlsZHMoW1wia3MxXzJfb3B0aWtfaHB2clwiLCBuZXcgVmlzdWFsRWxlbWVudChcImtzMlwiKS5vbihcImhwPTJcIildKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwia3MxX29wdGlrX2hwXCIpLm9mZihcIlZSc2lnXCIpLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oXCJocD0xXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtcbiAgICAgICAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwia3MxX2hwdnJcIikub24oXCJWUnNpZ1wiKS5vbihcInpzM3Y+MFwiKS5ibGlua3QodHJ1ZSksXG4gICAgICAgICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImtzMV9ocHZyXCIpLm9uKFwiVlJzaWdcIikub2ZmKFwienMzdj4wXCIpLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJrczFfaHBcIikub2ZmKFwiVlJzaWdcIikub24oXCJ6czN2PjBcIikuYmxpbmt0KHRydWUpLFxuICAgICAgICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJrczFfaHBcIikub2ZmKFwiVlJzaWd8fHpzM3Y+MFwiKSxcbiAgICAgICAgICAgIF0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcIm3DtmhyZVwiKS5vbihcIlZSc2lnXCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJocDBcIikub24oXCJocD0wXCIpLFxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoKVxuICAgICAgICAgICAgLm9uKFtDT05ESVRJT05TLkFzaWcsIENPTkRJVElPTlMuQktzaWcsIENPTkRJVElPTlMuU0JLXSlcbiAgICAgICAgICAgIC5jaGlsZHMoW1wienMxX29wdGlrXCIsIG5ldyBWaXN1YWxFbGVtZW50KFwienMxXCIpLm9uKFwiZXJzYXR6PXpzMVwiKS5vZmYoXCJocD4wXCIpLmJsaW5rdCh0cnVlKV0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oW0NPTkRJVElPTlMuRXNpZywgQ09ORElUSU9OUy5ac2lnXSlcbiAgICAgICAgICAgIC5jaGlsZHMoW1wienM3X29wdGlrXCIsIG5ldyBWaXN1YWxFbGVtZW50KFwienM3XCIpLm9uKFwiZXJzYXR6PXpzN1wiKS5vZmYoXCJocD4wXCIpXSksXG4gICAgICAgICAsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oQ09ORElUSU9OUy5CQUhOSE9GKVxuICAgICAgICAgICAgLmNoaWxkcyhbXCJzaDFfb3B0aWtcIiwgXCJ6czFfb3B0aWtcIiwgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czEsc2gxXCIpLm9uKFwiZXJzYXR6PXNoMVwiKS5vZmYoXCJocD4wXCIpXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcInZyX29wPXZlcmsmJlZSc2lnXCIpXG4gICAgICAgICAgICAuY2hpbGRzKFtcImtlbm5saWNodF9vcHRpa1wiLCBuZXcgVmlzdWFsRWxlbWVudChcImtlbm5saWNodFwiKS5vbihcInZlcms9MVwiKS5vZmYoXCJocD0wfHxocD0xJiZ6czN2PD0wXCIpXSksXG4gICAgICAgICAsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudCgpXG4gICAgICAgICAgICAub24oQ09ORElUSU9OUy5CQUhOSE9GKVxuICAgICAgICAgICAgLmNoaWxkcyhbXCJrZW5ubGljaHRfb3B0aWtcIiwgbmV3IFZpc3VhbEVsZW1lbnQoXCJrZW5ubGljaHRcIikub24oXCJlcnNhdHo9a2VubmxpY2h0XCIpLm9mZihcImhwPj0wXCIpXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcInpzM3Y+MFwiKVxuICAgICAgICAgICAgLm9mZihcInp1c2F0el91bnRlblwiKVxuICAgICAgICAgICAgLmNoaWxkcyhbXCJ6czN2XCIsIG5ldyBUZXh0RWxlbWVudChcInpzM3ZcIiwgWzgwLCBcIkFyaWFsXCIsIDFdLCBcIiNmZmRlMzZcIikucG9zKFs4NSwgNDkwXSldKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czZfbGljaHRcIikub24oXCJ6czY9MVwiKS5vbihcInp1c2F0el9vYmVuXCIpLm9mZihcImhwPD0wfHx6czM+MFwiKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czN2X2xpY2h0XCIpXG4gICAgICAgICAgICAub24oXCJ6dXNhdHpfdW50ZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW25ldyBUZXh0RWxlbWVudChcInpzM3ZcIiwgWzg1LFwiRE9UXCJdLCBcIiNmZmRlMzZcIikub24oXCJ6czN2PjBcIikub2ZmKFwiaHA8PTBcIikucG9zKFs5MCwgNTIwXSldKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJzY2hpbGRcIikub24oXCJiZXpcIikuY2hpbGRzKFtuZXcgVGV4dEVsZW1lbnQoXCJiZXpcIiwgWzU1LFwiY29uZGVuY2VkXCIsMV0sIFwiIzMzM1wiKS5wb3MoWzg1LCA2MzRdKV0pLFxuICAgICAgXSxcbiAgICAgIFtcIkhQc2lnXCIsIENPTkRJVElPTlMuQXNpZywgXCJocD0wXCJdXG4gICApO1xuICAgdC5zY2FsZSA9IDAuMTU7XG4gICB0LmRpc3RhbmNlX2Zyb21fdHJhY2sgPSAxNTtcbiAgIHQuY3JlYXRlU2lnbmFsQ29tbWFuZE1lbnUoW1xuICAgICAgW1wiaHA9MCxocD0xKEtzIDEpLGhwPTIoS3MgMilcIiwgXCJ6czNcIl0sXG4gICAgICBcInpzM3ZcIixcbiAgICAgIFwiZXJzYXR6PXpzMSxlcnNhdHo9enM3LGVyc2F0ej16czgsZXJzYXR6PXNoMSxlcnNhdHo9a2VubmxpY2h0XCIsXG4gICAgICBcInZlcms9MShWZXJrKVwiLFxuICAgICAgXCJ6czY9MShacyA2KVwiLFxuICAgXSk7XG5cbiAgIC8vc2lnbmFsOiBpc3QgZGFzIHNpZ25hbCwgZGVzc2VuIFN0ZWxsdW5nIHdpciBnZXJhZGUgc2V0emVuXG4gICAvL2hwOiBpc3QgZGFzIHNpZ25hbCwgZGVzc2VuIFN0ZWxsdW5nIHdpciB2b3JzaWduYWxpc2llcmVuIHdvbGxlblxuICAgdC5jaGVja1NpZ25hbERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoc2lnbmFsLCBocCkge1xuICAgICAgLy9tYWtlIHN1cmUgd2Ugb25seSBoYW5kbGUgbWFpbiBzaWduYWxzXG4gICAgICBpZiAoIWhwLmNoZWNrKFwiSFBzaWdcIikgfHwgIXNpZ25hbC5jaGVjayhcIlZSc2lnXCIpKSByZXR1cm47XG4gICAgICBsZXQgc3RvcF9wcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgICAgLy8tMSBoZWnDn3QsIGRhcyBTaWduYWwgaXN0IHZvbSBVc2VyIGF1c2dlc2NoYWx0ZXRcbiAgICAgIGlmIChzaWduYWwuZ2V0KFwiaHBcIikgIT0gLTEpIHtcbiAgICAgICAgIC8vRGFzIEhhdXB0c2lnbmFsIHplaWd0IG5pY2h0IEhwIDAgb2RlciBlcyBpc3QgZWluIGFsbGVpbnN0ZWhuZGVzIFZvcnNpZ25hbFxuICAgICAgICAgbGV0IGFuZGVyZXNfenMzID0gaHAuZ2V0KFwienMzXCIpO1xuICAgICAgICAgbGV0IGVpZ2VuZXNfenMzID0gc2lnbmFsLmdldChcInpzM1wiKTtcbiAgICAgICAgIGlmICghc2lnbmFsLmNoZWNrKFwiSFBzaWdcIikgfHwgc2lnbmFsLmdldChcImhwXCIpICE9IDApIHtcbiAgICAgICAgICAgIGxldCB4ID0gaHAuZ2V0KFwiaHBcIik7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoaHAuX3RlbXBsYXRlLmlkKSB7XG4gICAgICAgICAgICAgICBjYXNlIFwiSHY3N1wiOlxuICAgICAgICAgICAgICAgY2FzZSBcImh2X2hwXCI6XG4gICAgICAgICAgICAgICBjYXNlIFwiaHZfdnJcIjpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5zZXRfc3RlbGx1bmcoXCJocFwiLCB4ID49IDEgPyAxIDogMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHggPT0gMiAmJiBhbmRlcmVzX3pzMyA8PSAwKSBhbmRlcmVzX3pzMyA9IDQ7XG5cbiAgICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmFsLmNoZWNrKFwidnJfb3A9d2RoXCIpKSBzdG9wX3Byb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgY2FzZSBcIkhsXCI6XG4gICAgICAgICAgICAgICBjYXNlIFwia3NcIjpcbiAgICAgICAgICAgICAgIGNhc2UgXCJrc192clwiOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldF9zdGVsbHVuZyhcImhwXCIsIHggPD0gMCA/IDIgOiAxLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgIGlmICghc2lnbmFsLmNoZWNrKFwidnJfb3A9d2RoXCIpKSBzdG9wX3Byb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAgaWYgKGVpZ2VuZXNfenMzIDw9IGFuZGVyZXNfenMzICYmIGVpZ2VuZXNfenMzID4gMCkgYW5kZXJlc196czMgPSAtMTtcbiAgICAgICAgIHNpZ25hbC5zZXRfc3RlbGx1bmcoXCJ6czN2XCIsIGFuZGVyZXNfenMzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9wX3Byb3BhZ2F0aW9uO1xuICAgfTtcblxuICAgc2lnbmFsVGVtcGxhdGVzLmtzID0gdDtcblxuICAgdCA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwia3NfdnJcIixcbiAgICAgIFwiS3MgVm9yc2lnbmFsXCIsXG4gICAgICBcImtzXCIsXG4gICAgICBbXG4gICAgICAgICBcIm1hc3RcIixcbiAgICAgICAgIFwic2NoaXJtX3ZyXCIsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcImtzMl92clwiKS5vbihcImhwPTJcIiksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcImhwPTFcIilcbiAgICAgICAgICAgIC5jaGlsZHMoW25ldyBWaXN1YWxFbGVtZW50KFwia3MxX3ZyXCIpLm9uKFwienMzdj4wXCIpLmJsaW5rdCh0cnVlKSwgbmV3IFZpc3VhbEVsZW1lbnQoXCJrczFfdnJcIikub2ZmKFwienMzdj4wXCIpXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KCkub24oXCJ2cl9vcC53ZGhcIikuY2hpbGRzKFtcInNoMV9vcHRpa1wiLCBuZXcgVmlzdWFsRWxlbWVudChcInZlcmtcIikub2ZmKFwiaHA9MHx8aHA9MSYmenMzdjw9MFwiKV0pLFxuXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcIm5lMlwiKS5vZmYoXCJ2cl9vcC53ZGhcIiksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KCkub24oXCJ2cl9vcC52ZXJrXCIpLmNoaWxkcyhbXCJ2ZXJrX29wdGlrXCIsIG5ldyBWaXN1YWxFbGVtZW50KFwidmVya1wiKS5vZmYoXCJocD0wfHxocD0xJiZ6czN2PD0wXCIpXSksXG5cbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KClcbiAgICAgICAgICAgIC5vbihcInpzM3Y+MFwiKVxuICAgICAgICAgICAgLm9mZihcInp1c2F0el91bnRlblwiKVxuICAgICAgICAgICAgLmNoaWxkcyhbXCJ6czN2XCIsIG5ldyBUZXh0RWxlbWVudChcInpzM3ZcIiwgWzgwLCBcIkFyaWFsXCIsIDFdLCBcIiNmZmRlMzZcIikucG9zKFs4NSwgNDkwXSldKSxcblxuICAgICAgICAgbmV3IFZpc3VhbEVsZW1lbnQoXCJ6czN2X2xpY2h0XCIpXG4gICAgICAgICAgICAub24oXCJ6dXNhdHpfdW50ZW5cIilcbiAgICAgICAgICAgIC5jaGlsZHMoW25ldyBUZXh0RWxlbWVudChcInpzM3ZcIiwgWzg1LFwiRE9UXCJdLCBcIiNmZmRlMzZcIikub24oXCJ6czN2PjBcIikub2ZmKFwiaHA8PTBcIikucG9zKFs5MCwgNTIwXSldKSxcbiAgICAgIF0sXG4gICAgICBbXCJWUnNpZ1wiLCBcImhwPTJcIl1cbiAgICk7XG4gICB0LnNjYWxlID0gMC4xMztcbiAgIHQuZGlzdGFuY2VfZnJvbV90cmFjayA9IDE1O1xuICAgdC5jcmVhdGVTaWduYWxDb21tYW5kTWVudShbXCJocD0xKEtzIDEpLGhwPTIoS3MgMilcIiwgXCJ6czN2XCIsIFwiZXJzYXR6PWtlbm5saWNodFwiXSk7XG5cbiAgIHQuY2hlY2tTaWduYWxEZXBlbmRlbmN5ID0gc2lnbmFsVGVtcGxhdGVzLmtzLmNoZWNrU2lnbmFsRGVwZW5kZW5jeTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5rc192ciA9IHQ7XG5cbiAgIC8vbHNcbiAgIHQgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXG4gICAgICBcImxzXCIsXG4gICAgICBcIkxpY2h0c3BlcnJzaWduYWxcIixcbiAgICAgIFwibHNcIixcbiAgICAgIFtcbiAgICAgICAgIFwiYmFzaXNcIixcbiAgICAgICAgIFwid3J3XCIsXG4gICAgICAgICBcImxwX3JfbGlua3NcIixcbiAgICAgICAgIFwibHBfcl9yZWNodHNcIixcbiAgICAgICAgIFwibHBfd19vYmVuXCIsXG4gICAgICAgICBcImxwX3dfdW50ZW5cIixcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwicl9saW5rcyxyX3JlY2h0c1wiKS5vbihcImhwPTBcIiksXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcIndfb2Jlbix3X3VudGVuXCIpLm9uKFwiaHA9MVwiKSxcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwid19vYmVuXCIpLm9uKFwiZXJzYXR6PWtlbm5saWNodFwiKSxcbiAgICAgICAgIFwic2NodXRlX3JfbGlua3NcIixcbiAgICAgICAgIFwic2NodXRlX3JfcmVjaHRzXCIsXG4gICAgICAgICBcInNjaHV0ZV93X29iZW5cIixcbiAgICAgICAgIFwic2NodXRlX3dfdW50ZW5cIixcbiAgICAgICAgIG5ldyBWaXN1YWxFbGVtZW50KFwic2NoaWxkXCIpLm9uKFwiYmV6XCIpLmNoaWxkcyhbbmV3IFRleHRFbGVtZW50KFwiYmV6XCIsIFs1NSxcImNvbmRlbmNlZFwiLDFdLCBcIiMzMzNcIikucG9zKFsyMTAsIDEyNV0pXSksXG4gICAgICBdLFxuICAgICAgXCJocD0wXCJcbiAgICk7XG4gICB0LnNjYWxlID0gMC4wNztcbiAgIHQuY3JlYXRlU2lnbmFsQ29tbWFuZE1lbnUoW1wiaHA9MCxocD0xKFNoIDEpXCIsIFwiZXJzYXR6PWtlbm5saWNodChLZW5ubGljaHQpXCJdKTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5scyA9IHQ7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy5uZTQgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXCJuZTRcIiwgXCJOZSA0XCIsIFwiYmFzaXNcIik7XG4gICBzaWduYWxUZW1wbGF0ZXMubmU0LnNjYWxlID0gMC4yO1xuICAgc2lnbmFsVGVtcGxhdGVzLm5lNC5wcmV2aWV3c2l6ZSA9IDEwO1xuXG4gICBzaWduYWxUZW1wbGF0ZXMubmUxID0gbmV3IFNpZ25hbFRlbXBsYXRlKFwibmUxXCIsIFwiTmUgMVwiLCBcImJhc2lzXCIsIFtcbiAgICAgIFwibmUxXCIsXG4gICAgICBuZXcgVGV4dEVsZW1lbnQoXCJuZTFcIiwgWzIwLCBcIkFyaWFsXCIsIDFdKS5wb3MoWzEwMCwgMTA1XSksXG4gICBdKTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5uZTEuc2NhbGUgPSAwLjE1O1xuICAgc2lnbmFsVGVtcGxhdGVzLm5lMS5kaXN0YW5jZV9mcm9tX3RyYWNrID0gNTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5uZTIgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXCJuZTJcIiwgXCJOZSAyXCIsIFwiYmFzaXNcIik7XG4gICBzaWduYWxUZW1wbGF0ZXMubmUyLnNjYWxlID0gMC4yNTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5uZTIucHJldmlld3NpemUgPSAyMDtcblxuICAgc2lnbmFsVGVtcGxhdGVzLmxmNiA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwibGY2XCIsXG4gICAgICBcIkxmIDZcIixcbiAgICAgIFwiYmFzaXNcIixcbiAgICAgIFtcImxmNlwiLCBuZXcgVGV4dEVsZW1lbnQoXCJnZXNjaHdcIiwgWzExMCwgXCJBcmlhbFwiLCAxXSwgXCIjMzMzXCIpLnBvcyhbOTgsIDhdKV0sXG4gICAgICBbXCJzbGF2ZVwiLCBcImdlc2Nodz05XCJdXG4gICApO1xuICAgc2lnbmFsVGVtcGxhdGVzLmxmNi5jcmVhdGVTaWduYWxDb21tYW5kTWVudShbXCJnZXNjaHcoKVwiXSk7XG4gICBzaWduYWxUZW1wbGF0ZXMubGY2LnNjYWxlID0gMC4xMjtcblxuICAgc2lnbmFsVGVtcGxhdGVzLmxmNyA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwibGY3XCIsXG4gICAgICBcIkxmIDdcIixcbiAgICAgIFwiYmFzaXNcIixcbiAgICAgIFtcImxmN1wiLCBuZXcgVGV4dEVsZW1lbnQoXCJnZXNjaHdcIiwgWzEzMCwgXCJBcmlhbFwiLCAxXSwgXCIjMzMzXCIpLnBvcyhbNTUsIDIwXSldLFxuICAgICAgW1wibWFzdGVyXCIsIFwiZ2VzY2h3PTlcIl1cbiAgICk7XG4gICBzaWduYWxUZW1wbGF0ZXMubGY3LmNyZWF0ZVNpZ25hbENvbW1hbmRNZW51KFtcImdlc2NodygpXCJdKTtcbiAgIHNpZ25hbFRlbXBsYXRlcy5sZjcuc2NhbGUgPSAwLjE1O1xuICAgc2lnbmFsVGVtcGxhdGVzLmxmNy5wcmV2aWV3c2l6ZSA9IDMwO1xuXG4gICBzaWduYWxUZW1wbGF0ZXMubGY3LmNoZWNrU2lnbmFsRGVwZW5kZW5jeSA9IHNpZ25hbFRlbXBsYXRlcy5sZjYuY2hlY2tTaWduYWxEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHNpZ25hbCwgaHApIHtcbiAgICAgIGlmIChzaWduYWwuX3RlbXBsYXRlLmlkID09IFwibGY2XCIgJiYgaHAuX3RlbXBsYXRlLmlkID09IFwibGY3XCIpIHtcbiAgICAgICAgIHNpZ25hbC5zZXRfc3RlbGx1bmcoXCJnZXNjaHdcIiwgaHAuZ2V0KFwiZ2VzY2h3XCIpLCBmYWxzZSk7XG4gICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH07XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy56czMgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXG4gICAgICBcInpzM1wiLFxuICAgICAgXCJacyAzIChhbGxlaW5zdC4pXCIsXG4gICAgICBcImJhc2lzXCIsXG4gICAgICBbXCJ6czNcIiwgbmV3IFRleHRFbGVtZW50KFwiZ2VzY2h3XCIsWzEyMCwgXCJBcmlhbFwiLCAxXSkucG9zKFs5MCwgNjBdKV0sXG4gICAgICBcImdlc2Nodz05XCJcbiAgICk7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy56czMuY3JlYXRlU2lnbmFsQ29tbWFuZE1lbnUoW1wiZ2VzY2h3KClcIl0pO1xuICAgc2lnbmFsVGVtcGxhdGVzLnpzMy5zY2FsZSA9IDAuMTU7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy56czEwID0gbmV3IFNpZ25hbFRlbXBsYXRlKFwienMxMFwiLCBcIlpzIDEwXCIsIFwiYmFzaXNcIik7XG4gICBzaWduYWxUZW1wbGF0ZXMuenMxMC5zY2FsZSA9IDAuMjtcbiAgIHNpZ25hbFRlbXBsYXRlcy56czEwLnByZXZpZXdzaXplID0gMTU7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy5yYTEwID0gbmV3IFNpZ25hbFRlbXBsYXRlKFwicmExMFwiLCBcIlJhIDEwXCIsIFwiYmFzaXNcIik7XG4gICBzaWduYWxUZW1wbGF0ZXMucmExMC5zY2FsZSA9IDAuMTU7XG5cbiAgIHNpZ25hbFRlbXBsYXRlcy56czYgPSBuZXcgU2lnbmFsVGVtcGxhdGUoXCJ6czZcIiwgXCJacyA2XCIsIFwiYmFzaXNcIiwgW1wienM2X2JsZWNoX21hc3RcIiwgXCJ6czZfYmxlY2hcIl0pO1xuICAgc2lnbmFsVGVtcGxhdGVzLnpzNi5zY2FsZSA9IDAuMjtcbiAgIHNpZ25hbFRlbXBsYXRlcy56czYucHJldmlld3NpemUgPSAzMDtcblxuICAgc2lnbmFsVGVtcGxhdGVzLnp1c2F0elNpZ25hbCA9IG5ldyBTaWduYWxUZW1wbGF0ZShcbiAgICAgIFwienVzYXR6XCIsXG4gICAgICBcIlp1c2F0emFuemVpZ2VyXCIsXG4gICAgICBcImJhc2lzXCIsXG4gICAgICBbXG4gICAgICAgICBcInp1c2F0emFuemVpZ2VyXCIsXG4gICAgICAgICBuZXcgVmlzdWFsRWxlbWVudChcInpzNl9saWNodFwiKS5vbihcInpzNj0xXCIpLFxuICAgICAgICAgbmV3IFRleHRFbGVtZW50KFwienMzXCIsIFs4NSxcIkRPVFwiXSkucG9zKFs3MCwgNDBdKS5vZmYoXCJ6czY9MVwiKS5vbihcInpzMz4wXCIpLFxuICAgICAgXSxcbiAgICAgIFwienM2PTFcIlxuICAgKTtcbiAgIHNpZ25hbFRlbXBsYXRlcy56dXNhdHpTaWduYWwuc2NhbGUgPSAwLjE1O1xuICAgc2lnbmFsVGVtcGxhdGVzLnp1c2F0elNpZ25hbC5jcmVhdGVTaWduYWxDb21tYW5kTWVudShbW1wienM2PTEoWnMgNilcIl0sIFwienMzKClcIl0pO1xuICAgc2lnbmFsVGVtcGxhdGVzLnp1c2F0elNpZ25hbC5wcmV2aWV3c2l6ZSA9IDMwO1xufVxuXG5cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/code/signal_library.js\n\n}");

/***/ }),

/***/ "./www/code/signaling.js":
/*!*******************************!*\
  !*** ./www/code/signaling.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SignalTemplate: () => (/* binding */ SignalTemplate),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   VisualElement: () => (/* binding */ VisualElement)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _application_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./application.js */ \"./www/code/application.js\");\n\n\n// ES6 Module imports\n\n\n\n//Signals are build of Visual elements. Some elements are always been drawn, like the \"Mast\", others have a varianty of\n//conditions.\n//1st: a VE has conditions, these must match with the Signals features. e.g.: sh1 are only on Zsig and Asig\n//2nd: the visual elemnt must be enabled.\nclass VisualElement {\n   #_blinkt = null;\n   #_image = null;\n   #_pos = 0;\n   #_enabled = null;\n   #_on = [];\n   #_off = null;\n   #_childs = null;\n\n   constructor(image) {\n      this.#_image = image;\n   }\n\n   on(condition, logic_op = \"||\") {\n      if (condition === undefined) return this.#_on;\n      else {\n         if (Array.isArray(condition)) condition = condition.join(logic_op);\n         if (this.#_on == null || !Array.isArray(this.#_on)) this.#_on = condition;\n         else this.#_on.push(condition);\n         return this;\n      }\n   }\n\n   off(condition, logic_op = \"||\") {\n      if (condition === undefined) return this.#_off;\n      else {\n         if (Array.isArray(condition)) condition = condition.join(logic_op);\n         if (this.#_off == null || !Array.isArray(this.#_off)) this.#_off = condition;\n         else this.#_off.push(condition);\n         return this;\n      }\n   }\n\n   childs(childs) {\n      if (childs === undefined) return this.#_childs;\n      else {\n         this.#_childs = childs;\n         return this;\n      }\n   }\n\n   blinkt(blinkt) {\n      if (blinkt === undefined) return this.#_blinkt;\n      else {\n         this.#_blinkt = blinkt;\n         return this;\n      }\n   }\n\n   pos(pos) {\n      if (pos === undefined) return this.#_pos;\n      else {\n         this.#_pos = pos;\n         return this;\n      }\n   }\n\n   get [Symbol.toStringTag]() {\n      return this.#_image;\n   }\n\n   get image() {\n      return this.#_image;\n   }\n\n   //visual elements are visible if the enabled function returns true and the signalstellung is set on the signal\n   //if both are not set, its always enabled\n   isEnabled(signal) {\n      return (this.#_enabled == null || this.#_enabled(signal)) && signal.check(this.#_on);\n   }\n\n   isAllowed(signal) {\n      return this.off() == null || !signal.check(this.off());\n   }\n}\n\nclass TextElement extends VisualElement {\n   #_format;\n   #_color;\n   #_source;\n   #_width_height;\n\n   constructor(source, format = [\"25\",\"Arial\",\"bold\"], color = \"#eee\") {\n      super();\n      this.#_source = source;\n      this.#_format = format;\n      this.#_color = color;\n   }\n\n   \n   get format() {\n      return this.#_format;\n   }\n\n   get color() {\n      return this.#_color;\n   }\n\n\n   //must be an array containing max width and height\n   bounds(width_height){\n      if (width_height === undefined) return this.#_width_height;\n      else {         \n         this.#_width_height = width_height;\n         return this;\n      }\n   }\n\n   getText(signal) {\n      return signal.get(this.#_source);\n   }\n}\n\nclass SignalTemplate {\n   #_id = null;\n   #_title = null;\n   #_start = null;\n   #_json_file = null;\n   #_scale = 0.5;\n   #_signalMenu = null;\n   #_distance_from_track = 0;\n\n   contextMenu = [];\n   elements = [];\n   rules = [];\n\n   get id() {\n      return this.#_id;\n   }\n   get title() {\n      return this.#_title;\n   }\n   get initialSignalStellung() {\n      return this.#_start;\n   }\n   get json_file() {\n      return this.#_json_file;\n   }\n   get scale() {\n      return this.#_scale;\n   }\n   set scale(v) {\n      this.#_scale = v;\n   }\n   get distance_from_track() {\n      return this.#_distance_from_track;\n   }\n   set distance_from_track(v) {\n      this.#_distance_from_track = v;\n   }\n\n   get signalMenu() {\n      return this.#_signalMenu;\n   }\n\n   get start() {\n      return this.#_start;\n   }\n\n   ///creates a structed onbject tree that represents a menu from an array of strings\n   ///array: keeps the array\n   ///comma sperated string e.g.\"hp=0,hp=1,hp=2\": buttonGroup\n   ///single string e.g. \"verk=1(verk)\": btn\n   ///single string without '=' e.g. zs3v: dropdown\n   createSignalCommandMenu(menu_string_array) {\n      let menu_items = menu_string_array.map(\n         function (item) {\n            if (!Array.isArray(item)) item = [item];\n            return item.map(\n               function (str) {\n                  let items = str.split(\",\").map(\n                     function (str) {\n                        let text, command;\n                        let match = str.match(/\\(([^)]*)\\)/);\n                        if (match) {\n                           command = str.split(\"(\")[0];\n                           text = match[1];\n                        } else {\n                           command = str;\n                           // 1. Entferne alles vor und inklusive einem \"=\"\n                           text = command.includes(\"=\") ? command.split(\"=\")[1] : command;\n                           if (text.length == 1) text = command.replace(\"=\", \" \");\n                           else text = text.replace(/(\\d)/, \" $1\");\n                           // 2. Das erste Zeichen in einen Großbuchstaben verwandeln\n                           text = text.charAt(0).toUpperCase() + text.slice(1);\n                        }\n                        return {\n                           type: command.includes(\"=\") ? \"btn\" : \"dropdown\",\n                           text: text,\n                           command: command,\n                           visual_elements: this.getVisualElementsByOnCondition(command),\n                        };\n                     }.bind(this)\n                  );\n\n                  if (items.length > 1)\n                     return {\n                        type: \"buttonGroup\",\n                        items: items,\n                     };\n                  else return items[0];\n               }.bind(this)\n            );\n         }.bind(this)\n      );\n      this.#_signalMenu = menu_items;\n   }\n\n   constructor(id, title, json_file, startElements, initialSignalStellung) {\n      this.#_id = id;\n      this.#_title = title;\n      if (initialSignalStellung) this.#_start = Array.isArray(initialSignalStellung) ? initialSignalStellung : [initialSignalStellung];\n      this.#_json_file = json_file;\n\n      if (startElements) {\n         if (Array.isArray(startElements)) this.elements = startElements;\n         else this.elements = [startElements];\n      } else this.elements = [id];\n\n      _application_js__WEBPACK_IMPORTED_MODULE_1__.Application.getInstance().preLoader.addSpriteSheet(json_file);\n   }\n\n   getVisualElementsByOnCondition(condition) {\n      let results = [];\n      function iterateItems(ve) {\n         if (Array.isArray(ve)) return ve.some((item) => iterateItems(item));\n         else if (ve instanceof VisualElement) {\n            if (ve.childs()?.some((item) => iterateItems(item)) || [].concat(ve.on()).some((c) => c === condition)) {\n               results.push(ve);\n               return true;\n            }\n         }\n         return false;\n      }\n\n      iterateItems(this.elements);\n\n      return results;\n   }\n\n   ///returns an array with all conditions. Used by UI to determent if a Feauture should be displayed\n   getAllVisualElementConditions() {\n      const stack = [...this.elements];\n      const conditions = [];\n      let ve;\n      while (stack.length > 0) {\n         ve = stack.pop();\n         if (typeof ve == \"object\") {\n            [].concat(ve.on()).forEach((c) => {\n               if (c) c.split(\"&&\").forEach((c) => _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.pushUnique(conditions, c.replace(\"!\", \"\")));\n            });\n\n            if (ve.childs()) stack.push(...ve.childs());\n         }\n      }\n      return conditions;\n   }\n\n   addRule(trigger, setting) {\n      this.rules.push([trigger, setting]);\n   }\n\n   stringify() {\n      return this.id;\n   }\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS9zaWduYWxpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBYTs7QUFFYjtBQUN3QztBQUNPOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUixNQUFNLHdEQUFXO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpREFBVTtBQUM3RCxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2xlaXNwbGFuZWRpdG9yLy4vd3d3L2NvZGUvc2lnbmFsaW5nLmpzP2IwOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgQXJyYXlVdGlscyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQXBwbGljYXRpb24gfSBmcm9tICcuL2FwcGxpY2F0aW9uLmpzJztcblxuLy9TaWduYWxzIGFyZSBidWlsZCBvZiBWaXN1YWwgZWxlbWVudHMuIFNvbWUgZWxlbWVudHMgYXJlIGFsd2F5cyBiZWVuIGRyYXduLCBsaWtlIHRoZSBcIk1hc3RcIiwgb3RoZXJzIGhhdmUgYSB2YXJpYW50eSBvZlxuLy9jb25kaXRpb25zLlxuLy8xc3Q6IGEgVkUgaGFzIGNvbmRpdGlvbnMsIHRoZXNlIG11c3QgbWF0Y2ggd2l0aCB0aGUgU2lnbmFscyBmZWF0dXJlcy4gZS5nLjogc2gxIGFyZSBvbmx5IG9uIFpzaWcgYW5kIEFzaWdcbi8vMm5kOiB0aGUgdmlzdWFsIGVsZW1udCBtdXN0IGJlIGVuYWJsZWQuXG5leHBvcnQgY2xhc3MgVmlzdWFsRWxlbWVudCB7XG4gICAjX2JsaW5rdCA9IG51bGw7XG4gICAjX2ltYWdlID0gbnVsbDtcbiAgICNfcG9zID0gMDtcbiAgICNfZW5hYmxlZCA9IG51bGw7XG4gICAjX29uID0gW107XG4gICAjX29mZiA9IG51bGw7XG4gICAjX2NoaWxkcyA9IG51bGw7XG5cbiAgIGNvbnN0cnVjdG9yKGltYWdlKSB7XG4gICAgICB0aGlzLiNfaW1hZ2UgPSBpbWFnZTtcbiAgIH1cblxuICAgb24oY29uZGl0aW9uLCBsb2dpY19vcCA9IFwifHxcIikge1xuICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy4jX29uO1xuICAgICAgZWxzZSB7XG4gICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25kaXRpb24pKSBjb25kaXRpb24gPSBjb25kaXRpb24uam9pbihsb2dpY19vcCk7XG4gICAgICAgICBpZiAodGhpcy4jX29uID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodGhpcy4jX29uKSkgdGhpcy4jX29uID0gY29uZGl0aW9uO1xuICAgICAgICAgZWxzZSB0aGlzLiNfb24ucHVzaChjb25kaXRpb24pO1xuICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICB9XG5cbiAgIG9mZihjb25kaXRpb24sIGxvZ2ljX29wID0gXCJ8fFwiKSB7XG4gICAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLiNfb2ZmO1xuICAgICAgZWxzZSB7XG4gICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25kaXRpb24pKSBjb25kaXRpb24gPSBjb25kaXRpb24uam9pbihsb2dpY19vcCk7XG4gICAgICAgICBpZiAodGhpcy4jX29mZiA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHRoaXMuI19vZmYpKSB0aGlzLiNfb2ZmID0gY29uZGl0aW9uO1xuICAgICAgICAgZWxzZSB0aGlzLiNfb2ZmLnB1c2goY29uZGl0aW9uKTtcbiAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgfVxuXG4gICBjaGlsZHMoY2hpbGRzKSB7XG4gICAgICBpZiAoY2hpbGRzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLiNfY2hpbGRzO1xuICAgICAgZWxzZSB7XG4gICAgICAgICB0aGlzLiNfY2hpbGRzID0gY2hpbGRzO1xuICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICB9XG5cbiAgIGJsaW5rdChibGlua3QpIHtcbiAgICAgIGlmIChibGlua3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuI19ibGlua3Q7XG4gICAgICBlbHNlIHtcbiAgICAgICAgIHRoaXMuI19ibGlua3QgPSBibGlua3Q7XG4gICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgIH1cblxuICAgcG9zKHBvcykge1xuICAgICAgaWYgKHBvcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy4jX3BvcztcbiAgICAgIGVsc2Uge1xuICAgICAgICAgdGhpcy4jX3BvcyA9IHBvcztcbiAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgfVxuXG4gICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICByZXR1cm4gdGhpcy4jX2ltYWdlO1xuICAgfVxuXG4gICBnZXQgaW1hZ2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy4jX2ltYWdlO1xuICAgfVxuXG4gICAvL3Zpc3VhbCBlbGVtZW50cyBhcmUgdmlzaWJsZSBpZiB0aGUgZW5hYmxlZCBmdW5jdGlvbiByZXR1cm5zIHRydWUgYW5kIHRoZSBzaWduYWxzdGVsbHVuZyBpcyBzZXQgb24gdGhlIHNpZ25hbFxuICAgLy9pZiBib3RoIGFyZSBub3Qgc2V0LCBpdHMgYWx3YXlzIGVuYWJsZWRcbiAgIGlzRW5hYmxlZChzaWduYWwpIHtcbiAgICAgIHJldHVybiAodGhpcy4jX2VuYWJsZWQgPT0gbnVsbCB8fCB0aGlzLiNfZW5hYmxlZChzaWduYWwpKSAmJiBzaWduYWwuY2hlY2sodGhpcy4jX29uKTtcbiAgIH1cblxuICAgaXNBbGxvd2VkKHNpZ25hbCkge1xuICAgICAgcmV0dXJuIHRoaXMub2ZmKCkgPT0gbnVsbCB8fCAhc2lnbmFsLmNoZWNrKHRoaXMub2ZmKCkpO1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGV4dEVsZW1lbnQgZXh0ZW5kcyBWaXN1YWxFbGVtZW50IHtcbiAgICNfZm9ybWF0O1xuICAgI19jb2xvcjtcbiAgICNfc291cmNlO1xuICAgI193aWR0aF9oZWlnaHQ7XG5cbiAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZm9ybWF0ID0gW1wiMjVcIixcIkFyaWFsXCIsXCJib2xkXCJdLCBjb2xvciA9IFwiI2VlZVwiKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy4jX3NvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuI19mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICB0aGlzLiNfY29sb3IgPSBjb2xvcjtcbiAgIH1cblxuICAgXG4gICBnZXQgZm9ybWF0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19mb3JtYXQ7XG4gICB9XG5cbiAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfY29sb3I7XG4gICB9XG5cblxuICAgLy9tdXN0IGJlIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF4IHdpZHRoIGFuZCBoZWlnaHRcbiAgIGJvdW5kcyh3aWR0aF9oZWlnaHQpe1xuICAgICAgaWYgKHdpZHRoX2hlaWdodCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy4jX3dpZHRoX2hlaWdodDtcbiAgICAgIGVsc2UgeyAgICAgICAgIFxuICAgICAgICAgdGhpcy4jX3dpZHRoX2hlaWdodCA9IHdpZHRoX2hlaWdodDtcbiAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgfVxuXG4gICBnZXRUZXh0KHNpZ25hbCkge1xuICAgICAgcmV0dXJuIHNpZ25hbC5nZXQodGhpcy4jX3NvdXJjZSk7XG4gICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaWduYWxUZW1wbGF0ZSB7XG4gICAjX2lkID0gbnVsbDtcbiAgICNfdGl0bGUgPSBudWxsO1xuICAgI19zdGFydCA9IG51bGw7XG4gICAjX2pzb25fZmlsZSA9IG51bGw7XG4gICAjX3NjYWxlID0gMC41O1xuICAgI19zaWduYWxNZW51ID0gbnVsbDtcbiAgICNfZGlzdGFuY2VfZnJvbV90cmFjayA9IDA7XG5cbiAgIGNvbnRleHRNZW51ID0gW107XG4gICBlbGVtZW50cyA9IFtdO1xuICAgcnVsZXMgPSBbXTtcblxuICAgZ2V0IGlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19pZDtcbiAgIH1cbiAgIGdldCB0aXRsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfdGl0bGU7XG4gICB9XG4gICBnZXQgaW5pdGlhbFNpZ25hbFN0ZWxsdW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19zdGFydDtcbiAgIH1cbiAgIGdldCBqc29uX2ZpbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy4jX2pzb25fZmlsZTtcbiAgIH1cbiAgIGdldCBzY2FsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfc2NhbGU7XG4gICB9XG4gICBzZXQgc2NhbGUodikge1xuICAgICAgdGhpcy4jX3NjYWxlID0gdjtcbiAgIH1cbiAgIGdldCBkaXN0YW5jZV9mcm9tX3RyYWNrKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19kaXN0YW5jZV9mcm9tX3RyYWNrO1xuICAgfVxuICAgc2V0IGRpc3RhbmNlX2Zyb21fdHJhY2sodikge1xuICAgICAgdGhpcy4jX2Rpc3RhbmNlX2Zyb21fdHJhY2sgPSB2O1xuICAgfVxuXG4gICBnZXQgc2lnbmFsTWVudSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfc2lnbmFsTWVudTtcbiAgIH1cblxuICAgZ2V0IHN0YXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19zdGFydDtcbiAgIH1cblxuICAgLy8vY3JlYXRlcyBhIHN0cnVjdGVkIG9uYmplY3QgdHJlZSB0aGF0IHJlcHJlc2VudHMgYSBtZW51IGZyb20gYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgLy8vYXJyYXk6IGtlZXBzIHRoZSBhcnJheVxuICAgLy8vY29tbWEgc3BlcmF0ZWQgc3RyaW5nIGUuZy5cImhwPTAsaHA9MSxocD0yXCI6IGJ1dHRvbkdyb3VwXG4gICAvLy9zaW5nbGUgc3RyaW5nIGUuZy4gXCJ2ZXJrPTEodmVyaylcIjogYnRuXG4gICAvLy9zaW5nbGUgc3RyaW5nIHdpdGhvdXQgJz0nIGUuZy4genMzdjogZHJvcGRvd25cbiAgIGNyZWF0ZVNpZ25hbENvbW1hbmRNZW51KG1lbnVfc3RyaW5nX2FycmF5KSB7XG4gICAgICBsZXQgbWVudV9pdGVtcyA9IG1lbnVfc3RyaW5nX2FycmF5Lm1hcChcbiAgICAgICAgIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbSkpIGl0ZW0gPSBbaXRlbV07XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5tYXAoXG4gICAgICAgICAgICAgICBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBzdHIuc3BsaXQoXCIsXCIpLm1hcChcbiAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0LCBjb21tYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gc3RyLm1hdGNoKC9cXCgoW14pXSopXFwpLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBzdHIuc3BsaXQoXCIoXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBzdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLiBFbnRmZXJuZSBhbGxlcyB2b3IgdW5kIGlua2x1c2l2ZSBlaW5lbSBcIj1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGNvbW1hbmQuaW5jbHVkZXMoXCI9XCIpID8gY29tbWFuZC5zcGxpdChcIj1cIilbMV0gOiBjb21tYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEpIHRleHQgPSBjb21tYW5kLnJlcGxhY2UoXCI9XCIsIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGV4dCA9IHRleHQucmVwbGFjZSgvKFxcZCkvLCBcIiAkMVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuIERhcyBlcnN0ZSBaZWljaGVuIGluIGVpbmVuIEdyb8OfYnVjaHN0YWJlbiB2ZXJ3YW5kZWxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbWFuZC5pbmNsdWRlcyhcIj1cIikgPyBcImJ0blwiIDogXCJkcm9wZG93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2aXN1YWxfZWxlbWVudHM6IHRoaXMuZ2V0VmlzdWFsRWxlbWVudHNCeU9uQ29uZGl0aW9uKGNvbW1hbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25Hcm91cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGl0ZW1zWzBdO1xuICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgICAgdGhpcy4jX3NpZ25hbE1lbnUgPSBtZW51X2l0ZW1zO1xuICAgfVxuXG4gICBjb25zdHJ1Y3RvcihpZCwgdGl0bGUsIGpzb25fZmlsZSwgc3RhcnRFbGVtZW50cywgaW5pdGlhbFNpZ25hbFN0ZWxsdW5nKSB7XG4gICAgICB0aGlzLiNfaWQgPSBpZDtcbiAgICAgIHRoaXMuI190aXRsZSA9IHRpdGxlO1xuICAgICAgaWYgKGluaXRpYWxTaWduYWxTdGVsbHVuZykgdGhpcy4jX3N0YXJ0ID0gQXJyYXkuaXNBcnJheShpbml0aWFsU2lnbmFsU3RlbGx1bmcpID8gaW5pdGlhbFNpZ25hbFN0ZWxsdW5nIDogW2luaXRpYWxTaWduYWxTdGVsbHVuZ107XG4gICAgICB0aGlzLiNfanNvbl9maWxlID0ganNvbl9maWxlO1xuXG4gICAgICBpZiAoc3RhcnRFbGVtZW50cykge1xuICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RhcnRFbGVtZW50cykpIHRoaXMuZWxlbWVudHMgPSBzdGFydEVsZW1lbnRzO1xuICAgICAgICAgZWxzZSB0aGlzLmVsZW1lbnRzID0gW3N0YXJ0RWxlbWVudHNdO1xuICAgICAgfSBlbHNlIHRoaXMuZWxlbWVudHMgPSBbaWRdO1xuXG4gICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnByZUxvYWRlci5hZGRTcHJpdGVTaGVldChqc29uX2ZpbGUpO1xuICAgfVxuXG4gICBnZXRWaXN1YWxFbGVtZW50c0J5T25Db25kaXRpb24oY29uZGl0aW9uKSB7XG4gICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgICAgZnVuY3Rpb24gaXRlcmF0ZUl0ZW1zKHZlKSB7XG4gICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2ZSkpIHJldHVybiB2ZS5zb21lKChpdGVtKSA9PiBpdGVyYXRlSXRlbXMoaXRlbSkpO1xuICAgICAgICAgZWxzZSBpZiAodmUgaW5zdGFuY2VvZiBWaXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodmUuY2hpbGRzKCk/LnNvbWUoKGl0ZW0pID0+IGl0ZXJhdGVJdGVtcyhpdGVtKSkgfHwgW10uY29uY2F0KHZlLm9uKCkpLnNvbWUoKGMpID0+IGMgPT09IGNvbmRpdGlvbikpIHtcbiAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2ZSk7XG4gICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZUl0ZW1zKHRoaXMuZWxlbWVudHMpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgIH1cblxuICAgLy8vcmV0dXJucyBhbiBhcnJheSB3aXRoIGFsbCBjb25kaXRpb25zLiBVc2VkIGJ5IFVJIHRvIGRldGVybWVudCBpZiBhIEZlYXV0dXJlIHNob3VsZCBiZSBkaXNwbGF5ZWRcbiAgIGdldEFsbFZpc3VhbEVsZW1lbnRDb25kaXRpb25zKCkge1xuICAgICAgY29uc3Qgc3RhY2sgPSBbLi4udGhpcy5lbGVtZW50c107XG4gICAgICBjb25zdCBjb25kaXRpb25zID0gW107XG4gICAgICBsZXQgdmU7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgdmUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgIGlmICh0eXBlb2YgdmUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgW10uY29uY2F0KHZlLm9uKCkpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgIGlmIChjKSBjLnNwbGl0KFwiJiZcIikuZm9yRWFjaCgoYykgPT4gQXJyYXlVdGlscy5wdXNoVW5pcXVlKGNvbmRpdGlvbnMsIGMucmVwbGFjZShcIiFcIiwgXCJcIikpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodmUuY2hpbGRzKCkpIHN0YWNrLnB1c2goLi4udmUuY2hpbGRzKCkpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmRpdGlvbnM7XG4gICB9XG5cbiAgIGFkZFJ1bGUodHJpZ2dlciwgc2V0dGluZykge1xuICAgICAgdGhpcy5ydWxlcy5wdXNoKFt0cmlnZ2VyLCBzZXR0aW5nXSk7XG4gICB9XG5cbiAgIHN0cmluZ2lmeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgfVxufVxuXG5cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/code/signaling.js\n\n}");

/***/ }),

/***/ "./www/code/start.js":
/*!***************************!*\
  !*** ./www/code/start.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signalTemplates: () => (/* binding */ signalTemplates)\n/* harmony export */ });\n/* harmony import */ var _preLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./preLoader.js */ \"./www/code/preLoader.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n/* harmony import */ var _trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./trackRendering_basic.js */ \"./www/code/trackRendering_basic.js\");\n/* harmony import */ var _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./trackRendering_textured.js */ \"./www/code/trackRendering_textured.js\");\n/* harmony import */ var _signal_library_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./signal_library.js */ \"./www/code/signal_library.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./config.js */ \"./www/code/config.js\");\n/* harmony import */ var _application_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./application.js */ \"./www/code/application.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar grid;\nvar app;\nvar previousTouch;\nvar showGrid = true;\nvar edit_mode = true;\n\nvar renderer;\n\nvar undoHistory = [];\n\nvar signalTemplates = {};\n\n\n// Make variables globally accessible for other modules during transition\n\nwindow.DIRECTION = _config_js__WEBPACK_IMPORTED_MODULE_13__.DIRECTION;\nwindow.CUSTOM_MOUSE_ACTION = _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION;\nwindow.MOST_UNDO = _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.MOST_UNDO;\nwindow.signalTemplates = signalTemplates;\nwindow.updateUndoButtonState = updateUndoButtonState;\nwindow.selectObject = selectObject;\nwindow.selectRenderer = selectRenderer;\nwindow.deleteSelectedObject = deleteSelectedObject;\nwindow.alignSignalContainerWithTrack = alignSignalContainerWithTrack;\nwindow.startDragAndDropSignal = startDragAndDropSignal;\nwindow.handleMouseMove = handleMouseMove;\nwindow.handleStageMouseDown = handleStageMouseDown;\nwindow.handleStageMouseUp = handleStageMouseUp;\n\n$(() => {\n   initializeApplication();\n});\n\nasync function initializeApplication() {\n   try {\n      app = _application_js__WEBPACK_IMPORTED_MODULE_14__.Application.getInstance();\n      await app.initialize();\n      \n      // Set up remaining event listeners (temporary until moved to Application class)\n      initializeRemainingEventListeners();\n      \n      // Show pre-build screen after initialization\n      UI.showPreBuildScreen();\n      \n   } catch (error) {\n      console.error(\"Failed to initialize application:\", error);\n      _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showErrorToast(error);\n   }\n}\n\n// After the application is initialized, set up the remaining event listeners\n// These will be moved to the Application class in later phases\nfunction initializeRemainingEventListeners() {\n   app.stage.addEventListener(\"stagemousedown\", handleStageMouseDown);\n   app.stage.addEventListener(\"stagemouseup\", handleStageMouseUp);\n\n   myCanvas.oncontextmenu = () => false;\n   myCanvas.addEventListener(\"wheel\", (event) => {\n      event.preventDefault();\n      if (!myCanvas.prevent_input) {\n         myCanvas.prevent_input = true;\n         let point = new createjs.Point(app.stage.mouseX, app.stage.mouseY);\n         let localPoint = app.stage.globalToLocal(point.x, point.y);\n         let old_scale = app.stage.scale;\n         let step = event.deltaY / (_config_js__WEBPACK_IMPORTED_MODULE_13__.INPUT.ZOOM_STEP_DIVISOR / app.stage.scale);\n         app.stage.scale -= step;\n         app.stage.scale = Math.min(Math.max(_config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.MIN_SCALE, app.stage.scale), _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.MAX_SCALE);\n\n         if (app.stage.scale != old_scale) {\n            //if we reached MIN or MAX, the scale value doesnt change anymore\n            // Find where the original point is now\n            let globalPoint = app.stage.localToGlobal(localPoint.x, localPoint.y);\n            // Move the map by the difference\n            app.stage.x -= globalPoint.x - point.x;\n            app.stage.y -= globalPoint.y - point.y;\n            RENDERING.drawGrid();\n            app.renderer.reDrawEverything();\n            app.stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n         }\n         myCanvas.prevent_input = false;\n      }\n   });\n   if (createjs.Touch.isSupported()) {\n      myCanvas.addEventListener(\"touchstart\", (event) => {\n         if (event.touches.length === 1) {\n            let touch = event.touches[0];\n            //startTrackDrawing(app.stage.globalToLocal(touch.clientX, touch.clientY));\n         }\n\n         /* console.log(\"touch:\" + event.touches.length);\n            for (let index = 0; index < event.touches.length; index++) {\n                const item = event.touches[index];\n                console.log(\"x:\" + item.clientX + \":\" + item.clientY);\n            } */\n      });\n\n      myCanvas.addEventListener(\"touchmove\", (event) => {\n         if (event.touches.length === 1) {\n            let touch = event.touches[0];\n\n            if (previousTouch) {\n               // be aware that these only store the movement of the first touch in the touches array\n               app.stage.x += touch.clientX - previousTouch.clientX;\n               app.stage.y += touch.clientY - previousTouch.clientY;\n\n               RENDERING.drawGrid(false);\n               renderer.reDrawEverything();\n            }\n\n            previousTouch = touch;\n         }\n      });\n   }\n\n   $(\"#btnDrawTracks,#btnPlay\").click(() => toggleEditMode());\n\n   $(\"#switch_renderer\").on(\"change\", (e) => {\n      selectRenderer(!$(\"#switch_renderer\").is(\":checked\"));\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n   });\n\n   $(\"#btnAddSignals\").click(() => UI.showMenu(_config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.NEW_SIGNAL));\n   $(\"#btnAddTrain\").click(() => UI.showMenu(_config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.NEW_TRAIN));\n   $(\"#btnAddObject\").click(() => UI.showMenu(_config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.NEW_OBJECT));\n\n   $(\"#btnClear\").click(() => {\n      RENDERING.clear();\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n   });\n\n   $(\"#btnCenter\").click(() => {\n      RENDERING.center();\n   });\n\n   $(\"#btnRedraw\").click(() => {\n      //testPerformance(() => renderer.reDrawEverything(true), \"Total redraw time\");\n      app.renderer.reDrawEverything(true);\n   });\n\n   $(\"#btnImage\").click((e) => {\n      let backup = { x: app.stage.x, y: app.stage.y, scale: app.stage.scale };\n\n      try {\n         const custom_scale = 2;\n         app.stage.enableDOMEvents(false);\n\n         app.stage.scale = custom_scale;\n\n         app.renderer.reDrawEverything(true, true);\n\n         let bounds = app.containers.main.getBounds();\n         if (!bounds) {\n            _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showInfoToast(\"nothing to export\");\n            return;\n         }\n         const anotherCanvas = $(\"<canvas>\", { id: \"test\" })\n            .attr(\"width\", bounds.width * custom_scale)\n            .attr(\"height\", bounds.height * custom_scale);\n         app.stage.canvas = anotherCanvas[0];\n         app.stage.x = bounds.x * -custom_scale;\n         app.stage.y = bounds.y * -custom_scale;\n         grid.visible = false;\n         app.containers.drawing.visible = false;\n         app.containers.ui.visible = false;\n         app.stage.update();\n\n         let img_data = app.stage.toDataURL(_config_js__WEBPACK_IMPORTED_MODULE_13__.COLORS.TRANSPARENT, \"image/png\");\n         const img = $(\"<img>\", { src: img_data, width: \"100%\" }).css(\"object-fit\", \"scale-down\").css(\"max-height\", \"50vh\");\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showModalDialog(img, (e) => {\n            const a = $(\"<a>\", { download: \"gleisplan.png\", href: img_data });\n            a[0].click();\n         });\n      } catch (error) {\n         _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showErrorToast(error);\n      } finally {\n         app.stage.x = backup.x;\n         app.stage.y = backup.y;\n         app.stage.scale = backup.scale;\n         app.stage.canvas = myCanvas;\n         grid.visible = showGrid;\n         app.containers.drawing.visible = true;\n         app.containers.ui.visible = true;\n         app.renderer.reDrawEverything(true);\n         app.stage.enableDOMEvents(true);\n         app.stage.update();\n      }\n   });\n\n   $(\"#btnDraw\").click((e) => {\n      app.customMouseMode = $(\"#btnDraw\").hasClass(\"active\") ? _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.DRAWING : _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.NONE;\n      \n      const bsOffcanvas = bootstrap.Offcanvas.getOrCreateInstance(document.getElementById(\"drawingPanel\"));\n      if (app.customMouseMode === _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.DRAWING) {\n         bsOffcanvas.show();\n      } else {\n         bsOffcanvas.hide();\n      }\n   });\n\n   $(\"#btnDrawingClear\").click((e) => {\n      app.containers.drawing.removeAllChildren();\n      app.stage.update();\n   });\n\n   $(\"#btnGrundstellung\").click((e) => {\n      if (app.selection.type == \"Signal\") {\n         [].concat(app.selection.object).forEach((s) => {\n            s._signalStellung = {};\n            if (s._template.initialSignalStellung)\n               s._template.initialSignalStellung.forEach((i) => s.set_stellung(i, null, true));\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            app.renderer.reDrawEverything(true);\n            app.stage.update();\n         });\n      }\n   });\n\n   $(\"#btnUndo\").click((e) => {\n      undo();\n   });\n\n   document.addEventListener(\"keydown\", (e) => {\n      if (e.target.tagName != \"INPUT\" && (e.code == \"Delete\" || e.code == \"Backspace\")) {\n         deleteSelectedObject();\n      }\n   });\n\n   $(\"#signalEditMenuHeader a\").on(\"click\", () => {\n      $(\"#signalEditMenuHeader .card-text\").hide();\n      $(\"#signalEditMenuHeader input\")\n         .val(app.selection.object.get(\"bez\"))\n         .show()\n         .focus()\n         .on(\"keydown\", function (e) {\n            if (e.key === \"Enter\") {\n               app.selection.object.set_stellung(\"bez\", $(this).val());\n               $(\"#signalEditMenuHeader .card-text\").show();\n               $(\"#signalEditMenuHeader input\").hide();\n               _signal_js__WEBPACK_IMPORTED_MODULE_1__.Sig_UI.syncSignalMenu(app.selection.object);\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n               app.renderer.reDrawEverything(true);\n               app.stage.update();\n            }\n         })\n         .on(\"blur\", () => {\n            $(\"#signalEditMenuHeader .card-text\").show();\n            $(\"#signalEditMenuHeader input\").hide();\n         });\n   });\n\n   onResizeWindow();\n   toggleEditMode(edit_mode);\n\n   $(window).resize(onResizeWindow);\n   myCanvas.focus();\n}\n\nfunction deleteSelectedObject() {\n   if (app.selection.object) {\n      if (app.selection.type == \"Track\") {\n         const removedTracks = [].concat(app.selection.object);\n         removedTracks.forEach((t) => _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.removeTrack(t));\n         // Check and remove any trains that were on the deleted tracks\n         for (const track of removedTracks) {\n            const trainsOnTrack = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.allTrains.filter((train) => train.track === track);\n            for (const train of trainsOnTrack) {\n               _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.deleteTrain(train);\n            }\n         }\n         _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.createRailNetwork();\n      }\n      if (app.selection.type == \"Signal\") [].concat(app.selection.object).forEach((s) => _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal.removeSignal(s, null));\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n      app.renderer.reDrawEverything(true);\n      app.stage.update();\n      app.selectObject();\n   }\n}\n\nfunction updateUndoButtonState() {\n   $(\"#btnUndo\").prop(\"disabled\", undoHistory.length <= 1);\n}\n\nfunction undo() {\n   _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.restoreLastUndoStep();\n   _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n   app.renderer.reDrawEverything(true);\n   app.stage.update();\n   updateUndoButtonState();\n}\n\nconst RENDERING = {\n   clear() {\n      app.selectObject();\n      // Stop any moving trains first\n      _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.stopAllTrains();\n\n      _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.allTracks = [];\n      _switch_js__WEBPACK_IMPORTED_MODULE_3__.Switch.allSwitches = [];\n      _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal.allSignals = new Set();\n      _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.allTrains = [];\n      _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.all_objects = [];\n\n      app.renderer?.reDrawEverything(true);\n   },\n   center() {\n      app.stage.scale = 1;\n      app.stage.x = 0;\n      app.stage.y = 0;\n      _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n      RENDERING.drawGrid();\n      app.renderer.reDrawEverything();\n      app.stage.update();\n   },\n   drawGrid(repaint = true) {\n      if (!grid) {\n         grid = new createjs.Shape();\n         grid.name = \"grid\";\n         grid.mouseEnabled = false;\n         app.stage.addChildAt(grid, 0);\n         grid.graphics.setStrokeStyle(1, \"round\");\n      }\n\n      grid.visible = showGrid;\n      if (!showGrid) return;\n\n      if (repaint) {\n         const bounds = app.stage.canvas.getBoundingClientRect();\n         const scale = app.stage.scale;\n\n         // Calculate visible area in grid coordinates\n         const size = {\n            width: Math.ceil(bounds.width / scale / _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE) * _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE,\n            height: Math.ceil(bounds.height / scale / _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE) * _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE,\n         };\n\n         // Add padding to prevent gaps during panning\n         const padding = _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE * 2;\n\n         grid.graphics.clear().setStrokeStyle(1, \"round\").setStrokeDash([5, 5], 2).beginStroke(_config_js__WEBPACK_IMPORTED_MODULE_13__.COLORS.GRID);\n\n         // Draw vertical lines\n         for (let x = -padding; x <= size.width + padding; x += _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE) {\n            grid.graphics.moveTo(x, -padding).lineTo(x, size.height + padding);\n         }\n\n         // Draw horizontal lines\n         for (let y = -padding; y <= size.height + padding; y += _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE) {\n            grid.graphics.moveTo(-padding, y).lineTo(size.width + padding, y);\n         }\n\n         // Cache with padding to prevent artifacts\n         grid.cache(-padding, -padding, size.width + padding * 2, size.height + padding * 2, scale);\n      }\n\n      // Align grid to nearest grid line to prevent floating point artifacts\n      const scaled_grid_size = _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE * app.stage.scale;\n      grid.x = Math.floor(app.stage.x / scaled_grid_size) * -_config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE;\n      grid.y = Math.floor(app.stage.y / scaled_grid_size) * -_config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE;\n   },\n};\n\nwindow.RENDERING = RENDERING;\n\nconst UI = {\n   ///Shows the menu on the right.\n   /// menu==null just hides it.\n   showMenu(menu) {\n      var bsOffcanvas = bootstrap.Offcanvas.getOrCreateInstance($(\"#sidebar\"));\n      $(\"input,button\", bsOffcanvas._element).off().removeClass(\"active\");\n\n      if (menu == null) {\n         bsOffcanvas.hide();\n         return;\n      }\n      const current_id = $('#sidebar>div:not([style*=\"display: none\"])');\n      let div_id;\n      switch (menu) {\n         case _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.EDIT_SIGNAL:\n            div_id = \"signalEditMenu\";\n            let body = $(\"#nav-home\");\n            body.empty();\n            body.append(_signal_js__WEBPACK_IMPORTED_MODULE_1__.Sig_UI.getHTML(app.selection.object));\n            _signal_js__WEBPACK_IMPORTED_MODULE_1__.Sig_UI.initSignalMenu();\n            _signal_js__WEBPACK_IMPORTED_MODULE_1__.Sig_UI.syncSignalMenu(app.selection.object);\n            break;\n         case _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.NEW_SIGNAL:\n            div_id = \"newItemMenu\";\n            break;\n         case _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.EDIT_TRAIN:\n            div_id = \"editTrainMenu\";\n            _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.initEditTrainMenu(app.selection.object);\n            break;\n         case _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.NEW_TRAIN:\n            div_id = \"newTrainMenu\";\n            $(\"#newTrain\").on(\"mousedown\", (e) => {\n               mouseAction = {\n                  action: _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.ADD_TRAIN,\n               };\n\n               //mouseup beim document anmelden, weil mouseup im stage nicht ausgelöst wird, wenn mousedown nicht auch auf der stage war\n               //little hack, weil handleStageMouseUp ein event von createjs erwartet\n               document.addEventListener(\"mouseup\", (e) => handleStageMouseUp({ nativeEvent: e }), {\n                  once: true,\n               });\n\n               app.stage.addEventListener(\"stagemousemove\", handleMouseMove);\n\n               let local_point = app.stage.globalToLocal(app.stage.mouseX, app.stage.mouseY);\n               mouseAction.container = new createjs.Bitmap(\"zug.png\").set({\n                  x: local_point.x,\n                  y: local_point.y,\n                  scale: 0.5,\n                  regY: 96 / 2,\n               });\n\n               app.containers.overlay.addChild(mouseAction.container);\n            });\n            break;\n         case _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.NEW_OBJECT:\n            div_id = \"newObjectMenu\";\n            $(\"#btnAddText\").click(() => {\n               app.customMouseMode = $(\"#btnAddText\").hasClass(\"active\") ? _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.TEXT : _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.NONE;\n               UI.activate_custom_mouse_mode();\n            });\n            $(\"#btnAddPlatform\").click(() => {\n               app.customMouseMode = $(\"#btnAddPlatform\").hasClass(\"active\")\n                  ? _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.PLATTFORM\n                  : _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.NONE;\n               UI.activate_custom_mouse_mode();\n            });\n            break;\n         case _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.EDIT_OBJECT:\n            div_id = \"editObjectMenu\";\n            _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.initEditMenu(app.selection.object);\n            break;\n         default:\n            throw new Error(\"unknown Menu\");\n      }\n\n      $(\"#sidebar > div\")\n         .not(\"#\" + div_id)\n         .hide();\n      $(\"#sidebar > #\" + div_id).show();\n\n      bsOffcanvas.show();\n      if (bsOffcanvas._isShown) {\n         //bsOffcanvas.show();\n      } else {\n         //bsOffcanvas.hide();\n      }\n   },\n\n   activate_custom_mouse_mode() {\n      switch (app.customMouseMode) {\n         case _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.TEXT:\n            myCanvas.style.cursor = \"text\";\n            break;\n         default:\n            myCanvas.style.cursor = \"auto\";\n      }\n   },\n\n   showPreBuildScreen() {\n      if (localStorage.getItem(\"bahnhof_last1\") == null) $(btnLoadRecent).attr(\"disabled\", \"disabled\");\n      $(btnStartFromZero).click(UI.hideStartScreen);\n      $(btnLoadRecent).click(() => {\n         _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.loadRecent();\n         UI.hideStartScreen();\n         RENDERING.drawGrid();\n         app.renderer.reDrawEverything(true);\n      });\n      $(\"#btnLoad2Gleisig,#btnLoad1Gleisig\").on(\"click\", (e) => {\n         const name = $(e.target).attr(\"data\");\n         _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.loadPrebuildbyName(name).then(() => {\n            UI.hideStartScreen();\n            RENDERING.drawGrid();\n            app.renderer.reDrawEverything(true);\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n         });\n      });\n      /*$(btnLoadFromFile).click(() => { loadSignalsFromFile(); hideStartScreen(); });\n       loadPrebuilds(); */\n      let m = bootstrap.Modal.getOrCreateInstance(loadModal);\n      m._element.addEventListener(\n         \"hidden.bs.modal\",\n         (x) => {\n            bootstrap.Modal.getOrCreateInstance(x.target).dispose();\n            $(btnStartFromZero).off(\"click\");\n            $(btnLoadRecent).off(\"click\");\n            $(btnLoadFromFile).off(\"click\");\n         },\n         { once: true }\n      );\n      m.show();\n   },\n\n   hideStartScreen() {\n      $(\"myCanvas\").focus();\n      bootstrap.Modal.getInstance(loadModal).hide();\n   },\n\n   \n\n   GetDataURL_FromTemplate(template) {\n      const tmpStage = new createjs.Stage($(\"<canvas>\").attr({ width: 450, height: 450 })[0]);\n      tmpStage.scale = template.scale;\n\n      // Use dedicated preview rendering method\n      _signal_js__WEBPACK_IMPORTED_MODULE_1__.SignalRenderer.drawPreview(template, tmpStage);\n      tmpStage.update();\n\n      const sig_bounds = tmpStage.getBounds();\n      if (sig_bounds == null) throw Error(template.title + \" has no visual Element visible\");\n      tmpStage.cache(sig_bounds.x, sig_bounds.y, sig_bounds.width, sig_bounds.height, 0.5);\n      return tmpStage.bitmapCache.getCacheDataURL();\n   },\n};\n\nfunction toggleEditMode(mode) {\n   app.editMode = mode != undefined ? mode : $(btnDrawTracks).is(\":checked\");\n   app.showGrid = app.editMode;\n   RENDERING.drawGrid();\n   app.stage.update();\n   if (mode != undefined) $(btnDrawTracks).prop(\":checked\", app.editMode);\n}\n\nfunction selectRenderer(textured) {\n   if (textured) {\n      app.renderer = new _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_8__.trackRendering_textured();\n      $(\"#switch_renderer\").prop(\"checked\", false);\n   } else {\n      app.renderer = new _trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__.trackRendering_basic();\n      $(\"#switch_renderer\").prop(\"checked\", true);\n   }   \n   app.renderer.reDrawEverything(true);\n   app.stage.update();\n}\n\nfunction selectObject(object, e) {\n   if (!object) {\n      app.selection.object = null;\n      app.selection.type = \"\";\n      app.renderer?.updateSelection();\n      UI.showMenu();\n      return;\n   }\n   const t = (0,_tools_js__WEBPACK_IMPORTED_MODULE_10__.type)(object);\n   if (object) console.log(object);\n\n   if (t != app.selection.type) {\n      app.selection.object = object;\n      app.selection.type = t;\n   } else {\n      if (e?.nativeEvent?.ctrlKey)\n         app.selection.object = Array.isArray(app.selection.object) ? [...app.selection.object, object] : [app.selection.object, object];\n      else app.selection.object = object;\n   }\n   app.renderer?.updateSelection();\n\n   let menu;\n   switch (t) {\n      case \"Signal\":\n         if (!Array.isArray(app.selection.object)) menu = _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.EDIT_SIGNAL;\n         break;\n      case \"Train\":\n         menu = _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.EDIT_TRAIN;\n         break;\n      case \"GenericObject\":\n         menu = _config_js__WEBPACK_IMPORTED_MODULE_13__.MENU.EDIT_OBJECT;\n         break;\n      default:\n         menu = null;\n         break;\n   }\n\n   UI.showMenu(menu);\n}\n\nfunction onResizeWindow() {\n   $(myCanvas).attr(\"height\", $(CanvasContainer).height() - 5);\n   $(myCanvas).attr(\"width\", $(CanvasContainer).width());\n   RENDERING.drawGrid();\n   app.stage.update();\n}\n\nfunction handleStageMouseDown(event) {\n   //console.log(\"handleStageMouseDown\", event);\n\n   let hittest = getHitTest();\n\n   console.log(hittest ? hittest : \"nothing hit\");\n\n   let mouseAction = {\n      action: app.customMouseMode != _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.NONE ? _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.CUSTOM : _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.NONE,\n      container: hittest,\n      startPoint: app.stage.globalToLocal(app.stage.mouseX, app.stage.mouseY),\n      _distancePoint: new _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point(event.stageX, event.stageY),\n      offset: hittest?.globalToLocal(app.stage.mouseX, app.stage.mouseY), //Koordinate auf dem angeklickten Object (zb Signal), damit der Container am Mauszeiger \"klebt\"\n      distance: function () {\n         return _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry.distance(this._distancePoint, new _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point(app.stage.mouseX, app.stage.mouseY));\n      },\n   };\n\n   // Check if we clicked on a track endpoint\n   if (mouseAction.container?.name === \"track_endpoint\") {\n      mouseAction.action = _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.DND_TRACK;\n      mouseAction.track = mouseAction.container.track;\n      mouseAction.endpoint = mouseAction.container.endpoint;\n   }\n\n   if (app.customMouseMode == _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.DRAWING) {\n      const color = document.querySelector('input[name=\"DrawingColor\"]:checked').value;\n      const width = document.querySelector('input[name=\"DrawingWidth\"]:checked').value;\n\n      app.containers.drawing.addChild((mouseAction.shape = new createjs.Shape()));\n      mouseAction.shape.graphics.setStrokeStyle(width, \"round\", \"round\").beginStroke(color);\n      mouseAction.old_point = new _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point(event.stageX, event.stageY);\n   }\n   //console.log(mouseAction);\n   app.mouseAction = mouseAction;\n   app.stage.addEventListener(\"stagemousemove\", handleMouseMove);\n}\n\nfunction getHitTest(container) {\n   let local_point = app.stage.globalToLocal(app.stage.mouseX, app.stage.mouseY);\n\n   return (container ? container : app.stage).getObjectUnderPoint(local_point.x, local_point.y, 1);\n}\n\nfunction getHitInfoForSignalPositioning(testPoint) {\n   for (const track of _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.allTracks) {\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_11__.NumberUtils.between(testPoint.x, track.start.x, track.end.x)) {\n         const distance = _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry.pointToSegmentDistance(testPoint, track.start, track.end);\n         if (distance <= _config_js__WEBPACK_IMPORTED_MODULE_13__.COMPUTED.GRID_SIZE_2) {\n            const point = _tools_js__WEBPACK_IMPORTED_MODULE_10__.TOOLS.nearestPointOnLine(track.start, track.end, testPoint);\n\n            return {\n               track: track,\n               point: point,\n               km: track.getKmfromPoint(point),\n               above: testPoint.y < point.y,\n            };\n         }\n      }\n   }\n}\n\nfunction alignSignalContainerWithTrack(c, pos) {\n   //koordinaten anhand des Strecken KM suchen, wenn sie nicht übergeben worden sind\n\n   const point = pos.track.getPointFromKm(pos.km);\n\n   let p;\n   if (pos.above) {\n      c.rotation = 270 + pos.track.deg;\n      p = point.add(\n         _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry\n            .perpendicular(pos.track.unit)\n            .multiply(-app.renderer.SIGNAL_DISTANCE_FROM_TRACK - c.data._template.distance_from_track)\n      );\n   } else {\n      c.rotation = 90 + pos.track.deg;\n      p = point.add(\n         _tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry\n            .perpendicular(pos.track.unit)\n            .multiply(app.renderer.SIGNAL_DISTANCE_FROM_TRACK + c.data._template.distance_from_track)\n      );\n   }\n   if (pos.flipped) c.rotation += 180;\n\n   c.x = p.x;\n   c.y = p.y;\n}\n\nfunction startDragAndDropSignal(mouseX, mouseY) {\n   if (app.mouseAction.container) {\n      app.mouseAction.container.parent.removeChild(app.mouseAction.container);\n   } else {\n      let signal = new _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal(app.mouseAction.template);\n      app.mouseAction.container = _signal_js__WEBPACK_IMPORTED_MODULE_1__.SignalRenderer.createSignalContainer(signal);\n      app.mouseAction.container.x = mouseX;\n      app.mouseAction.container.y = mouseY;\n   }\n\n   app.containers.overlay.addChild(app.mouseAction.container);\n   app.stage.update();\n}\n\nfunction handleMouseMove(event) {\n   //console.log(\"handleMouseMove\", event);\n   if (!event.primary) return;\n   if (app.mouseAction == null) {\n      app.stage.removeEventListener(\"stagemousemove\", handleMouseMove);\n      return;\n   }\n   //falls mouseMove noch läuft, obwohl der User keinen button mehr drückt\n   //tritt vor allem beim debugging auf\n   if (event.nativeEvent.buttons == 0) {\n      console.log(\"debug mouse error\");\n      return handleStageMouseUp(event);\n   }\n\n   let local_point = app.stage.globalToLocal(app.stage.mouseX, app.stage.mouseY);\n\n   if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.NONE) {\n      determineMouseAction(event, local_point);\n   } else if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.CUSTOM) {\n      if (app.customMouseMode == _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.DRAWING) {\n         app.mouseAction.shape.graphics.mt(app.mouseAction.startPoint.x, app.mouseAction.startPoint.y).lt(local_point.x, local_point.y);\n         app.mouseAction.startPoint.x = local_point.x;\n         app.mouseAction.startPoint.y = local_point.y;\n      } else if (app.customMouseMode == _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.PLATTFORM) {\n         app.containers.overlay.removeAllChildren();\n         app.containers.overlay.addChild((app.mouseAction.shape = new createjs.Shape()));\n         app.mouseAction.shape.graphics\n            .beginStroke(\"#111111\")\n            .drawRect(\n               app.mouseAction.startPoint.x,\n               app.mouseAction.startPoint.y,\n               local_point.x - app.mouseAction.startPoint.x,\n               local_point.y - app.mouseAction.startPoint.y\n            );\n         app.stage.update();\n      }\n   } else if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.MOVE_OBJECT) {\n      const o = app.mouseAction.container.data;\n      o.pos(local_point);\n      if (app.mouseAction.offset) {\n         let p = app.mouseAction.container.localToLocal(app.mouseAction.offset.x, app.mouseAction.offset.y, app.stage);\n         local_point.x -= p.x - app.mouseAction.container.x;\n         local_point.y -= p.y - app.mouseAction.container.y;\n      }\n      app.mouseAction.container.x = local_point.x;\n      app.mouseAction.container.y = local_point.y;\n      app.renderer.updateSelection();\n   } else if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.DND_SIGNAL) {\n      dragnDropSignal(local_point, event.nativeEvent.altKey);\n      app.renderer.updateSelection();\n   } else if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.BUILD_TRACK) {\n      const grid_snap_point = getSnapPoint(local_point);\n\n               if (_tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry.distance(local_point, grid_snap_point) <= _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.SNAP_TO_GRID) {\n            if (_track_js__WEBPACK_IMPORTED_MODULE_4__.Track.isValidTrackNodePoint(local_point)) {\n               addTrackAnchorPoint(grid_snap_point);\n            }\n         }\n      drawBluePrintTrack();\n   } else if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.SCROLL) {\n      app.stage.x += event.nativeEvent.movementX;\n      app.stage.y += event.nativeEvent.movementY;\n      RENDERING.drawGrid(false);\n      app.renderer.reDrawEverything();\n   } else if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.MOVE_TRAIN) {\n      _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.moveTrain(app.mouseAction.container.data, event.nativeEvent.movementX);\n      app.renderer.reDrawEverything();\n   } else if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.ADD_TRAIN) {\n      app.mouseAction.container.x = local_point.x;\n      app.mouseAction.container.y = local_point.y;\n   } else if (app.mouseAction.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.DND_TRACK) {\n      const grid_snap_point = getSnapPoint(local_point);\n\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_10__.geometry.distance(local_point, grid_snap_point) <= _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.SNAP_TO_GRID) {\n         if (_track_js__WEBPACK_IMPORTED_MODULE_4__.Track.isValidTrackNodePoint(grid_snap_point)) {\n            if (app.mouseAction.endpoint === \"start\") {\n               app.mouseAction.track.setNewStart(grid_snap_point);\n            } else {\n               app.mouseAction.track.setNewEnd(grid_snap_point);\n            }\n            _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.createRailNetwork();\n            app.renderer.reDrawEverything(true);\n         }\n      }\n   }\n\n   app.stage.update();\n}\n\nfunction getSnapPoint(local_point) {\n   return new _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point(Math.round(local_point.x / _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE) * _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE, Math.round(local_point.y / _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE) * _config_js__WEBPACK_IMPORTED_MODULE_13__.CONFIG.GRID_SIZE);\n}\n\nfunction determineMouseAction(event, local_point) {\n   let ma = app.mouseAction;\n   //wie weit wurde die maus seit mousedown bewegt\n   if (ma.distance() > _config_js__WEBPACK_IMPORTED_MODULE_13__.INPUT.MOUSE_MOVEMENT_THRESHOLD) {\n      if (event.nativeEvent.buttons == 1) {\n         if (app.editMode) {\n            if (ma.container?.name == \"signal\") {\n               myCanvas.style.cursor = \"move\";\n               ma.action = _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.DND_SIGNAL;\n               ma.container.data._positioning.track.removeSignal(ma.container.data);\n               startDragAndDropSignal();\n            } else if (ma.container?.name == \"GenericObject\") {\n               myCanvas.style.cursor = \"move\";\n\n               ma.action = _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.MOVE_OBJECT;\n            } else if (\n               ma.container?.name == \"track\" ||\n               ma.container?.name == \"switch\" ||\n               ma.container == null\n            ) {\n               ma.action = _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.BUILD_TRACK;\n               addTrackAnchorPoint(getSnapPoint(local_point));\n               app.containers.overlay.addChild((ma.lineShape = new createjs.Shape()));\n            }\n         }\n         if (ma.container?.name == \"train\") {\n            ma.action = _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.MOVE_TRAIN;\n         }\n      } else if (event.nativeEvent.buttons == 2) {\n         ma.action = _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.SCROLL;\n      }\n   }\n}\n\nfunction dragnDropSignal(local_point, flipped) {\n   let ma = app.mouseAction;\n\n   let hitInformation = getHitInfoForSignalPositioning(local_point);\n   if (hitInformation) {\n      hitInformation.flipped = flipped;\n      ma.hit_track = hitInformation;\n      console.log(hitInformation);\n      alignSignalContainerWithTrack(ma.container, hitInformation);\n   } else {\n      ma.hit_track = null;\n      ma.container.rotation = 0;\n      if (ma.offset) {\n         let p = ma.container.localToLocal(ma.offset.x, ma.offset.y, app.stage);\n         local_point.x -= p.x - ma.container.x;\n         local_point.y -= p.y - ma.container.y;\n      }\n      ma.container.x = local_point.x;\n      ma.container.y = local_point.y;\n   }\n   draw_SignalPositionLine();\n}\n\nfunction draw_SignalPositionLine() {\n   let shape = app.containers.overlay.getChildByName(\"SignalPositionLine\");\n   if (shape) app.containers.overlay.removeChild(shape);\n\n   if (app.mouseAction.hit_track) {\n      const point = app.mouseAction.hit_track.point;\n      shape = new createjs.Shape();\n      shape.name = \"SignalPositionLine\";\n      shape.graphics\n         .setStrokeStyle(1)\n         .beginStroke(_config_js__WEBPACK_IMPORTED_MODULE_13__.COLORS.SIGNAL_POSITION_LINE)\n         .mt(app.mouseAction.container.x, app.mouseAction.container.y)\n         .lt(point.x, point.y)\n         .es();\n      app.containers.overlay.addChild(shape);\n   }\n}\n\nfunction drawBluePrintTrack() {\n   if (app.mouseAction.nodes == null) return;\n   const g = app.mouseAction.lineShape.graphics;\n   g.c().setStrokeStyle(_trackRendering_basic_js__WEBPACK_IMPORTED_MODULE_7__.trackRendering_basic.STROKE).beginStroke(_config_js__WEBPACK_IMPORTED_MODULE_13__.COLORS.DRAWING_BLUEPRINT).moveTo(app.mouseAction.nodes[0].x, app.mouseAction.nodes[0].y);\n\n   for (let index = 1; index < app.mouseAction.nodes.length; index++) {\n      const point = app.mouseAction.nodes[index];\n      g.lt(point.x, point.y);\n   }\n\n   const last = _utils_js__WEBPACK_IMPORTED_MODULE_11__.ArrayUtils.last(app.mouseAction.nodes);\n   const p = app.stage.globalToLocal(app.stage.mouseX, app.stage.mouseY);\n   g.beginStroke(_config_js__WEBPACK_IMPORTED_MODULE_13__.COLORS.DRAWING_ACTIVE).moveTo(last.x, last.y).lt(p.x, p.y).endStroke();\n}\n\nfunction addTrackAnchorPoint(p) {\n   if (app.mouseAction.nodes == null) {\n      app.mouseAction.nodes = [];\n   }\n\n   //wenn der letzte Punkt gleich dem aktuellen ist, dann nichts tun\n   if (_utils_js__WEBPACK_IMPORTED_MODULE_11__.ArrayUtils.last(app.mouseAction.nodes)?.equals(p)) return;\n   //wenn der Startpunkt gleich dem aktuellen ist, dann Track zurücksetzen\n   if (_utils_js__WEBPACK_IMPORTED_MODULE_11__.ArrayUtils.first(app.mouseAction.nodes)?.equals(p)) {\n      app.mouseAction.nodes = [app.mouseAction.nodes[0]];\n      return;\n   }\n\n   app.mouseAction.nodes.push(p);\n   return;\n\n   // removed by dead control flow\n{}\n}\n\nfunction handleStageMouseUp(e) {\n   //console.log(\"handleStageMouseUp\", e);\n   let ma = app.mouseAction;\n   try {\n      app.stage.removeEventListener(\"stagemousemove\", handleMouseMove);\n      myCanvas.style.cursor = \"auto\";\n      if (ma == null) return;\n\n      let local_point = _tools_js__WEBPACK_IMPORTED_MODULE_10__.Point.fromPoint(app.stage.globalToLocal(app.stage.mouseX, app.stage.mouseY));\n      //left button\n      if (e.nativeEvent.which == 1) {\n         if (ma.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.DND_SIGNAL) {\n            app.containers.overlay.removeChild(ma.container);\n\n            if (ma.hit_track) {\n               app.containers.signals.addChild(ma.container);\n               const signal = ma.container.data;\n               ma.hit_track.track.AddSignal(\n                  signal,\n                  ma.hit_track.km,\n                  ma.hit_track.above,\n                  ma.hit_track.flipped\n               );\n            }\n            else{\n               _signal_js__WEBPACK_IMPORTED_MODULE_1__.Signal.removeSignal(ma.container.data);\n            }\n            app.renderer.reDrawEverything(true);\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n         } else if (ma.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.BUILD_TRACK) {\n            if (ma.nodes.length > 0) {\n               _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.checkNodesAndCreateTracks(ma.nodes);\n               _track_js__WEBPACK_IMPORTED_MODULE_4__.Track.createRailNetwork();\n               app.renderer.reDrawEverything(true);\n               _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.allTrains.forEach((t) => t.restore());\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            }\n         } else if (ma.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.ADD_TRAIN) {\n            app.containers.overlay.removeChild(ma.container);\n            const hit = getHitTest(app.containers.tracks);\n            if (hit?.name == \"track\") {\n               const color = _utils_js__WEBPACK_IMPORTED_MODULE_11__.ArrayUtils.random(_config_js__WEBPACK_IMPORTED_MODULE_13__.COLORS.TRAIN_COLORS);\n               const track = hit.data;\n               const hitInfo = getHitInfoForSignalPositioning(local_point);\n               let train, car, car2;\n               const km = hitInfo.km;\n\n               // Create locomotive as the first car\n               car = train = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.addTrain(track, km, color, _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.CAR_TYPES.LOCOMOTIVE, \"\");\n\n               // Add passenger cars\n               car2 = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.addTrain(track, km, color, _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.CAR_TYPES.PASSENGER, \"\");\n               car.coupleBack(car2);\n               car = car2;\n\n               // Add another passenger car\n               car2 = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.addTrain(track, km, color, _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.CAR_TYPES.PASSENGER, \"\");\n               car.coupleBack(car2);\n               car = car2;\n\n               // Add a third passenger car\n               car2 = _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.addTrain(track, km, color, _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.CAR_TYPES.PASSENGER, \"\");\n               car.coupleBack(car2);\n\n               // Update train positions\n               _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.moveTrain(train, 0);\n               app.renderer.renderAllTrains();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            }\n         } else if (_utils_js__WEBPACK_IMPORTED_MODULE_11__.NumberUtils.is(ma.action, _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.MOVE_TRAIN, _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.MOVE_OBJECT)) {\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n         } else if (ma.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.CUSTOM) {\n            if (app.customMouseMode == _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.TEXT) {\n               const o = new _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject(_generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.OBJECT_TYPE.text).pos(local_point).content(\"Text\");\n               _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.all_objects.push(o);\n               selectObject(o);\n               app.renderer.renderAllGenericObjects();\n               app.customMouseMode = _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.NONE;\n               UI.activate_custom_mouse_mode();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            } else if (app.customMouseMode == _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.PLATTFORM) {\n               app.containers.overlay.removeAllChildren();\n               const o = new _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject(_generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.OBJECT_TYPE.plattform)\n                  .content(\"Bahnsteig\")\n                  .pos(ma.startPoint)\n                  .size(local_point.x - ma.startPoint.x, local_point.y - ma.startPoint.y);\n               _generic_object_js__WEBPACK_IMPORTED_MODULE_5__.GenericObject.all_objects.push(o);\n               app.renderer.renderAllGenericObjects();\n               selectObject(o);\n               app.customMouseMode = _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.NONE;\n               UI.activate_custom_mouse_mode();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.saveUndoHistory();\n               _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n            } else if (app.customMouseMode === _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.TRAIN_DECOUPLE) {\n               if (ma.container?.name == \"decouplingPoint\") {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.handleDecouplingClick(ma.container.data);\n               } else {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.exitDecouplingMode();\n               }\n            } else if (app.customMouseMode === _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.TRAIN_COUPLE) {\n               if (ma.container?.name == \"couplingPoint\") {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.handleCouplingClick(ma.container.data);\n               } else {\n                  _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.exitCouplingMode();\n               }\n            }\n         } else if (ma.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.NONE && ma.distance() < _config_js__WEBPACK_IMPORTED_MODULE_13__.INPUT.MOUSE_MOVEMENT_THRESHOLD) {\n            if (ma.container?.name == \"signal\") {\n               selectObject(ma.container.data, e);\n            } else if (ma.container?.name == \"couplingPoint\" && app.customMouseMode === _config_js__WEBPACK_IMPORTED_MODULE_13__.CUSTOM_MOUSE_ACTION.TRAIN_COUPLE) {\n               // Handle coupling at this point\n               _train_js__WEBPACK_IMPORTED_MODULE_2__.Train.handleCouplingClick(ma.container.data);\n            } else if (ma.container?.name == \"train\") {\n               selectObject(ma.container.data, e);\n            } else if (ma.container?.name == \"track\") {\n               selectObject(ma.container.data, e);\n            } else if (ma.container?.name == \"GenericObject\") {\n               selectObject(ma.container.data, e);\n            } else if (ma.container?.name == \"switch\") {\n               _switch_js__WEBPACK_IMPORTED_MODULE_3__.Switch.switch_A_Switch(ma.container.data, local_point.x);\n               app.renderer.renderSwitchUI(ma.container.data);\n            } else {\n               selectObject();\n            }\n         }\n      } else if (ma.action === _config_js__WEBPACK_IMPORTED_MODULE_13__.MOUSE_DOWN_ACTION.SCROLL) {\n         _storage_js__WEBPACK_IMPORTED_MODULE_6__.STORAGE.save();\n      }\n   } catch (error) {\n      _ui_js__WEBPACK_IMPORTED_MODULE_12__.ui.showErrorToast(error);\n   } finally {\n      ma = null;\n      app.containers.overlay.removeAllChildren();\n      app.stage.update();\n   }\n}\n\nfunction drawPoint(point, displayObject, label = \"\", color = \"#000\", size = 0.5) {\n   const s = new createjs.Shape();\n   s.graphics.setStrokeStyle(1).beginStroke(color).beginFill(color).drawCircle(0, 0, size);\n   s.x = point.x;\n   s.y = point.y;\n\n   app.containers.debug.addChild(s);\n\n   if (label) {\n      const text = new createjs.Text(label, \"Italic 6px Arial\", color);\n      text.x = s.x;\n      text.y = s.y - 5;\n      text.textBaseline = \"alphabetic\";\n      app.containers.debug.addChild(text);\n   }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b2RlL3N0YXJ0LmpzPzk3OGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgcHJlTG9hZGVyIH0gZnJvbSAnLi9wcmVMb2FkZXIuanMnO1xuaW1wb3J0IHsgU2lnbmFsUmVuZGVyZXIsIFNpZ25hbCwgU2lnX1VJIH0gZnJvbSAnLi9zaWduYWwuanMnO1xuaW1wb3J0IHsgVHJhaW4gfSBmcm9tICcuL3RyYWluLmpzJztcbmltcG9ydCB7IFN3aXRjaCB9IGZyb20gJy4vc3dpdGNoLmpzJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay5qcyc7XG5pbXBvcnQgeyBHZW5lcmljT2JqZWN0IH0gZnJvbSAnLi9nZW5lcmljX29iamVjdC5qcyc7XG5pbXBvcnQgeyBTVE9SQUdFIH0gZnJvbSAnLi9zdG9yYWdlLmpzJztcbmltcG9ydCB7IHRyYWNrUmVuZGVyaW5nX2Jhc2ljIH0gZnJvbSAnLi90cmFja1JlbmRlcmluZ19iYXNpYy5qcyc7XG5pbXBvcnQgeyB0cmFja1JlbmRlcmluZ190ZXh0dXJlZCB9IGZyb20gJy4vdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuanMnO1xuaW1wb3J0IHsgaW5pdFNpZ25hbHMgfSBmcm9tICcuL3NpZ25hbF9saWJyYXJ5LmpzJztcbmltcG9ydCB7IFxuICAgdHlwZSwgXG4gICBUT09MUywgXG4gICBnZW9tZXRyeSwgXG4gICBQb2ludCwgXG59IGZyb20gJy4vdG9vbHMuanMnO1xuaW1wb3J0IHsgTnVtYmVyVXRpbHMsIEFycmF5VXRpbHMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHVpIH0gZnJvbSAnLi91aS5qcyc7XG5pbXBvcnQgeyBcbiAgIENPTkZJRywgXG4gICBDT01QVVRFRCwgXG4gICBESVJFQ1RJT04sIFxuICAgTU9VU0VfRE9XTl9BQ1RJT04sIFxuICAgQ1VTVE9NX01PVVNFX0FDVElPTiwgXG4gICBNRU5VLFxuICAgQ09MT1JTLFxuICAgQ09OVEFJTkVSUyxcbiAgIElOUFVULFxuICAgUEFUSFMgXG59IGZyb20gJy4vY29uZmlnLmpzJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSAnLi9hcHBsaWNhdGlvbi5qcyc7XG5cbnZhciBncmlkO1xudmFyIGFwcDtcbnZhciBwcmV2aW91c1RvdWNoO1xudmFyIHNob3dHcmlkID0gdHJ1ZTtcbnZhciBlZGl0X21vZGUgPSB0cnVlO1xuXG52YXIgcmVuZGVyZXI7XG5cbnZhciB1bmRvSGlzdG9yeSA9IFtdO1xuXG5leHBvcnQgdmFyIHNpZ25hbFRlbXBsYXRlcyA9IHt9O1xuXG5cbi8vIE1ha2UgdmFyaWFibGVzIGdsb2JhbGx5IGFjY2Vzc2libGUgZm9yIG90aGVyIG1vZHVsZXMgZHVyaW5nIHRyYW5zaXRpb25cblxud2luZG93LkRJUkVDVElPTiA9IERJUkVDVElPTjtcbndpbmRvdy5DVVNUT01fTU9VU0VfQUNUSU9OID0gQ1VTVE9NX01PVVNFX0FDVElPTjtcbndpbmRvdy5NT1NUX1VORE8gPSBDT05GSUcuTU9TVF9VTkRPO1xud2luZG93LnNpZ25hbFRlbXBsYXRlcyA9IHNpZ25hbFRlbXBsYXRlcztcbndpbmRvdy51cGRhdGVVbmRvQnV0dG9uU3RhdGUgPSB1cGRhdGVVbmRvQnV0dG9uU3RhdGU7XG53aW5kb3cuc2VsZWN0T2JqZWN0ID0gc2VsZWN0T2JqZWN0O1xud2luZG93LnNlbGVjdFJlbmRlcmVyID0gc2VsZWN0UmVuZGVyZXI7XG53aW5kb3cuZGVsZXRlU2VsZWN0ZWRPYmplY3QgPSBkZWxldGVTZWxlY3RlZE9iamVjdDtcbndpbmRvdy5hbGlnblNpZ25hbENvbnRhaW5lcldpdGhUcmFjayA9IGFsaWduU2lnbmFsQ29udGFpbmVyV2l0aFRyYWNrO1xud2luZG93LnN0YXJ0RHJhZ0FuZERyb3BTaWduYWwgPSBzdGFydERyYWdBbmREcm9wU2lnbmFsO1xud2luZG93LmhhbmRsZU1vdXNlTW92ZSA9IGhhbmRsZU1vdXNlTW92ZTtcbndpbmRvdy5oYW5kbGVTdGFnZU1vdXNlRG93biA9IGhhbmRsZVN0YWdlTW91c2VEb3duO1xud2luZG93LmhhbmRsZVN0YWdlTW91c2VVcCA9IGhhbmRsZVN0YWdlTW91c2VVcDtcblxuJCgoKSA9PiB7XG4gICBpbml0aWFsaXplQXBwbGljYXRpb24oKTtcbn0pO1xuXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplQXBwbGljYXRpb24oKSB7XG4gICB0cnkge1xuICAgICAgYXBwID0gQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKTtcbiAgICAgIGF3YWl0IGFwcC5pbml0aWFsaXplKCk7XG4gICAgICBcbiAgICAgIC8vIFNldCB1cCByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzICh0ZW1wb3JhcnkgdW50aWwgbW92ZWQgdG8gQXBwbGljYXRpb24gY2xhc3MpXG4gICAgICBpbml0aWFsaXplUmVtYWluaW5nRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBwcmUtYnVpbGQgc2NyZWVuIGFmdGVyIGluaXRpYWxpemF0aW9uXG4gICAgICBVSS5zaG93UHJlQnVpbGRTY3JlZW4oKTtcbiAgICAgIFxuICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBhcHBsaWNhdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgdWkuc2hvd0Vycm9yVG9hc3QoZXJyb3IpO1xuICAgfVxufVxuXG4vLyBBZnRlciB0aGUgYXBwbGljYXRpb24gaXMgaW5pdGlhbGl6ZWQsIHNldCB1cCB0aGUgcmVtYWluaW5nIGV2ZW50IGxpc3RlbmVyc1xuLy8gVGhlc2Ugd2lsbCBiZSBtb3ZlZCB0byB0aGUgQXBwbGljYXRpb24gY2xhc3MgaW4gbGF0ZXIgcGhhc2VzXG5mdW5jdGlvbiBpbml0aWFsaXplUmVtYWluaW5nRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICBhcHAuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWdlbW91c2Vkb3duXCIsIGhhbmRsZVN0YWdlTW91c2VEb3duKTtcbiAgIGFwcC5zdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZXVwXCIsIGhhbmRsZVN0YWdlTW91c2VVcCk7XG5cbiAgIG15Q2FudmFzLm9uY29udGV4dG1lbnUgPSAoKSA9PiBmYWxzZTtcbiAgIG15Q2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIW15Q2FudmFzLnByZXZlbnRfaW5wdXQpIHtcbiAgICAgICAgIG15Q2FudmFzLnByZXZlbnRfaW5wdXQgPSB0cnVlO1xuICAgICAgICAgbGV0IHBvaW50ID0gbmV3IGNyZWF0ZWpzLlBvaW50KGFwcC5zdGFnZS5tb3VzZVgsIGFwcC5zdGFnZS5tb3VzZVkpO1xuICAgICAgICAgbGV0IGxvY2FsUG9pbnQgPSBhcHAuc3RhZ2UuZ2xvYmFsVG9Mb2NhbChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgIGxldCBvbGRfc2NhbGUgPSBhcHAuc3RhZ2Uuc2NhbGU7XG4gICAgICAgICBsZXQgc3RlcCA9IGV2ZW50LmRlbHRhWSAvIChJTlBVVC5aT09NX1NURVBfRElWSVNPUiAvIGFwcC5zdGFnZS5zY2FsZSk7XG4gICAgICAgICBhcHAuc3RhZ2Uuc2NhbGUgLT0gc3RlcDtcbiAgICAgICAgIGFwcC5zdGFnZS5zY2FsZSA9IE1hdGgubWluKE1hdGgubWF4KENPTkZJRy5NSU5fU0NBTEUsIGFwcC5zdGFnZS5zY2FsZSksIENPTkZJRy5NQVhfU0NBTEUpO1xuXG4gICAgICAgICBpZiAoYXBwLnN0YWdlLnNjYWxlICE9IG9sZF9zY2FsZSkge1xuICAgICAgICAgICAgLy9pZiB3ZSByZWFjaGVkIE1JTiBvciBNQVgsIHRoZSBzY2FsZSB2YWx1ZSBkb2VzbnQgY2hhbmdlIGFueW1vcmVcbiAgICAgICAgICAgIC8vIEZpbmQgd2hlcmUgdGhlIG9yaWdpbmFsIHBvaW50IGlzIG5vd1xuICAgICAgICAgICAgbGV0IGdsb2JhbFBvaW50ID0gYXBwLnN0YWdlLmxvY2FsVG9HbG9iYWwobG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICAgICAgLy8gTW92ZSB0aGUgbWFwIGJ5IHRoZSBkaWZmZXJlbmNlXG4gICAgICAgICAgICBhcHAuc3RhZ2UueCAtPSBnbG9iYWxQb2ludC54IC0gcG9pbnQueDtcbiAgICAgICAgICAgIGFwcC5zdGFnZS55IC09IGdsb2JhbFBvaW50LnkgLSBwb2ludC55O1xuICAgICAgICAgICAgUkVOREVSSU5HLmRyYXdHcmlkKCk7XG4gICAgICAgICAgICBhcHAucmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZygpO1xuICAgICAgICAgICAgYXBwLnN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICAgICB9XG4gICAgICAgICBteUNhbnZhcy5wcmV2ZW50X2lucHV0ID0gZmFsc2U7XG4gICAgICB9XG4gICB9KTtcbiAgIGlmIChjcmVhdGVqcy5Ub3VjaC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICBteUNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbGV0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgICAgIC8vc3RhcnRUcmFja0RyYXdpbmcoYXBwLnN0YWdlLmdsb2JhbFRvTG9jYWwodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSkpO1xuICAgICAgICAgfVxuXG4gICAgICAgICAvKiBjb25zb2xlLmxvZyhcInRvdWNoOlwiICsgZXZlbnQudG91Y2hlcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGV2ZW50LnRvdWNoZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwieDpcIiArIGl0ZW0uY2xpZW50WCArIFwiOlwiICsgaXRlbS5jbGllbnRZKTtcbiAgICAgICAgICAgIH0gKi9cbiAgICAgIH0pO1xuXG4gICAgICBteUNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNUb3VjaCkge1xuICAgICAgICAgICAgICAgLy8gYmUgYXdhcmUgdGhhdCB0aGVzZSBvbmx5IHN0b3JlIHRoZSBtb3ZlbWVudCBvZiB0aGUgZmlyc3QgdG91Y2ggaW4gdGhlIHRvdWNoZXMgYXJyYXlcbiAgICAgICAgICAgICAgIGFwcC5zdGFnZS54ICs9IHRvdWNoLmNsaWVudFggLSBwcmV2aW91c1RvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICBhcHAuc3RhZ2UueSArPSB0b3VjaC5jbGllbnRZIC0gcHJldmlvdXNUb3VjaC5jbGllbnRZO1xuXG4gICAgICAgICAgICAgICBSRU5ERVJJTkcuZHJhd0dyaWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgcmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2aW91c1RvdWNoID0gdG91Y2g7XG4gICAgICAgICB9XG4gICAgICB9KTtcbiAgIH1cblxuICAgJChcIiNidG5EcmF3VHJhY2tzLCNidG5QbGF5XCIpLmNsaWNrKCgpID0+IHRvZ2dsZUVkaXRNb2RlKCkpO1xuXG4gICAkKFwiI3N3aXRjaF9yZW5kZXJlclwiKS5vbihcImNoYW5nZVwiLCAoZSkgPT4ge1xuICAgICAgc2VsZWN0UmVuZGVyZXIoISQoXCIjc3dpdGNoX3JlbmRlcmVyXCIpLmlzKFwiOmNoZWNrZWRcIikpO1xuICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICB9KTtcblxuICAgJChcIiNidG5BZGRTaWduYWxzXCIpLmNsaWNrKCgpID0+IFVJLnNob3dNZW51KE1FTlUuTkVXX1NJR05BTCkpO1xuICAgJChcIiNidG5BZGRUcmFpblwiKS5jbGljaygoKSA9PiBVSS5zaG93TWVudShNRU5VLk5FV19UUkFJTikpO1xuICAgJChcIiNidG5BZGRPYmplY3RcIikuY2xpY2soKCkgPT4gVUkuc2hvd01lbnUoTUVOVS5ORVdfT0JKRUNUKSk7XG5cbiAgICQoXCIjYnRuQ2xlYXJcIikuY2xpY2soKCkgPT4ge1xuICAgICAgUkVOREVSSU5HLmNsZWFyKCk7XG4gICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICB9KTtcblxuICAgJChcIiNidG5DZW50ZXJcIikuY2xpY2soKCkgPT4ge1xuICAgICAgUkVOREVSSU5HLmNlbnRlcigpO1xuICAgfSk7XG5cbiAgICQoXCIjYnRuUmVkcmF3XCIpLmNsaWNrKCgpID0+IHtcbiAgICAgIC8vdGVzdFBlcmZvcm1hbmNlKCgpID0+IHJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSksIFwiVG90YWwgcmVkcmF3IHRpbWVcIik7XG4gICAgICBhcHAucmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlKTtcbiAgIH0pO1xuXG4gICAkKFwiI2J0bkltYWdlXCIpLmNsaWNrKChlKSA9PiB7XG4gICAgICBsZXQgYmFja3VwID0geyB4OiBhcHAuc3RhZ2UueCwgeTogYXBwLnN0YWdlLnksIHNjYWxlOiBhcHAuc3RhZ2Uuc2NhbGUgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgIGNvbnN0IGN1c3RvbV9zY2FsZSA9IDI7XG4gICAgICAgICBhcHAuc3RhZ2UuZW5hYmxlRE9NRXZlbnRzKGZhbHNlKTtcblxuICAgICAgICAgYXBwLnN0YWdlLnNjYWxlID0gY3VzdG9tX3NjYWxlO1xuXG4gICAgICAgICBhcHAucmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlLCB0cnVlKTtcblxuICAgICAgICAgbGV0IGJvdW5kcyA9IGFwcC5jb250YWluZXJzLm1haW4uZ2V0Qm91bmRzKCk7XG4gICAgICAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICAgICAgdWkuc2hvd0luZm9Ub2FzdChcIm5vdGhpbmcgdG8gZXhwb3J0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuICAgICAgICAgY29uc3QgYW5vdGhlckNhbnZhcyA9ICQoXCI8Y2FudmFzPlwiLCB7IGlkOiBcInRlc3RcIiB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBib3VuZHMud2lkdGggKiBjdXN0b21fc2NhbGUpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBib3VuZHMuaGVpZ2h0ICogY3VzdG9tX3NjYWxlKTtcbiAgICAgICAgIGFwcC5zdGFnZS5jYW52YXMgPSBhbm90aGVyQ2FudmFzWzBdO1xuICAgICAgICAgYXBwLnN0YWdlLnggPSBib3VuZHMueCAqIC1jdXN0b21fc2NhbGU7XG4gICAgICAgICBhcHAuc3RhZ2UueSA9IGJvdW5kcy55ICogLWN1c3RvbV9zY2FsZTtcbiAgICAgICAgIGdyaWQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgYXBwLmNvbnRhaW5lcnMuZHJhd2luZy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICBhcHAuY29udGFpbmVycy51aS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICBhcHAuc3RhZ2UudXBkYXRlKCk7XG5cbiAgICAgICAgIGxldCBpbWdfZGF0YSA9IGFwcC5zdGFnZS50b0RhdGFVUkwoQ09MT1JTLlRSQU5TUEFSRU5ULCBcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgIGNvbnN0IGltZyA9ICQoXCI8aW1nPlwiLCB7IHNyYzogaW1nX2RhdGEsIHdpZHRoOiBcIjEwMCVcIiB9KS5jc3MoXCJvYmplY3QtZml0XCIsIFwic2NhbGUtZG93blwiKS5jc3MoXCJtYXgtaGVpZ2h0XCIsIFwiNTB2aFwiKTtcbiAgICAgICAgIHVpLnNob3dNb2RhbERpYWxvZyhpbWcsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gJChcIjxhPlwiLCB7IGRvd25sb2FkOiBcImdsZWlzcGxhbi5wbmdcIiwgaHJlZjogaW1nX2RhdGEgfSk7XG4gICAgICAgICAgICBhWzBdLmNsaWNrKCk7XG4gICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICB1aS5zaG93RXJyb3JUb2FzdChlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgYXBwLnN0YWdlLnggPSBiYWNrdXAueDtcbiAgICAgICAgIGFwcC5zdGFnZS55ID0gYmFja3VwLnk7XG4gICAgICAgICBhcHAuc3RhZ2Uuc2NhbGUgPSBiYWNrdXAuc2NhbGU7XG4gICAgICAgICBhcHAuc3RhZ2UuY2FudmFzID0gbXlDYW52YXM7XG4gICAgICAgICBncmlkLnZpc2libGUgPSBzaG93R3JpZDtcbiAgICAgICAgIGFwcC5jb250YWluZXJzLmRyYXdpbmcudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICBhcHAuY29udGFpbmVycy51aS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgIGFwcC5yZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgICAgYXBwLnN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcbiAgICAgICAgIGFwcC5zdGFnZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgIH0pO1xuXG4gICAkKFwiI2J0bkRyYXdcIikuY2xpY2soKGUpID0+IHtcbiAgICAgIGFwcC5jdXN0b21Nb3VzZU1vZGUgPSAkKFwiI2J0bkRyYXdcIikuaGFzQ2xhc3MoXCJhY3RpdmVcIikgPyBDVVNUT01fTU9VU0VfQUNUSU9OLkRSQVdJTkcgOiBDVVNUT01fTU9VU0VfQUNUSU9OLk5PTkU7XG4gICAgICBcbiAgICAgIGNvbnN0IGJzT2ZmY2FudmFzID0gYm9vdHN0cmFwLk9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHJhd2luZ1BhbmVsXCIpKTtcbiAgICAgIGlmIChhcHAuY3VzdG9tTW91c2VNb2RlID09PSBDVVNUT01fTU9VU0VfQUNUSU9OLkRSQVdJTkcpIHtcbiAgICAgICAgIGJzT2ZmY2FudmFzLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBic09mZmNhbnZhcy5oaWRlKCk7XG4gICAgICB9XG4gICB9KTtcblxuICAgJChcIiNidG5EcmF3aW5nQ2xlYXJcIikuY2xpY2soKGUpID0+IHtcbiAgICAgIGFwcC5jb250YWluZXJzLmRyYXdpbmcucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIGFwcC5zdGFnZS51cGRhdGUoKTtcbiAgIH0pO1xuXG4gICAkKFwiI2J0bkdydW5kc3RlbGx1bmdcIikuY2xpY2soKGUpID0+IHtcbiAgICAgIGlmIChhcHAuc2VsZWN0aW9uLnR5cGUgPT0gXCJTaWduYWxcIikge1xuICAgICAgICAgW10uY29uY2F0KGFwcC5zZWxlY3Rpb24ub2JqZWN0KS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICBzLl9zaWduYWxTdGVsbHVuZyA9IHt9O1xuICAgICAgICAgICAgaWYgKHMuX3RlbXBsYXRlLmluaXRpYWxTaWduYWxTdGVsbHVuZylcbiAgICAgICAgICAgICAgIHMuX3RlbXBsYXRlLmluaXRpYWxTaWduYWxTdGVsbHVuZy5mb3JFYWNoKChpKSA9PiBzLnNldF9zdGVsbHVuZyhpLCBudWxsLCB0cnVlKSk7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgICAgIGFwcC5yZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgICAgICAgYXBwLnN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgfSk7XG4gICAgICB9XG4gICB9KTtcblxuICAgJChcIiNidG5VbmRvXCIpLmNsaWNrKChlKSA9PiB7XG4gICAgICB1bmRvKCk7XG4gICB9KTtcblxuICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lICE9IFwiSU5QVVRcIiAmJiAoZS5jb2RlID09IFwiRGVsZXRlXCIgfHwgZS5jb2RlID09IFwiQmFja3NwYWNlXCIpKSB7XG4gICAgICAgICBkZWxldGVTZWxlY3RlZE9iamVjdCgpO1xuICAgICAgfVxuICAgfSk7XG5cbiAgICQoXCIjc2lnbmFsRWRpdE1lbnVIZWFkZXIgYVwiKS5vbihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICQoXCIjc2lnbmFsRWRpdE1lbnVIZWFkZXIgLmNhcmQtdGV4dFwiKS5oaWRlKCk7XG4gICAgICAkKFwiI3NpZ25hbEVkaXRNZW51SGVhZGVyIGlucHV0XCIpXG4gICAgICAgICAudmFsKGFwcC5zZWxlY3Rpb24ub2JqZWN0LmdldChcImJlelwiKSlcbiAgICAgICAgIC5zaG93KClcbiAgICAgICAgIC5mb2N1cygpXG4gICAgICAgICAub24oXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgICAgICAgYXBwLnNlbGVjdGlvbi5vYmplY3Quc2V0X3N0ZWxsdW5nKFwiYmV6XCIsICQodGhpcykudmFsKCkpO1xuICAgICAgICAgICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciAuY2FyZC10ZXh0XCIpLnNob3coKTtcbiAgICAgICAgICAgICAgICQoXCIjc2lnbmFsRWRpdE1lbnVIZWFkZXIgaW5wdXRcIikuaGlkZSgpO1xuICAgICAgICAgICAgICAgU2lnX1VJLnN5bmNTaWduYWxNZW51KGFwcC5zZWxlY3Rpb24ub2JqZWN0KTtcbiAgICAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgICAgICAgYXBwLnJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICBhcHAuc3RhZ2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9KVxuICAgICAgICAgLm9uKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICAkKFwiI3NpZ25hbEVkaXRNZW51SGVhZGVyIC5jYXJkLXRleHRcIikuc2hvdygpO1xuICAgICAgICAgICAgJChcIiNzaWduYWxFZGl0TWVudUhlYWRlciBpbnB1dFwiKS5oaWRlKCk7XG4gICAgICAgICB9KTtcbiAgIH0pO1xuXG4gICBvblJlc2l6ZVdpbmRvdygpO1xuICAgdG9nZ2xlRWRpdE1vZGUoZWRpdF9tb2RlKTtcblxuICAgJCh3aW5kb3cpLnJlc2l6ZShvblJlc2l6ZVdpbmRvdyk7XG4gICBteUNhbnZhcy5mb2N1cygpO1xufVxuXG5mdW5jdGlvbiBkZWxldGVTZWxlY3RlZE9iamVjdCgpIHtcbiAgIGlmIChhcHAuc2VsZWN0aW9uLm9iamVjdCkge1xuICAgICAgaWYgKGFwcC5zZWxlY3Rpb24udHlwZSA9PSBcIlRyYWNrXCIpIHtcbiAgICAgICAgIGNvbnN0IHJlbW92ZWRUcmFja3MgPSBbXS5jb25jYXQoYXBwLnNlbGVjdGlvbi5vYmplY3QpO1xuICAgICAgICAgcmVtb3ZlZFRyYWNrcy5mb3JFYWNoKCh0KSA9PiBUcmFjay5yZW1vdmVUcmFjayh0KSk7XG4gICAgICAgICAvLyBDaGVjayBhbmQgcmVtb3ZlIGFueSB0cmFpbnMgdGhhdCB3ZXJlIG9uIHRoZSBkZWxldGVkIHRyYWNrc1xuICAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiByZW1vdmVkVHJhY2tzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFpbnNPblRyYWNrID0gVHJhaW4uYWxsVHJhaW5zLmZpbHRlcigodHJhaW4pID0+IHRyYWluLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWluIG9mIHRyYWluc09uVHJhY2spIHtcbiAgICAgICAgICAgICAgIFRyYWluLmRlbGV0ZVRyYWluKHRyYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIFRyYWNrLmNyZWF0ZVJhaWxOZXR3b3JrKCk7XG4gICAgICB9XG4gICAgICBpZiAoYXBwLnNlbGVjdGlvbi50eXBlID09IFwiU2lnbmFsXCIpIFtdLmNvbmNhdChhcHAuc2VsZWN0aW9uLm9iamVjdCkuZm9yRWFjaCgocykgPT4gU2lnbmFsLnJlbW92ZVNpZ25hbChzLCBudWxsKSk7XG4gICAgICBTVE9SQUdFLnNhdmVVbmRvSGlzdG9yeSgpO1xuICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICBhcHAucmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlKTtcbiAgICAgIGFwcC5zdGFnZS51cGRhdGUoKTtcbiAgICAgIGFwcC5zZWxlY3RPYmplY3QoKTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlVW5kb0J1dHRvblN0YXRlKCkge1xuICAgJChcIiNidG5VbmRvXCIpLnByb3AoXCJkaXNhYmxlZFwiLCB1bmRvSGlzdG9yeS5sZW5ndGggPD0gMSk7XG59XG5cbmZ1bmN0aW9uIHVuZG8oKSB7XG4gICBTVE9SQUdFLnJlc3RvcmVMYXN0VW5kb1N0ZXAoKTtcbiAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgYXBwLnJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICBhcHAuc3RhZ2UudXBkYXRlKCk7XG4gICB1cGRhdGVVbmRvQnV0dG9uU3RhdGUoKTtcbn1cblxuY29uc3QgUkVOREVSSU5HID0ge1xuICAgY2xlYXIoKSB7XG4gICAgICBhcHAuc2VsZWN0T2JqZWN0KCk7XG4gICAgICAvLyBTdG9wIGFueSBtb3ZpbmcgdHJhaW5zIGZpcnN0XG4gICAgICBUcmFpbi5zdG9wQWxsVHJhaW5zKCk7XG5cbiAgICAgIFRyYWNrLmFsbFRyYWNrcyA9IFtdO1xuICAgICAgU3dpdGNoLmFsbFN3aXRjaGVzID0gW107XG4gICAgICBTaWduYWwuYWxsU2lnbmFscyA9IG5ldyBTZXQoKTtcbiAgICAgIFRyYWluLmFsbFRyYWlucyA9IFtdO1xuICAgICAgR2VuZXJpY09iamVjdC5hbGxfb2JqZWN0cyA9IFtdO1xuXG4gICAgICBhcHAucmVuZGVyZXI/LnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICB9LFxuICAgY2VudGVyKCkge1xuICAgICAgYXBwLnN0YWdlLnNjYWxlID0gMTtcbiAgICAgIGFwcC5zdGFnZS54ID0gMDtcbiAgICAgIGFwcC5zdGFnZS55ID0gMDtcbiAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgUkVOREVSSU5HLmRyYXdHcmlkKCk7XG4gICAgICBhcHAucmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZygpO1xuICAgICAgYXBwLnN0YWdlLnVwZGF0ZSgpO1xuICAgfSxcbiAgIGRyYXdHcmlkKHJlcGFpbnQgPSB0cnVlKSB7XG4gICAgICBpZiAoIWdyaWQpIHtcbiAgICAgICAgIGdyaWQgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgICAgIGdyaWQubmFtZSA9IFwiZ3JpZFwiO1xuICAgICAgICAgZ3JpZC5tb3VzZUVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgIGFwcC5zdGFnZS5hZGRDaGlsZEF0KGdyaWQsIDApO1xuICAgICAgICAgZ3JpZC5ncmFwaGljcy5zZXRTdHJva2VTdHlsZSgxLCBcInJvdW5kXCIpO1xuICAgICAgfVxuXG4gICAgICBncmlkLnZpc2libGUgPSBzaG93R3JpZDtcbiAgICAgIGlmICghc2hvd0dyaWQpIHJldHVybjtcblxuICAgICAgaWYgKHJlcGFpbnQpIHtcbiAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGFwcC5zdGFnZS5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICBjb25zdCBzY2FsZSA9IGFwcC5zdGFnZS5zY2FsZTtcblxuICAgICAgICAgLy8gQ2FsY3VsYXRlIHZpc2libGUgYXJlYSBpbiBncmlkIGNvb3JkaW5hdGVzXG4gICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgICAgd2lkdGg6IE1hdGguY2VpbChib3VuZHMud2lkdGggLyBzY2FsZSAvIENPTkZJRy5HUklEX1NJWkUpICogQ09ORklHLkdSSURfU0laRSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5jZWlsKGJvdW5kcy5oZWlnaHQgLyBzY2FsZSAvIENPTkZJRy5HUklEX1NJWkUpICogQ09ORklHLkdSSURfU0laRSxcbiAgICAgICAgIH07XG5cbiAgICAgICAgIC8vIEFkZCBwYWRkaW5nIHRvIHByZXZlbnQgZ2FwcyBkdXJpbmcgcGFubmluZ1xuICAgICAgICAgY29uc3QgcGFkZGluZyA9IENPTkZJRy5HUklEX1NJWkUgKiAyO1xuXG4gICAgICAgICBncmlkLmdyYXBoaWNzLmNsZWFyKCkuc2V0U3Ryb2tlU3R5bGUoMSwgXCJyb3VuZFwiKS5zZXRTdHJva2VEYXNoKFs1LCA1XSwgMikuYmVnaW5TdHJva2UoQ09MT1JTLkdSSUQpO1xuXG4gICAgICAgICAvLyBEcmF3IHZlcnRpY2FsIGxpbmVzXG4gICAgICAgICBmb3IgKGxldCB4ID0gLXBhZGRpbmc7IHggPD0gc2l6ZS53aWR0aCArIHBhZGRpbmc7IHggKz0gQ09ORklHLkdSSURfU0laRSkge1xuICAgICAgICAgICAgZ3JpZC5ncmFwaGljcy5tb3ZlVG8oeCwgLXBhZGRpbmcpLmxpbmVUbyh4LCBzaXplLmhlaWdodCArIHBhZGRpbmcpO1xuICAgICAgICAgfVxuXG4gICAgICAgICAvLyBEcmF3IGhvcml6b250YWwgbGluZXNcbiAgICAgICAgIGZvciAobGV0IHkgPSAtcGFkZGluZzsgeSA8PSBzaXplLmhlaWdodCArIHBhZGRpbmc7IHkgKz0gQ09ORklHLkdSSURfU0laRSkge1xuICAgICAgICAgICAgZ3JpZC5ncmFwaGljcy5tb3ZlVG8oLXBhZGRpbmcsIHkpLmxpbmVUbyhzaXplLndpZHRoICsgcGFkZGluZywgeSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIENhY2hlIHdpdGggcGFkZGluZyB0byBwcmV2ZW50IGFydGlmYWN0c1xuICAgICAgICAgZ3JpZC5jYWNoZSgtcGFkZGluZywgLXBhZGRpbmcsIHNpemUud2lkdGggKyBwYWRkaW5nICogMiwgc2l6ZS5oZWlnaHQgKyBwYWRkaW5nICogMiwgc2NhbGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGlnbiBncmlkIHRvIG5lYXJlc3QgZ3JpZCBsaW5lIHRvIHByZXZlbnQgZmxvYXRpbmcgcG9pbnQgYXJ0aWZhY3RzXG4gICAgICBjb25zdCBzY2FsZWRfZ3JpZF9zaXplID0gQ09ORklHLkdSSURfU0laRSAqIGFwcC5zdGFnZS5zY2FsZTtcbiAgICAgIGdyaWQueCA9IE1hdGguZmxvb3IoYXBwLnN0YWdlLnggLyBzY2FsZWRfZ3JpZF9zaXplKSAqIC1DT05GSUcuR1JJRF9TSVpFO1xuICAgICAgZ3JpZC55ID0gTWF0aC5mbG9vcihhcHAuc3RhZ2UueSAvIHNjYWxlZF9ncmlkX3NpemUpICogLUNPTkZJRy5HUklEX1NJWkU7XG4gICB9LFxufTtcblxud2luZG93LlJFTkRFUklORyA9IFJFTkRFUklORztcblxuY29uc3QgVUkgPSB7XG4gICAvLy9TaG93cyB0aGUgbWVudSBvbiB0aGUgcmlnaHQuXG4gICAvLy8gbWVudT09bnVsbCBqdXN0IGhpZGVzIGl0LlxuICAgc2hvd01lbnUobWVudSkge1xuICAgICAgdmFyIGJzT2ZmY2FudmFzID0gYm9vdHN0cmFwLk9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKCQoXCIjc2lkZWJhclwiKSk7XG4gICAgICAkKFwiaW5wdXQsYnV0dG9uXCIsIGJzT2ZmY2FudmFzLl9lbGVtZW50KS5vZmYoKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcblxuICAgICAgaWYgKG1lbnUgPT0gbnVsbCkge1xuICAgICAgICAgYnNPZmZjYW52YXMuaGlkZSgpO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudF9pZCA9ICQoJyNzaWRlYmFyPmRpdjpub3QoW3N0eWxlKj1cImRpc3BsYXk6IG5vbmVcIl0pJyk7XG4gICAgICBsZXQgZGl2X2lkO1xuICAgICAgc3dpdGNoIChtZW51KSB7XG4gICAgICAgICBjYXNlIE1FTlUuRURJVF9TSUdOQUw6XG4gICAgICAgICAgICBkaXZfaWQgPSBcInNpZ25hbEVkaXRNZW51XCI7XG4gICAgICAgICAgICBsZXQgYm9keSA9ICQoXCIjbmF2LWhvbWVcIik7XG4gICAgICAgICAgICBib2R5LmVtcHR5KCk7XG4gICAgICAgICAgICBib2R5LmFwcGVuZChTaWdfVUkuZ2V0SFRNTChhcHAuc2VsZWN0aW9uLm9iamVjdCkpO1xuICAgICAgICAgICAgU2lnX1VJLmluaXRTaWduYWxNZW51KCk7XG4gICAgICAgICAgICBTaWdfVUkuc3luY1NpZ25hbE1lbnUoYXBwLnNlbGVjdGlvbi5vYmplY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICBjYXNlIE1FTlUuTkVXX1NJR05BTDpcbiAgICAgICAgICAgIGRpdl9pZCA9IFwibmV3SXRlbU1lbnVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgY2FzZSBNRU5VLkVESVRfVFJBSU46XG4gICAgICAgICAgICBkaXZfaWQgPSBcImVkaXRUcmFpbk1lbnVcIjtcbiAgICAgICAgICAgIFRyYWluLmluaXRFZGl0VHJhaW5NZW51KGFwcC5zZWxlY3Rpb24ub2JqZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgY2FzZSBNRU5VLk5FV19UUkFJTjpcbiAgICAgICAgICAgIGRpdl9pZCA9IFwibmV3VHJhaW5NZW51XCI7XG4gICAgICAgICAgICAkKFwiI25ld1RyYWluXCIpLm9uKFwibW91c2Vkb3duXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICBtb3VzZUFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbjogTU9VU0VfRE9XTl9BQ1RJT04uQUREX1RSQUlOLFxuICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgLy9tb3VzZXVwIGJlaW0gZG9jdW1lbnQgYW5tZWxkZW4sIHdlaWwgbW91c2V1cCBpbSBzdGFnZSBuaWNodCBhdXNnZWzDtnN0IHdpcmQsIHdlbm4gbW91c2Vkb3duIG5pY2h0IGF1Y2ggYXVmIGRlciBzdGFnZSB3YXJcbiAgICAgICAgICAgICAgIC8vbGl0dGxlIGhhY2ssIHdlaWwgaGFuZGxlU3RhZ2VNb3VzZVVwIGVpbiBldmVudCB2b24gY3JlYXRlanMgZXJ3YXJ0ZXRcbiAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIChlKSA9PiBoYW5kbGVTdGFnZU1vdXNlVXAoeyBuYXRpdmVFdmVudDogZSB9KSwge1xuICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICBhcHAuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWdlbW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG5cbiAgICAgICAgICAgICAgIGxldCBsb2NhbF9wb2ludCA9IGFwcC5zdGFnZS5nbG9iYWxUb0xvY2FsKGFwcC5zdGFnZS5tb3VzZVgsIGFwcC5zdGFnZS5tb3VzZVkpO1xuICAgICAgICAgICAgICAgbW91c2VBY3Rpb24uY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcInp1Zy5wbmdcIikuc2V0KHtcbiAgICAgICAgICAgICAgICAgIHg6IGxvY2FsX3BvaW50LngsXG4gICAgICAgICAgICAgICAgICB5OiBsb2NhbF9wb2ludC55LFxuICAgICAgICAgICAgICAgICAgc2NhbGU6IDAuNSxcbiAgICAgICAgICAgICAgICAgIHJlZ1k6IDk2IC8gMixcbiAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICBhcHAuY29udGFpbmVycy5vdmVybGF5LmFkZENoaWxkKG1vdXNlQWN0aW9uLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgY2FzZSBNRU5VLk5FV19PQkpFQ1Q6XG4gICAgICAgICAgICBkaXZfaWQgPSBcIm5ld09iamVjdE1lbnVcIjtcbiAgICAgICAgICAgICQoXCIjYnRuQWRkVGV4dFwiKS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICBhcHAuY3VzdG9tTW91c2VNb2RlID0gJChcIiNidG5BZGRUZXh0XCIpLmhhc0NsYXNzKFwiYWN0aXZlXCIpID8gQ1VTVE9NX01PVVNFX0FDVElPTi5URVhUIDogQ1VTVE9NX01PVVNFX0FDVElPTi5OT05FO1xuICAgICAgICAgICAgICAgVUkuYWN0aXZhdGVfY3VzdG9tX21vdXNlX21vZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJChcIiNidG5BZGRQbGF0Zm9ybVwiKS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICBhcHAuY3VzdG9tTW91c2VNb2RlID0gJChcIiNidG5BZGRQbGF0Zm9ybVwiKS5oYXNDbGFzcyhcImFjdGl2ZVwiKVxuICAgICAgICAgICAgICAgICAgPyBDVVNUT01fTU9VU0VfQUNUSU9OLlBMQVRURk9STVxuICAgICAgICAgICAgICAgICAgOiBDVVNUT01fTU9VU0VfQUNUSU9OLk5PTkU7XG4gICAgICAgICAgICAgICBVSS5hY3RpdmF0ZV9jdXN0b21fbW91c2VfbW9kZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGNhc2UgTUVOVS5FRElUX09CSkVDVDpcbiAgICAgICAgICAgIGRpdl9pZCA9IFwiZWRpdE9iamVjdE1lbnVcIjtcbiAgICAgICAgICAgIEdlbmVyaWNPYmplY3QuaW5pdEVkaXRNZW51KGFwcC5zZWxlY3Rpb24ub2JqZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gTWVudVwiKTtcbiAgICAgIH1cblxuICAgICAgJChcIiNzaWRlYmFyID4gZGl2XCIpXG4gICAgICAgICAubm90KFwiI1wiICsgZGl2X2lkKVxuICAgICAgICAgLmhpZGUoKTtcbiAgICAgICQoXCIjc2lkZWJhciA+ICNcIiArIGRpdl9pZCkuc2hvdygpO1xuXG4gICAgICBic09mZmNhbnZhcy5zaG93KCk7XG4gICAgICBpZiAoYnNPZmZjYW52YXMuX2lzU2hvd24pIHtcbiAgICAgICAgIC8vYnNPZmZjYW52YXMuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vYnNPZmZjYW52YXMuaGlkZSgpO1xuICAgICAgfVxuICAgfSxcblxuICAgYWN0aXZhdGVfY3VzdG9tX21vdXNlX21vZGUoKSB7XG4gICAgICBzd2l0Y2ggKGFwcC5jdXN0b21Nb3VzZU1vZGUpIHtcbiAgICAgICAgIGNhc2UgQ1VTVE9NX01PVVNFX0FDVElPTi5URVhUOlxuICAgICAgICAgICAgbXlDYW52YXMuc3R5bGUuY3Vyc29yID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBteUNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcImF1dG9cIjtcbiAgICAgIH1cbiAgIH0sXG5cbiAgIHNob3dQcmVCdWlsZFNjcmVlbigpIHtcbiAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImJhaG5ob2ZfbGFzdDFcIikgPT0gbnVsbCkgJChidG5Mb2FkUmVjZW50KS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgICAgICQoYnRuU3RhcnRGcm9tWmVybykuY2xpY2soVUkuaGlkZVN0YXJ0U2NyZWVuKTtcbiAgICAgICQoYnRuTG9hZFJlY2VudCkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgU1RPUkFHRS5sb2FkUmVjZW50KCk7XG4gICAgICAgICBVSS5oaWRlU3RhcnRTY3JlZW4oKTtcbiAgICAgICAgIFJFTkRFUklORy5kcmF3R3JpZCgpO1xuICAgICAgICAgYXBwLnJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgICQoXCIjYnRuTG9hZDJHbGVpc2lnLCNidG5Mb2FkMUdsZWlzaWdcIikub24oXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICAgY29uc3QgbmFtZSA9ICQoZS50YXJnZXQpLmF0dHIoXCJkYXRhXCIpO1xuICAgICAgICAgU1RPUkFHRS5sb2FkUHJlYnVpbGRieU5hbWUobmFtZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBVSS5oaWRlU3RhcnRTY3JlZW4oKTtcbiAgICAgICAgICAgIFJFTkRFUklORy5kcmF3R3JpZCgpO1xuICAgICAgICAgICAgYXBwLnJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmVVbmRvSGlzdG9yeSgpO1xuICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8qJChidG5Mb2FkRnJvbUZpbGUpLmNsaWNrKCgpID0+IHsgbG9hZFNpZ25hbHNGcm9tRmlsZSgpOyBoaWRlU3RhcnRTY3JlZW4oKTsgfSk7XG4gICAgICAgbG9hZFByZWJ1aWxkcygpOyAqL1xuICAgICAgbGV0IG0gPSBib290c3RyYXAuTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZShsb2FkTW9kYWwpO1xuICAgICAgbS5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgXCJoaWRkZW4uYnMubW9kYWxcIixcbiAgICAgICAgICh4KSA9PiB7XG4gICAgICAgICAgICBib290c3RyYXAuTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh4LnRhcmdldCkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgJChidG5TdGFydEZyb21aZXJvKS5vZmYoXCJjbGlja1wiKTtcbiAgICAgICAgICAgICQoYnRuTG9hZFJlY2VudCkub2ZmKFwiY2xpY2tcIik7XG4gICAgICAgICAgICAkKGJ0bkxvYWRGcm9tRmlsZSkub2ZmKFwiY2xpY2tcIik7XG4gICAgICAgICB9LFxuICAgICAgICAgeyBvbmNlOiB0cnVlIH1cbiAgICAgICk7XG4gICAgICBtLnNob3coKTtcbiAgIH0sXG5cbiAgIGhpZGVTdGFydFNjcmVlbigpIHtcbiAgICAgICQoXCJteUNhbnZhc1wiKS5mb2N1cygpO1xuICAgICAgYm9vdHN0cmFwLk1vZGFsLmdldEluc3RhbmNlKGxvYWRNb2RhbCkuaGlkZSgpO1xuICAgfSxcblxuICAgXG5cbiAgIEdldERhdGFVUkxfRnJvbVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICBjb25zdCB0bXBTdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZSgkKFwiPGNhbnZhcz5cIikuYXR0cih7IHdpZHRoOiA0NTAsIGhlaWdodDogNDUwIH0pWzBdKTtcbiAgICAgIHRtcFN0YWdlLnNjYWxlID0gdGVtcGxhdGUuc2NhbGU7XG5cbiAgICAgIC8vIFVzZSBkZWRpY2F0ZWQgcHJldmlldyByZW5kZXJpbmcgbWV0aG9kXG4gICAgICBTaWduYWxSZW5kZXJlci5kcmF3UHJldmlldyh0ZW1wbGF0ZSwgdG1wU3RhZ2UpO1xuICAgICAgdG1wU3RhZ2UudXBkYXRlKCk7XG5cbiAgICAgIGNvbnN0IHNpZ19ib3VuZHMgPSB0bXBTdGFnZS5nZXRCb3VuZHMoKTtcbiAgICAgIGlmIChzaWdfYm91bmRzID09IG51bGwpIHRocm93IEVycm9yKHRlbXBsYXRlLnRpdGxlICsgXCIgaGFzIG5vIHZpc3VhbCBFbGVtZW50IHZpc2libGVcIik7XG4gICAgICB0bXBTdGFnZS5jYWNoZShzaWdfYm91bmRzLngsIHNpZ19ib3VuZHMueSwgc2lnX2JvdW5kcy53aWR0aCwgc2lnX2JvdW5kcy5oZWlnaHQsIDAuNSk7XG4gICAgICByZXR1cm4gdG1wU3RhZ2UuYml0bWFwQ2FjaGUuZ2V0Q2FjaGVEYXRhVVJMKCk7XG4gICB9LFxufTtcblxuZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUobW9kZSkge1xuICAgYXBwLmVkaXRNb2RlID0gbW9kZSAhPSB1bmRlZmluZWQgPyBtb2RlIDogJChidG5EcmF3VHJhY2tzKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgYXBwLnNob3dHcmlkID0gYXBwLmVkaXRNb2RlO1xuICAgUkVOREVSSU5HLmRyYXdHcmlkKCk7XG4gICBhcHAuc3RhZ2UudXBkYXRlKCk7XG4gICBpZiAobW9kZSAhPSB1bmRlZmluZWQpICQoYnRuRHJhd1RyYWNrcykucHJvcChcIjpjaGVja2VkXCIsIGFwcC5lZGl0TW9kZSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFJlbmRlcmVyKHRleHR1cmVkKSB7XG4gICBpZiAodGV4dHVyZWQpIHtcbiAgICAgIGFwcC5yZW5kZXJlciA9IG5ldyB0cmFja1JlbmRlcmluZ190ZXh0dXJlZCgpO1xuICAgICAgJChcIiNzd2l0Y2hfcmVuZGVyZXJcIikucHJvcChcImNoZWNrZWRcIiwgZmFsc2UpO1xuICAgfSBlbHNlIHtcbiAgICAgIGFwcC5yZW5kZXJlciA9IG5ldyB0cmFja1JlbmRlcmluZ19iYXNpYygpO1xuICAgICAgJChcIiNzd2l0Y2hfcmVuZGVyZXJcIikucHJvcChcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICB9ICAgXG4gICBhcHAucmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlKTtcbiAgIGFwcC5zdGFnZS51cGRhdGUoKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0T2JqZWN0KG9iamVjdCwgZSkge1xuICAgaWYgKCFvYmplY3QpIHtcbiAgICAgIGFwcC5zZWxlY3Rpb24ub2JqZWN0ID0gbnVsbDtcbiAgICAgIGFwcC5zZWxlY3Rpb24udHlwZSA9IFwiXCI7XG4gICAgICBhcHAucmVuZGVyZXI/LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgVUkuc2hvd01lbnUoKTtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIGNvbnN0IHQgPSB0eXBlKG9iamVjdCk7XG4gICBpZiAob2JqZWN0KSBjb25zb2xlLmxvZyhvYmplY3QpO1xuXG4gICBpZiAodCAhPSBhcHAuc2VsZWN0aW9uLnR5cGUpIHtcbiAgICAgIGFwcC5zZWxlY3Rpb24ub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgYXBwLnNlbGVjdGlvbi50eXBlID0gdDtcbiAgIH0gZWxzZSB7XG4gICAgICBpZiAoZT8ubmF0aXZlRXZlbnQ/LmN0cmxLZXkpXG4gICAgICAgICBhcHAuc2VsZWN0aW9uLm9iamVjdCA9IEFycmF5LmlzQXJyYXkoYXBwLnNlbGVjdGlvbi5vYmplY3QpID8gWy4uLmFwcC5zZWxlY3Rpb24ub2JqZWN0LCBvYmplY3RdIDogW2FwcC5zZWxlY3Rpb24ub2JqZWN0LCBvYmplY3RdO1xuICAgICAgZWxzZSBhcHAuc2VsZWN0aW9uLm9iamVjdCA9IG9iamVjdDtcbiAgIH1cbiAgIGFwcC5yZW5kZXJlcj8udXBkYXRlU2VsZWN0aW9uKCk7XG5cbiAgIGxldCBtZW51O1xuICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFwiU2lnbmFsXCI6XG4gICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXBwLnNlbGVjdGlvbi5vYmplY3QpKSBtZW51ID0gTUVOVS5FRElUX1NJR05BTDtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlRyYWluXCI6XG4gICAgICAgICBtZW51ID0gTUVOVS5FRElUX1RSQUlOO1xuICAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiR2VuZXJpY09iamVjdFwiOlxuICAgICAgICAgbWVudSA9IE1FTlUuRURJVF9PQkpFQ1Q7XG4gICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICBtZW51ID0gbnVsbDtcbiAgICAgICAgIGJyZWFrO1xuICAgfVxuXG4gICBVSS5zaG93TWVudShtZW51KTtcbn1cblxuZnVuY3Rpb24gb25SZXNpemVXaW5kb3coKSB7XG4gICAkKG15Q2FudmFzKS5hdHRyKFwiaGVpZ2h0XCIsICQoQ2FudmFzQ29udGFpbmVyKS5oZWlnaHQoKSAtIDUpO1xuICAgJChteUNhbnZhcykuYXR0cihcIndpZHRoXCIsICQoQ2FudmFzQ29udGFpbmVyKS53aWR0aCgpKTtcbiAgIFJFTkRFUklORy5kcmF3R3JpZCgpO1xuICAgYXBwLnN0YWdlLnVwZGF0ZSgpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdGFnZU1vdXNlRG93bihldmVudCkge1xuICAgLy9jb25zb2xlLmxvZyhcImhhbmRsZVN0YWdlTW91c2VEb3duXCIsIGV2ZW50KTtcblxuICAgbGV0IGhpdHRlc3QgPSBnZXRIaXRUZXN0KCk7XG5cbiAgIGNvbnNvbGUubG9nKGhpdHRlc3QgPyBoaXR0ZXN0IDogXCJub3RoaW5nIGhpdFwiKTtcblxuICAgbGV0IG1vdXNlQWN0aW9uID0ge1xuICAgICAgYWN0aW9uOiBhcHAuY3VzdG9tTW91c2VNb2RlICE9IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORSA/IE1PVVNFX0RPV05fQUNUSU9OLkNVU1RPTSA6IE1PVVNFX0RPV05fQUNUSU9OLk5PTkUsXG4gICAgICBjb250YWluZXI6IGhpdHRlc3QsXG4gICAgICBzdGFydFBvaW50OiBhcHAuc3RhZ2UuZ2xvYmFsVG9Mb2NhbChhcHAuc3RhZ2UubW91c2VYLCBhcHAuc3RhZ2UubW91c2VZKSxcbiAgICAgIF9kaXN0YW5jZVBvaW50OiBuZXcgUG9pbnQoZXZlbnQuc3RhZ2VYLCBldmVudC5zdGFnZVkpLFxuICAgICAgb2Zmc2V0OiBoaXR0ZXN0Py5nbG9iYWxUb0xvY2FsKGFwcC5zdGFnZS5tb3VzZVgsIGFwcC5zdGFnZS5tb3VzZVkpLCAvL0tvb3JkaW5hdGUgYXVmIGRlbSBhbmdla2xpY2t0ZW4gT2JqZWN0ICh6YiBTaWduYWwpLCBkYW1pdCBkZXIgQ29udGFpbmVyIGFtIE1hdXN6ZWlnZXIgXCJrbGVidFwiXG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgcmV0dXJuIGdlb21ldHJ5LmRpc3RhbmNlKHRoaXMuX2Rpc3RhbmNlUG9pbnQsIG5ldyBQb2ludChhcHAuc3RhZ2UubW91c2VYLCBhcHAuc3RhZ2UubW91c2VZKSk7XG4gICAgICB9LFxuICAgfTtcblxuICAgLy8gQ2hlY2sgaWYgd2UgY2xpY2tlZCBvbiBhIHRyYWNrIGVuZHBvaW50XG4gICBpZiAobW91c2VBY3Rpb24uY29udGFpbmVyPy5uYW1lID09PSBcInRyYWNrX2VuZHBvaW50XCIpIHtcbiAgICAgIG1vdXNlQWN0aW9uLmFjdGlvbiA9IE1PVVNFX0RPV05fQUNUSU9OLkRORF9UUkFDSztcbiAgICAgIG1vdXNlQWN0aW9uLnRyYWNrID0gbW91c2VBY3Rpb24uY29udGFpbmVyLnRyYWNrO1xuICAgICAgbW91c2VBY3Rpb24uZW5kcG9pbnQgPSBtb3VzZUFjdGlvbi5jb250YWluZXIuZW5kcG9pbnQ7XG4gICB9XG5cbiAgIGlmIChhcHAuY3VzdG9tTW91c2VNb2RlID09IENVU1RPTV9NT1VTRV9BQ1RJT04uRFJBV0lORykge1xuICAgICAgY29uc3QgY29sb3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwiRHJhd2luZ0NvbG9yXCJdOmNoZWNrZWQnKS52YWx1ZTtcbiAgICAgIGNvbnN0IHdpZHRoID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cIkRyYXdpbmdXaWR0aFwiXTpjaGVja2VkJykudmFsdWU7XG5cbiAgICAgIGFwcC5jb250YWluZXJzLmRyYXdpbmcuYWRkQ2hpbGQoKG1vdXNlQWN0aW9uLnNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkpKTtcbiAgICAgIG1vdXNlQWN0aW9uLnNoYXBlLmdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKHdpZHRoLCBcInJvdW5kXCIsIFwicm91bmRcIikuYmVnaW5TdHJva2UoY29sb3IpO1xuICAgICAgbW91c2VBY3Rpb24ub2xkX3BvaW50ID0gbmV3IFBvaW50KGV2ZW50LnN0YWdlWCwgZXZlbnQuc3RhZ2VZKTtcbiAgIH1cbiAgIC8vY29uc29sZS5sb2cobW91c2VBY3Rpb24pO1xuICAgYXBwLm1vdXNlQWN0aW9uID0gbW91c2VBY3Rpb247XG4gICBhcHAuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWdlbW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG59XG5cbmZ1bmN0aW9uIGdldEhpdFRlc3QoY29udGFpbmVyKSB7XG4gICBsZXQgbG9jYWxfcG9pbnQgPSBhcHAuc3RhZ2UuZ2xvYmFsVG9Mb2NhbChhcHAuc3RhZ2UubW91c2VYLCBhcHAuc3RhZ2UubW91c2VZKTtcblxuICAgcmV0dXJuIChjb250YWluZXIgPyBjb250YWluZXIgOiBhcHAuc3RhZ2UpLmdldE9iamVjdFVuZGVyUG9pbnQobG9jYWxfcG9pbnQueCwgbG9jYWxfcG9pbnQueSwgMSk7XG59XG5cbmZ1bmN0aW9uIGdldEhpdEluZm9Gb3JTaWduYWxQb3NpdGlvbmluZyh0ZXN0UG9pbnQpIHtcbiAgIGZvciAoY29uc3QgdHJhY2sgb2YgVHJhY2suYWxsVHJhY2tzKSB7XG4gICAgICBpZiAoTnVtYmVyVXRpbHMuYmV0d2Vlbih0ZXN0UG9pbnQueCwgdHJhY2suc3RhcnQueCwgdHJhY2suZW5kLngpKSB7XG4gICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGdlb21ldHJ5LnBvaW50VG9TZWdtZW50RGlzdGFuY2UodGVzdFBvaW50LCB0cmFjay5zdGFydCwgdHJhY2suZW5kKTtcbiAgICAgICAgIGlmIChkaXN0YW5jZSA8PSBDT01QVVRFRC5HUklEX1NJWkVfMikge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBUT09MUy5uZWFyZXN0UG9pbnRPbkxpbmUodHJhY2suc3RhcnQsIHRyYWNrLmVuZCwgdGVzdFBvaW50KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgIGttOiB0cmFjay5nZXRLbWZyb21Qb2ludChwb2ludCksXG4gICAgICAgICAgICAgICBhYm92ZTogdGVzdFBvaW50LnkgPCBwb2ludC55LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cbn1cblxuZnVuY3Rpb24gYWxpZ25TaWduYWxDb250YWluZXJXaXRoVHJhY2soYywgcG9zKSB7XG4gICAvL2tvb3JkaW5hdGVuIGFuaGFuZCBkZXMgU3RyZWNrZW4gS00gc3VjaGVuLCB3ZW5uIHNpZSBuaWNodCDDvGJlcmdlYmVuIHdvcmRlbiBzaW5kXG5cbiAgIGNvbnN0IHBvaW50ID0gcG9zLnRyYWNrLmdldFBvaW50RnJvbUttKHBvcy5rbSk7XG5cbiAgIGxldCBwO1xuICAgaWYgKHBvcy5hYm92ZSkge1xuICAgICAgYy5yb3RhdGlvbiA9IDI3MCArIHBvcy50cmFjay5kZWc7XG4gICAgICBwID0gcG9pbnQuYWRkKFxuICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgIC5wZXJwZW5kaWN1bGFyKHBvcy50cmFjay51bml0KVxuICAgICAgICAgICAgLm11bHRpcGx5KC1hcHAucmVuZGVyZXIuU0lHTkFMX0RJU1RBTkNFX0ZST01fVFJBQ0sgLSBjLmRhdGEuX3RlbXBsYXRlLmRpc3RhbmNlX2Zyb21fdHJhY2spXG4gICAgICApO1xuICAgfSBlbHNlIHtcbiAgICAgIGMucm90YXRpb24gPSA5MCArIHBvcy50cmFjay5kZWc7XG4gICAgICBwID0gcG9pbnQuYWRkKFxuICAgICAgICAgZ2VvbWV0cnlcbiAgICAgICAgICAgIC5wZXJwZW5kaWN1bGFyKHBvcy50cmFjay51bml0KVxuICAgICAgICAgICAgLm11bHRpcGx5KGFwcC5yZW5kZXJlci5TSUdOQUxfRElTVEFOQ0VfRlJPTV9UUkFDSyArIGMuZGF0YS5fdGVtcGxhdGUuZGlzdGFuY2VfZnJvbV90cmFjaylcbiAgICAgICk7XG4gICB9XG4gICBpZiAocG9zLmZsaXBwZWQpIGMucm90YXRpb24gKz0gMTgwO1xuXG4gICBjLnggPSBwLng7XG4gICBjLnkgPSBwLnk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RHJhZ0FuZERyb3BTaWduYWwobW91c2VYLCBtb3VzZVkpIHtcbiAgIGlmIChhcHAubW91c2VBY3Rpb24uY29udGFpbmVyKSB7XG4gICAgICBhcHAubW91c2VBY3Rpb24uY29udGFpbmVyLnBhcmVudC5yZW1vdmVDaGlsZChhcHAubW91c2VBY3Rpb24uY29udGFpbmVyKTtcbiAgIH0gZWxzZSB7XG4gICAgICBsZXQgc2lnbmFsID0gbmV3IFNpZ25hbChhcHAubW91c2VBY3Rpb24udGVtcGxhdGUpO1xuICAgICAgYXBwLm1vdXNlQWN0aW9uLmNvbnRhaW5lciA9IFNpZ25hbFJlbmRlcmVyLmNyZWF0ZVNpZ25hbENvbnRhaW5lcihzaWduYWwpO1xuICAgICAgYXBwLm1vdXNlQWN0aW9uLmNvbnRhaW5lci54ID0gbW91c2VYO1xuICAgICAgYXBwLm1vdXNlQWN0aW9uLmNvbnRhaW5lci55ID0gbW91c2VZO1xuICAgfVxuXG4gICBhcHAuY29udGFpbmVycy5vdmVybGF5LmFkZENoaWxkKGFwcC5tb3VzZUFjdGlvbi5jb250YWluZXIpO1xuICAgYXBwLnN0YWdlLnVwZGF0ZSgpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgIC8vY29uc29sZS5sb2coXCJoYW5kbGVNb3VzZU1vdmVcIiwgZXZlbnQpO1xuICAgaWYgKCFldmVudC5wcmltYXJ5KSByZXR1cm47XG4gICBpZiAoYXBwLm1vdXNlQWN0aW9uID09IG51bGwpIHtcbiAgICAgIGFwcC5zdGFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIC8vZmFsbHMgbW91c2VNb3ZlIG5vY2ggbMOkdWZ0LCBvYndvaGwgZGVyIFVzZXIga2VpbmVuIGJ1dHRvbiBtZWhyIGRyw7xja3RcbiAgIC8vdHJpdHQgdm9yIGFsbGVtIGJlaW0gZGVidWdnaW5nIGF1ZlxuICAgaWYgKGV2ZW50Lm5hdGl2ZUV2ZW50LmJ1dHRvbnMgPT0gMCkge1xuICAgICAgY29uc29sZS5sb2coXCJkZWJ1ZyBtb3VzZSBlcnJvclwiKTtcbiAgICAgIHJldHVybiBoYW5kbGVTdGFnZU1vdXNlVXAoZXZlbnQpO1xuICAgfVxuXG4gICBsZXQgbG9jYWxfcG9pbnQgPSBhcHAuc3RhZ2UuZ2xvYmFsVG9Mb2NhbChhcHAuc3RhZ2UubW91c2VYLCBhcHAuc3RhZ2UubW91c2VZKTtcblxuICAgaWYgKGFwcC5tb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLk5PTkUpIHtcbiAgICAgIGRldGVybWluZU1vdXNlQWN0aW9uKGV2ZW50LCBsb2NhbF9wb2ludCk7XG4gICB9IGVsc2UgaWYgKGFwcC5tb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLkNVU1RPTSkge1xuICAgICAgaWYgKGFwcC5jdXN0b21Nb3VzZU1vZGUgPT0gQ1VTVE9NX01PVVNFX0FDVElPTi5EUkFXSU5HKSB7XG4gICAgICAgICBhcHAubW91c2VBY3Rpb24uc2hhcGUuZ3JhcGhpY3MubXQoYXBwLm1vdXNlQWN0aW9uLnN0YXJ0UG9pbnQueCwgYXBwLm1vdXNlQWN0aW9uLnN0YXJ0UG9pbnQueSkubHQobG9jYWxfcG9pbnQueCwgbG9jYWxfcG9pbnQueSk7XG4gICAgICAgICBhcHAubW91c2VBY3Rpb24uc3RhcnRQb2ludC54ID0gbG9jYWxfcG9pbnQueDtcbiAgICAgICAgIGFwcC5tb3VzZUFjdGlvbi5zdGFydFBvaW50LnkgPSBsb2NhbF9wb2ludC55O1xuICAgICAgfSBlbHNlIGlmIChhcHAuY3VzdG9tTW91c2VNb2RlID09IENVU1RPTV9NT1VTRV9BQ1RJT04uUExBVFRGT1JNKSB7XG4gICAgICAgICBhcHAuY29udGFpbmVycy5vdmVybGF5LnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgICBhcHAuY29udGFpbmVycy5vdmVybGF5LmFkZENoaWxkKChhcHAubW91c2VBY3Rpb24uc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKSkpO1xuICAgICAgICAgYXBwLm1vdXNlQWN0aW9uLnNoYXBlLmdyYXBoaWNzXG4gICAgICAgICAgICAuYmVnaW5TdHJva2UoXCIjMTExMTExXCIpXG4gICAgICAgICAgICAuZHJhd1JlY3QoXG4gICAgICAgICAgICAgICBhcHAubW91c2VBY3Rpb24uc3RhcnRQb2ludC54LFxuICAgICAgICAgICAgICAgYXBwLm1vdXNlQWN0aW9uLnN0YXJ0UG9pbnQueSxcbiAgICAgICAgICAgICAgIGxvY2FsX3BvaW50LnggLSBhcHAubW91c2VBY3Rpb24uc3RhcnRQb2ludC54LFxuICAgICAgICAgICAgICAgbG9jYWxfcG9pbnQueSAtIGFwcC5tb3VzZUFjdGlvbi5zdGFydFBvaW50LnlcbiAgICAgICAgICAgICk7XG4gICAgICAgICBhcHAuc3RhZ2UudXBkYXRlKCk7XG4gICAgICB9XG4gICB9IGVsc2UgaWYgKGFwcC5tb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLk1PVkVfT0JKRUNUKSB7XG4gICAgICBjb25zdCBvID0gYXBwLm1vdXNlQWN0aW9uLmNvbnRhaW5lci5kYXRhO1xuICAgICAgby5wb3MobG9jYWxfcG9pbnQpO1xuICAgICAgaWYgKGFwcC5tb3VzZUFjdGlvbi5vZmZzZXQpIHtcbiAgICAgICAgIGxldCBwID0gYXBwLm1vdXNlQWN0aW9uLmNvbnRhaW5lci5sb2NhbFRvTG9jYWwoYXBwLm1vdXNlQWN0aW9uLm9mZnNldC54LCBhcHAubW91c2VBY3Rpb24ub2Zmc2V0LnksIGFwcC5zdGFnZSk7XG4gICAgICAgICBsb2NhbF9wb2ludC54IC09IHAueCAtIGFwcC5tb3VzZUFjdGlvbi5jb250YWluZXIueDtcbiAgICAgICAgIGxvY2FsX3BvaW50LnkgLT0gcC55IC0gYXBwLm1vdXNlQWN0aW9uLmNvbnRhaW5lci55O1xuICAgICAgfVxuICAgICAgYXBwLm1vdXNlQWN0aW9uLmNvbnRhaW5lci54ID0gbG9jYWxfcG9pbnQueDtcbiAgICAgIGFwcC5tb3VzZUFjdGlvbi5jb250YWluZXIueSA9IGxvY2FsX3BvaW50Lnk7XG4gICAgICBhcHAucmVuZGVyZXIudXBkYXRlU2VsZWN0aW9uKCk7XG4gICB9IGVsc2UgaWYgKGFwcC5tb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLkRORF9TSUdOQUwpIHtcbiAgICAgIGRyYWduRHJvcFNpZ25hbChsb2NhbF9wb2ludCwgZXZlbnQubmF0aXZlRXZlbnQuYWx0S2V5KTtcbiAgICAgIGFwcC5yZW5kZXJlci51cGRhdGVTZWxlY3Rpb24oKTtcbiAgIH0gZWxzZSBpZiAoYXBwLm1vdXNlQWN0aW9uLmFjdGlvbiA9PT0gTU9VU0VfRE9XTl9BQ1RJT04uQlVJTERfVFJBQ0spIHtcbiAgICAgIGNvbnN0IGdyaWRfc25hcF9wb2ludCA9IGdldFNuYXBQb2ludChsb2NhbF9wb2ludCk7XG5cbiAgICAgICAgICAgICAgIGlmIChnZW9tZXRyeS5kaXN0YW5jZShsb2NhbF9wb2ludCwgZ3JpZF9zbmFwX3BvaW50KSA8PSBDT05GSUcuU05BUF9UT19HUklEKSB7XG4gICAgICAgICAgICBpZiAoVHJhY2suaXNWYWxpZFRyYWNrTm9kZVBvaW50KGxvY2FsX3BvaW50KSkge1xuICAgICAgICAgICAgICAgYWRkVHJhY2tBbmNob3JQb2ludChncmlkX3NuYXBfcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgZHJhd0JsdWVQcmludFRyYWNrKCk7XG4gICB9IGVsc2UgaWYgKGFwcC5tb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLlNDUk9MTCkge1xuICAgICAgYXBwLnN0YWdlLnggKz0gZXZlbnQubmF0aXZlRXZlbnQubW92ZW1lbnRYO1xuICAgICAgYXBwLnN0YWdlLnkgKz0gZXZlbnQubmF0aXZlRXZlbnQubW92ZW1lbnRZO1xuICAgICAgUkVOREVSSU5HLmRyYXdHcmlkKGZhbHNlKTtcbiAgICAgIGFwcC5yZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKCk7XG4gICB9IGVsc2UgaWYgKGFwcC5tb3VzZUFjdGlvbi5hY3Rpb24gPT09IE1PVVNFX0RPV05fQUNUSU9OLk1PVkVfVFJBSU4pIHtcbiAgICAgIFRyYWluLm1vdmVUcmFpbihhcHAubW91c2VBY3Rpb24uY29udGFpbmVyLmRhdGEsIGV2ZW50Lm5hdGl2ZUV2ZW50Lm1vdmVtZW50WCk7XG4gICAgICBhcHAucmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZygpO1xuICAgfSBlbHNlIGlmIChhcHAubW91c2VBY3Rpb24uYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5BRERfVFJBSU4pIHtcbiAgICAgIGFwcC5tb3VzZUFjdGlvbi5jb250YWluZXIueCA9IGxvY2FsX3BvaW50Lng7XG4gICAgICBhcHAubW91c2VBY3Rpb24uY29udGFpbmVyLnkgPSBsb2NhbF9wb2ludC55O1xuICAgfSBlbHNlIGlmIChhcHAubW91c2VBY3Rpb24uYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5ETkRfVFJBQ0spIHtcbiAgICAgIGNvbnN0IGdyaWRfc25hcF9wb2ludCA9IGdldFNuYXBQb2ludChsb2NhbF9wb2ludCk7XG5cbiAgICAgIGlmIChnZW9tZXRyeS5kaXN0YW5jZShsb2NhbF9wb2ludCwgZ3JpZF9zbmFwX3BvaW50KSA8PSBDT05GSUcuU05BUF9UT19HUklEKSB7XG4gICAgICAgICBpZiAoVHJhY2suaXNWYWxpZFRyYWNrTm9kZVBvaW50KGdyaWRfc25hcF9wb2ludCkpIHtcbiAgICAgICAgICAgIGlmIChhcHAubW91c2VBY3Rpb24uZW5kcG9pbnQgPT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgYXBwLm1vdXNlQWN0aW9uLnRyYWNrLnNldE5ld1N0YXJ0KGdyaWRfc25hcF9wb2ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgYXBwLm1vdXNlQWN0aW9uLnRyYWNrLnNldE5ld0VuZChncmlkX3NuYXBfcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVHJhY2suY3JlYXRlUmFpbE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGFwcC5yZW5kZXJlci5yZURyYXdFdmVyeXRoaW5nKHRydWUpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuXG4gICBhcHAuc3RhZ2UudXBkYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGdldFNuYXBQb2ludChsb2NhbF9wb2ludCkge1xuICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLnJvdW5kKGxvY2FsX3BvaW50LnggLyBDT05GSUcuR1JJRF9TSVpFKSAqIENPTkZJRy5HUklEX1NJWkUsIE1hdGgucm91bmQobG9jYWxfcG9pbnQueSAvIENPTkZJRy5HUklEX1NJWkUpICogQ09ORklHLkdSSURfU0laRSk7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1vdXNlQWN0aW9uKGV2ZW50LCBsb2NhbF9wb2ludCkge1xuICAgbGV0IG1hID0gYXBwLm1vdXNlQWN0aW9uO1xuICAgLy93aWUgd2VpdCB3dXJkZSBkaWUgbWF1cyBzZWl0IG1vdXNlZG93biBiZXdlZ3RcbiAgIGlmIChtYS5kaXN0YW5jZSgpID4gSU5QVVQuTU9VU0VfTU9WRU1FTlRfVEhSRVNIT0xEKSB7XG4gICAgICBpZiAoZXZlbnQubmF0aXZlRXZlbnQuYnV0dG9ucyA9PSAxKSB7XG4gICAgICAgICBpZiAoYXBwLmVkaXRNb2RlKSB7XG4gICAgICAgICAgICBpZiAobWEuY29udGFpbmVyPy5uYW1lID09IFwic2lnbmFsXCIpIHtcbiAgICAgICAgICAgICAgIG15Q2FudmFzLnN0eWxlLmN1cnNvciA9IFwibW92ZVwiO1xuICAgICAgICAgICAgICAgbWEuYWN0aW9uID0gTU9VU0VfRE9XTl9BQ1RJT04uRE5EX1NJR05BTDtcbiAgICAgICAgICAgICAgIG1hLmNvbnRhaW5lci5kYXRhLl9wb3NpdGlvbmluZy50cmFjay5yZW1vdmVTaWduYWwobWEuY29udGFpbmVyLmRhdGEpO1xuICAgICAgICAgICAgICAgc3RhcnREcmFnQW5kRHJvcFNpZ25hbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYS5jb250YWluZXI/Lm5hbWUgPT0gXCJHZW5lcmljT2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgIG15Q2FudmFzLnN0eWxlLmN1cnNvciA9IFwibW92ZVwiO1xuXG4gICAgICAgICAgICAgICBtYS5hY3Rpb24gPSBNT1VTRV9ET1dOX0FDVElPTi5NT1ZFX09CSkVDVDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICBtYS5jb250YWluZXI/Lm5hbWUgPT0gXCJ0cmFja1wiIHx8XG4gICAgICAgICAgICAgICBtYS5jb250YWluZXI/Lm5hbWUgPT0gXCJzd2l0Y2hcIiB8fFxuICAgICAgICAgICAgICAgbWEuY29udGFpbmVyID09IG51bGxcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgbWEuYWN0aW9uID0gTU9VU0VfRE9XTl9BQ1RJT04uQlVJTERfVFJBQ0s7XG4gICAgICAgICAgICAgICBhZGRUcmFja0FuY2hvclBvaW50KGdldFNuYXBQb2ludChsb2NhbF9wb2ludCkpO1xuICAgICAgICAgICAgICAgYXBwLmNvbnRhaW5lcnMub3ZlcmxheS5hZGRDaGlsZCgobWEubGluZVNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChtYS5jb250YWluZXI/Lm5hbWUgPT0gXCJ0cmFpblwiKSB7XG4gICAgICAgICAgICBtYS5hY3Rpb24gPSBNT1VTRV9ET1dOX0FDVElPTi5NT1ZFX1RSQUlOO1xuICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudC5uYXRpdmVFdmVudC5idXR0b25zID09IDIpIHtcbiAgICAgICAgIG1hLmFjdGlvbiA9IE1PVVNFX0RPV05fQUNUSU9OLlNDUk9MTDtcbiAgICAgIH1cbiAgIH1cbn1cblxuZnVuY3Rpb24gZHJhZ25Ecm9wU2lnbmFsKGxvY2FsX3BvaW50LCBmbGlwcGVkKSB7XG4gICBsZXQgbWEgPSBhcHAubW91c2VBY3Rpb247XG5cbiAgIGxldCBoaXRJbmZvcm1hdGlvbiA9IGdldEhpdEluZm9Gb3JTaWduYWxQb3NpdGlvbmluZyhsb2NhbF9wb2ludCk7XG4gICBpZiAoaGl0SW5mb3JtYXRpb24pIHtcbiAgICAgIGhpdEluZm9ybWF0aW9uLmZsaXBwZWQgPSBmbGlwcGVkO1xuICAgICAgbWEuaGl0X3RyYWNrID0gaGl0SW5mb3JtYXRpb247XG4gICAgICBjb25zb2xlLmxvZyhoaXRJbmZvcm1hdGlvbik7XG4gICAgICBhbGlnblNpZ25hbENvbnRhaW5lcldpdGhUcmFjayhtYS5jb250YWluZXIsIGhpdEluZm9ybWF0aW9uKTtcbiAgIH0gZWxzZSB7XG4gICAgICBtYS5oaXRfdHJhY2sgPSBudWxsO1xuICAgICAgbWEuY29udGFpbmVyLnJvdGF0aW9uID0gMDtcbiAgICAgIGlmIChtYS5vZmZzZXQpIHtcbiAgICAgICAgIGxldCBwID0gbWEuY29udGFpbmVyLmxvY2FsVG9Mb2NhbChtYS5vZmZzZXQueCwgbWEub2Zmc2V0LnksIGFwcC5zdGFnZSk7XG4gICAgICAgICBsb2NhbF9wb2ludC54IC09IHAueCAtIG1hLmNvbnRhaW5lci54O1xuICAgICAgICAgbG9jYWxfcG9pbnQueSAtPSBwLnkgLSBtYS5jb250YWluZXIueTtcbiAgICAgIH1cbiAgICAgIG1hLmNvbnRhaW5lci54ID0gbG9jYWxfcG9pbnQueDtcbiAgICAgIG1hLmNvbnRhaW5lci55ID0gbG9jYWxfcG9pbnQueTtcbiAgIH1cbiAgIGRyYXdfU2lnbmFsUG9zaXRpb25MaW5lKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdfU2lnbmFsUG9zaXRpb25MaW5lKCkge1xuICAgbGV0IHNoYXBlID0gYXBwLmNvbnRhaW5lcnMub3ZlcmxheS5nZXRDaGlsZEJ5TmFtZShcIlNpZ25hbFBvc2l0aW9uTGluZVwiKTtcbiAgIGlmIChzaGFwZSkgYXBwLmNvbnRhaW5lcnMub3ZlcmxheS5yZW1vdmVDaGlsZChzaGFwZSk7XG5cbiAgIGlmIChhcHAubW91c2VBY3Rpb24uaGl0X3RyYWNrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IGFwcC5tb3VzZUFjdGlvbi5oaXRfdHJhY2sucG9pbnQ7XG4gICAgICBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgc2hhcGUubmFtZSA9IFwiU2lnbmFsUG9zaXRpb25MaW5lXCI7XG4gICAgICBzaGFwZS5ncmFwaGljc1xuICAgICAgICAgLnNldFN0cm9rZVN0eWxlKDEpXG4gICAgICAgICAuYmVnaW5TdHJva2UoQ09MT1JTLlNJR05BTF9QT1NJVElPTl9MSU5FKVxuICAgICAgICAgLm10KGFwcC5tb3VzZUFjdGlvbi5jb250YWluZXIueCwgYXBwLm1vdXNlQWN0aW9uLmNvbnRhaW5lci55KVxuICAgICAgICAgLmx0KHBvaW50LngsIHBvaW50LnkpXG4gICAgICAgICAuZXMoKTtcbiAgICAgIGFwcC5jb250YWluZXJzLm92ZXJsYXkuYWRkQ2hpbGQoc2hhcGUpO1xuICAgfVxufVxuXG5mdW5jdGlvbiBkcmF3Qmx1ZVByaW50VHJhY2soKSB7XG4gICBpZiAoYXBwLm1vdXNlQWN0aW9uLm5vZGVzID09IG51bGwpIHJldHVybjtcbiAgIGNvbnN0IGcgPSBhcHAubW91c2VBY3Rpb24ubGluZVNoYXBlLmdyYXBoaWNzO1xuICAgZy5jKCkuc2V0U3Ryb2tlU3R5bGUodHJhY2tSZW5kZXJpbmdfYmFzaWMuU1RST0tFKS5iZWdpblN0cm9rZShDT0xPUlMuRFJBV0lOR19CTFVFUFJJTlQpLm1vdmVUbyhhcHAubW91c2VBY3Rpb24ubm9kZXNbMF0ueCwgYXBwLm1vdXNlQWN0aW9uLm5vZGVzWzBdLnkpO1xuXG4gICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXBwLm1vdXNlQWN0aW9uLm5vZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBhcHAubW91c2VBY3Rpb24ubm9kZXNbaW5kZXhdO1xuICAgICAgZy5sdChwb2ludC54LCBwb2ludC55KTtcbiAgIH1cblxuICAgY29uc3QgbGFzdCA9IEFycmF5VXRpbHMubGFzdChhcHAubW91c2VBY3Rpb24ubm9kZXMpO1xuICAgY29uc3QgcCA9IGFwcC5zdGFnZS5nbG9iYWxUb0xvY2FsKGFwcC5zdGFnZS5tb3VzZVgsIGFwcC5zdGFnZS5tb3VzZVkpO1xuICAgZy5iZWdpblN0cm9rZShDT0xPUlMuRFJBV0lOR19BQ1RJVkUpLm1vdmVUbyhsYXN0LngsIGxhc3QueSkubHQocC54LCBwLnkpLmVuZFN0cm9rZSgpO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFja0FuY2hvclBvaW50KHApIHtcbiAgIGlmIChhcHAubW91c2VBY3Rpb24ubm9kZXMgPT0gbnVsbCkge1xuICAgICAgYXBwLm1vdXNlQWN0aW9uLm5vZGVzID0gW107XG4gICB9XG5cbiAgIC8vd2VubiBkZXIgbGV0enRlIFB1bmt0IGdsZWljaCBkZW0gYWt0dWVsbGVuIGlzdCwgZGFubiBuaWNodHMgdHVuXG4gICBpZiAoQXJyYXlVdGlscy5sYXN0KGFwcC5tb3VzZUFjdGlvbi5ub2Rlcyk/LmVxdWFscyhwKSkgcmV0dXJuO1xuICAgLy93ZW5uIGRlciBTdGFydHB1bmt0IGdsZWljaCBkZW0gYWt0dWVsbGVuIGlzdCwgZGFubiBUcmFjayB6dXLDvGNrc2V0emVuXG4gICBpZiAoQXJyYXlVdGlscy5maXJzdChhcHAubW91c2VBY3Rpb24ubm9kZXMpPy5lcXVhbHMocCkpIHtcbiAgICAgIGFwcC5tb3VzZUFjdGlvbi5ub2RlcyA9IFthcHAubW91c2VBY3Rpb24ubm9kZXNbMF1dO1xuICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICBhcHAubW91c2VBY3Rpb24ubm9kZXMucHVzaChwKTtcbiAgIHJldHVybjtcblxuICAgaWYgKGFua2VyUG9pbnRzID09IG51bGwgfHwgYW5rZXJQb2ludHMubGVuZ3RoID09IDApIHtcbiAgICAgIGFwcC5tb3VzZUFjdGlvbi5hbmtlclBvaW50cyA9IFtwXTtcbiAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2VvbWV0cnkuZGlzdGFuY2UobG9jYWxfcG9pbnQsIHApID4gQ09ORklHLlNOQVBfVE9fR1JJRCkge1xuICAgICAgICAgLyogaWYgKGFua2VyUG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGFua2VyUG9pbnRzLnBvcCgpO1xuICAgICAgICAgfSAqL1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsYXN0ID0gYW5rZXJQb2ludHMubGFzdCgpO1xuICAgICAgLy9pZiAoIWxvY2FsX3BvaW50LnguY2xvc2VUb0J5KEdSSURfU0laRSwgU05BUF8yX0dSSUQpIHx8ICFsb2NhbF9wb2ludC55LmNsb3NlVG9CeShHUklEX1NJWkUsIFNOQVBfMl9HUklEKSkgcmV0dXJuO1xuICAgICAgaWYgKCFsYXN0LmVxdWFscyhwKSkge1xuICAgICAgICAgY29uc3Qgc2xvcGUgPSBnZW9tZXRyeS5zbG9wZShsYXN0LCBwKTtcbiAgICAgICAgIGlmIChhbmtlclBvaW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaWYgKHNsb3BlLmJldHdlZW4oMSwgLTEpKSBhbmtlclBvaW50cy5wdXNoKHApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBNYXRoLnNpZ24oYW5rZXJQb2ludHNbMV0ueCAtIGFua2VyUG9pbnRzWzBdLngpO1xuICAgICAgICAgICAgLy9oYWJlbiB3aXIgZGVuIFB1bmt0IHNjaG9uIGVpbmdldHJhZ2VuP1xuICAgICAgICAgICAgY29uc3QgeSA9IHAueCAtIEdSSURfU0laRSAqIGRpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBhbmtlclBvaW50cy5maW5kSW5kZXgoKHApID0+IE1hdGguc2lnbihwLnggLSB5KSA9PSBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAvL2JpcyB6dSBkaWVzZW0gUHVua3QgYWxsZSB2b3JoYW5kZW5lbiBQdW5rdGUgbMO2c2NoZW4gdW5kIGRlbiBha3R1ZWxsZW4gUHVua3QgdmVyc3VjaGVuIG5ldSBlaW56dXRyYWdlblxuICAgICAgICAgICAgICAgYW5rZXJQb2ludHMuc3BsaWNlKGkpO1xuICAgICAgICAgICAgICAgYWRkVHJhY2tBbmNob3JQb2ludChsb2NhbF9wb2ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgLy9jaGVja3MgZm9yIHRoZSByaWdodCBzbG9wZVxuICAgICAgICAgICAgICAgLy9ubyBvdGhlciBzdHJhaWdodCBvciA0NcKwIGFuZCB0aGUgcHJldmlvdXMgc2xvcGUgYW5kIGN1cnJlbnQgc2xvcGUgbXVzc3Qgbm90IGNyZWF0ZSBhIDkwwrAgYW5nbGVcbiAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNsb3BlLmJldHdlZW4oMSwgLTEpICYmXG4gICAgICAgICAgICAgICAgICAoc2xvcGUgPT0gMCB8fCBzbG9wZSArIGdlb21ldHJ5LnNsb3BlKGxhc3QsIGFua2VyUG9pbnRzW2Fua2VyUG9pbnRzLmxlbmd0aCAtIDJdKSAhPSAwKVxuICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBhbmtlclBvaW50cy5wdXNoKHApO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVTdGFnZU1vdXNlVXAoZSkge1xuICAgLy9jb25zb2xlLmxvZyhcImhhbmRsZVN0YWdlTW91c2VVcFwiLCBlKTtcbiAgIGxldCBtYSA9IGFwcC5tb3VzZUFjdGlvbjtcbiAgIHRyeSB7XG4gICAgICBhcHAuc3RhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YWdlbW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBteUNhbnZhcy5zdHlsZS5jdXJzb3IgPSBcImF1dG9cIjtcbiAgICAgIGlmIChtYSA9PSBudWxsKSByZXR1cm47XG5cbiAgICAgIGxldCBsb2NhbF9wb2ludCA9IFBvaW50LmZyb21Qb2ludChhcHAuc3RhZ2UuZ2xvYmFsVG9Mb2NhbChhcHAuc3RhZ2UubW91c2VYLCBhcHAuc3RhZ2UubW91c2VZKSk7XG4gICAgICAvL2xlZnQgYnV0dG9uXG4gICAgICBpZiAoZS5uYXRpdmVFdmVudC53aGljaCA9PSAxKSB7XG4gICAgICAgICBpZiAobWEuYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5ETkRfU0lHTkFMKSB7XG4gICAgICAgICAgICBhcHAuY29udGFpbmVycy5vdmVybGF5LnJlbW92ZUNoaWxkKG1hLmNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChtYS5oaXRfdHJhY2spIHtcbiAgICAgICAgICAgICAgIGFwcC5jb250YWluZXJzLnNpZ25hbHMuYWRkQ2hpbGQobWEuY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IG1hLmNvbnRhaW5lci5kYXRhO1xuICAgICAgICAgICAgICAgbWEuaGl0X3RyYWNrLnRyYWNrLkFkZFNpZ25hbChcbiAgICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgICAgIG1hLmhpdF90cmFjay5rbSxcbiAgICAgICAgICAgICAgICAgIG1hLmhpdF90cmFjay5hYm92ZSxcbiAgICAgICAgICAgICAgICAgIG1hLmhpdF90cmFjay5mbGlwcGVkXG4gICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgIFNpZ25hbC5yZW1vdmVTaWduYWwobWEuY29udGFpbmVyLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBwLnJlbmRlcmVyLnJlRHJhd0V2ZXJ5dGhpbmcodHJ1ZSk7XG4gICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICAgICAgICB9IGVsc2UgaWYgKG1hLmFjdGlvbiA9PT0gTU9VU0VfRE9XTl9BQ1RJT04uQlVJTERfVFJBQ0spIHtcbiAgICAgICAgICAgIGlmIChtYS5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICBUcmFjay5jaGVja05vZGVzQW5kQ3JlYXRlVHJhY2tzKG1hLm5vZGVzKTtcbiAgICAgICAgICAgICAgIFRyYWNrLmNyZWF0ZVJhaWxOZXR3b3JrKCk7XG4gICAgICAgICAgICAgICBhcHAucmVuZGVyZXIucmVEcmF3RXZlcnl0aGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgIFRyYWluLmFsbFRyYWlucy5mb3JFYWNoKCh0KSA9PiB0LnJlc3RvcmUoKSk7XG4gICAgICAgICAgICAgICBTVE9SQUdFLnNhdmVVbmRvSGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2UgaWYgKG1hLmFjdGlvbiA9PT0gTU9VU0VfRE9XTl9BQ1RJT04uQUREX1RSQUlOKSB7XG4gICAgICAgICAgICBhcHAuY29udGFpbmVycy5vdmVybGF5LnJlbW92ZUNoaWxkKG1hLmNvbnRhaW5lcik7XG4gICAgICAgICAgICBjb25zdCBoaXQgPSBnZXRIaXRUZXN0KGFwcC5jb250YWluZXJzLnRyYWNrcyk7XG4gICAgICAgICAgICBpZiAoaGl0Py5uYW1lID09IFwidHJhY2tcIikge1xuICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBBcnJheVV0aWxzLnJhbmRvbShDT0xPUlMuVFJBSU5fQ09MT1JTKTtcbiAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gaGl0LmRhdGE7XG4gICAgICAgICAgICAgICBjb25zdCBoaXRJbmZvID0gZ2V0SGl0SW5mb0ZvclNpZ25hbFBvc2l0aW9uaW5nKGxvY2FsX3BvaW50KTtcbiAgICAgICAgICAgICAgIGxldCB0cmFpbiwgY2FyLCBjYXIyO1xuICAgICAgICAgICAgICAgY29uc3Qga20gPSBoaXRJbmZvLmttO1xuXG4gICAgICAgICAgICAgICAvLyBDcmVhdGUgbG9jb21vdGl2ZSBhcyB0aGUgZmlyc3QgY2FyXG4gICAgICAgICAgICAgICBjYXIgPSB0cmFpbiA9IFRyYWluLmFkZFRyYWluKHRyYWNrLCBrbSwgY29sb3IsIFRyYWluLkNBUl9UWVBFUy5MT0NPTU9USVZFLCBcIlwiKTtcblxuICAgICAgICAgICAgICAgLy8gQWRkIHBhc3NlbmdlciBjYXJzXG4gICAgICAgICAgICAgICBjYXIyID0gVHJhaW4uYWRkVHJhaW4odHJhY2ssIGttLCBjb2xvciwgVHJhaW4uQ0FSX1RZUEVTLlBBU1NFTkdFUiwgXCJcIik7XG4gICAgICAgICAgICAgICBjYXIuY291cGxlQmFjayhjYXIyKTtcbiAgICAgICAgICAgICAgIGNhciA9IGNhcjI7XG5cbiAgICAgICAgICAgICAgIC8vIEFkZCBhbm90aGVyIHBhc3NlbmdlciBjYXJcbiAgICAgICAgICAgICAgIGNhcjIgPSBUcmFpbi5hZGRUcmFpbih0cmFjaywga20sIGNvbG9yLCBUcmFpbi5DQVJfVFlQRVMuUEFTU0VOR0VSLCBcIlwiKTtcbiAgICAgICAgICAgICAgIGNhci5jb3VwbGVCYWNrKGNhcjIpO1xuICAgICAgICAgICAgICAgY2FyID0gY2FyMjtcblxuICAgICAgICAgICAgICAgLy8gQWRkIGEgdGhpcmQgcGFzc2VuZ2VyIGNhclxuICAgICAgICAgICAgICAgY2FyMiA9IFRyYWluLmFkZFRyYWluKHRyYWNrLCBrbSwgY29sb3IsIFRyYWluLkNBUl9UWVBFUy5QQVNTRU5HRVIsIFwiXCIpO1xuICAgICAgICAgICAgICAgY2FyLmNvdXBsZUJhY2soY2FyMik7XG5cbiAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0cmFpbiBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgIFRyYWluLm1vdmVUcmFpbih0cmFpbiwgMCk7XG4gICAgICAgICAgICAgICBhcHAucmVuZGVyZXIucmVuZGVyQWxsVHJhaW5zKCk7XG4gICAgICAgICAgICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyVXRpbHMuaXMobWEuYWN0aW9uLCBNT1VTRV9ET1dOX0FDVElPTi5NT1ZFX1RSQUlOLCBNT1VTRV9ET1dOX0FDVElPTi5NT1ZFX09CSkVDVCkpIHtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgICAgU1RPUkFHRS5zYXZlVW5kb0hpc3RvcnkoKTtcbiAgICAgICAgIH0gZWxzZSBpZiAobWEuYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5DVVNUT00pIHtcbiAgICAgICAgICAgIGlmIChhcHAuY3VzdG9tTW91c2VNb2RlID09IENVU1RPTV9NT1VTRV9BQ1RJT04uVEVYVCkge1xuICAgICAgICAgICAgICAgY29uc3QgbyA9IG5ldyBHZW5lcmljT2JqZWN0KEdlbmVyaWNPYmplY3QuT0JKRUNUX1RZUEUudGV4dCkucG9zKGxvY2FsX3BvaW50KS5jb250ZW50KFwiVGV4dFwiKTtcbiAgICAgICAgICAgICAgIEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMucHVzaChvKTtcbiAgICAgICAgICAgICAgIHNlbGVjdE9iamVjdChvKTtcbiAgICAgICAgICAgICAgIGFwcC5yZW5kZXJlci5yZW5kZXJBbGxHZW5lcmljT2JqZWN0cygpO1xuICAgICAgICAgICAgICAgYXBwLmN1c3RvbU1vdXNlTW9kZSA9IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORTtcbiAgICAgICAgICAgICAgIFVJLmFjdGl2YXRlX2N1c3RvbV9tb3VzZV9tb2RlKCk7XG4gICAgICAgICAgICAgICBTVE9SQUdFLnNhdmVVbmRvSGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFwcC5jdXN0b21Nb3VzZU1vZGUgPT0gQ1VTVE9NX01PVVNFX0FDVElPTi5QTEFUVEZPUk0pIHtcbiAgICAgICAgICAgICAgIGFwcC5jb250YWluZXJzLm92ZXJsYXkucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgIGNvbnN0IG8gPSBuZXcgR2VuZXJpY09iamVjdChHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLnBsYXR0Zm9ybSlcbiAgICAgICAgICAgICAgICAgIC5jb250ZW50KFwiQmFobnN0ZWlnXCIpXG4gICAgICAgICAgICAgICAgICAucG9zKG1hLnN0YXJ0UG9pbnQpXG4gICAgICAgICAgICAgICAgICAuc2l6ZShsb2NhbF9wb2ludC54IC0gbWEuc3RhcnRQb2ludC54LCBsb2NhbF9wb2ludC55IC0gbWEuc3RhcnRQb2ludC55KTtcbiAgICAgICAgICAgICAgIEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMucHVzaChvKTtcbiAgICAgICAgICAgICAgIGFwcC5yZW5kZXJlci5yZW5kZXJBbGxHZW5lcmljT2JqZWN0cygpO1xuICAgICAgICAgICAgICAgc2VsZWN0T2JqZWN0KG8pO1xuICAgICAgICAgICAgICAgYXBwLmN1c3RvbU1vdXNlTW9kZSA9IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORTtcbiAgICAgICAgICAgICAgIFVJLmFjdGl2YXRlX2N1c3RvbV9tb3VzZV9tb2RlKCk7XG4gICAgICAgICAgICAgICBTVE9SQUdFLnNhdmVVbmRvSGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgU1RPUkFHRS5zYXZlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFwcC5jdXN0b21Nb3VzZU1vZGUgPT09IENVU1RPTV9NT1VTRV9BQ1RJT04uVFJBSU5fREVDT1VQTEUpIHtcbiAgICAgICAgICAgICAgIGlmIChtYS5jb250YWluZXI/Lm5hbWUgPT0gXCJkZWNvdXBsaW5nUG9pbnRcIikge1xuICAgICAgICAgICAgICAgICAgVHJhaW4uaGFuZGxlRGVjb3VwbGluZ0NsaWNrKG1hLmNvbnRhaW5lci5kYXRhKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBUcmFpbi5leGl0RGVjb3VwbGluZ01vZGUoKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwLmN1c3RvbU1vdXNlTW9kZSA9PT0gQ1VTVE9NX01PVVNFX0FDVElPTi5UUkFJTl9DT1VQTEUpIHtcbiAgICAgICAgICAgICAgIGlmIChtYS5jb250YWluZXI/Lm5hbWUgPT0gXCJjb3VwbGluZ1BvaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgIFRyYWluLmhhbmRsZUNvdXBsaW5nQ2xpY2sobWEuY29udGFpbmVyLmRhdGEpO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIFRyYWluLmV4aXRDb3VwbGluZ01vZGUoKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSBpZiAobWEuYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5OT05FICYmIG1hLmRpc3RhbmNlKCkgPCBJTlBVVC5NT1VTRV9NT1ZFTUVOVF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgIGlmIChtYS5jb250YWluZXI/Lm5hbWUgPT0gXCJzaWduYWxcIikge1xuICAgICAgICAgICAgICAgc2VsZWN0T2JqZWN0KG1hLmNvbnRhaW5lci5kYXRhLCBlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWEuY29udGFpbmVyPy5uYW1lID09IFwiY291cGxpbmdQb2ludFwiICYmIGFwcC5jdXN0b21Nb3VzZU1vZGUgPT09IENVU1RPTV9NT1VTRV9BQ1RJT04uVFJBSU5fQ09VUExFKSB7XG4gICAgICAgICAgICAgICAvLyBIYW5kbGUgY291cGxpbmcgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgVHJhaW4uaGFuZGxlQ291cGxpbmdDbGljayhtYS5jb250YWluZXIuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hLmNvbnRhaW5lcj8ubmFtZSA9PSBcInRyYWluXCIpIHtcbiAgICAgICAgICAgICAgIHNlbGVjdE9iamVjdChtYS5jb250YWluZXIuZGF0YSwgZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hLmNvbnRhaW5lcj8ubmFtZSA9PSBcInRyYWNrXCIpIHtcbiAgICAgICAgICAgICAgIHNlbGVjdE9iamVjdChtYS5jb250YWluZXIuZGF0YSwgZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hLmNvbnRhaW5lcj8ubmFtZSA9PSBcIkdlbmVyaWNPYmplY3RcIikge1xuICAgICAgICAgICAgICAgc2VsZWN0T2JqZWN0KG1hLmNvbnRhaW5lci5kYXRhLCBlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWEuY29udGFpbmVyPy5uYW1lID09IFwic3dpdGNoXCIpIHtcbiAgICAgICAgICAgICAgIFN3aXRjaC5zd2l0Y2hfQV9Td2l0Y2gobWEuY29udGFpbmVyLmRhdGEsIGxvY2FsX3BvaW50LngpO1xuICAgICAgICAgICAgICAgYXBwLnJlbmRlcmVyLnJlbmRlclN3aXRjaFVJKG1hLmNvbnRhaW5lci5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBzZWxlY3RPYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWEuYWN0aW9uID09PSBNT1VTRV9ET1dOX0FDVElPTi5TQ1JPTEwpIHtcbiAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgfVxuICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHVpLnNob3dFcnJvclRvYXN0KGVycm9yKTtcbiAgIH0gZmluYWxseSB7XG4gICAgICBtYSA9IG51bGw7XG4gICAgICBhcHAuY29udGFpbmVycy5vdmVybGF5LnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICBhcHAuc3RhZ2UudXBkYXRlKCk7XG4gICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludChwb2ludCwgZGlzcGxheU9iamVjdCwgbGFiZWwgPSBcIlwiLCBjb2xvciA9IFwiIzAwMFwiLCBzaXplID0gMC41KSB7XG4gICBjb25zdCBzID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICBzLmdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDEpLmJlZ2luU3Ryb2tlKGNvbG9yKS5iZWdpbkZpbGwoY29sb3IpLmRyYXdDaXJjbGUoMCwgMCwgc2l6ZSk7XG4gICBzLnggPSBwb2ludC54O1xuICAgcy55ID0gcG9pbnQueTtcblxuICAgYXBwLmNvbnRhaW5lcnMuZGVidWcuYWRkQ2hpbGQocyk7XG5cbiAgIGlmIChsYWJlbCkge1xuICAgICAgY29uc3QgdGV4dCA9IG5ldyBjcmVhdGVqcy5UZXh0KGxhYmVsLCBcIkl0YWxpYyA2cHggQXJpYWxcIiwgY29sb3IpO1xuICAgICAgdGV4dC54ID0gcy54O1xuICAgICAgdGV4dC55ID0gcy55IC0gNTtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgICBhcHAuY29udGFpbmVycy5kZWJ1Zy5hZGRDaGlsZCh0ZXh0KTtcbiAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/start.js\n\n}");

/***/ }),

/***/ "./www/code/storage.js":
/*!*****************************!*\
  !*** ./www/code/storage.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STORAGE: () => (/* binding */ STORAGE)\n/* harmony export */ });\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./config.js */ \"./www/code/config.js\");\n/* harmony import */ var _application_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./application.js */ \"./www/code/application.js\");\n/* harmony import */ var _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./trackRendering_textured.js */ \"./www/code/trackRendering_textured.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\n\n\n\nconst STORAGE = {\n   MIN_STORAGE_VERSION: 0.5,\n   STORAGE_IDENT: \"bahnhof_last1\",\n   \n\n   getClassMap() {\n      return {\n         Track: _track_js__WEBPACK_IMPORTED_MODULE_0__.Track,\n         Switch: _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch,\n         Signal: _signal_js__WEBPACK_IMPORTED_MODULE_2__.Signal,\n         Train: _train_js__WEBPACK_IMPORTED_MODULE_3__.Train,\n         GenericObject: _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject,\n      };\n   },\n\n   receiver(key, value) {\n      if (value?._class && STORAGE.getClassMap()[value._class]) {\n         const MyClass = STORAGE.getClassMap()[value._class];\n         const instance = MyClass.FromObject(value);\n         if (instance == null) _ui_js__WEBPACK_IMPORTED_MODULE_6__.ui.showErrorToast(new Error(\"error loading \" + key));\n         return instance;\n      }\n      return value;\n   },\n\n   replacer(key, value) {\n      return typeof value?.stringify === \"function\" ? value.stringify() : value;\n   },\n\n   getSaveString() {\n      return (\n         _config_js__WEBPACK_IMPORTED_MODULE_7__.CONFIG.VERSION +\n         \";\" +\n         JSON.stringify(\n            {\n               tracks: _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks,\n               trains: _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains,\n               switches: _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches,\n               objects: _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects,\n               settings: {\n                  zoom: _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().stage.scale,\n                  scrollX: _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().stage.x,\n                  scrollY: _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().stage.y,\n                  renderer: _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().renderer instanceof _trackRendering_textured_js__WEBPACK_IMPORTED_MODULE_9__.trackRendering_textured ? \"textured\" : \"basic\",\n               },\n            },\n            STORAGE.replacer\n         )\n      );\n   },\n\n   restoreLastUndoStep() {\n      if (_application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().undoHistory.length <= 1) return;\n      _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().undoHistory.pop();\n      const last = _utils_js__WEBPACK_IMPORTED_MODULE_5__.ArrayUtils.last(_application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().undoHistory);\n      if (last) {\n         STORAGE.loadFromJson(last);\n      } else _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks = [];\n\n      _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().updateUndoButtonState();\n   },\n\n   linkObjects() {\n      // Link switches to tracks\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.forEach((s) => {\n         if (s.tracks_id) {\n            s.tracks = s.tracks_id.map((id) => (id ? _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.find((t) => t.id === id) : null));\n         }\n         s.branch = s.branch_id ? _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.find((t) => t.id === s.branch_id) : null;\n         s.from = s.from_id ? _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.find((t) => t.id === s.from_id) : null;\n         s.calculateParameters();\n         delete s.tracks_id;\n         delete s.branch_id;\n         delete s.from_id;\n      });\n\n      // Link tracks to switches/other tracks\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.forEach((t) => {\n         t.switches = t.switches_data.map((sd) => {\n            if (!sd) return null;\n            if (sd.type === \"Switch\") {\n               return _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.find((s) => s.id === sd.id);\n            } else if (sd.type === \"Track\") {\n               return _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.find((tr) => tr.id === sd.id);\n            }\n            return null;\n         });\n         delete t.switches_data;\n      });\n   },\n\n   loadFromJson(json) {\n      RENDERING.clear();\n      let loaded = JSON.parse(json, STORAGE.receiver);\n      if (loaded.settings) {\n         _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().stage.x = loaded.settings.scrollX;\n         _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().stage.y = loaded.settings.scrollY;\n         _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().stage.scale = loaded.settings.zoom;\n         if (loaded.settings.renderer) {\n            _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().selectRenderer(loaded.settings.renderer === \"textured\");\n         }\n      }\n      if (loaded.objects) _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects = loaded.objects;\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks = loaded.tracks ? _utils_js__WEBPACK_IMPORTED_MODULE_5__.ArrayUtils.cleanUp(loaded.tracks) : []; //when something went wront while loading track, we filter all nulls\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches = loaded.switches ? _utils_js__WEBPACK_IMPORTED_MODULE_5__.ArrayUtils.cleanUp(loaded.switches) : []; //when something went wront while loading switch, we filter all nulls\n\n      // Reset counters\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.counter = _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.length ? Math.max(..._track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.map((t) => t.id)) + 1 : 0;\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.counter = _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.length ? Math.max(..._switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.map((s) => s.id)) + 1 : 0;\n\n      STORAGE.linkObjects();\n\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.createRailNetwork();\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains = loaded.trains ? _utils_js__WEBPACK_IMPORTED_MODULE_5__.ArrayUtils.cleanUp(loaded.trains) : []; ////when something went wront while loading trains, we filter all nulls\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains.forEach((t) => t.restore());\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains.forEach((t) => {\n         delete t.trainCoupledFrontId;\n         delete t.trainCoupledBackId;\n      });\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains = _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains.filter((t) => t.track != null);\n   },\n\n   saveUndoHistory() {\n      _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().undoHistory.push(JSON.stringify({ tracks: _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks, objects: _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects }, STORAGE.replacer));\n      if (_application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().undoHistory.length > _config_js__WEBPACK_IMPORTED_MODULE_7__.CONFIG.MOST_UNDO) _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().undoHistory.shift();\n\n      _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().updateUndoButtonState();\n   },\n\n   save() {\n      localStorage.setItem(STORAGE.STORAGE_IDENT, STORAGE.getSaveString());\n   },\n\n   loadRecent() {\n      try {\n         const x = localStorage.getItem(STORAGE.STORAGE_IDENT);\n         if (x != null) {\n            const indexOfFirst = x.indexOf(\";\");\n            if (indexOfFirst > -1) {\n               const loaded_version = parseFloat(x.substring(0, indexOfFirst));\n               if (loaded_version >= STORAGE.MIN_STORAGE_VERSION) STORAGE.loadFromJson(x.slice(indexOfFirst + 1));\n               else console.error(`stored version ${loaded_version} to old`);\n            } else throw new Error(\"Version Tag is missing\");\n            STORAGE.saveUndoHistory();\n         }\n      } catch (error) {\n         _ui_js__WEBPACK_IMPORTED_MODULE_6__.ui.showErrorToast(error);\n      }\n      _application_js__WEBPACK_IMPORTED_MODULE_8__.Application.getInstance().updateUndoButtonState();\n   },\n\n   loadPrebuildbyName(name) {\n      return new Promise((resolve, reject) => {\n         let xmlhttp = new XMLHttpRequest();\n         xmlhttp.onreadystatechange = function () {\n            if (this.readyState == 4 && this.status == 200) {\n               let i;\n               let xmlDoc = this.responseXML;\n\n               let x = xmlDoc.getElementsByTagName(\"setup\");\n               for (i = 0; i < x.length; i++) {\n                  if (x[i].getElementsByTagName(\"title\")[0].textContent == name) {\n                     STORAGE.loadFromJson(x[i].getElementsByTagName(\"json\")[0].childNodes[0].wholeText.trim());\n                     resolve();\n                  }\n               }\n            }\n         };\n         xmlhttp.open(\"GET\", \"prebuilds.xml\" + \"?\" + Math.floor(Math.random() * 100), true);\n         xmlhttp.send();\n      });\n   },\n};\n\n //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUk7QUFDSjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3N0b3JhZ2UuanM/ZGI4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLy8gRVM2IE1vZHVsZSBpbXBvcnRzXG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vdHJhY2suanMnO1xuaW1wb3J0IHsgU3dpdGNoIH0gZnJvbSAnLi9zd2l0Y2guanMnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnLi9zaWduYWwuanMnO1xuaW1wb3J0IHsgVHJhaW4gfSBmcm9tICcuL3RyYWluLmpzJztcbmltcG9ydCB7IEdlbmVyaWNPYmplY3QgfSBmcm9tICcuL2dlbmVyaWNfb2JqZWN0LmpzJztcbmltcG9ydCB7IEFycmF5VXRpbHMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHVpIH0gZnJvbSAnLi91aS5qcyc7XG5pbXBvcnQgeyBDT05GSUcgfSBmcm9tICcuL2NvbmZpZy5qcyc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvbiB9IGZyb20gJy4vYXBwbGljYXRpb24uanMnO1xuaW1wb3J0IHsgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQgfSBmcm9tICcuL3RyYWNrUmVuZGVyaW5nX3RleHR1cmVkLmpzJztcblxuZXhwb3J0IGNvbnN0IFNUT1JBR0UgPSB7XG4gICBNSU5fU1RPUkFHRV9WRVJTSU9OOiAwLjUsXG4gICBTVE9SQUdFX0lERU5UOiBcImJhaG5ob2ZfbGFzdDFcIixcbiAgIFxuXG4gICBnZXRDbGFzc01hcCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICBUcmFjazogVHJhY2ssXG4gICAgICAgICBTd2l0Y2g6IFN3aXRjaCxcbiAgICAgICAgIFNpZ25hbDogU2lnbmFsLFxuICAgICAgICAgVHJhaW46IFRyYWluLFxuICAgICAgICAgR2VuZXJpY09iamVjdDogR2VuZXJpY09iamVjdCxcbiAgICAgIH07XG4gICB9LFxuXG4gICByZWNlaXZlcihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWU/Ll9jbGFzcyAmJiBTVE9SQUdFLmdldENsYXNzTWFwKClbdmFsdWUuX2NsYXNzXSkge1xuICAgICAgICAgY29uc3QgTXlDbGFzcyA9IFNUT1JBR0UuZ2V0Q2xhc3NNYXAoKVt2YWx1ZS5fY2xhc3NdO1xuICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBNeUNsYXNzLkZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgaWYgKGluc3RhbmNlID09IG51bGwpIHVpLnNob3dFcnJvclRvYXN0KG5ldyBFcnJvcihcImVycm9yIGxvYWRpbmcgXCIgKyBrZXkpKTtcbiAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgIH0sXG5cbiAgIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWU/LnN0cmluZ2lmeSA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUuc3RyaW5naWZ5KCkgOiB2YWx1ZTtcbiAgIH0sXG5cbiAgIGdldFNhdmVTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAgQ09ORklHLlZFUlNJT04gK1xuICAgICAgICAgXCI7XCIgK1xuICAgICAgICAgSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICB0cmFja3M6IFRyYWNrLmFsbFRyYWNrcyxcbiAgICAgICAgICAgICAgIHRyYWluczogVHJhaW4uYWxsVHJhaW5zLFxuICAgICAgICAgICAgICAgc3dpdGNoZXM6IFN3aXRjaC5hbGxTd2l0Y2hlcyxcbiAgICAgICAgICAgICAgIG9iamVjdHM6IEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMsXG4gICAgICAgICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgICAgICAgem9vbTogQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5zdGFnZS5zY2FsZSxcbiAgICAgICAgICAgICAgICAgIHNjcm9sbFg6IEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuc3RhZ2UueCxcbiAgICAgICAgICAgICAgICAgIHNjcm9sbFk6IEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuc3RhZ2UueSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnJlbmRlcmVyIGluc3RhbmNlb2YgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQgPyBcInRleHR1cmVkXCIgOiBcImJhc2ljXCIsXG4gICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNUT1JBR0UucmVwbGFjZXJcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9LFxuXG4gICByZXN0b3JlTGFzdFVuZG9TdGVwKCkge1xuICAgICAgaWYgKEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkudW5kb0hpc3RvcnkubGVuZ3RoIDw9IDEpIHJldHVybjtcbiAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkudW5kb0hpc3RvcnkucG9wKCk7XG4gICAgICBjb25zdCBsYXN0ID0gQXJyYXlVdGlscy5sYXN0KEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkudW5kb0hpc3RvcnkpO1xuICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgIFNUT1JBR0UubG9hZEZyb21Kc29uKGxhc3QpO1xuICAgICAgfSBlbHNlIFRyYWNrLmFsbFRyYWNrcyA9IFtdO1xuXG4gICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnVwZGF0ZVVuZG9CdXR0b25TdGF0ZSgpO1xuICAgfSxcblxuICAgbGlua09iamVjdHMoKSB7XG4gICAgICAvLyBMaW5rIHN3aXRjaGVzIHRvIHRyYWNrc1xuICAgICAgU3dpdGNoLmFsbFN3aXRjaGVzLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgIGlmIChzLnRyYWNrc19pZCkge1xuICAgICAgICAgICAgcy50cmFja3MgPSBzLnRyYWNrc19pZC5tYXAoKGlkKSA9PiAoaWQgPyBUcmFjay5hbGxUcmFja3MuZmluZCgodCkgPT4gdC5pZCA9PT0gaWQpIDogbnVsbCkpO1xuICAgICAgICAgfVxuICAgICAgICAgcy5icmFuY2ggPSBzLmJyYW5jaF9pZCA/IFRyYWNrLmFsbFRyYWNrcy5maW5kKCh0KSA9PiB0LmlkID09PSBzLmJyYW5jaF9pZCkgOiBudWxsO1xuICAgICAgICAgcy5mcm9tID0gcy5mcm9tX2lkID8gVHJhY2suYWxsVHJhY2tzLmZpbmQoKHQpID0+IHQuaWQgPT09IHMuZnJvbV9pZCkgOiBudWxsO1xuICAgICAgICAgcy5jYWxjdWxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgICAgICBkZWxldGUgcy50cmFja3NfaWQ7XG4gICAgICAgICBkZWxldGUgcy5icmFuY2hfaWQ7XG4gICAgICAgICBkZWxldGUgcy5mcm9tX2lkO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIExpbmsgdHJhY2tzIHRvIHN3aXRjaGVzL290aGVyIHRyYWNrc1xuICAgICAgVHJhY2suYWxsVHJhY2tzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgIHQuc3dpdGNoZXMgPSB0LnN3aXRjaGVzX2RhdGEubWFwKChzZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoc2QudHlwZSA9PT0gXCJTd2l0Y2hcIikge1xuICAgICAgICAgICAgICAgcmV0dXJuIFN3aXRjaC5hbGxTd2l0Y2hlcy5maW5kKChzKSA9PiBzLmlkID09PSBzZC5pZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNkLnR5cGUgPT09IFwiVHJhY2tcIikge1xuICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNrLmFsbFRyYWNrcy5maW5kKCh0cikgPT4gdHIuaWQgPT09IHNkLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgfSk7XG4gICAgICAgICBkZWxldGUgdC5zd2l0Y2hlc19kYXRhO1xuICAgICAgfSk7XG4gICB9LFxuXG4gICBsb2FkRnJvbUpzb24oanNvbikge1xuICAgICAgUkVOREVSSU5HLmNsZWFyKCk7XG4gICAgICBsZXQgbG9hZGVkID0gSlNPTi5wYXJzZShqc29uLCBTVE9SQUdFLnJlY2VpdmVyKTtcbiAgICAgIGlmIChsb2FkZWQuc2V0dGluZ3MpIHtcbiAgICAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuc3RhZ2UueCA9IGxvYWRlZC5zZXR0aW5ncy5zY3JvbGxYO1xuICAgICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5zdGFnZS55ID0gbG9hZGVkLnNldHRpbmdzLnNjcm9sbFk7XG4gICAgICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnN0YWdlLnNjYWxlID0gbG9hZGVkLnNldHRpbmdzLnpvb207XG4gICAgICAgICBpZiAobG9hZGVkLnNldHRpbmdzLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnNlbGVjdFJlbmRlcmVyKGxvYWRlZC5zZXR0aW5ncy5yZW5kZXJlciA9PT0gXCJ0ZXh0dXJlZFwiKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb2FkZWQub2JqZWN0cykgR2VuZXJpY09iamVjdC5hbGxfb2JqZWN0cyA9IGxvYWRlZC5vYmplY3RzO1xuICAgICAgVHJhY2suYWxsVHJhY2tzID0gbG9hZGVkLnRyYWNrcyA/IEFycmF5VXRpbHMuY2xlYW5VcChsb2FkZWQudHJhY2tzKSA6IFtdOyAvL3doZW4gc29tZXRoaW5nIHdlbnQgd3JvbnQgd2hpbGUgbG9hZGluZyB0cmFjaywgd2UgZmlsdGVyIGFsbCBudWxsc1xuICAgICAgU3dpdGNoLmFsbFN3aXRjaGVzID0gbG9hZGVkLnN3aXRjaGVzID8gQXJyYXlVdGlscy5jbGVhblVwKGxvYWRlZC5zd2l0Y2hlcykgOiBbXTsgLy93aGVuIHNvbWV0aGluZyB3ZW50IHdyb250IHdoaWxlIGxvYWRpbmcgc3dpdGNoLCB3ZSBmaWx0ZXIgYWxsIG51bGxzXG5cbiAgICAgIC8vIFJlc2V0IGNvdW50ZXJzXG4gICAgICBUcmFjay5jb3VudGVyID0gVHJhY2suYWxsVHJhY2tzLmxlbmd0aCA/IE1hdGgubWF4KC4uLlRyYWNrLmFsbFRyYWNrcy5tYXAoKHQpID0+IHQuaWQpKSArIDEgOiAwO1xuICAgICAgU3dpdGNoLmNvdW50ZXIgPSBTd2l0Y2guYWxsU3dpdGNoZXMubGVuZ3RoID8gTWF0aC5tYXgoLi4uU3dpdGNoLmFsbFN3aXRjaGVzLm1hcCgocykgPT4gcy5pZCkpICsgMSA6IDA7XG5cbiAgICAgIFNUT1JBR0UubGlua09iamVjdHMoKTtcblxuICAgICAgVHJhY2suY3JlYXRlUmFpbE5ldHdvcmsoKTtcbiAgICAgIFRyYWluLmFsbFRyYWlucyA9IGxvYWRlZC50cmFpbnMgPyBBcnJheVV0aWxzLmNsZWFuVXAobG9hZGVkLnRyYWlucykgOiBbXTsgLy8vL3doZW4gc29tZXRoaW5nIHdlbnQgd3JvbnQgd2hpbGUgbG9hZGluZyB0cmFpbnMsIHdlIGZpbHRlciBhbGwgbnVsbHNcbiAgICAgIFRyYWluLmFsbFRyYWlucy5mb3JFYWNoKCh0KSA9PiB0LnJlc3RvcmUoKSk7XG4gICAgICBUcmFpbi5hbGxUcmFpbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgZGVsZXRlIHQudHJhaW5Db3VwbGVkRnJvbnRJZDtcbiAgICAgICAgIGRlbGV0ZSB0LnRyYWluQ291cGxlZEJhY2tJZDtcbiAgICAgIH0pO1xuICAgICAgVHJhaW4uYWxsVHJhaW5zID0gVHJhaW4uYWxsVHJhaW5zLmZpbHRlcigodCkgPT4gdC50cmFjayAhPSBudWxsKTtcbiAgIH0sXG5cbiAgIHNhdmVVbmRvSGlzdG9yeSgpIHtcbiAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkudW5kb0hpc3RvcnkucHVzaChKU09OLnN0cmluZ2lmeSh7IHRyYWNrczogVHJhY2suYWxsVHJhY2tzLCBvYmplY3RzOiBHZW5lcmljT2JqZWN0LmFsbF9vYmplY3RzIH0sIFNUT1JBR0UucmVwbGFjZXIpKTtcbiAgICAgIGlmIChBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnVuZG9IaXN0b3J5Lmxlbmd0aCA+IENPTkZJRy5NT1NUX1VORE8pIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkudW5kb0hpc3Rvcnkuc2hpZnQoKTtcblxuICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS51cGRhdGVVbmRvQnV0dG9uU3RhdGUoKTtcbiAgIH0sXG5cbiAgIHNhdmUoKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFLlNUT1JBR0VfSURFTlQsIFNUT1JBR0UuZ2V0U2F2ZVN0cmluZygpKTtcbiAgIH0sXG5cbiAgIGxvYWRSZWNlbnQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgY29uc3QgeCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0UuU1RPUkFHRV9JREVOVCk7XG4gICAgICAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleE9mRmlyc3QgPSB4LmluZGV4T2YoXCI7XCIpO1xuICAgICAgICAgICAgaWYgKGluZGV4T2ZGaXJzdCA+IC0xKSB7XG4gICAgICAgICAgICAgICBjb25zdCBsb2FkZWRfdmVyc2lvbiA9IHBhcnNlRmxvYXQoeC5zdWJzdHJpbmcoMCwgaW5kZXhPZkZpcnN0KSk7XG4gICAgICAgICAgICAgICBpZiAobG9hZGVkX3ZlcnNpb24gPj0gU1RPUkFHRS5NSU5fU1RPUkFHRV9WRVJTSU9OKSBTVE9SQUdFLmxvYWRGcm9tSnNvbih4LnNsaWNlKGluZGV4T2ZGaXJzdCArIDEpKTtcbiAgICAgICAgICAgICAgIGVsc2UgY29uc29sZS5lcnJvcihgc3RvcmVkIHZlcnNpb24gJHtsb2FkZWRfdmVyc2lvbn0gdG8gb2xkYCk7XG4gICAgICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBUYWcgaXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZVVuZG9IaXN0b3J5KCk7XG4gICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgdWkuc2hvd0Vycm9yVG9hc3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS51cGRhdGVVbmRvQnV0dG9uU3RhdGUoKTtcbiAgIH0sXG5cbiAgIGxvYWRQcmVidWlsZGJ5TmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgbGV0IHhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgIHhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgICBsZXQgeG1sRG9jID0gdGhpcy5yZXNwb25zZVhNTDtcblxuICAgICAgICAgICAgICAgbGV0IHggPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzZXR1cFwiKTtcbiAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoeFtpXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRpdGxlXCIpWzBdLnRleHRDb250ZW50ID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgIFNUT1JBR0UubG9hZEZyb21Kc29uKHhbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJqc29uXCIpWzBdLmNoaWxkTm9kZXNbMF0ud2hvbGVUZXh0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICB9O1xuICAgICAgICAgeG1saHR0cC5vcGVuKFwiR0VUXCIsIFwicHJlYnVpbGRzLnhtbFwiICsgXCI/XCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApLCB0cnVlKTtcbiAgICAgICAgIHhtbGh0dHAuc2VuZCgpO1xuICAgICAgfSk7XG4gICB9LFxufTtcblxuICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/storage.js\n\n}");

/***/ }),

/***/ "./www/code/switch.js":
/*!****************************!*\
  !*** ./www/code/switch.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Switch: () => (/* binding */ Switch)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config.js */ \"./www/code/config.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\nclass Switch {\n   static allSwitches = [];\n   static counter = 0;\n\n   static _getID() {\n      return Switch.counter++;\n   }\n\n   static SWITCH_TYPE = {\n      NONE: 0,\n      TO_RIGHT: 1, //45°\n      FROM_RIGHT: 2, //135°\n      FROM_LEFT: 3, //225°\n      TO_LEFT: 4, //315°\n      DKW: 9,\n      CROSSING: 10,\n   };\n\n   //sw=switch location\n   //rad= angle of track_1 in rad\n   //c= end of the track_2 to find angle\n   static findAngle(sw, c, rad = 0) {\n      let atan = Math.atan2(c.y - sw.y, c.x - sw.x) - rad;\n      if (atan < 0) atan += 2 * Math.PI; //macht aus neg Winkeln durch addition von 360° positive winkel\n\n      let val = (atan * 180) / Math.PI;\n      return val;\n   }\n\n   /**\n    * Validates if a switch at a given location is valid based on the provided tracks.\n    *\n    * @param {Object} location - The location to check for a valid switch.\n    * @param {Array} tracks - An array of track objects, each containing nodes with start and end points.\n    * @returns {boolean} - Returns true if the switch is valid, otherwise false.\n    */\n   static isValidSwitch(location, tracks) {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.between(tracks.length, 3, 4)) {\n         console.log(`too many nodes ${tracks.length}`);\n         return false;\n      }\n      const slopes = tracks.map((t) => t.slope);\n      const equal_slopes = _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.countNonUnique(slopes);\n      if (!((tracks.length == 3 && equal_slopes == 1) || (tracks.length == 4 && equal_slopes == 2))) {\n         console.log(`2 tracks with the same slope are necessary`);\n         return false;\n      }\n\n      for (let i = 1; i < slopes.length; i++) {\n         if (Math.abs(slopes[i - 1] - slopes[i]) > 1) {\n            console.log(`slope between 2 tracks must be lower than 45°`);\n            return false;\n         }\n      }\n      return true;\n   }\n   /**\n    * Creates a switch object based on the provided location and tracks.\n    *\n    * @param {Object} location - The location of the switch.\n    * @param {Array} tracks - An array of track objects.\n    * @returns {Object} The created switch object.\n    * @throws {Error} If the tracks do not have 2 different angles.\n    */\n   static createSwitch(location, tracks) {\n      const sw = new Switch(location);\n\n      const left_tracks = tracks.filter((t) => t.end.equals(location)).sort((a, b) => b.slope - a.slope);\n      const right_tracks = tracks.filter((t) => t.start.equals(location)).sort((a, b) => b.slope - a.slope);\n      let rad = 0;\n\n      if (left_tracks.length == 1) {\n         sw.track1 = left_tracks[0];\n         rad = sw.track1.rad;\n         sw.track2 = right_tracks.find((t) => t.rad == rad);\n      } else {\n         sw.track1 = right_tracks[0];\n         rad = sw.track1.rad;\n         sw.track2 = left_tracks.find((t) => t.rad == rad);\n      }\n\n      if (sw.track2 == null) throw new Error(\"couldnt find 2 tracks with the same slope\");\n\n      //find the other two tracks and sort them by their start point\n      [sw.track3, sw.track4] = tracks\n         .filter((t) => t != sw.track1 && t != sw.track2)\n         .sort((a, b) => a.start.x - b.start.x);\n\n      // Calculate direction vectors for each track branch\n      sw.calculateParameters();\n\n      //TODO calculate connection points and shorten the tracks\n\n      sw.branch = sw.track2;\n      sw.from = sw.track1;\n\n      return sw;\n   }\n\n   /**\n    * Checks for and creates/updates a switch at a specific point in the track network.\n    * This function encapsulates the logic for determining if a point is a simple connection,\n    * a valid switch, or an invalid connection, and performs the necessary updates.\n    * @param {Point} point - The connection point to check.\n    * @param {Switch} [existingSwitch=null] - An optional, pre-existing switch to re-evaluate.\n    */\n   static updateSwitchAtPoint(point, existingSwitch = null) {\n      const tracksAtPoint = _track_js__WEBPACK_IMPORTED_MODULE_1__.Track.allTracks.filter(\n         (t) => t.start.equals(point) || t.end.equals(point)\n      );\n\n      if (!existingSwitch) {\n         existingSwitch = Switch.allSwitches.find(sw => sw.location.equals(point));\n      }else{\n         if(!existingSwitch.location.equals(point)) throw new Error(\"existing switch at wrong point\");\n      }\n\n      if (tracksAtPoint.length === 2) {\n         // Simple connection, not a switch.\n         const track1 = tracksAtPoint[0];\n         const track2 = tracksAtPoint[1];\n\n         if (track1.start.equals(point)) track1.switchAtTheStart = track2;\n         else track1.switchAtTheEnd = track2;\n         \n         if (track2.start.equals(point)) track2.switchAtTheStart = track1;\n         else track2.switchAtTheEnd = track1;\n\n         if (existingSwitch) {\n            Switch.removeSwitch(existingSwitch);\n         }\n      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.between(tracksAtPoint.length, 3, 4)) {\n         // Potential switch.\n         if (Switch.isValidSwitch(point, tracksAtPoint)) {\n            if (existingSwitch) {\n               const existingTracks = [\n                  existingSwitch.track1,\n                  existingSwitch.track2,\n                  existingSwitch.track3,\n                  existingSwitch.track4,\n               ].filter((t) => t);\n               const tracksMatch =\n                  existingTracks.length === tracksAtPoint.length &&\n                  existingTracks.every((existingTrack) =>\n                     tracksAtPoint.some((currentTrack) => currentTrack === existingTrack)\n                  );\n\n               if (!tracksMatch) {\n                  Switch.removeSwitch(existingSwitch);\n                  const sw = Switch.createSwitch(point, tracksAtPoint);\n                  [sw.track1, sw.track2, sw.track3, sw.track4].forEach((track) => track && track.addSwitch(sw));\n                  Switch.allSwitches.push(sw);\n               }\n            } else {\n               const sw = Switch.createSwitch(point, tracksAtPoint);\n               [sw.track1, sw.track2, sw.track3, sw.track4].forEach((track) => track && track.addSwitch(sw));\n               Switch.allSwitches.push(sw);\n            }\n         } else if (existingSwitch) {\n            Switch.removeSwitch(existingSwitch);\n         }\n      } else if (existingSwitch) {\n         // Any other configuration is not a switch, so remove if one exists.\n         Switch.removeSwitch(existingSwitch);\n      }\n   }\n\n   /**\n    * Removes a switch and cleans up all references to it\n    * @param {Switch} switchToRemove - The switch to remove\n    */\n   static removeSwitch(switchToRemove) {\n      // Remove switch from all tracks that reference it\n      [switchToRemove.track1, switchToRemove.track2, switchToRemove.track3, switchToRemove.track4].forEach(\n         (track) => {\n            if (track) {\n               track.switches = track.switches.map((sw) => (sw === switchToRemove ? null : sw));\n            }\n         }\n      );\n\n      // Remove switch from the global switches array\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.remove(Switch.allSwitches, switchToRemove);\n   }\n\n   static switch_A_Switch(sw, mouseX) {\n      if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.is(sw.type, Switch.SWITCH_TYPE.DKW)) {\n         sw.branch = (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.swap)(sw.branch, sw.track2, sw.track3);\n      } else {\n         if (mouseX < sw.location.x) {\n            sw.branch = (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.swap)(sw.branch, sw.track2, sw.track3);\n         } else {\n            sw.from = (0,_tools_js__WEBPACK_IMPORTED_MODULE_2__.swap)(sw.from, sw.track1, sw.track4);\n         }\n      }\n   }\n\n   constructor(location) {\n      this.id = Switch._getID();\n      this.location = location;\n      this.type = Switch.SWITCH_TYPE.NONE;\n\n      this.size = _config_js__WEBPACK_IMPORTED_MODULE_3__.CONFIG.GRID_SIZE;\n\n      this.tracks = new Array(4).fill(null);\n\n      this.branch = null;\n      this.from = null;\n\n      // Direction information for rendering - stores the direction vector for each track\n      this.track_directions = new Array(4);\n   }\n\n   get track1() {\n      return this.tracks[0];\n   }\n   set track1(track) {\n      this.tracks[0] = track;\n   }\n   get track2() {\n      return this.tracks[1];\n   }\n   set track2(track) {\n      this.tracks[1] = track;\n   }\n   get track3() {\n      return this.tracks[2];\n   }\n   set track3(track) {\n      this.tracks[2] = track;\n   }\n   get track4() {\n      return this.tracks[3];\n   }\n   set track4(track) {\n      this.tracks[3] = track;\n   }\n\n   /**\n    * Calculates the direction vectors for each track branch\n    * This eliminates the need for runtime direction calculations during rendering\n    */\n   calculateParameters() {\n      // For each track, determine if it connects to the switch at its start or end\n      // and use the appropriate direction (unit vector or its opposite)\n\n      this.track_directions = this.tracks.map((track) =>\n         track ? (track.end.equals(this.location) ? _tools_js__WEBPACK_IMPORTED_MODULE_2__.V2.fromV2(track.unit).invert() : _tools_js__WEBPACK_IMPORTED_MODULE_2__.V2.fromV2(track.unit)) : null\n      );\n\n      if (this.track4) this.type = Switch.SWITCH_TYPE.DKW;\n      else {\n         const angle = Switch.findAngle(this.location, this.track3.end.equals(this.location) ? this.track3.start : this.track3.end, this.track1.rad);\n         this.type = Math.ceil((angle % 360) / 90);\n      }\n\n   }\n\n   /**\n    * Replaces all references to an old track with a new track within this switch.\n    * @param {Track} oldTrack - The track to be replaced.\n    * @param {Track} newTrack - The new track to reference.\n    */\n   replaceTrackReference(oldTrack, newTrack) {\n      if (this.track1 === oldTrack) this.track1 = newTrack;\n      if (this.track2 === oldTrack) this.track2 = newTrack;\n      if (this.track3 === oldTrack) this.track3 = newTrack;\n      if (this.track4 === oldTrack) this.track4 = newTrack;\n\n      if (this.branch === oldTrack) this.branch = newTrack;\n      if (this.from === oldTrack) this.from = newTrack;\n\n      // After updating track references, it's crucial to recalculate the directions\n      // for rendering and other logic.\n      this.calculateParameters();\n   }\n\n   getBranchEndPoint(branch, size = this.size) {\n      return this.location.add(this.track_directions[branch].multiply(size));\n   }\n\n   stringify() {\n      return {\n         _class: \"Switch\",\n         id: this.id,\n         location: this.location,\n         tracks: this.tracks.map((t) => t?.id),\n         branch: this.branch?.id,\n         from: this.from?.id,\n      };\n   }\n\n   static FromObject(o) {\n      const s = new Switch(_tools_js__WEBPACK_IMPORTED_MODULE_2__.Point.fromPoint(o.location));\n      s.id = o.id;\n\n      // Store IDs for later linking\n      s.tracks_id = o.tracks;\n      s.branch_id = o.branch;\n      s.from_id = o.from;\n\n      return s;\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3N3aXRjaC5qcz82YjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IE51bWJlclV0aWxzLCBBcnJheVV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vdHJhY2suanMnO1xuaW1wb3J0IHsgVjIsIFBvaW50LCBnZW9tZXRyeSwgdHlwZSwgc3dhcCB9IGZyb20gJy4vdG9vbHMuanMnO1xuaW1wb3J0IHsgQ09ORklHIH0gZnJvbSAnLi9jb25maWcuanMnO1xuXG5leHBvcnQgY2xhc3MgU3dpdGNoIHtcbiAgIHN0YXRpYyBhbGxTd2l0Y2hlcyA9IFtdO1xuICAgc3RhdGljIGNvdW50ZXIgPSAwO1xuXG4gICBzdGF0aWMgX2dldElEKCkge1xuICAgICAgcmV0dXJuIFN3aXRjaC5jb3VudGVyKys7XG4gICB9XG5cbiAgIHN0YXRpYyBTV0lUQ0hfVFlQRSA9IHtcbiAgICAgIE5PTkU6IDAsXG4gICAgICBUT19SSUdIVDogMSwgLy80NcKwXG4gICAgICBGUk9NX1JJR0hUOiAyLCAvLzEzNcKwXG4gICAgICBGUk9NX0xFRlQ6IDMsIC8vMjI1wrBcbiAgICAgIFRPX0xFRlQ6IDQsIC8vMzE1wrBcbiAgICAgIERLVzogOSxcbiAgICAgIENST1NTSU5HOiAxMCxcbiAgIH07XG5cbiAgIC8vc3c9c3dpdGNoIGxvY2F0aW9uXG4gICAvL3JhZD0gYW5nbGUgb2YgdHJhY2tfMSBpbiByYWRcbiAgIC8vYz0gZW5kIG9mIHRoZSB0cmFja18yIHRvIGZpbmQgYW5nbGVcbiAgIHN0YXRpYyBmaW5kQW5nbGUoc3csIGMsIHJhZCA9IDApIHtcbiAgICAgIGxldCBhdGFuID0gTWF0aC5hdGFuMihjLnkgLSBzdy55LCBjLnggLSBzdy54KSAtIHJhZDtcbiAgICAgIGlmIChhdGFuIDwgMCkgYXRhbiArPSAyICogTWF0aC5QSTsgLy9tYWNodCBhdXMgbmVnIFdpbmtlbG4gZHVyY2ggYWRkaXRpb24gdm9uIDM2MMKwIHBvc2l0aXZlIHdpbmtlbFxuXG4gICAgICBsZXQgdmFsID0gKGF0YW4gKiAxODApIC8gTWF0aC5QSTtcbiAgICAgIHJldHVybiB2YWw7XG4gICB9XG5cbiAgIC8qKlxuICAgICogVmFsaWRhdGVzIGlmIGEgc3dpdGNoIGF0IGEgZ2l2ZW4gbG9jYXRpb24gaXMgdmFsaWQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRyYWNrcy5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gY2hlY2sgZm9yIGEgdmFsaWQgc3dpdGNoLlxuICAgICogQHBhcmFtIHtBcnJheX0gdHJhY2tzIC0gQW4gYXJyYXkgb2YgdHJhY2sgb2JqZWN0cywgZWFjaCBjb250YWluaW5nIG5vZGVzIHdpdGggc3RhcnQgYW5kIGVuZCBwb2ludHMuXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHN3aXRjaCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICovXG4gICBzdGF0aWMgaXNWYWxpZFN3aXRjaChsb2NhdGlvbiwgdHJhY2tzKSB7XG4gICAgICBpZiAoIU51bWJlclV0aWxzLmJldHdlZW4odHJhY2tzLmxlbmd0aCwgMywgNCkpIHtcbiAgICAgICAgIGNvbnNvbGUubG9nKGB0b28gbWFueSBub2RlcyAke3RyYWNrcy5sZW5ndGh9YCk7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzbG9wZXMgPSB0cmFja3MubWFwKCh0KSA9PiB0LnNsb3BlKTtcbiAgICAgIGNvbnN0IGVxdWFsX3Nsb3BlcyA9IEFycmF5VXRpbHMuY291bnROb25VbmlxdWUoc2xvcGVzKTtcbiAgICAgIGlmICghKCh0cmFja3MubGVuZ3RoID09IDMgJiYgZXF1YWxfc2xvcGVzID09IDEpIHx8ICh0cmFja3MubGVuZ3RoID09IDQgJiYgZXF1YWxfc2xvcGVzID09IDIpKSkge1xuICAgICAgICAgY29uc29sZS5sb2coYDIgdHJhY2tzIHdpdGggdGhlIHNhbWUgc2xvcGUgYXJlIG5lY2Vzc2FyeWApO1xuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNsb3Blcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgaWYgKE1hdGguYWJzKHNsb3Blc1tpIC0gMV0gLSBzbG9wZXNbaV0pID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHNsb3BlIGJldHdlZW4gMiB0cmFja3MgbXVzdCBiZSBsb3dlciB0aGFuIDQ1wrBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxuICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgc3dpdGNoIG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb24gYW5kIHRyYWNrcy5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gb2YgdGhlIHN3aXRjaC5cbiAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYWNrcyAtIEFuIGFycmF5IG9mIHRyYWNrIG9iamVjdHMuXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3JlYXRlZCBzd2l0Y2ggb2JqZWN0LlxuICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0cmFja3MgZG8gbm90IGhhdmUgMiBkaWZmZXJlbnQgYW5nbGVzLlxuICAgICovXG4gICBzdGF0aWMgY3JlYXRlU3dpdGNoKGxvY2F0aW9uLCB0cmFja3MpIHtcbiAgICAgIGNvbnN0IHN3ID0gbmV3IFN3aXRjaChsb2NhdGlvbik7XG5cbiAgICAgIGNvbnN0IGxlZnRfdHJhY2tzID0gdHJhY2tzLmZpbHRlcigodCkgPT4gdC5lbmQuZXF1YWxzKGxvY2F0aW9uKSkuc29ydCgoYSwgYikgPT4gYi5zbG9wZSAtIGEuc2xvcGUpO1xuICAgICAgY29uc3QgcmlnaHRfdHJhY2tzID0gdHJhY2tzLmZpbHRlcigodCkgPT4gdC5zdGFydC5lcXVhbHMobG9jYXRpb24pKS5zb3J0KChhLCBiKSA9PiBiLnNsb3BlIC0gYS5zbG9wZSk7XG4gICAgICBsZXQgcmFkID0gMDtcblxuICAgICAgaWYgKGxlZnRfdHJhY2tzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICBzdy50cmFjazEgPSBsZWZ0X3RyYWNrc1swXTtcbiAgICAgICAgIHJhZCA9IHN3LnRyYWNrMS5yYWQ7XG4gICAgICAgICBzdy50cmFjazIgPSByaWdodF90cmFja3MuZmluZCgodCkgPT4gdC5yYWQgPT0gcmFkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBzdy50cmFjazEgPSByaWdodF90cmFja3NbMF07XG4gICAgICAgICByYWQgPSBzdy50cmFjazEucmFkO1xuICAgICAgICAgc3cudHJhY2syID0gbGVmdF90cmFja3MuZmluZCgodCkgPT4gdC5yYWQgPT0gcmFkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN3LnRyYWNrMiA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG50IGZpbmQgMiB0cmFja3Mgd2l0aCB0aGUgc2FtZSBzbG9wZVwiKTtcblxuICAgICAgLy9maW5kIHRoZSBvdGhlciB0d28gdHJhY2tzIGFuZCBzb3J0IHRoZW0gYnkgdGhlaXIgc3RhcnQgcG9pbnRcbiAgICAgIFtzdy50cmFjazMsIHN3LnRyYWNrNF0gPSB0cmFja3NcbiAgICAgICAgIC5maWx0ZXIoKHQpID0+IHQgIT0gc3cudHJhY2sxICYmIHQgIT0gc3cudHJhY2syKVxuICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQueCAtIGIuc3RhcnQueCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBkaXJlY3Rpb24gdmVjdG9ycyBmb3IgZWFjaCB0cmFjayBicmFuY2hcbiAgICAgIHN3LmNhbGN1bGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgLy9UT0RPIGNhbGN1bGF0ZSBjb25uZWN0aW9uIHBvaW50cyBhbmQgc2hvcnRlbiB0aGUgdHJhY2tzXG5cbiAgICAgIHN3LmJyYW5jaCA9IHN3LnRyYWNrMjtcbiAgICAgIHN3LmZyb20gPSBzdy50cmFjazE7XG5cbiAgICAgIHJldHVybiBzdztcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGVja3MgZm9yIGFuZCBjcmVhdGVzL3VwZGF0ZXMgYSBzd2l0Y2ggYXQgYSBzcGVjaWZpYyBwb2ludCBpbiB0aGUgdHJhY2sgbmV0d29yay5cbiAgICAqIFRoaXMgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIHRoZSBsb2dpYyBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBwb2ludCBpcyBhIHNpbXBsZSBjb25uZWN0aW9uLFxuICAgICogYSB2YWxpZCBzd2l0Y2gsIG9yIGFuIGludmFsaWQgY29ubmVjdGlvbiwgYW5kIHBlcmZvcm1zIHRoZSBuZWNlc3NhcnkgdXBkYXRlcy5cbiAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIGNvbm5lY3Rpb24gcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0ge1N3aXRjaH0gW2V4aXN0aW5nU3dpdGNoPW51bGxdIC0gQW4gb3B0aW9uYWwsIHByZS1leGlzdGluZyBzd2l0Y2ggdG8gcmUtZXZhbHVhdGUuXG4gICAgKi9cbiAgIHN0YXRpYyB1cGRhdGVTd2l0Y2hBdFBvaW50KHBvaW50LCBleGlzdGluZ1N3aXRjaCA9IG51bGwpIHtcbiAgICAgIGNvbnN0IHRyYWNrc0F0UG9pbnQgPSBUcmFjay5hbGxUcmFja3MuZmlsdGVyKFxuICAgICAgICAgKHQpID0+IHQuc3RhcnQuZXF1YWxzKHBvaW50KSB8fCB0LmVuZC5lcXVhbHMocG9pbnQpXG4gICAgICApO1xuXG4gICAgICBpZiAoIWV4aXN0aW5nU3dpdGNoKSB7XG4gICAgICAgICBleGlzdGluZ1N3aXRjaCA9IFN3aXRjaC5hbGxTd2l0Y2hlcy5maW5kKHN3ID0+IHN3LmxvY2F0aW9uLmVxdWFscyhwb2ludCkpO1xuICAgICAgfWVsc2V7XG4gICAgICAgICBpZighZXhpc3RpbmdTd2l0Y2gubG9jYXRpb24uZXF1YWxzKHBvaW50KSkgdGhyb3cgbmV3IEVycm9yKFwiZXhpc3Rpbmcgc3dpdGNoIGF0IHdyb25nIHBvaW50XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2tzQXRQb2ludC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgIC8vIFNpbXBsZSBjb25uZWN0aW9uLCBub3QgYSBzd2l0Y2guXG4gICAgICAgICBjb25zdCB0cmFjazEgPSB0cmFja3NBdFBvaW50WzBdO1xuICAgICAgICAgY29uc3QgdHJhY2syID0gdHJhY2tzQXRQb2ludFsxXTtcblxuICAgICAgICAgaWYgKHRyYWNrMS5zdGFydC5lcXVhbHMocG9pbnQpKSB0cmFjazEuc3dpdGNoQXRUaGVTdGFydCA9IHRyYWNrMjtcbiAgICAgICAgIGVsc2UgdHJhY2sxLnN3aXRjaEF0VGhlRW5kID0gdHJhY2syO1xuICAgICAgICAgXG4gICAgICAgICBpZiAodHJhY2syLnN0YXJ0LmVxdWFscyhwb2ludCkpIHRyYWNrMi5zd2l0Y2hBdFRoZVN0YXJ0ID0gdHJhY2sxO1xuICAgICAgICAgZWxzZSB0cmFjazIuc3dpdGNoQXRUaGVFbmQgPSB0cmFjazE7XG5cbiAgICAgICAgIGlmIChleGlzdGluZ1N3aXRjaCkge1xuICAgICAgICAgICAgU3dpdGNoLnJlbW92ZVN3aXRjaChleGlzdGluZ1N3aXRjaCk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKE51bWJlclV0aWxzLmJldHdlZW4odHJhY2tzQXRQb2ludC5sZW5ndGgsIDMsIDQpKSB7XG4gICAgICAgICAvLyBQb3RlbnRpYWwgc3dpdGNoLlxuICAgICAgICAgaWYgKFN3aXRjaC5pc1ZhbGlkU3dpdGNoKHBvaW50LCB0cmFja3NBdFBvaW50KSkge1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3dpdGNoKSB7XG4gICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RyYWNrcyA9IFtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3dpdGNoLnRyYWNrMSxcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3dpdGNoLnRyYWNrMixcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3dpdGNoLnRyYWNrMyxcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3dpdGNoLnRyYWNrNCxcbiAgICAgICAgICAgICAgIF0uZmlsdGVyKCh0KSA9PiB0KTtcbiAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrc01hdGNoID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVHJhY2tzLmxlbmd0aCA9PT0gdHJhY2tzQXRQb2ludC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVHJhY2tzLmV2ZXJ5KChleGlzdGluZ1RyYWNrKSA9PlxuICAgICAgICAgICAgICAgICAgICAgdHJhY2tzQXRQb2ludC5zb21lKChjdXJyZW50VHJhY2spID0+IGN1cnJlbnRUcmFjayA9PT0gZXhpc3RpbmdUcmFjaylcbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgIGlmICghdHJhY2tzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgIFN3aXRjaC5yZW1vdmVTd2l0Y2goZXhpc3RpbmdTd2l0Y2gpO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3cgPSBTd2l0Y2guY3JlYXRlU3dpdGNoKHBvaW50LCB0cmFja3NBdFBvaW50KTtcbiAgICAgICAgICAgICAgICAgIFtzdy50cmFjazEsIHN3LnRyYWNrMiwgc3cudHJhY2szLCBzdy50cmFjazRdLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjayAmJiB0cmFjay5hZGRTd2l0Y2goc3cpKTtcbiAgICAgICAgICAgICAgICAgIFN3aXRjaC5hbGxTd2l0Y2hlcy5wdXNoKHN3KTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBjb25zdCBzdyA9IFN3aXRjaC5jcmVhdGVTd2l0Y2gocG9pbnQsIHRyYWNrc0F0UG9pbnQpO1xuICAgICAgICAgICAgICAgW3N3LnRyYWNrMSwgc3cudHJhY2syLCBzdy50cmFjazMsIHN3LnRyYWNrNF0uZm9yRWFjaCgodHJhY2spID0+IHRyYWNrICYmIHRyYWNrLmFkZFN3aXRjaChzdykpO1xuICAgICAgICAgICAgICAgU3dpdGNoLmFsbFN3aXRjaGVzLnB1c2goc3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1N3aXRjaCkge1xuICAgICAgICAgICAgU3dpdGNoLnJlbW92ZVN3aXRjaChleGlzdGluZ1N3aXRjaCk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nU3dpdGNoKSB7XG4gICAgICAgICAvLyBBbnkgb3RoZXIgY29uZmlndXJhdGlvbiBpcyBub3QgYSBzd2l0Y2gsIHNvIHJlbW92ZSBpZiBvbmUgZXhpc3RzLlxuICAgICAgICAgU3dpdGNoLnJlbW92ZVN3aXRjaChleGlzdGluZ1N3aXRjaCk7XG4gICAgICB9XG4gICB9XG5cbiAgIC8qKlxuICAgICogUmVtb3ZlcyBhIHN3aXRjaCBhbmQgY2xlYW5zIHVwIGFsbCByZWZlcmVuY2VzIHRvIGl0XG4gICAgKiBAcGFyYW0ge1N3aXRjaH0gc3dpdGNoVG9SZW1vdmUgLSBUaGUgc3dpdGNoIHRvIHJlbW92ZVxuICAgICovXG4gICBzdGF0aWMgcmVtb3ZlU3dpdGNoKHN3aXRjaFRvUmVtb3ZlKSB7XG4gICAgICAvLyBSZW1vdmUgc3dpdGNoIGZyb20gYWxsIHRyYWNrcyB0aGF0IHJlZmVyZW5jZSBpdFxuICAgICAgW3N3aXRjaFRvUmVtb3ZlLnRyYWNrMSwgc3dpdGNoVG9SZW1vdmUudHJhY2syLCBzd2l0Y2hUb1JlbW92ZS50cmFjazMsIHN3aXRjaFRvUmVtb3ZlLnRyYWNrNF0uZm9yRWFjaChcbiAgICAgICAgICh0cmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAgICB0cmFjay5zd2l0Y2hlcyA9IHRyYWNrLnN3aXRjaGVzLm1hcCgoc3cpID0+IChzdyA9PT0gc3dpdGNoVG9SZW1vdmUgPyBudWxsIDogc3cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIFJlbW92ZSBzd2l0Y2ggZnJvbSB0aGUgZ2xvYmFsIHN3aXRjaGVzIGFycmF5XG4gICAgICBBcnJheVV0aWxzLnJlbW92ZShTd2l0Y2guYWxsU3dpdGNoZXMsIHN3aXRjaFRvUmVtb3ZlKTtcbiAgIH1cblxuICAgc3RhdGljIHN3aXRjaF9BX1N3aXRjaChzdywgbW91c2VYKSB7XG4gICAgICBpZiAoIU51bWJlclV0aWxzLmlzKHN3LnR5cGUsIFN3aXRjaC5TV0lUQ0hfVFlQRS5ES1cpKSB7XG4gICAgICAgICBzdy5icmFuY2ggPSBzd2FwKHN3LmJyYW5jaCwgc3cudHJhY2syLCBzdy50cmFjazMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIGlmIChtb3VzZVggPCBzdy5sb2NhdGlvbi54KSB7XG4gICAgICAgICAgICBzdy5icmFuY2ggPSBzd2FwKHN3LmJyYW5jaCwgc3cudHJhY2syLCBzdy50cmFjazMpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3LmZyb20gPSBzd2FwKHN3LmZyb20sIHN3LnRyYWNrMSwgc3cudHJhY2s0KTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgY29uc3RydWN0b3IobG9jYXRpb24pIHtcbiAgICAgIHRoaXMuaWQgPSBTd2l0Y2guX2dldElEKCk7XG4gICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICB0aGlzLnR5cGUgPSBTd2l0Y2guU1dJVENIX1RZUEUuTk9ORTtcblxuICAgICAgdGhpcy5zaXplID0gQ09ORklHLkdSSURfU0laRTtcblxuICAgICAgdGhpcy50cmFja3MgPSBuZXcgQXJyYXkoNCkuZmlsbChudWxsKTtcblxuICAgICAgdGhpcy5icmFuY2ggPSBudWxsO1xuICAgICAgdGhpcy5mcm9tID0gbnVsbDtcblxuICAgICAgLy8gRGlyZWN0aW9uIGluZm9ybWF0aW9uIGZvciByZW5kZXJpbmcgLSBzdG9yZXMgdGhlIGRpcmVjdGlvbiB2ZWN0b3IgZm9yIGVhY2ggdHJhY2tcbiAgICAgIHRoaXMudHJhY2tfZGlyZWN0aW9ucyA9IG5ldyBBcnJheSg0KTtcbiAgIH1cblxuICAgZ2V0IHRyYWNrMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc1swXTtcbiAgIH1cbiAgIHNldCB0cmFjazEodHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2tzWzBdID0gdHJhY2s7XG4gICB9XG4gICBnZXQgdHJhY2syKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzWzFdO1xuICAgfVxuICAgc2V0IHRyYWNrMih0cmFjaykge1xuICAgICAgdGhpcy50cmFja3NbMV0gPSB0cmFjaztcbiAgIH1cbiAgIGdldCB0cmFjazMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFja3NbMl07XG4gICB9XG4gICBzZXQgdHJhY2szKHRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrc1syXSA9IHRyYWNrO1xuICAgfVxuICAgZ2V0IHRyYWNrNCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrc1szXTtcbiAgIH1cbiAgIHNldCB0cmFjazQodHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2tzWzNdID0gdHJhY2s7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2FsY3VsYXRlcyB0aGUgZGlyZWN0aW9uIHZlY3RvcnMgZm9yIGVhY2ggdHJhY2sgYnJhbmNoXG4gICAgKiBUaGlzIGVsaW1pbmF0ZXMgdGhlIG5lZWQgZm9yIHJ1bnRpbWUgZGlyZWN0aW9uIGNhbGN1bGF0aW9ucyBkdXJpbmcgcmVuZGVyaW5nXG4gICAgKi9cbiAgIGNhbGN1bGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgICAvLyBGb3IgZWFjaCB0cmFjaywgZGV0ZXJtaW5lIGlmIGl0IGNvbm5lY3RzIHRvIHRoZSBzd2l0Y2ggYXQgaXRzIHN0YXJ0IG9yIGVuZFxuICAgICAgLy8gYW5kIHVzZSB0aGUgYXBwcm9wcmlhdGUgZGlyZWN0aW9uICh1bml0IHZlY3RvciBvciBpdHMgb3Bwb3NpdGUpXG5cbiAgICAgIHRoaXMudHJhY2tfZGlyZWN0aW9ucyA9IHRoaXMudHJhY2tzLm1hcCgodHJhY2spID0+XG4gICAgICAgICB0cmFjayA/ICh0cmFjay5lbmQuZXF1YWxzKHRoaXMubG9jYXRpb24pID8gVjIuZnJvbVYyKHRyYWNrLnVuaXQpLmludmVydCgpIDogVjIuZnJvbVYyKHRyYWNrLnVuaXQpKSA6IG51bGxcbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLnRyYWNrNCkgdGhpcy50eXBlID0gU3dpdGNoLlNXSVRDSF9UWVBFLkRLVztcbiAgICAgIGVsc2Uge1xuICAgICAgICAgY29uc3QgYW5nbGUgPSBTd2l0Y2guZmluZEFuZ2xlKHRoaXMubG9jYXRpb24sIHRoaXMudHJhY2szLmVuZC5lcXVhbHModGhpcy5sb2NhdGlvbikgPyB0aGlzLnRyYWNrMy5zdGFydCA6IHRoaXMudHJhY2szLmVuZCwgdGhpcy50cmFjazEucmFkKTtcbiAgICAgICAgIHRoaXMudHlwZSA9IE1hdGguY2VpbCgoYW5nbGUgJSAzNjApIC8gOTApO1xuICAgICAgfVxuXG4gICB9XG5cbiAgIC8qKlxuICAgICogUmVwbGFjZXMgYWxsIHJlZmVyZW5jZXMgdG8gYW4gb2xkIHRyYWNrIHdpdGggYSBuZXcgdHJhY2sgd2l0aGluIHRoaXMgc3dpdGNoLlxuICAgICogQHBhcmFtIHtUcmFja30gb2xkVHJhY2sgLSBUaGUgdHJhY2sgdG8gYmUgcmVwbGFjZWQuXG4gICAgKiBAcGFyYW0ge1RyYWNrfSBuZXdUcmFjayAtIFRoZSBuZXcgdHJhY2sgdG8gcmVmZXJlbmNlLlxuICAgICovXG4gICByZXBsYWNlVHJhY2tSZWZlcmVuY2Uob2xkVHJhY2ssIG5ld1RyYWNrKSB7XG4gICAgICBpZiAodGhpcy50cmFjazEgPT09IG9sZFRyYWNrKSB0aGlzLnRyYWNrMSA9IG5ld1RyYWNrO1xuICAgICAgaWYgKHRoaXMudHJhY2syID09PSBvbGRUcmFjaykgdGhpcy50cmFjazIgPSBuZXdUcmFjaztcbiAgICAgIGlmICh0aGlzLnRyYWNrMyA9PT0gb2xkVHJhY2spIHRoaXMudHJhY2szID0gbmV3VHJhY2s7XG4gICAgICBpZiAodGhpcy50cmFjazQgPT09IG9sZFRyYWNrKSB0aGlzLnRyYWNrNCA9IG5ld1RyYWNrO1xuXG4gICAgICBpZiAodGhpcy5icmFuY2ggPT09IG9sZFRyYWNrKSB0aGlzLmJyYW5jaCA9IG5ld1RyYWNrO1xuICAgICAgaWYgKHRoaXMuZnJvbSA9PT0gb2xkVHJhY2spIHRoaXMuZnJvbSA9IG5ld1RyYWNrO1xuXG4gICAgICAvLyBBZnRlciB1cGRhdGluZyB0cmFjayByZWZlcmVuY2VzLCBpdCdzIGNydWNpYWwgdG8gcmVjYWxjdWxhdGUgdGhlIGRpcmVjdGlvbnNcbiAgICAgIC8vIGZvciByZW5kZXJpbmcgYW5kIG90aGVyIGxvZ2ljLlxuICAgICAgdGhpcy5jYWxjdWxhdGVQYXJhbWV0ZXJzKCk7XG4gICB9XG5cbiAgIGdldEJyYW5jaEVuZFBvaW50KGJyYW5jaCwgc2l6ZSA9IHRoaXMuc2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYWRkKHRoaXMudHJhY2tfZGlyZWN0aW9uc1ticmFuY2hdLm11bHRpcGx5KHNpemUpKTtcbiAgIH1cblxuICAgc3RyaW5naWZ5KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIF9jbGFzczogXCJTd2l0Y2hcIixcbiAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgbG9jYXRpb246IHRoaXMubG9jYXRpb24sXG4gICAgICAgICB0cmFja3M6IHRoaXMudHJhY2tzLm1hcCgodCkgPT4gdD8uaWQpLFxuICAgICAgICAgYnJhbmNoOiB0aGlzLmJyYW5jaD8uaWQsXG4gICAgICAgICBmcm9tOiB0aGlzLmZyb20/LmlkLFxuICAgICAgfTtcbiAgIH1cblxuICAgc3RhdGljIEZyb21PYmplY3Qobykge1xuICAgICAgY29uc3QgcyA9IG5ldyBTd2l0Y2goUG9pbnQuZnJvbVBvaW50KG8ubG9jYXRpb24pKTtcbiAgICAgIHMuaWQgPSBvLmlkO1xuXG4gICAgICAvLyBTdG9yZSBJRHMgZm9yIGxhdGVyIGxpbmtpbmdcbiAgICAgIHMudHJhY2tzX2lkID0gby50cmFja3M7XG4gICAgICBzLmJyYW5jaF9pZCA9IG8uYnJhbmNoO1xuICAgICAgcy5mcm9tX2lkID0gby5mcm9tO1xuXG4gICAgICByZXR1cm4gcztcbiAgIH1cbn1cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./www/code/switch.js\n\n}");

/***/ }),

/***/ "./www/code/tools.js":
/*!***************************!*\
  !*** ./www/code/tools.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   TOOLS: () => (/* binding */ TOOLS),\n/* harmony export */   V2: () => (/* binding */ V2),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   findFieldNameForObject: () => (/* binding */ findFieldNameForObject),\n/* harmony export */   geometry: () => (/* binding */ geometry),\n/* harmony export */   isPointInsideBox: () => (/* binding */ isPointInsideBox),\n/* harmony export */   rotatePointAroundPivot: () => (/* binding */ rotatePointAroundPivot),\n/* harmony export */   swap: () => (/* binding */ swap),\n/* harmony export */   testPerformance: () => (/* binding */ testPerformance),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n\n\n\n\n// Utility functions\nfunction findFieldNameForObject(container, ref) {\n   for (let key of Object.keys(container)) {\n      if (container[key] === ref) {\n         return key;\n      }\n   }\n   return null;\n}\n\nfunction type(value) {\n   if (value === null) {\n      return \"null\";\n   }\n   const baseType = typeof value;\n   // Primitive types\n   if (![\"object\", \"function\"].includes(baseType)) {\n      return baseType;\n   }\n\n   // Symbol.toStringTag often specifies the \"display name\" of the\n   // object's class. It's used in Object.prototype.toString().\n   const tag = value[Symbol.toStringTag];\n   if (typeof tag === \"string\") {\n      return tag;\n   }\n\n   // If it's a function whose source code starts with the \"class\" keyword\n   if (baseType === \"function\" && Function.prototype.toString.call(value).startsWith(\"class\")) {\n      return \"class\";\n   }\n\n   // The name of the constructor; for example `Array`, `GeneratorFunction`,\n   // `Number`, `String`, `Boolean` or `MyCustomClass`\n   const className = value.constructor.name;\n   if (typeof className === \"string\" && className !== \"\") {\n      return className;\n   }\n\n   // At this point there's no robust way to get the type of value,\n   // so we use the base implementation.\n   return baseType;\n}\n\nfunction swap(current, value1, value2) {\n   return current === value1 ? value2 : value1;\n}\n\nfunction deepEqual(x, y) {\n   const ok = Object.keys,\n      tx = typeof x,\n      ty = typeof y;\n   return x && y && tx === \"object\" && tx === ty\n      ? ok(x).length === ok(y).length && ok(x).every((key) => deepEqual(x[key], y[key]))\n      : x === y;\n}\n\nfunction clone(obj) {\n   var copy;\n\n   // Handle the 3 simple types, and null or undefined\n   if (null == obj || \"object\" != typeof obj) return obj;\n\n   // Handle Date\n   if (obj instanceof Date) {\n      copy = new Date();\n      copy.setTime(obj.getTime());\n      return copy;\n   }\n\n   // Handle Array\n   if (obj instanceof Array) {\n      copy = [];\n      for (var i = 0, len = obj.length; i < len; i++) {\n         copy[i] = clone(obj[i]);\n      }\n      return copy;\n   }\n\n   // Handle Object\n   if (obj instanceof Object) {\n      copy = {};\n      for (var attr in obj) {\n         if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\n      }\n      return copy;\n   }\n\n   throw new Error(\"Unable to copy obj! Its type isn't supported.\");\n}\n\nfunction uuidv4() {\n   return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>\n      (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)\n   );\n}\n\nfunction isPointInsideBox(point, box, rotationAngle) {\n   const { topLeft, topRight, bottomRight, bottomLeft } = box;\n\n   // Translate the point to align with the box's axes based on the given rotation angle\n   const translatedPoint = {\n      x: (point.x - topLeft.x) * Math.cos(-rotationAngle) - (point.y - topLeft.y) * Math.sin(-rotationAngle),\n      y: (point.x - topLeft.x) * Math.sin(-rotationAngle) + (point.y - topLeft.y) * Math.cos(-rotationAngle),\n   };\n\n   // Check if the translated point is inside the aligned box\n   const isInsideX = translatedPoint.x > 0 && translatedPoint.x < Math.hypot(topRight.x - topLeft.x, topRight.y - topLeft.y);\n   const isInsideY = translatedPoint.y > 0 && translatedPoint.y < Math.hypot(bottomLeft.x - topLeft.x, bottomLeft.y - topLeft.y);\n\n   return isInsideX && isInsideY;\n}\n\nfunction rotatePointAroundPivot(angle, pivot, point) {\n   var cos = Math.cos(angle);\n   var sin = Math.sin(angle);\n   var dx = point.x - pivot.x;\n   var dy = point.y - pivot.y;\n   var x = dx * cos - dy * sin + pivot.x;\n   var y = dy * cos + dx * sin + pivot.y;\n   return { x: x, y: y };\n}\n\nconst TOOLS = {\n   /**\n    * Finds the nearest point on a line segment to a given point\n    * @param {Point|{x: number, y: number}} start - Start point of the line segment\n    * @param {Point|{x: number, y: number}} end - End point of the line segment\n    * @param {Point|{x: number, y: number}} point - Point to find nearest position to\n    * @returns {Point} The nearest point on the line segment\n    */\n   nearestPointOnLine(start, end, point) {\n      const lineDeltaX = end.x - start.x;\n      const lineDeltaY = end.y - start.y;\n      \n      // Handle degenerate case where start and end are the same point\n      if (lineDeltaX === 0 && lineDeltaY === 0) {\n         return new Point(start.x, start.y);\n      }\n\n      // Find the closest point on the line to the point\n      // We can avoid the sqrt in lineLength by using squared values\n      const lengthSquared = lineDeltaX * lineDeltaX + lineDeltaY * lineDeltaY;\n      let u = ((point.x - start.x) * lineDeltaX + (point.y - start.y) * lineDeltaY) / lengthSquared;\n\n      // Clamp u to the range [0, 1]\n      u = Math.max(0, Math.min(1, u));\n\n      // Calculate the closest point on the line segment\n      return new Point(\n         start.x + u * lineDeltaX,\n         start.y + u * lineDeltaY\n      );\n   },\n};\n\nconst geometry = {\n   PRECISION: 3,\n   distance: function (p1, p2) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round(Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)), this.PRECISION);\n   },\n   length: function (v) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round(Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2)), this.PRECISION);\n   },\n   slope: function (p1, p2) {\n      return (p1.y - p2.y) / (p1.x - p2.x);\n   },\n   \n   getIntersectionPoint: function (line1, line2) {\n      const denominator =\n         (line2.end.y - line2.start.y) * (line1.end.x - line1.start.x) -\n         (line2.end.x - line2.start.x) * (line1.end.y - line1.start.y);\n\n      // If the denominator is 0, the lines are parallel and don't intersect\n      if (denominator === 0) {\n         return null;\n      }\n\n      const ua =\n         ((line2.end.x - line2.start.x) * (line1.start.y - line2.start.y) -\n            (line2.end.y - line2.start.y) * (line1.start.x - line2.start.x)) /\n         denominator;\n      const ub =\n         ((line1.end.x - line1.start.x) * (line1.start.y - line2.start.y) -\n            (line1.end.y - line1.start.y) * (line1.start.x - line2.start.x)) /\n         denominator;\n\n      // If ua or ub is less than 0 or greater than 1, the intersection point is outside of the segments\n      if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n         return null;\n      }\n\n      // Calculate the intersection point\n      const intersectionX = line1.start.x + ua * (line1.end.x - line1.start.x);\n      const intersectionY = line1.start.y + ua * (line1.end.y - line1.start.y);\n\n      return new Point(intersectionX, intersectionY);\n   },\n\n   //returns the intersection point of 2 lines, regardless of their length\n   getIntersectionPointX: function (p1, d1, p2, d2) {\n      // Solve for t and s using the equations:\n      const denominator = d1.x * d2.y - d1.y * d2.x;\n      if (denominator === 0) return null; // Vectors are parallel or collinear\n      // Compute parameters t and s\n      const t = ((p2.x - p1.x) * d2.y - (p2.y - p1.y) * d2.x) / denominator;\n      // Compute the intersection point using either vector\n      return new Point(p1.x + t * d1.x, p1.y + t * d1.y);\n   },\n\n   /**\n    * Checks if a target point lies on the line segment defined by two points.\n    * @param {Object} point1 - The first point of the line segment.\n    * @param {number} point1.x - The x-coordinate of the first point.\n    * @param {number} point1.y - The y-coordinate of the first point.\n    * @param {Object} point2 - The second point of the line segment.\n    * @param {number} point2.x - The x-coordinate of the second point.\n    * @param {number} point2.y - The y-coordinate of the second point.\n    * @param {Object} targetPoint - The point to check.\n    * @param {number} targetPoint.x - The x-coordinate of the target point.\n    * @param {number} targetPoint.y - The y-coordinate of the target point.\n    * @returns {boolean} True if the target point lies on the line segment, false otherwise.\n    */\n   pointOnLine: function (point1, point2, targetPoint) {\n      // Extract coordinates from the objects\n      let x1 = point1.x,\n         y1 = point1.y;\n      let x2 = point2.x,\n         y2 = point2.y;\n      let px = targetPoint.x,\n         py = targetPoint.y;\n\n      //if(x1==px && y1==py || x2==px && y2 == py) return false;\n\n      // Calculate parameters for the parametric equations\n      let tX = px == x1 && x1 == x2 ? 0 : (px - x1) / (x2 - x1);\n      let tY = py == y1 && y1 == y2 ? 0 : (py - y1) / (y2 - y1);\n\n      // Check if the point is on the line (within the segment boundaries)\n      if (tX >= 0 && tX <= 1 && tY >= 0 && tY <= 1) {\n         return true; // Point lies on the line segment\n      } else {\n         return false; // Point is outside the line segment\n      }\n   },\n   areSegmentsOverlapping2D: function (p1, p2, p3, p4) {\n\n      if (p1.x === p3.x && p1.y === p3.y && p2.x === p4.x && p2.y === p4.y) return true;\n\n      if ((p2.x === p3.x && p2.y === p3.y) || (p1.x === p4.x && p1.y === p4.y)) return false;\n\n      // Check if the segments are parallel\n      const slopeCheck = (p2.y - p1.y) * (p4.x - p3.x) === (p4.y - p3.y) * (p2.x - p1.x);\n\n      // Check if they lie on the same line\n      const colinearCheck = (p3.y - p1.y) * (p2.x - p1.x) === (p3.x - p1.x) * (p2.y - p1.y);\n\n      if (!slopeCheck || !colinearCheck) {\n         return false; // Not parallel or not colinear\n      }\n\n      // Check for overlap in projections (dominant axis)\n      const overlapX = Math.max(p1.x, p2.x) >= Math.min(p3.x, p4.x) && Math.max(p3.x, p4.x) >= Math.min(p1.x, p2.x);\n      const overlapY = Math.max(p1.y, p2.y) >= Math.min(p3.y, p4.y) && Math.max(p3.y, p4.y) >= Math.min(p1.y, p2.y);\n\n      return overlapX && overlapY;\n   },\n   //returns true if 2 line, described by 4 points intersect, each other\n   doLineSegmentsIntersect: function (p1, q1, p2, q2) {\n      const orientation = (p, q, r) => {\n         const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n         return val === 0 ? 0 : val > 0 ? 1 : 2;\n      };\n\n      const onSegment = (p, q, r) => {\n         return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n      };\n\n      const o1 = orientation(p1, q1, p2);\n      const o2 = orientation(p1, q1, q2);\n      const o3 = orientation(p2, q2, p1);\n      const o4 = orientation(p2, q2, q1);\n\n      if (o1 !== o2 && o3 !== o4) {\n         return true; // Segments intersect\n      }\n\n      if (o1 === 0 && onSegment(p1, p2, q1)) return true;\n      if (o2 === 0 && onSegment(p1, q2, q1)) return true;\n      if (o3 === 0 && onSegment(p2, p1, q2)) return true;\n      if (o4 === 0 && onSegment(p2, q1, q2)) return true;\n\n      return false; // No intersection\n   },\n   pointOnArc: function (radius, rad, centerpoint) {\n      const v = {\n         x: radius * Math.cos(rad) + centerpoint?.x,\n         y: radius * Math.sin(rad) + centerpoint?.y,\n      };\n\n      return v;\n   },\n\n   //returns the distance between a point and a line\n   pointToSegmentDistance: function(point, start, end) {\n      const dx = end.x - start.x;\n      const dy = end.y - start.y;\n      \n      // Handle degenerate case where start and end are the same point\n      if (dx === 0 && dy === 0) {\n          return Math.hypot(point.x - start.x, point.y - start.y);\n      }\n      \n      // Compute the projection of the point onto the line defined by start and end\n      const t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / (dx * dx + dy * dy);\n      \n      // Clamp t to the range [0,1] to restrict to the segment\n      const tClamped = Math.max(0, Math.min(1, t));\n      \n      // Find the closest point on the segment\n      const closestX = start.x + tClamped * dx;\n      const closestY = start.y + tClamped * dy;\n      \n      // Return the Euclidean distance\n      return Math.hypot(point.x - closestX, point.y - closestY);\n  },\n\n   \n   //calculates a point which is perpendicular to the given vector\n   perpendicular: function (v) {\n      return new V2({\n         y: v.x,\n         x: -v.y,\n      });\n   },\n\n   //returns the unit vector of the given vector\n   unit: function (v, l) {\n      const length = l ? l : this.length(v);\n      return this.multiply(v, 1 / length);\n   },\n\n   multiply: function (v, s) {\n      return {\n         x: _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round(v.x * s, this.PRECISION),\n         y: _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round(v.y * s, this.PRECISION),\n      };\n   },\n\n   add: function (v1, v2) {\n      return new Point(v1.x + v2.x, v1.y + v2.y);\n   },\n\n   sub: function (v1, v2) {\n      return new Point(v1.x - v2.x, v1.y - v2.y);\n   },\n\n   calculateAngle: function (reference, point1, point2) {\n      // Calculate vectors\n      const v1 = { x: point1.x - reference.x, y: point1.y - reference.y };\n      const v2 = { x: point2.x - reference.x, y: point2.y - reference.y };\n\n      // Dot product\n      const dotProduct = v1.x * v2.x + v1.y * v2.y;\n\n      // Magnitudes\n      const magnitudeV1 = Math.sqrt(v1.x ** 2 + v1.y ** 2);\n      const magnitudeV2 = Math.sqrt(v2.x ** 2 + v2.y ** 2);\n\n      // Cosine of the angle\n      const cosTheta = dotProduct / (magnitudeV1 * magnitudeV2);\n\n      // Angle in radians\n      const theta = Math.acos(cosTheta);\n\n      // Convert to degrees (optional)\n      return theta * (180 / Math.PI); // Return the angle in degrees\n   },\n\n   /**\n    * Returns the midpoint between two points\n    * @param {Object} p1 - First point\n    * @param {number} p1.x - X coordinate of first point\n    * @param {number} p1.y - Y coordinate of first point\n    * @param {Object} p2 - Second point\n    * @param {number} p2.x - X coordinate of second point\n    * @param {number} p2.y - Y coordinate of second point\n    * @returns {Point} The midpoint between p1 and p2\n    */\n   midpoint: function(p1, p2) {\n      return new Point(\n         _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round((p1.x + p2.x) / 2, this.PRECISION),\n         _utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.round((p1.y + p2.y) / 2, this.PRECISION)\n      );\n   },\n\n   /**\n    * Returns the angle bisector of two normalized vectors\n    * @param {Object} v1 - First normalized vector\n    * @param {number} v1.x - X component of first vector\n    * @param {number} v1.y - Y component of first vector\n    * @param {Object} v2 - Second normalized vector\n    * @param {number} v2.x - X component of second vector\n    * @param {number} v2.y - Y component of second vector\n    * @returns {Point} The angle bisector vector (normalized)\n    */\n   angleBisector: function(v1, v2) {\n      // Add the two vectors to get the bisector\n      const bisector = this.add(v1, v2);    \n      \n      \n      // Normalize the bisector using the existing normalize function\n      return this.unit(bisector);\n   },\n\n   /**\n    * Returns a point along the angle bisector of two unit vectors at a given distance\n    * @param {Object} v1 - First normalized vector\n    * @param {number} v1.x - X component of first vector\n    * @param {number} v1.y - Y component of first vector\n    * @param {Object} v2 - Second normalized vector\n    * @param {number} v2.x - X component of second vector\n    * @param {number} v2.y - Y component of second vector\n    * @param {number} distance - Distance to move along the bisector\n    * @returns {Point} The point at the specified distance along the angle bisector\n    */\n   pointAlongBisector: function(v1, v2, distance) {\n      // Get the angle bisector vector\n      const bisector = this.angleBisector(v1, v2);\n      \n      // Scale the bisector by the desired distance\n      const scaledBisector = this.multiply(bisector, distance);\n      \n      return scaledBisector;\n   },\n\n   /**\n    * Inverts a given vector by negating both x and y components\n    * @param {Object} v - Vector to invert\n    * @param {number} v.x - X component of vector\n    * @param {number} v.y - Y component of vector\n    * @returns {Point} The inverted vector\n    */\n   invert: function(v) {\n      return new Point(-v.x, -v.y);\n   },\n};\n\nclass V2 {\n   static fromV2(v) {\n      return new V2(v);\n   }\n\n   #_length = null;\n\n   get length() {\n      if (this.#_length == null) this.#_length = geometry.length(this);\n      return this.#_length;\n   }\n\n   get x() {\n      return this._p.x;\n   }\n\n   get y() {\n      return this._p.y;\n   }\n\n   constructor(p) {\n      this._p = p;\n   }\n\n   add(v) {\n      return new V2(geometry.add(this, v));\n   }\n\n   sub(v) {\n      return new V2(geometry.sub(this, v));\n   }\n\n   multiply(s) {\n      return new V2(geometry.multiply(this, s));\n   }\n\n   unit() {\n      return new V2(geometry.unit(this));\n   }\n   invert() {\n      return new V2(geometry.invert(this));\n   }\n}\n\nclass Point {\n   static fromPoint(p) {\n      return new Point(p.x, p.y);\n   }\n\n   constructor(x, y) {\n      this.x = x;\n      this.y = y;\n   }\n\n   add(v) {\n      return new Point(this.x + v.x, this.y + v.y);\n   }\n\n   sub(v) {\n      return new Point(this.x - v.x, this.y - v.y);\n   }\n\n   equals(p) {\n      return p.x == this.x && p.y == this.y;\n   }\n}\n\nfunction testPerformance(f, txt) {\n   const start = performance.now();\n   f();\n   const end = performance.now();\n   console.info(`${txt}: ${(end - start).toFixed(3)}ms`);\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSSxJQUFJLHlCQUF5QjtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3Rvb2xzLmpzP2U1YTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IE51bWJlclV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpZWxkTmFtZUZvck9iamVjdChjb250YWluZXIsIHJlZikge1xuICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGNvbnRhaW5lcikpIHtcbiAgICAgIGlmIChjb250YWluZXJba2V5XSA9PT0gcmVmKSB7XG4gICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfVxuICAgfVxuICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlKHZhbHVlKSB7XG4gICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgIH1cbiAgIGNvbnN0IGJhc2VUeXBlID0gdHlwZW9mIHZhbHVlO1xuICAgLy8gUHJpbWl0aXZlIHR5cGVzXG4gICBpZiAoIVtcIm9iamVjdFwiLCBcImZ1bmN0aW9uXCJdLmluY2x1ZGVzKGJhc2VUeXBlKSkge1xuICAgICAgcmV0dXJuIGJhc2VUeXBlO1xuICAgfVxuXG4gICAvLyBTeW1ib2wudG9TdHJpbmdUYWcgb2Z0ZW4gc3BlY2lmaWVzIHRoZSBcImRpc3BsYXkgbmFtZVwiIG9mIHRoZVxuICAgLy8gb2JqZWN0J3MgY2xhc3MuIEl0J3MgdXNlZCBpbiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKCkuXG4gICBjb25zdCB0YWcgPSB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddO1xuICAgaWYgKHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0YWc7XG4gICB9XG5cbiAgIC8vIElmIGl0J3MgYSBmdW5jdGlvbiB3aG9zZSBzb3VyY2UgY29kZSBzdGFydHMgd2l0aCB0aGUgXCJjbGFzc1wiIGtleXdvcmRcbiAgIGlmIChiYXNlVHlwZSA9PT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zdGFydHNXaXRoKFwiY2xhc3NcIikpIHtcbiAgICAgIHJldHVybiBcImNsYXNzXCI7XG4gICB9XG5cbiAgIC8vIFRoZSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvcjsgZm9yIGV4YW1wbGUgYEFycmF5YCwgYEdlbmVyYXRvckZ1bmN0aW9uYCxcbiAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYEJvb2xlYW5gIG9yIGBNeUN1c3RvbUNsYXNzYFxuICAgY29uc3QgY2xhc3NOYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGNsYXNzTmFtZSAhPT0gXCJcIikge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgIH1cblxuICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSdzIG5vIHJvYnVzdCB3YXkgdG8gZ2V0IHRoZSB0eXBlIG9mIHZhbHVlLFxuICAgLy8gc28gd2UgdXNlIHRoZSBiYXNlIGltcGxlbWVudGF0aW9uLlxuICAgcmV0dXJuIGJhc2VUeXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3dhcChjdXJyZW50LCB2YWx1ZTEsIHZhbHVlMikge1xuICAgcmV0dXJuIGN1cnJlbnQgPT09IHZhbHVlMSA/IHZhbHVlMiA6IHZhbHVlMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBFcXVhbCh4LCB5KSB7XG4gICBjb25zdCBvayA9IE9iamVjdC5rZXlzLFxuICAgICAgdHggPSB0eXBlb2YgeCxcbiAgICAgIHR5ID0gdHlwZW9mIHk7XG4gICByZXR1cm4geCAmJiB5ICYmIHR4ID09PSBcIm9iamVjdFwiICYmIHR4ID09PSB0eVxuICAgICAgPyBvayh4KS5sZW5ndGggPT09IG9rKHkpLmxlbmd0aCAmJiBvayh4KS5ldmVyeSgoa2V5KSA9PiBkZWVwRXF1YWwoeFtrZXldLCB5W2tleV0pKVxuICAgICAgOiB4ID09PSB5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gICB2YXIgY29weTtcblxuICAgLy8gSGFuZGxlIHRoZSAzIHNpbXBsZSB0eXBlcywgYW5kIG51bGwgb3IgdW5kZWZpbmVkXG4gICBpZiAobnVsbCA9PSBvYmogfHwgXCJvYmplY3RcIiAhPSB0eXBlb2Ygb2JqKSByZXR1cm4gb2JqO1xuXG4gICAvLyBIYW5kbGUgRGF0ZVxuICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGNvcHkgPSBuZXcgRGF0ZSgpO1xuICAgICAgY29weS5zZXRUaW1lKG9iai5nZXRUaW1lKCkpO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICB9XG5cbiAgIC8vIEhhbmRsZSBBcnJheVxuICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjb3B5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICBjb3B5W2ldID0gY2xvbmUob2JqW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3B5O1xuICAgfVxuXG4gICAvLyBIYW5kbGUgT2JqZWN0XG4gICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBjb3B5ID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIG9iaikge1xuICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShhdHRyKSkgY29weVthdHRyXSA9IGNsb25lKG9ialthdHRyXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29weTtcbiAgIH1cblxuICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgb2JqISBJdHMgdHlwZSBpc24ndCBzdXBwb3J0ZWQuXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXVpZHY0KCkge1xuICAgcmV0dXJuIChbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExKS5yZXBsYWNlKC9bMDE4XS9nLCAoYykgPT5cbiAgICAgIChjIF4gKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMSkpWzBdICYgKDE1ID4+IChjIC8gNCkpKSkudG9TdHJpbmcoMTYpXG4gICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQb2ludEluc2lkZUJveChwb2ludCwgYm94LCByb3RhdGlvbkFuZ2xlKSB7XG4gICBjb25zdCB7IHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdCB9ID0gYm94O1xuXG4gICAvLyBUcmFuc2xhdGUgdGhlIHBvaW50IHRvIGFsaWduIHdpdGggdGhlIGJveCdzIGF4ZXMgYmFzZWQgb24gdGhlIGdpdmVuIHJvdGF0aW9uIGFuZ2xlXG4gICBjb25zdCB0cmFuc2xhdGVkUG9pbnQgPSB7XG4gICAgICB4OiAocG9pbnQueCAtIHRvcExlZnQueCkgKiBNYXRoLmNvcygtcm90YXRpb25BbmdsZSkgLSAocG9pbnQueSAtIHRvcExlZnQueSkgKiBNYXRoLnNpbigtcm90YXRpb25BbmdsZSksXG4gICAgICB5OiAocG9pbnQueCAtIHRvcExlZnQueCkgKiBNYXRoLnNpbigtcm90YXRpb25BbmdsZSkgKyAocG9pbnQueSAtIHRvcExlZnQueSkgKiBNYXRoLmNvcygtcm90YXRpb25BbmdsZSksXG4gICB9O1xuXG4gICAvLyBDaGVjayBpZiB0aGUgdHJhbnNsYXRlZCBwb2ludCBpcyBpbnNpZGUgdGhlIGFsaWduZWQgYm94XG4gICBjb25zdCBpc0luc2lkZVggPSB0cmFuc2xhdGVkUG9pbnQueCA+IDAgJiYgdHJhbnNsYXRlZFBvaW50LnggPCBNYXRoLmh5cG90KHRvcFJpZ2h0LnggLSB0b3BMZWZ0LngsIHRvcFJpZ2h0LnkgLSB0b3BMZWZ0LnkpO1xuICAgY29uc3QgaXNJbnNpZGVZID0gdHJhbnNsYXRlZFBvaW50LnkgPiAwICYmIHRyYW5zbGF0ZWRQb2ludC55IDwgTWF0aC5oeXBvdChib3R0b21MZWZ0LnggLSB0b3BMZWZ0LngsIGJvdHRvbUxlZnQueSAtIHRvcExlZnQueSk7XG5cbiAgIHJldHVybiBpc0luc2lkZVggJiYgaXNJbnNpZGVZO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlUG9pbnRBcm91bmRQaXZvdChhbmdsZSwgcGl2b3QsIHBvaW50KSB7XG4gICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgIHZhciBkeCA9IHBvaW50LnggLSBwaXZvdC54O1xuICAgdmFyIGR5ID0gcG9pbnQueSAtIHBpdm90Lnk7XG4gICB2YXIgeCA9IGR4ICogY29zIC0gZHkgKiBzaW4gKyBwaXZvdC54O1xuICAgdmFyIHkgPSBkeSAqIGNvcyArIGR4ICogc2luICsgcGl2b3QueTtcbiAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFRPT0xTID0ge1xuICAgLyoqXG4gICAgKiBGaW5kcyB0aGUgbmVhcmVzdCBwb2ludCBvbiBhIGxpbmUgc2VnbWVudCB0byBhIGdpdmVuIHBvaW50XG4gICAgKiBAcGFyYW0ge1BvaW50fHt4OiBudW1iZXIsIHk6IG51bWJlcn19IHN0YXJ0IC0gU3RhcnQgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICogQHBhcmFtIHtQb2ludHx7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBlbmQgLSBFbmQgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxuICAgICogQHBhcmFtIHtQb2ludHx7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludCAtIFBvaW50IHRvIGZpbmQgbmVhcmVzdCBwb3NpdGlvbiB0b1xuICAgICogQHJldHVybnMge1BvaW50fSBUaGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgbGluZSBzZWdtZW50XG4gICAgKi9cbiAgIG5lYXJlc3RQb2ludE9uTGluZShzdGFydCwgZW5kLCBwb2ludCkge1xuICAgICAgY29uc3QgbGluZURlbHRhWCA9IGVuZC54IC0gc3RhcnQueDtcbiAgICAgIGNvbnN0IGxpbmVEZWx0YVkgPSBlbmQueSAtIHN0YXJ0Lnk7XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBkZWdlbmVyYXRlIGNhc2Ugd2hlcmUgc3RhcnQgYW5kIGVuZCBhcmUgdGhlIHNhbWUgcG9pbnRcbiAgICAgIGlmIChsaW5lRGVsdGFYID09PSAwICYmIGxpbmVEZWx0YVkgPT09IDApIHtcbiAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmUgdG8gdGhlIHBvaW50XG4gICAgICAvLyBXZSBjYW4gYXZvaWQgdGhlIHNxcnQgaW4gbGluZUxlbmd0aCBieSB1c2luZyBzcXVhcmVkIHZhbHVlc1xuICAgICAgY29uc3QgbGVuZ3RoU3F1YXJlZCA9IGxpbmVEZWx0YVggKiBsaW5lRGVsdGFYICsgbGluZURlbHRhWSAqIGxpbmVEZWx0YVk7XG4gICAgICBsZXQgdSA9ICgocG9pbnQueCAtIHN0YXJ0LngpICogbGluZURlbHRhWCArIChwb2ludC55IC0gc3RhcnQueSkgKiBsaW5lRGVsdGFZKSAvIGxlbmd0aFNxdWFyZWQ7XG5cbiAgICAgIC8vIENsYW1wIHUgdG8gdGhlIHJhbmdlIFswLCAxXVxuICAgICAgdSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHUpKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICBzdGFydC54ICsgdSAqIGxpbmVEZWx0YVgsXG4gICAgICAgICBzdGFydC55ICsgdSAqIGxpbmVEZWx0YVlcbiAgICAgICk7XG4gICB9LFxufTtcblxuZXhwb3J0IGNvbnN0IGdlb21ldHJ5ID0ge1xuICAgUFJFQ0lTSU9OOiAzLFxuICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgIHJldHVybiBOdW1iZXJVdGlscy5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKSwgdGhpcy5QUkVDSVNJT04pO1xuICAgfSxcbiAgIGxlbmd0aDogZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBOdW1iZXJVdGlscy5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3codi54LCAyKSArIE1hdGgucG93KHYueSwgMikpLCB0aGlzLlBSRUNJU0lPTik7XG4gICB9LFxuICAgc2xvcGU6IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgIHJldHVybiAocDEueSAtIHAyLnkpIC8gKHAxLnggLSBwMi54KTtcbiAgIH0sXG4gICBcbiAgIGdldEludGVyc2VjdGlvblBvaW50OiBmdW5jdGlvbiAobGluZTEsIGxpbmUyKSB7XG4gICAgICBjb25zdCBkZW5vbWluYXRvciA9XG4gICAgICAgICAobGluZTIuZW5kLnkgLSBsaW5lMi5zdGFydC55KSAqIChsaW5lMS5lbmQueCAtIGxpbmUxLnN0YXJ0LngpIC1cbiAgICAgICAgIChsaW5lMi5lbmQueCAtIGxpbmUyLnN0YXJ0LngpICogKGxpbmUxLmVuZC55IC0gbGluZTEuc3RhcnQueSk7XG5cbiAgICAgIC8vIElmIHRoZSBkZW5vbWluYXRvciBpcyAwLCB0aGUgbGluZXMgYXJlIHBhcmFsbGVsIGFuZCBkb24ndCBpbnRlcnNlY3RcbiAgICAgIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVhID1cbiAgICAgICAgICgobGluZTIuZW5kLnggLSBsaW5lMi5zdGFydC54KSAqIChsaW5lMS5zdGFydC55IC0gbGluZTIuc3RhcnQueSkgLVxuICAgICAgICAgICAgKGxpbmUyLmVuZC55IC0gbGluZTIuc3RhcnQueSkgKiAobGluZTEuc3RhcnQueCAtIGxpbmUyLnN0YXJ0LngpKSAvXG4gICAgICAgICBkZW5vbWluYXRvcjtcbiAgICAgIGNvbnN0IHViID1cbiAgICAgICAgICgobGluZTEuZW5kLnggLSBsaW5lMS5zdGFydC54KSAqIChsaW5lMS5zdGFydC55IC0gbGluZTIuc3RhcnQueSkgLVxuICAgICAgICAgICAgKGxpbmUxLmVuZC55IC0gbGluZTEuc3RhcnQueSkgKiAobGluZTEuc3RhcnQueCAtIGxpbmUyLnN0YXJ0LngpKSAvXG4gICAgICAgICBkZW5vbWluYXRvcjtcblxuICAgICAgLy8gSWYgdWEgb3IgdWIgaXMgbGVzcyB0aGFuIDAgb3IgZ3JlYXRlciB0aGFuIDEsIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgb3V0c2lkZSBvZiB0aGUgc2VnbWVudHNcbiAgICAgIGlmICh1YSA8IDAgfHwgdWEgPiAxIHx8IHViIDwgMCB8fCB1YiA+IDEpIHtcbiAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgY29uc3QgaW50ZXJzZWN0aW9uWCA9IGxpbmUxLnN0YXJ0LnggKyB1YSAqIChsaW5lMS5lbmQueCAtIGxpbmUxLnN0YXJ0LngpO1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW9uWSA9IGxpbmUxLnN0YXJ0LnkgKyB1YSAqIChsaW5lMS5lbmQueSAtIGxpbmUxLnN0YXJ0LnkpO1xuXG4gICAgICByZXR1cm4gbmV3IFBvaW50KGludGVyc2VjdGlvblgsIGludGVyc2VjdGlvblkpO1xuICAgfSxcblxuICAgLy9yZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgMiBsaW5lcywgcmVnYXJkbGVzcyBvZiB0aGVpciBsZW5ndGhcbiAgIGdldEludGVyc2VjdGlvblBvaW50WDogZnVuY3Rpb24gKHAxLCBkMSwgcDIsIGQyKSB7XG4gICAgICAvLyBTb2x2ZSBmb3IgdCBhbmQgcyB1c2luZyB0aGUgZXF1YXRpb25zOlxuICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBkMS54ICogZDIueSAtIGQxLnkgKiBkMi54O1xuICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwKSByZXR1cm4gbnVsbDsgLy8gVmVjdG9ycyBhcmUgcGFyYWxsZWwgb3IgY29sbGluZWFyXG4gICAgICAvLyBDb21wdXRlIHBhcmFtZXRlcnMgdCBhbmQgc1xuICAgICAgY29uc3QgdCA9ICgocDIueCAtIHAxLngpICogZDIueSAtIChwMi55IC0gcDEueSkgKiBkMi54KSAvIGRlbm9taW5hdG9yO1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IHVzaW5nIGVpdGhlciB2ZWN0b3JcbiAgICAgIHJldHVybiBuZXcgUG9pbnQocDEueCArIHQgKiBkMS54LCBwMS55ICsgdCAqIGQxLnkpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBDaGVja3MgaWYgYSB0YXJnZXQgcG9pbnQgbGllcyBvbiB0aGUgbGluZSBzZWdtZW50IGRlZmluZWQgYnkgdHdvIHBvaW50cy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludDEgLSBUaGUgZmlyc3QgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudC5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludDEueCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50MS55IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnQyIC0gVGhlIHNlY29uZCBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50Mi54IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50Mi55IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFBvaW50IC0gVGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFBvaW50LnggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB0YXJnZXQgcG9pbnQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UG9pbnQueSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHRhcmdldCBwb2ludC5cbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0YXJnZXQgcG9pbnQgbGllcyBvbiB0aGUgbGluZSBzZWdtZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgKi9cbiAgIHBvaW50T25MaW5lOiBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIsIHRhcmdldFBvaW50KSB7XG4gICAgICAvLyBFeHRyYWN0IGNvb3JkaW5hdGVzIGZyb20gdGhlIG9iamVjdHNcbiAgICAgIGxldCB4MSA9IHBvaW50MS54LFxuICAgICAgICAgeTEgPSBwb2ludDEueTtcbiAgICAgIGxldCB4MiA9IHBvaW50Mi54LFxuICAgICAgICAgeTIgPSBwb2ludDIueTtcbiAgICAgIGxldCBweCA9IHRhcmdldFBvaW50LngsXG4gICAgICAgICBweSA9IHRhcmdldFBvaW50Lnk7XG5cbiAgICAgIC8vaWYoeDE9PXB4ICYmIHkxPT1weSB8fCB4Mj09cHggJiYgeTIgPT0gcHkpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHBhcmFtZXRlcnMgZm9yIHRoZSBwYXJhbWV0cmljIGVxdWF0aW9uc1xuICAgICAgbGV0IHRYID0gcHggPT0geDEgJiYgeDEgPT0geDIgPyAwIDogKHB4IC0geDEpIC8gKHgyIC0geDEpO1xuICAgICAgbGV0IHRZID0gcHkgPT0geTEgJiYgeTEgPT0geTIgPyAwIDogKHB5IC0geTEpIC8gKHkyIC0geTEpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgaXMgb24gdGhlIGxpbmUgKHdpdGhpbiB0aGUgc2VnbWVudCBib3VuZGFyaWVzKVxuICAgICAgaWYgKHRYID49IDAgJiYgdFggPD0gMSAmJiB0WSA+PSAwICYmIHRZIDw9IDEpIHtcbiAgICAgICAgIHJldHVybiB0cnVlOyAvLyBQb2ludCBsaWVzIG9uIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFBvaW50IGlzIG91dHNpZGUgdGhlIGxpbmUgc2VnbWVudFxuICAgICAgfVxuICAgfSxcbiAgIGFyZVNlZ21lbnRzT3ZlcmxhcHBpbmcyRDogZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG5cbiAgICAgIGlmIChwMS54ID09PSBwMy54ICYmIHAxLnkgPT09IHAzLnkgJiYgcDIueCA9PT0gcDQueCAmJiBwMi55ID09PSBwNC55KSByZXR1cm4gdHJ1ZTtcblxuICAgICAgaWYgKChwMi54ID09PSBwMy54ICYmIHAyLnkgPT09IHAzLnkpIHx8IChwMS54ID09PSBwNC54ICYmIHAxLnkgPT09IHA0LnkpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBzZWdtZW50cyBhcmUgcGFyYWxsZWxcbiAgICAgIGNvbnN0IHNsb3BlQ2hlY2sgPSAocDIueSAtIHAxLnkpICogKHA0LnggLSBwMy54KSA9PT0gKHA0LnkgLSBwMy55KSAqIChwMi54IC0gcDEueCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZXkgbGllIG9uIHRoZSBzYW1lIGxpbmVcbiAgICAgIGNvbnN0IGNvbGluZWFyQ2hlY2sgPSAocDMueSAtIHAxLnkpICogKHAyLnggLSBwMS54KSA9PT0gKHAzLnggLSBwMS54KSAqIChwMi55IC0gcDEueSk7XG5cbiAgICAgIGlmICghc2xvcGVDaGVjayB8fCAhY29saW5lYXJDaGVjaykge1xuICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBOb3QgcGFyYWxsZWwgb3Igbm90IGNvbGluZWFyXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBvdmVybGFwIGluIHByb2plY3Rpb25zIChkb21pbmFudCBheGlzKVxuICAgICAgY29uc3Qgb3ZlcmxhcFggPSBNYXRoLm1heChwMS54LCBwMi54KSA+PSBNYXRoLm1pbihwMy54LCBwNC54KSAmJiBNYXRoLm1heChwMy54LCBwNC54KSA+PSBNYXRoLm1pbihwMS54LCBwMi54KTtcbiAgICAgIGNvbnN0IG92ZXJsYXBZID0gTWF0aC5tYXgocDEueSwgcDIueSkgPj0gTWF0aC5taW4ocDMueSwgcDQueSkgJiYgTWF0aC5tYXgocDMueSwgcDQueSkgPj0gTWF0aC5taW4ocDEueSwgcDIueSk7XG5cbiAgICAgIHJldHVybiBvdmVybGFwWCAmJiBvdmVybGFwWTtcbiAgIH0sXG4gICAvL3JldHVybnMgdHJ1ZSBpZiAyIGxpbmUsIGRlc2NyaWJlZCBieSA0IHBvaW50cyBpbnRlcnNlY3QsIGVhY2ggb3RoZXJcbiAgIGRvTGluZVNlZ21lbnRzSW50ZXJzZWN0OiBmdW5jdGlvbiAocDEsIHExLCBwMiwgcTIpIHtcbiAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gKHAsIHEsIHIpID0+IHtcbiAgICAgICAgIGNvbnN0IHZhbCA9IChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xuICAgICAgICAgcmV0dXJuIHZhbCA9PT0gMCA/IDAgOiB2YWwgPiAwID8gMSA6IDI7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvblNlZ21lbnQgPSAocCwgcSwgcikgPT4ge1xuICAgICAgICAgcmV0dXJuIHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSAmJiBxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvMSA9IG9yaWVudGF0aW9uKHAxLCBxMSwgcDIpO1xuICAgICAgY29uc3QgbzIgPSBvcmllbnRhdGlvbihwMSwgcTEsIHEyKTtcbiAgICAgIGNvbnN0IG8zID0gb3JpZW50YXRpb24ocDIsIHEyLCBwMSk7XG4gICAgICBjb25zdCBvNCA9IG9yaWVudGF0aW9uKHAyLCBxMiwgcTEpO1xuXG4gICAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkge1xuICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFNlZ21lbnRzIGludGVyc2VjdFxuICAgICAgfVxuXG4gICAgICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvMiA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHEyLCBxMSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBpbnRlcnNlY3Rpb25cbiAgIH0sXG4gICBwb2ludE9uQXJjOiBmdW5jdGlvbiAocmFkaXVzLCByYWQsIGNlbnRlcnBvaW50KSB7XG4gICAgICBjb25zdCB2ID0ge1xuICAgICAgICAgeDogcmFkaXVzICogTWF0aC5jb3MocmFkKSArIGNlbnRlcnBvaW50Py54LFxuICAgICAgICAgeTogcmFkaXVzICogTWF0aC5zaW4ocmFkKSArIGNlbnRlcnBvaW50Py55LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHY7XG4gICB9LFxuXG4gICAvL3JldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCBhbmQgYSBsaW5lXG4gICBwb2ludFRvU2VnbWVudERpc3RhbmNlOiBmdW5jdGlvbihwb2ludCwgc3RhcnQsIGVuZCkge1xuICAgICAgY29uc3QgZHggPSBlbmQueCAtIHN0YXJ0Lng7XG4gICAgICBjb25zdCBkeSA9IGVuZC55IC0gc3RhcnQueTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIGRlZ2VuZXJhdGUgY2FzZSB3aGVyZSBzdGFydCBhbmQgZW5kIGFyZSB0aGUgc2FtZSBwb2ludFxuICAgICAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguaHlwb3QocG9pbnQueCAtIHN0YXJ0LngsIHBvaW50LnkgLSBzdGFydC55KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJvamVjdGlvbiBvZiB0aGUgcG9pbnQgb250byB0aGUgbGluZSBkZWZpbmVkIGJ5IHN0YXJ0IGFuZCBlbmRcbiAgICAgIGNvbnN0IHQgPSAoKHBvaW50LnggLSBzdGFydC54KSAqIGR4ICsgKHBvaW50LnkgLSBzdGFydC55KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBcbiAgICAgIC8vIENsYW1wIHQgdG8gdGhlIHJhbmdlIFswLDFdIHRvIHJlc3RyaWN0IHRvIHRoZSBzZWdtZW50XG4gICAgICBjb25zdCB0Q2xhbXBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcbiAgICAgIFxuICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxuICAgICAgY29uc3QgY2xvc2VzdFggPSBzdGFydC54ICsgdENsYW1wZWQgKiBkeDtcbiAgICAgIGNvbnN0IGNsb3Nlc3RZID0gc3RhcnQueSArIHRDbGFtcGVkICogZHk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiB0aGUgRXVjbGlkZWFuIGRpc3RhbmNlXG4gICAgICByZXR1cm4gTWF0aC5oeXBvdChwb2ludC54IC0gY2xvc2VzdFgsIHBvaW50LnkgLSBjbG9zZXN0WSk7XG4gIH0sXG5cbiAgIFxuICAgLy9jYWxjdWxhdGVzIGEgcG9pbnQgd2hpY2ggaXMgcGVycGVuZGljdWxhciB0byB0aGUgZ2l2ZW4gdmVjdG9yXG4gICBwZXJwZW5kaWN1bGFyOiBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIG5ldyBWMih7XG4gICAgICAgICB5OiB2LngsXG4gICAgICAgICB4OiAtdi55LFxuICAgICAgfSk7XG4gICB9LFxuXG4gICAvL3JldHVybnMgdGhlIHVuaXQgdmVjdG9yIG9mIHRoZSBnaXZlbiB2ZWN0b3JcbiAgIHVuaXQ6IGZ1bmN0aW9uICh2LCBsKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBsID8gbCA6IHRoaXMubGVuZ3RoKHYpO1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkodiwgMSAvIGxlbmd0aCk7XG4gICB9LFxuXG4gICBtdWx0aXBseTogZnVuY3Rpb24gKHYsIHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICB4OiBOdW1iZXJVdGlscy5yb3VuZCh2LnggKiBzLCB0aGlzLlBSRUNJU0lPTiksXG4gICAgICAgICB5OiBOdW1iZXJVdGlscy5yb3VuZCh2LnkgKiBzLCB0aGlzLlBSRUNJU0lPTiksXG4gICAgICB9O1xuICAgfSxcblxuICAgYWRkOiBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHYxLnggKyB2Mi54LCB2MS55ICsgdjIueSk7XG4gICB9LFxuXG4gICBzdWI6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodjEueCAtIHYyLngsIHYxLnkgLSB2Mi55KTtcbiAgIH0sXG5cbiAgIGNhbGN1bGF0ZUFuZ2xlOiBmdW5jdGlvbiAocmVmZXJlbmNlLCBwb2ludDEsIHBvaW50Mikge1xuICAgICAgLy8gQ2FsY3VsYXRlIHZlY3RvcnNcbiAgICAgIGNvbnN0IHYxID0geyB4OiBwb2ludDEueCAtIHJlZmVyZW5jZS54LCB5OiBwb2ludDEueSAtIHJlZmVyZW5jZS55IH07XG4gICAgICBjb25zdCB2MiA9IHsgeDogcG9pbnQyLnggLSByZWZlcmVuY2UueCwgeTogcG9pbnQyLnkgLSByZWZlcmVuY2UueSB9O1xuXG4gICAgICAvLyBEb3QgcHJvZHVjdFxuICAgICAgY29uc3QgZG90UHJvZHVjdCA9IHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnk7XG5cbiAgICAgIC8vIE1hZ25pdHVkZXNcbiAgICAgIGNvbnN0IG1hZ25pdHVkZVYxID0gTWF0aC5zcXJ0KHYxLnggKiogMiArIHYxLnkgKiogMik7XG4gICAgICBjb25zdCBtYWduaXR1ZGVWMiA9IE1hdGguc3FydCh2Mi54ICoqIDIgKyB2Mi55ICoqIDIpO1xuXG4gICAgICAvLyBDb3NpbmUgb2YgdGhlIGFuZ2xlXG4gICAgICBjb25zdCBjb3NUaGV0YSA9IGRvdFByb2R1Y3QgLyAobWFnbml0dWRlVjEgKiBtYWduaXR1ZGVWMik7XG5cbiAgICAgIC8vIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKGNvc1RoZXRhKTtcblxuICAgICAgLy8gQ29udmVydCB0byBkZWdyZWVzIChvcHRpb25hbClcbiAgICAgIHJldHVybiB0aGV0YSAqICgxODAgLyBNYXRoLlBJKTsgLy8gUmV0dXJuIHRoZSBhbmdsZSBpbiBkZWdyZWVzXG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJldHVybnMgdGhlIG1pZHBvaW50IGJldHdlZW4gdHdvIHBvaW50c1xuICAgICogQHBhcmFtIHtPYmplY3R9IHAxIC0gRmlyc3QgcG9pbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwMS54IC0gWCBjb29yZGluYXRlIG9mIGZpcnN0IHBvaW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gcDEueSAtIFkgY29vcmRpbmF0ZSBvZiBmaXJzdCBwb2ludFxuICAgICogQHBhcmFtIHtPYmplY3R9IHAyIC0gU2Vjb25kIHBvaW50XG4gICAgKiBAcGFyYW0ge251bWJlcn0gcDIueCAtIFggY29vcmRpbmF0ZSBvZiBzZWNvbmQgcG9pbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwMi55IC0gWSBjb29yZGluYXRlIG9mIHNlY29uZCBwb2ludFxuICAgICogQHJldHVybnMge1BvaW50fSBUaGUgbWlkcG9pbnQgYmV0d2VlbiBwMSBhbmQgcDJcbiAgICAqL1xuICAgbWlkcG9pbnQ6IGZ1bmN0aW9uKHAxLCBwMikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgIE51bWJlclV0aWxzLnJvdW5kKChwMS54ICsgcDIueCkgLyAyLCB0aGlzLlBSRUNJU0lPTiksXG4gICAgICAgICBOdW1iZXJVdGlscy5yb3VuZCgocDEueSArIHAyLnkpIC8gMiwgdGhpcy5QUkVDSVNJT04pXG4gICAgICApO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBiaXNlY3RvciBvZiB0d28gbm9ybWFsaXplZCB2ZWN0b3JzXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdjEgLSBGaXJzdCBub3JtYWxpemVkIHZlY3RvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHYxLnggLSBYIGNvbXBvbmVudCBvZiBmaXJzdCB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2MS55IC0gWSBjb21wb25lbnQgb2YgZmlyc3QgdmVjdG9yXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdjIgLSBTZWNvbmQgbm9ybWFsaXplZCB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2Mi54IC0gWCBjb21wb25lbnQgb2Ygc2Vjb25kIHZlY3RvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHYyLnkgLSBZIGNvbXBvbmVudCBvZiBzZWNvbmQgdmVjdG9yXG4gICAgKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBhbmdsZSBiaXNlY3RvciB2ZWN0b3IgKG5vcm1hbGl6ZWQpXG4gICAgKi9cbiAgIGFuZ2xlQmlzZWN0b3I6IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgLy8gQWRkIHRoZSB0d28gdmVjdG9ycyB0byBnZXQgdGhlIGJpc2VjdG9yXG4gICAgICBjb25zdCBiaXNlY3RvciA9IHRoaXMuYWRkKHYxLCB2Mik7ICAgIFxuICAgICAgXG4gICAgICBcbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgYmlzZWN0b3IgdXNpbmcgdGhlIGV4aXN0aW5nIG5vcm1hbGl6ZSBmdW5jdGlvblxuICAgICAgcmV0dXJuIHRoaXMudW5pdChiaXNlY3Rvcik7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJldHVybnMgYSBwb2ludCBhbG9uZyB0aGUgYW5nbGUgYmlzZWN0b3Igb2YgdHdvIHVuaXQgdmVjdG9ycyBhdCBhIGdpdmVuIGRpc3RhbmNlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdjEgLSBGaXJzdCBub3JtYWxpemVkIHZlY3RvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHYxLnggLSBYIGNvbXBvbmVudCBvZiBmaXJzdCB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2MS55IC0gWSBjb21wb25lbnQgb2YgZmlyc3QgdmVjdG9yXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdjIgLSBTZWNvbmQgbm9ybWFsaXplZCB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2Mi54IC0gWCBjb21wb25lbnQgb2Ygc2Vjb25kIHZlY3RvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHYyLnkgLSBZIGNvbXBvbmVudCBvZiBzZWNvbmQgdmVjdG9yXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgLSBEaXN0YW5jZSB0byBtb3ZlIGFsb25nIHRoZSBiaXNlY3RvclxuICAgICogQHJldHVybnMge1BvaW50fSBUaGUgcG9pbnQgYXQgdGhlIHNwZWNpZmllZCBkaXN0YW5jZSBhbG9uZyB0aGUgYW5nbGUgYmlzZWN0b3JcbiAgICAqL1xuICAgcG9pbnRBbG9uZ0Jpc2VjdG9yOiBmdW5jdGlvbih2MSwgdjIsIGRpc3RhbmNlKSB7XG4gICAgICAvLyBHZXQgdGhlIGFuZ2xlIGJpc2VjdG9yIHZlY3RvclxuICAgICAgY29uc3QgYmlzZWN0b3IgPSB0aGlzLmFuZ2xlQmlzZWN0b3IodjEsIHYyKTtcbiAgICAgIFxuICAgICAgLy8gU2NhbGUgdGhlIGJpc2VjdG9yIGJ5IHRoZSBkZXNpcmVkIGRpc3RhbmNlXG4gICAgICBjb25zdCBzY2FsZWRCaXNlY3RvciA9IHRoaXMubXVsdGlwbHkoYmlzZWN0b3IsIGRpc3RhbmNlKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHNjYWxlZEJpc2VjdG9yO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBJbnZlcnRzIGEgZ2l2ZW4gdmVjdG9yIGJ5IG5lZ2F0aW5nIGJvdGggeCBhbmQgeSBjb21wb25lbnRzXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdiAtIFZlY3RvciB0byBpbnZlcnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2LnggLSBYIGNvbXBvbmVudCBvZiB2ZWN0b3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2LnkgLSBZIGNvbXBvbmVudCBvZiB2ZWN0b3JcbiAgICAqIEByZXR1cm5zIHtQb2ludH0gVGhlIGludmVydGVkIHZlY3RvclxuICAgICovXG4gICBpbnZlcnQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoLXYueCwgLXYueSk7XG4gICB9LFxufTtcblxuZXhwb3J0IGNsYXNzIFYyIHtcbiAgIHN0YXRpYyBmcm9tVjIodikge1xuICAgICAgcmV0dXJuIG5ldyBWMih2KTtcbiAgIH1cblxuICAgI19sZW5ndGggPSBudWxsO1xuXG4gICBnZXQgbGVuZ3RoKCkge1xuICAgICAgaWYgKHRoaXMuI19sZW5ndGggPT0gbnVsbCkgdGhpcy4jX2xlbmd0aCA9IGdlb21ldHJ5Lmxlbmd0aCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLiNfbGVuZ3RoO1xuICAgfVxuXG4gICBnZXQgeCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wLng7XG4gICB9XG5cbiAgIGdldCB5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3AueTtcbiAgIH1cblxuICAgY29uc3RydWN0b3IocCkge1xuICAgICAgdGhpcy5fcCA9IHA7XG4gICB9XG5cbiAgIGFkZCh2KSB7XG4gICAgICByZXR1cm4gbmV3IFYyKGdlb21ldHJ5LmFkZCh0aGlzLCB2KSk7XG4gICB9XG5cbiAgIHN1Yih2KSB7XG4gICAgICByZXR1cm4gbmV3IFYyKGdlb21ldHJ5LnN1Yih0aGlzLCB2KSk7XG4gICB9XG5cbiAgIG11bHRpcGx5KHMpIHtcbiAgICAgIHJldHVybiBuZXcgVjIoZ2VvbWV0cnkubXVsdGlwbHkodGhpcywgcykpO1xuICAgfVxuXG4gICB1bml0KCkge1xuICAgICAgcmV0dXJuIG5ldyBWMihnZW9tZXRyeS51bml0KHRoaXMpKTtcbiAgIH1cbiAgIGludmVydCgpIHtcbiAgICAgIHJldHVybiBuZXcgVjIoZ2VvbWV0cnkuaW52ZXJ0KHRoaXMpKTtcbiAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBvaW50IHtcbiAgIHN0YXRpYyBmcm9tUG9pbnQocCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngsIHAueSk7XG4gICB9XG5cbiAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgfVxuXG4gICBhZGQodikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB2LngsIHRoaXMueSArIHYueSk7XG4gICB9XG5cbiAgIHN1Yih2KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcbiAgIH1cblxuICAgZXF1YWxzKHApIHtcbiAgICAgIHJldHVybiBwLnggPT0gdGhpcy54ICYmIHAueSA9PSB0aGlzLnk7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UGVyZm9ybWFuY2UoZiwgdHh0KSB7XG4gICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgZigpO1xuICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICBjb25zb2xlLmluZm8oYCR7dHh0fTogJHsoZW5kIC0gc3RhcnQpLnRvRml4ZWQoMyl9bXNgKTtcbn1cblxuXG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/tools.js\n\n}");

/***/ }),

/***/ "./www/code/track.js":
/*!***************************!*\
  !*** ./www/code/track.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Track: () => (/* binding */ Track)\n/* harmony export */ });\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config.js */ \"./www/code/config.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\nclass Track {\n   static allTracks = [];\n\n   //track drawing\n   static isValidTrackNodePoint(p) {\n      return true;\n   }\n\n   static findTrackbySignal(s) {\n      return Track.allTracks.find((t) => t.signals.find((o) => o.data == s) != undefined);\n   }\n   static findTrackByPoint(p) {\n      return Track.allTracks.find((track) => {\n         return _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.pointOnLine(track.start, track.end, p);\n      });\n   }\n\n   static counter = 0;\n\n   static _getID() {\n      return Track.counter++;\n   }\n\n   static splitTrackAtPoint(track, point) {\n      const t1 = new Track(track.start, point);\n      const t2 = new Track(point, track.end);\n      const cut_km = track.getKmfromPoint(point);\n\n      track.signals.forEach((s) => {\n         if (s._positioning.km < cut_km) {\n            s._positioning.track = t1;\n            t1.AddSignal(s);\n         } else {\n            s._positioning.track = t2;\n            s._positioning.km -= cut_km;\n            t2.AddSignal(s);\n         }\n      });\n\n      return [t1, t2];\n   }\n\n   static joinTrack(track1, track2) {\n      let cut_km = track1.length;\n      track1.setNewEnd(track2.end);\n\n      // Remove any existing switch between the two tracks\n      if (track2.switchAtTheStart) {\n         _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.removeSwitch(track2.switchAtTheStart);\n      }\n\n      if (track1.switchAtTheEnd) {\n         _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.removeSwitch(track1.switchAtTheEnd);\n      }\n\n      track2.signals.forEach((s) => {\n         s._positioning.track = track1;\n         s._positioning.km += cut_km;\n         track1.AddSignal(s);\n      });\n   }\n\n   static checkNodesAndCreateTracks(points) {\n      if (points == null || points.length <= 1) return;\n\n      const new_tracks = [];\n\n      //reverse the points array if the user drew it from right to left, or if the user drew straight from bottom to top\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.first(points).x > _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.last(points).x || (_utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.first(points).x == _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.last(points).x && _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.first(points).y > _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.last(points).y)) {\n         points.reverse();\n      }\n\n      let current_point = points.shift();\n      let tmp_points = [current_point];\n\n      //iterate over all points and create tracks\n      while (points.length > 0) {\n         const next_point = points.shift();\n\n         // Check if the new segment would overlap with any existing track\n         const overlapping_tracks = Track.allTracks.filter((track) => {\n            return _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.areSegmentsOverlapping2D(current_point, next_point, track.start, track.end);\n         });\n\n         if (overlapping_tracks.length === 0) {\n            // No overlap, create a new track\n            tmp_points.push(next_point);\n            if (tmp_points.length >= 2) {\n               new_tracks.push(new Track(tmp_points[0], tmp_points[1]));\n               tmp_points = [next_point];\n            }\n         } else {\n            // Handle overlapping tracks\n            const overlapping_track = overlapping_tracks[0];\n\n            // If we have a partial track before the overlap, create it\n            if (tmp_points.length >= 2) {\n               new_tracks.push(new Track(tmp_points[0], tmp_points[1]));\n            }\n\n            // Check if we need to create a track from the last point to the overlap point\n            if (!current_point.equals(overlapping_track.start) && !current_point.equals(overlapping_track.end)) {\n               // Find the overlap point\n               const overlap_point = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.getIntersectionPoint(\n                  current_point,\n                  next_point,\n                  overlapping_track.start,\n                  overlapping_track.end\n               );\n\n               if (overlap_point) {\n                  new_tracks.push(new Track(current_point, overlap_point));\n                  tmp_points = [overlap_point];\n               }\n            }\n         }\n\n         current_point = next_point;\n      }\n\n      // Create final track if we have remaining points\n      if (tmp_points.length >= 2) {\n         new_tracks.push(new Track(tmp_points[0], tmp_points[1]));\n      }\n\n      Track.allTracks.push(...new_tracks);\n\n      return new_tracks;\n   }\n\n   static splitTracksAtIntersections() {\n      let intersection,\n         skip = false, // true if the track was already split\n         new_tracks = [],\n         remainingTracks = [...Track.allTracks]; //copy of the tracks, will be modified during the loop\n\n      //iterate over all tracks and search for intersections\n      while (remainingTracks.length > 0) {\n         skip = false;\n         const track1 = remainingTracks.shift();\n\n         //iterate over all remaining tracks\n         for (let k = 0; k < remainingTracks.length && !skip; k++) {\n            const track2 = remainingTracks[k];\n\n            // Get intersection point of the two tracks\n            intersection = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.getIntersectionPoint(track1, track2);\n\n            //check if the intersection point is on the grid\n            if (intersection && intersection.x % _config_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG.GRID_SIZE == 0 && intersection.y % _config_js__WEBPACK_IMPORTED_MODULE_4__.CONFIG.GRID_SIZE == 0) {\n               // Split track1 if intersection is not at start or end\n               if (!intersection.equals(track1.start) && !intersection.equals(track1.end)) {\n                  const km = track1.getKmfromPoint(intersection);\n                  const signals_on_track = [...track1.signals];\n\n                  // Create two new tracks\n                  const t1 = new Track(track1.start, intersection);\n                  const t2 = new Track(intersection, track1.end);\n\n                  const startSwitch = track1.switchAtTheStart;\n                  if (startSwitch) {\n                     if (startSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch) {\n                        startSwitch.replaceTrackReference(track1, t1);\n                        t1.switchAtTheStart = startSwitch;\n                     } else if (startSwitch instanceof Track) {\n                        // If it's a track, update the track reference\n                        if (startSwitch.switchAtTheEnd === track1) {\n                           startSwitch.switchAtTheEnd = t1;\n                        } else if (startSwitch.switchAtTheStart === track1) {\n                           startSwitch.switchAtTheStart = t1; //Ich glaube das ist nicht nötig\n                        }\n                        t1.switchAtTheStart = startSwitch;\n                     }\n\n                     \n                  }\n\n                  const endSwitch = track1.switchAtTheEnd;\n                  if (endSwitch) {\n                     if (endSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch) {\n                        endSwitch.replaceTrackReference(track1, t2);\n                        t2.switchAtTheEnd = endSwitch;\n                     } else if (endSwitch instanceof Track) {\n                        // If it's a track, update the track reference\n                        if (endSwitch.switchAtTheEnd === track1) {\n                           endSwitch.switchAtTheEnd = t2;\n                        } else if (endSwitch.switchAtTheStart === track1) {\n                           endSwitch.switchAtTheStart = t2; //Ich glaube das ist nicht nötig\n                        }\n                        t2.switchAtTheEnd = endSwitch;\n                     }\n                  }\n\n                  // Remove the original track\n                  _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(Track.allTracks, track1);\n                  _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(remainingTracks, track1);\n\n                  // Add new tracks\n                  new_tracks.push(t1, t2);\n\n                  // Reassign signals to the appropriate new track\n                  signals_on_track.forEach((signal) => {\n                     if (signal._positioning.km < km) {\n                        signal.setTrack(t1, signal._positioning.km);\n                     } else {\n                        signal.setTrack(t2, signal._positioning.km - km);\n                     }\n                  });\n\n                  remainingTracks.push(t1, t2);\n                  skip = true;\n               }\n\n               // Split track2 if intersection is not at start or end\n               if (!intersection.equals(track2.start) && !intersection.equals(track2.end)) {\n                  const km = track2.getKmfromPoint(intersection);\n                  const signals_on_track = [...track2.signals];\n\n                  // Create two new tracks\n                  const t1 = new Track(track2.start, intersection);\n                  const t2 = new Track(intersection, track2.end);\n\n                  const startSwitch = track2.switchAtTheStart;\n                  if (startSwitch) {\n                     if (startSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch) {\n                        startSwitch.replaceTrackReference(track2, t1);\n                        t1.switchAtTheStart = startSwitch;\n                     } else if (startSwitch instanceof Track) {\n                        // If it's a track, update the track reference\n                        if (startSwitch.switchAtTheEnd === track2) {\n                           startSwitch.switchAtTheEnd = t1;\n                        } else if (startSwitch.switchAtTheStart === track2) {\n                           startSwitch.switchAtTheStart = t1; //Ich glaube das ist nicht nötig\n                        }\n                        t1.switchAtTheStart = startSwitch;\n                     }\n                  }\n\n                  const endSwitch = track2.switchAtTheEnd;\n                  if (endSwitch) {\n                     if (endSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch) {\n                        endSwitch.replaceTrackReference(track2, t2);\n                        t2.switchAtTheEnd = endSwitch;\n                     } else if (endSwitch instanceof Track) {\n                        // If it's a track, update the track reference\n                        if (endSwitch.switchAtTheEnd === track2) {\n                           endSwitch.switchAtTheEnd = t2;\n                        } else if (endSwitch.switchAtTheStart === track2) {\n                           endSwitch.switchAtTheStart = t2; //Ich glaube das ist nicht nötig\n                        }\n                        t2.switchAtTheEnd = endSwitch;\n                     }\n                  }\n\n                  // Remove the original track\n                  _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(Track.allTracks, track2);\n                  _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(remainingTracks, track2);\n\n                  // Add new tracks\n                  new_tracks.push(t1, t2);\n\n                  // Reassign signals to the appropriate new track\n                  signals_on_track.forEach((signal) => {\n                     if (signal._positioning.km < km) {\n                        signal.setTrack(t1, signal._positioning.km);\n                     } else {\n                        signal.setTrack(t2, signal._positioning.km - km);\n                     }\n                  });\n\n                  remainingTracks.push(t1, t2);\n                  skip = true;\n               }\n            }\n         }\n      }\n\n      // Add all new tracks to the global tracks array\n      Track.allTracks.push(...new_tracks);\n   }\n\n   static cleanUpTracks() {\n      let i = 0;\n      while (i < Track.allTracks.length) {\n         const track = Track.allTracks[i];\n\n         //searches for every track wich starts or end at that point, filters tracks wich would combine to a 90° angle\n         const connected_tracks = Track.allTracks.filter(\n            (t) => t != track && (t.start.equals(track.end) || t.end.equals(track.end))\n         );\n\n         if (connected_tracks.length == 1 && connected_tracks[0].rad == track.rad) {\n            Track.joinTrack(track, connected_tracks[0]);\n            _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(Track.allTracks, connected_tracks[0]);\n         } else i++;\n      }\n   }\n\n   static createSwitches() {\n      const processedPoints = new Set();\n\n      Track.allTracks.forEach((track) => {\n         const end_point = track.end;\n         if (!processedPoints.has(end_point)) {\n            _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.updateSwitchAtPoint(end_point);\n            processedPoints.add(end_point);\n         }\n\n         const start_point = track.start;\n         if (!processedPoints.has(start_point)) {\n            _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.updateSwitchAtPoint(start_point);\n            processedPoints.add(start_point);\n         }\n      });\n   }\n\n   static removeTrack(track) {\n      // Get switches before removing the track\n      const startSwitch = track.switchAtTheStart;\n      const endSwitch = track.switchAtTheEnd;\n\n      // Remove track from allTracks array\n      _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(Track.allTracks, track);\n\n      if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_0__.type)(track.switchAtTheStart) == \"Track\") track.switchAtTheStart.switchAtTheEnd = null;\n      if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_0__.type)(track.switchAtTheEnd) == \"Track\") track.switchAtTheEnd.switchAtTheStart = null;\n      \n      // Update switches at the former track's endpoints\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.updateSwitchAtPoint(track.start, startSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch ? startSwitch : null);\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.updateSwitchAtPoint(track.end, endSwitch instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch ? endSwitch : null);\n\n      // Remove any signals on the track\n      track.signals.forEach((signal) => {\n         _utils_js__WEBPACK_IMPORTED_MODULE_3__.ArrayUtils.remove(_signal_js__WEBPACK_IMPORTED_MODULE_2__.Signal.allSignals, signal);\n      });\n   }\n\n   static createRailNetwork() {\n      Track.splitTracksAtIntersections();\n      Track.cleanUpTracks();\n      Track.createSwitches();\n   }\n\n   #_start = null;\n   #_end = null;\n   signals = [];\n\n   switches = [null, null];\n   id = 0;\n\n   // Vector calculations (moved from TrackNode)\n   #_vector = null;\n   #_rad = null;\n   #_deg = null;\n   #_length = null;\n   #_unit = null;\n   #_slope = null;\n   #_sin = null;\n   #_cos = null;\n\n   get id() {\n      return this.id;\n   }\n\n   get start() {\n      return this.#_start;\n   }\n\n   get end() {\n      return this.#_end;\n   }\n\n   get vector() {\n      if (!this.#_vector) {\n         this.#_vector = {\n            x: this.#_end.x - this.#_start.x,\n            y: this.#_end.y - this.#_start.y,\n         };\n      }\n      return this.#_vector;\n   }\n\n   get rad() {\n      if (!this.#_rad) this.#_rad = Math.atan2(this.vector.y, this.vector.x);\n      return this.#_rad;\n   }\n\n   get deg() {\n      if (!this.#_deg) this.#_deg = this.rad * (180 / Math.PI);\n      return this.#_deg;\n   }\n\n   get length() {\n      if (!this.#_length) this.#_length = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.length(this.vector);\n      return this.#_length;\n   }\n\n   get unit() {\n      if (!this.#_unit) this.#_unit = new _tools_js__WEBPACK_IMPORTED_MODULE_0__.V2(_tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.unit(this.vector, this.length));\n      return this.#_unit;\n   }\n\n   get slope() {\n      return this.#_slope ? this.#_slope : (this.#_slope = this.vector.y / this.vector.x);\n   }\n\n   get sin() {\n      if (!this.#_sin) this.#_sin = Math.sin(this.rad);\n      return this.#_sin;\n   }\n\n   get cos() {\n      if (!this.#_cos) this.#_cos = Math.cos(this.rad);\n      return this.#_cos;\n   }\n\n   #resetCache() {\n      this.#_vector = null;\n      this.#_rad = null;\n      this.#_deg = null;\n      this.#_length = null;\n      this.#_unit = null;\n      this.#_slope = null;\n      this.#_sin = null;\n      this.#_cos = null;\n   }\n\n   get switches() {\n      return this.switches;\n   }\n\n   get switchAtTheEnd() {\n      return this.switches[1];\n   }\n\n   set switchAtTheEnd(value) {\n      this.switches[1] = value;\n   }\n\n   get switchAtTheStart() {\n      return this.switches[0];\n   }\n\n   set switchAtTheStart(value) {\n      this.switches[0] = value;\n   }\n\n   constructor(start, end) {\n      if (!start || !end) throw new Error(\"Track must have start and end points\");\n      this.id = Track._getID();\n\n      if (start instanceof _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point) this.#_start = start;\n      else this.#_start = new _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point(start.x, start.y);\n\n      if (end instanceof _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point) this.#_end = end;\n      else this.#_end = new _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point(end.x, end.y);\n   }\n\n   //returns the Point\n   getPointFromKm(km) {\n      if (km < 0 || km > this.length) {\n         throw new Error(\"Km exceeds track length\");\n      }\n      const point = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.add(this.start, _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.multiply(this.unit, km));\n      return point;\n   }\n\n   getKmfromPoint(p) {\n      if (p.equals(this.start)) {\n         return 0;\n      }\n\n      if (!_tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.pointOnLine(this.start, this.end, p)) {\n         throw new Error(\"Point is not on the track.\");\n      }\n\n      const distanceOnTrack = _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.distance(this.start, p);\n      return distanceOnTrack;\n   }\n\n   //returns the point, if u go x km from point along the track, so point must be track.start or track.end\n   //the direction is automaticly optained\n   along(point, x) {\n      return _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.add(point, _tools_js__WEBPACK_IMPORTED_MODULE_0__.geometry.multiply(this.unit, x));\n   }\n\n   AddSignal(signal, km, above, flipped) {\n      signal._positioning.km = km;\n      signal._positioning.track = this;\n      signal._positioning.above = above;\n      signal._positioning.flipped = flipped;\n      let i = this.signals.findIndex((s) => km < s._positioning.km);\n      if (i != -1) this.signals.splice(i, 0, signal);\n      else this.signals.push(signal);\n   }\n\n   removeSignal(s) {\n      let i = this.signals.indexOf(s);\n      if (i != -1) {\n         this.signals.splice(i, 1);\n      }\n   }\n\n   addSwitch(sw) {\n      // Store switch at index 0 for start position, 1 for end position\n      const isAtEnd = this.end.equals(sw.location);\n      this.switches[isAtEnd ? 1 : 0] = sw;\n   }\n\n   stringify() {\n      const switchData = this.switches.map((s) => {\n         if (!s) return null;\n         return { type: s.constructor.name, id: s.id };\n      });\n      return {\n         _class: \"Track\",\n         id: this.id,\n         start: this.start,\n         end: this.end,\n         signals: this.signals,\n         switches: switchData,\n      };\n   }\n\n   static FromObject(o) {\n      let t = new Track(_tools_js__WEBPACK_IMPORTED_MODULE_0__.Point.fromPoint(o.start), _tools_js__WEBPACK_IMPORTED_MODULE_0__.Point.fromPoint(o.end));\n      t.id = o.id;\n      t.signals = o.signals;\n      t.switches_data = o.switches;\n      t.signals.forEach(function (s) {\n         s._positioning.track = t;\n      });\n      return t;\n   }\n\n   /**\n    * Changes the start point of the track to the new point\n    * @param {Point} newStart - The new start point\n    */\n   setNewStart(newStart) {\n      if (!newStart) return;\n      this.#_start = newStart;\n      this.#resetCache();\n   }\n\n   /**\n    * Changes the end point of the track to the new point\n    * @param {Point} newEnd - The new end point\n    */\n   setNewEnd(newEnd) {\n      if (!newEnd) return;\n      this.#_end = newEnd;\n      this.#resetCache();\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS90cmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTs7QUFFYjtBQUN1RDtBQUNsQjtBQUNBO0FBQ0c7QUFDSDs7QUFFOUI7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFRO0FBQ3hCLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLDhDQUFNO0FBQ2Y7O0FBRUE7QUFDQSxTQUFTLDhDQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsaURBQVUsbUJBQW1CLGlEQUFVLG9CQUFvQixpREFBVSxvQkFBb0IsaURBQVUsbUJBQW1CLGlEQUFVLG1CQUFtQixpREFBVTtBQUN2SztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQVE7QUFDM0IsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrQ0FBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDs7QUFFQTtBQUNBLDJCQUEyQiwrQ0FBUTs7QUFFbkM7QUFDQSxpREFBaUQsOENBQU0sb0NBQW9DLDhDQUFNO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELDhDQUFNO0FBQ3REO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDhDQUFNO0FBQ3BEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpREFBVTtBQUM1QixrQkFBa0IsaURBQVU7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELDhDQUFNO0FBQ3REO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLDhDQUFNO0FBQ3BEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpREFBVTtBQUM1QixrQkFBa0IsaURBQVU7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxpREFBVTtBQUN0QixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBTTtBQUNsQjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxpREFBVTs7QUFFaEIsVUFBVSwrQ0FBSTtBQUNkLFVBQVUsK0NBQUk7QUFDZDtBQUNBO0FBQ0EsTUFBTSw4Q0FBTSx5REFBeUQsOENBQU07QUFDM0UsTUFBTSw4Q0FBTSxxREFBcUQsOENBQU07O0FBRXZFO0FBQ0E7QUFDQSxTQUFTLGlEQUFVLFFBQVEsOENBQU07QUFDakMsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQywrQ0FBUTtBQUNsRDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLHlDQUFFLENBQUMsK0NBQVE7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDRDQUFLO0FBQ2hDLDhCQUE4Qiw0Q0FBSzs7QUFFbkMseUJBQXlCLDRDQUFLO0FBQzlCLDRCQUE0Qiw0Q0FBSztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFRLGlCQUFpQiwrQ0FBUTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTs7QUFFQSw4QkFBOEIsK0NBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtDQUFRLFlBQVksK0NBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDRDQUFLLHFCQUFxQiw0Q0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3RyYWNrLmpzPzZiNzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVTNiBNb2R1bGUgaW1wb3J0c1xuaW1wb3J0IHsgZ2VvbWV0cnksIFYyLCBQb2ludCwgdHlwZSB9IGZyb20gJy4vdG9vbHMuanMnO1xuaW1wb3J0IHsgU3dpdGNoIH0gZnJvbSAnLi9zd2l0Y2guanMnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnLi9zaWduYWwuanMnO1xuaW1wb3J0IHsgQXJyYXlVdGlscyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQ09ORklHIH0gZnJvbSAnLi9jb25maWcuanMnO1xuXG5leHBvcnQgY2xhc3MgVHJhY2sge1xuICAgc3RhdGljIGFsbFRyYWNrcyA9IFtdO1xuXG4gICAvL3RyYWNrIGRyYXdpbmdcbiAgIHN0YXRpYyBpc1ZhbGlkVHJhY2tOb2RlUG9pbnQocCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICB9XG5cbiAgIHN0YXRpYyBmaW5kVHJhY2tieVNpZ25hbChzKSB7XG4gICAgICByZXR1cm4gVHJhY2suYWxsVHJhY2tzLmZpbmQoKHQpID0+IHQuc2lnbmFscy5maW5kKChvKSA9PiBvLmRhdGEgPT0gcykgIT0gdW5kZWZpbmVkKTtcbiAgIH1cbiAgIHN0YXRpYyBmaW5kVHJhY2tCeVBvaW50KHApIHtcbiAgICAgIHJldHVybiBUcmFjay5hbGxUcmFja3MuZmluZCgodHJhY2spID0+IHtcbiAgICAgICAgIHJldHVybiBnZW9tZXRyeS5wb2ludE9uTGluZSh0cmFjay5zdGFydCwgdHJhY2suZW5kLCBwKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBzdGF0aWMgY291bnRlciA9IDA7XG5cbiAgIHN0YXRpYyBfZ2V0SUQoKSB7XG4gICAgICByZXR1cm4gVHJhY2suY291bnRlcisrO1xuICAgfVxuXG4gICBzdGF0aWMgc3BsaXRUcmFja0F0UG9pbnQodHJhY2ssIHBvaW50KSB7XG4gICAgICBjb25zdCB0MSA9IG5ldyBUcmFjayh0cmFjay5zdGFydCwgcG9pbnQpO1xuICAgICAgY29uc3QgdDIgPSBuZXcgVHJhY2socG9pbnQsIHRyYWNrLmVuZCk7XG4gICAgICBjb25zdCBjdXRfa20gPSB0cmFjay5nZXRLbWZyb21Qb2ludChwb2ludCk7XG5cbiAgICAgIHRyYWNrLnNpZ25hbHMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgaWYgKHMuX3Bvc2l0aW9uaW5nLmttIDwgY3V0X2ttKSB7XG4gICAgICAgICAgICBzLl9wb3NpdGlvbmluZy50cmFjayA9IHQxO1xuICAgICAgICAgICAgdDEuQWRkU2lnbmFsKHMpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMuX3Bvc2l0aW9uaW5nLnRyYWNrID0gdDI7XG4gICAgICAgICAgICBzLl9wb3NpdGlvbmluZy5rbSAtPSBjdXRfa207XG4gICAgICAgICAgICB0Mi5BZGRTaWduYWwocyk7XG4gICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFt0MSwgdDJdO1xuICAgfVxuXG4gICBzdGF0aWMgam9pblRyYWNrKHRyYWNrMSwgdHJhY2syKSB7XG4gICAgICBsZXQgY3V0X2ttID0gdHJhY2sxLmxlbmd0aDtcbiAgICAgIHRyYWNrMS5zZXROZXdFbmQodHJhY2syLmVuZCk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3Rpbmcgc3dpdGNoIGJldHdlZW4gdGhlIHR3byB0cmFja3NcbiAgICAgIGlmICh0cmFjazIuc3dpdGNoQXRUaGVTdGFydCkge1xuICAgICAgICAgU3dpdGNoLnJlbW92ZVN3aXRjaCh0cmFjazIuc3dpdGNoQXRUaGVTdGFydCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFjazEuc3dpdGNoQXRUaGVFbmQpIHtcbiAgICAgICAgIFN3aXRjaC5yZW1vdmVTd2l0Y2godHJhY2sxLnN3aXRjaEF0VGhlRW5kKTtcbiAgICAgIH1cblxuICAgICAgdHJhY2syLnNpZ25hbHMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgcy5fcG9zaXRpb25pbmcudHJhY2sgPSB0cmFjazE7XG4gICAgICAgICBzLl9wb3NpdGlvbmluZy5rbSArPSBjdXRfa207XG4gICAgICAgICB0cmFjazEuQWRkU2lnbmFsKHMpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHN0YXRpYyBjaGVja05vZGVzQW5kQ3JlYXRlVHJhY2tzKHBvaW50cykge1xuICAgICAgaWYgKHBvaW50cyA9PSBudWxsIHx8IHBvaW50cy5sZW5ndGggPD0gMSkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBuZXdfdHJhY2tzID0gW107XG5cbiAgICAgIC8vcmV2ZXJzZSB0aGUgcG9pbnRzIGFycmF5IGlmIHRoZSB1c2VyIGRyZXcgaXQgZnJvbSByaWdodCB0byBsZWZ0LCBvciBpZiB0aGUgdXNlciBkcmV3IHN0cmFpZ2h0IGZyb20gYm90dG9tIHRvIHRvcFxuICAgICAgaWYgKEFycmF5VXRpbHMuZmlyc3QocG9pbnRzKS54ID4gQXJyYXlVdGlscy5sYXN0KHBvaW50cykueCB8fCAoQXJyYXlVdGlscy5maXJzdChwb2ludHMpLnggPT0gQXJyYXlVdGlscy5sYXN0KHBvaW50cykueCAmJiBBcnJheVV0aWxzLmZpcnN0KHBvaW50cykueSA+IEFycmF5VXRpbHMubGFzdChwb2ludHMpLnkpKSB7XG4gICAgICAgICBwb2ludHMucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgY3VycmVudF9wb2ludCA9IHBvaW50cy5zaGlmdCgpO1xuICAgICAgbGV0IHRtcF9wb2ludHMgPSBbY3VycmVudF9wb2ludF07XG5cbiAgICAgIC8vaXRlcmF0ZSBvdmVyIGFsbCBwb2ludHMgYW5kIGNyZWF0ZSB0cmFja3NcbiAgICAgIHdoaWxlIChwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgY29uc3QgbmV4dF9wb2ludCA9IHBvaW50cy5zaGlmdCgpO1xuXG4gICAgICAgICAvLyBDaGVjayBpZiB0aGUgbmV3IHNlZ21lbnQgd291bGQgb3ZlcmxhcCB3aXRoIGFueSBleGlzdGluZyB0cmFja1xuICAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdfdHJhY2tzID0gVHJhY2suYWxsVHJhY2tzLmZpbHRlcigodHJhY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZW9tZXRyeS5hcmVTZWdtZW50c092ZXJsYXBwaW5nMkQoY3VycmVudF9wb2ludCwgbmV4dF9wb2ludCwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCk7XG4gICAgICAgICB9KTtcblxuICAgICAgICAgaWYgKG92ZXJsYXBwaW5nX3RyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5vIG92ZXJsYXAsIGNyZWF0ZSBhIG5ldyB0cmFja1xuICAgICAgICAgICAgdG1wX3BvaW50cy5wdXNoKG5leHRfcG9pbnQpO1xuICAgICAgICAgICAgaWYgKHRtcF9wb2ludHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgIG5ld190cmFja3MucHVzaChuZXcgVHJhY2sodG1wX3BvaW50c1swXSwgdG1wX3BvaW50c1sxXSkpO1xuICAgICAgICAgICAgICAgdG1wX3BvaW50cyA9IFtuZXh0X3BvaW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgb3ZlcmxhcHBpbmcgdHJhY2tzXG4gICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ190cmFjayA9IG92ZXJsYXBwaW5nX3RyYWNrc1swXTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBhcnRpYWwgdHJhY2sgYmVmb3JlIHRoZSBvdmVybGFwLCBjcmVhdGUgaXRcbiAgICAgICAgICAgIGlmICh0bXBfcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICBuZXdfdHJhY2tzLnB1c2gobmV3IFRyYWNrKHRtcF9wb2ludHNbMF0sIHRtcF9wb2ludHNbMV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBjcmVhdGUgYSB0cmFjayBmcm9tIHRoZSBsYXN0IHBvaW50IHRvIHRoZSBvdmVybGFwIHBvaW50XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRfcG9pbnQuZXF1YWxzKG92ZXJsYXBwaW5nX3RyYWNrLnN0YXJ0KSAmJiAhY3VycmVudF9wb2ludC5lcXVhbHMob3ZlcmxhcHBpbmdfdHJhY2suZW5kKSkge1xuICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgb3ZlcmxhcCBwb2ludFxuICAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcF9wb2ludCA9IGdlb21ldHJ5LmdldEludGVyc2VjdGlvblBvaW50KFxuICAgICAgICAgICAgICAgICAgY3VycmVudF9wb2ludCxcbiAgICAgICAgICAgICAgICAgIG5leHRfcG9pbnQsXG4gICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ190cmFjay5zdGFydCxcbiAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nX3RyYWNrLmVuZFxuICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBfcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgIG5ld190cmFja3MucHVzaChuZXcgVHJhY2soY3VycmVudF9wb2ludCwgb3ZlcmxhcF9wb2ludCkpO1xuICAgICAgICAgICAgICAgICAgdG1wX3BvaW50cyA9IFtvdmVybGFwX3BvaW50XTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgY3VycmVudF9wb2ludCA9IG5leHRfcG9pbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBmaW5hbCB0cmFjayBpZiB3ZSBoYXZlIHJlbWFpbmluZyBwb2ludHNcbiAgICAgIGlmICh0bXBfcG9pbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICBuZXdfdHJhY2tzLnB1c2gobmV3IFRyYWNrKHRtcF9wb2ludHNbMF0sIHRtcF9wb2ludHNbMV0pKTtcbiAgICAgIH1cblxuICAgICAgVHJhY2suYWxsVHJhY2tzLnB1c2goLi4ubmV3X3RyYWNrcyk7XG5cbiAgICAgIHJldHVybiBuZXdfdHJhY2tzO1xuICAgfVxuXG4gICBzdGF0aWMgc3BsaXRUcmFja3NBdEludGVyc2VjdGlvbnMoKSB7XG4gICAgICBsZXQgaW50ZXJzZWN0aW9uLFxuICAgICAgICAgc2tpcCA9IGZhbHNlLCAvLyB0cnVlIGlmIHRoZSB0cmFjayB3YXMgYWxyZWFkeSBzcGxpdFxuICAgICAgICAgbmV3X3RyYWNrcyA9IFtdLFxuICAgICAgICAgcmVtYWluaW5nVHJhY2tzID0gWy4uLlRyYWNrLmFsbFRyYWNrc107IC8vY29weSBvZiB0aGUgdHJhY2tzLCB3aWxsIGJlIG1vZGlmaWVkIGR1cmluZyB0aGUgbG9vcFxuXG4gICAgICAvL2l0ZXJhdGUgb3ZlciBhbGwgdHJhY2tzIGFuZCBzZWFyY2ggZm9yIGludGVyc2VjdGlvbnNcbiAgICAgIHdoaWxlIChyZW1haW5pbmdUcmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgICAgY29uc3QgdHJhY2sxID0gcmVtYWluaW5nVHJhY2tzLnNoaWZ0KCk7XG5cbiAgICAgICAgIC8vaXRlcmF0ZSBvdmVyIGFsbCByZW1haW5pbmcgdHJhY2tzXG4gICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlbWFpbmluZ1RyYWNrcy5sZW5ndGggJiYgIXNraXA7IGsrKykge1xuICAgICAgICAgICAgY29uc3QgdHJhY2syID0gcmVtYWluaW5nVHJhY2tzW2tdO1xuXG4gICAgICAgICAgICAvLyBHZXQgaW50ZXJzZWN0aW9uIHBvaW50IG9mIHRoZSB0d28gdHJhY2tzXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludCh0cmFjazEsIHRyYWNrMik7XG5cbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGludGVyc2VjdGlvbiBwb2ludCBpcyBvbiB0aGUgZ3JpZFxuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3Rpb24ueCAlIENPTkZJRy5HUklEX1NJWkUgPT0gMCAmJiBpbnRlcnNlY3Rpb24ueSAlIENPTkZJRy5HUklEX1NJWkUgPT0gMCkge1xuICAgICAgICAgICAgICAgLy8gU3BsaXQgdHJhY2sxIGlmIGludGVyc2VjdGlvbiBpcyBub3QgYXQgc3RhcnQgb3IgZW5kXG4gICAgICAgICAgICAgICBpZiAoIWludGVyc2VjdGlvbi5lcXVhbHModHJhY2sxLnN0YXJ0KSAmJiAhaW50ZXJzZWN0aW9uLmVxdWFscyh0cmFjazEuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qga20gPSB0cmFjazEuZ2V0S21mcm9tUG9pbnQoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbHNfb25fdHJhY2sgPSBbLi4udHJhY2sxLnNpZ25hbHNdO1xuXG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdHdvIG5ldyB0cmFja3NcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQxID0gbmV3IFRyYWNrKHRyYWNrMS5zdGFydCwgaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQyID0gbmV3IFRyYWNrKGludGVyc2VjdGlvbiwgdHJhY2sxLmVuZCk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3dpdGNoID0gdHJhY2sxLnN3aXRjaEF0VGhlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhcnRTd2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFN3aXRjaCBpbnN0YW5jZW9mIFN3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTd2l0Y2gucmVwbGFjZVRyYWNrUmVmZXJlbmNlKHRyYWNrMSwgdDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdDEuc3dpdGNoQXRUaGVTdGFydCA9IHN0YXJ0U3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydFN3aXRjaCBpbnN0YW5jZW9mIFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgdHJhY2ssIHVwZGF0ZSB0aGUgdHJhY2sgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPT09IHRyYWNrMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVTdGFydCA9PT0gdHJhY2sxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFN3aXRjaC5zd2l0Y2hBdFRoZVN0YXJ0ID0gdDE7IC8vSWNoIGdsYXViZSBkYXMgaXN0IG5pY2h0IG7DtnRpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdDEuc3dpdGNoQXRUaGVTdGFydCA9IHN0YXJ0U3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY29uc3QgZW5kU3dpdGNoID0gdHJhY2sxLnN3aXRjaEF0VGhlRW5kO1xuICAgICAgICAgICAgICAgICAgaWYgKGVuZFN3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFN3aXRjaCBpbnN0YW5jZW9mIFN3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3dpdGNoLnJlcGxhY2VUcmFja1JlZmVyZW5jZSh0cmFjazEsIHQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQyLnN3aXRjaEF0VGhlRW5kID0gZW5kU3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRTd2l0Y2ggaW5zdGFuY2VvZiBUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIHRyYWNrLCB1cGRhdGUgdGhlIHRyYWNrIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZFN3aXRjaC5zd2l0Y2hBdFRoZUVuZCA9PT0gdHJhY2sxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPSB0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5kU3dpdGNoLnN3aXRjaEF0VGhlU3RhcnQgPT09IHRyYWNrMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3dpdGNoLnN3aXRjaEF0VGhlU3RhcnQgPSB0MjsgLy9JY2ggZ2xhdWJlIGRhcyBpc3QgbmljaHQgbsO2dGlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0Mi5zd2l0Y2hBdFRoZUVuZCA9IGVuZFN3aXRjaDtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcmlnaW5hbCB0cmFja1xuICAgICAgICAgICAgICAgICAgQXJyYXlVdGlscy5yZW1vdmUoVHJhY2suYWxsVHJhY2tzLCB0cmFjazEpO1xuICAgICAgICAgICAgICAgICAgQXJyYXlVdGlscy5yZW1vdmUocmVtYWluaW5nVHJhY2tzLCB0cmFjazEpO1xuXG4gICAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IHRyYWNrc1xuICAgICAgICAgICAgICAgICAgbmV3X3RyYWNrcy5wdXNoKHQxLCB0Mik7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFJlYXNzaWduIHNpZ25hbHMgdG8gdGhlIGFwcHJvcHJpYXRlIG5ldyB0cmFja1xuICAgICAgICAgICAgICAgICAgc2lnbmFsc19vbl90cmFjay5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduYWwuX3Bvc2l0aW9uaW5nLmttIDwga20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5zZXRUcmFjayh0MSwgc2lnbmFsLl9wb3NpdGlvbmluZy5rbSk7XG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldFRyYWNrKHQyLCBzaWduYWwuX3Bvc2l0aW9uaW5nLmttIC0ga20pO1xuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ1RyYWNrcy5wdXNoKHQxLCB0Mik7XG4gICAgICAgICAgICAgICAgICBza2lwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgLy8gU3BsaXQgdHJhY2syIGlmIGludGVyc2VjdGlvbiBpcyBub3QgYXQgc3RhcnQgb3IgZW5kXG4gICAgICAgICAgICAgICBpZiAoIWludGVyc2VjdGlvbi5lcXVhbHModHJhY2syLnN0YXJ0KSAmJiAhaW50ZXJzZWN0aW9uLmVxdWFscyh0cmFjazIuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qga20gPSB0cmFjazIuZ2V0S21mcm9tUG9pbnQoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbHNfb25fdHJhY2sgPSBbLi4udHJhY2syLnNpZ25hbHNdO1xuXG4gICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdHdvIG5ldyB0cmFja3NcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQxID0gbmV3IFRyYWNrKHRyYWNrMi5zdGFydCwgaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHQyID0gbmV3IFRyYWNrKGludGVyc2VjdGlvbiwgdHJhY2syLmVuZCk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3dpdGNoID0gdHJhY2syLnN3aXRjaEF0VGhlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhcnRTd2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydFN3aXRjaCBpbnN0YW5jZW9mIFN3aXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTd2l0Y2gucmVwbGFjZVRyYWNrUmVmZXJlbmNlKHRyYWNrMiwgdDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdDEuc3dpdGNoQXRUaGVTdGFydCA9IHN0YXJ0U3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydFN3aXRjaCBpbnN0YW5jZW9mIFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgdHJhY2ssIHVwZGF0ZSB0aGUgdHJhY2sgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPT09IHRyYWNrMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVFbmQgPSB0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRTd2l0Y2guc3dpdGNoQXRUaGVTdGFydCA9PT0gdHJhY2syKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFN3aXRjaC5zd2l0Y2hBdFRoZVN0YXJ0ID0gdDE7IC8vSWNoIGdsYXViZSBkYXMgaXN0IG5pY2h0IG7DtnRpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdDEuc3dpdGNoQXRUaGVTdGFydCA9IHN0YXJ0U3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBjb25zdCBlbmRTd2l0Y2ggPSB0cmFjazIuc3dpdGNoQXRUaGVFbmQ7XG4gICAgICAgICAgICAgICAgICBpZiAoZW5kU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICBpZiAoZW5kU3dpdGNoIGluc3RhbmNlb2YgU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRTd2l0Y2gucmVwbGFjZVRyYWNrUmVmZXJlbmNlKHRyYWNrMiwgdDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdDIuc3dpdGNoQXRUaGVFbmQgPSBlbmRTd2l0Y2g7XG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZFN3aXRjaCBpbnN0YW5jZW9mIFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgdHJhY2ssIHVwZGF0ZSB0aGUgdHJhY2sgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kU3dpdGNoLnN3aXRjaEF0VGhlRW5kID09PSB0cmFjazIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFN3aXRjaC5zd2l0Y2hBdFRoZUVuZCA9IHQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmRTd2l0Y2guc3dpdGNoQXRUaGVTdGFydCA9PT0gdHJhY2syKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRTd2l0Y2guc3dpdGNoQXRUaGVTdGFydCA9IHQyOyAvL0ljaCBnbGF1YmUgZGFzIGlzdCBuaWNodCBuw7Z0aWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHQyLnN3aXRjaEF0VGhlRW5kID0gZW5kU3dpdGNoO1xuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9yaWdpbmFsIHRyYWNrXG4gICAgICAgICAgICAgICAgICBBcnJheVV0aWxzLnJlbW92ZShUcmFjay5hbGxUcmFja3MsIHRyYWNrMik7XG4gICAgICAgICAgICAgICAgICBBcnJheVV0aWxzLnJlbW92ZShyZW1haW5pbmdUcmFja3MsIHRyYWNrMik7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgdHJhY2tzXG4gICAgICAgICAgICAgICAgICBuZXdfdHJhY2tzLnB1c2godDEsIHQyKTtcblxuICAgICAgICAgICAgICAgICAgLy8gUmVhc3NpZ24gc2lnbmFscyB0byB0aGUgYXBwcm9wcmlhdGUgbmV3IHRyYWNrXG4gICAgICAgICAgICAgICAgICBzaWduYWxzX29uX3RyYWNrLmZvckVhY2goKHNpZ25hbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbC5fcG9zaXRpb25pbmcua20gPCBrbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnNldFRyYWNrKHQxLCBzaWduYWwuX3Bvc2l0aW9uaW5nLmttKTtcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwuc2V0VHJhY2sodDIsIHNpZ25hbC5fcG9zaXRpb25pbmcua20gLSBrbSk7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgcmVtYWluaW5nVHJhY2tzLnB1c2godDEsIHQyKTtcbiAgICAgICAgICAgICAgICAgIHNraXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYWxsIG5ldyB0cmFja3MgdG8gdGhlIGdsb2JhbCB0cmFja3MgYXJyYXlcbiAgICAgIFRyYWNrLmFsbFRyYWNrcy5wdXNoKC4uLm5ld190cmFja3MpO1xuICAgfVxuXG4gICBzdGF0aWMgY2xlYW5VcFRyYWNrcygpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgVHJhY2suYWxsVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgY29uc3QgdHJhY2sgPSBUcmFjay5hbGxUcmFja3NbaV07XG5cbiAgICAgICAgIC8vc2VhcmNoZXMgZm9yIGV2ZXJ5IHRyYWNrIHdpY2ggc3RhcnRzIG9yIGVuZCBhdCB0aGF0IHBvaW50LCBmaWx0ZXJzIHRyYWNrcyB3aWNoIHdvdWxkIGNvbWJpbmUgdG8gYSA5MMKwIGFuZ2xlXG4gICAgICAgICBjb25zdCBjb25uZWN0ZWRfdHJhY2tzID0gVHJhY2suYWxsVHJhY2tzLmZpbHRlcihcbiAgICAgICAgICAgICh0KSA9PiB0ICE9IHRyYWNrICYmICh0LnN0YXJ0LmVxdWFscyh0cmFjay5lbmQpIHx8IHQuZW5kLmVxdWFscyh0cmFjay5lbmQpKVxuICAgICAgICAgKTtcblxuICAgICAgICAgaWYgKGNvbm5lY3RlZF90cmFja3MubGVuZ3RoID09IDEgJiYgY29ubmVjdGVkX3RyYWNrc1swXS5yYWQgPT0gdHJhY2sucmFkKSB7XG4gICAgICAgICAgICBUcmFjay5qb2luVHJhY2sodHJhY2ssIGNvbm5lY3RlZF90cmFja3NbMF0pO1xuICAgICAgICAgICAgQXJyYXlVdGlscy5yZW1vdmUoVHJhY2suYWxsVHJhY2tzLCBjb25uZWN0ZWRfdHJhY2tzWzBdKTtcbiAgICAgICAgIH0gZWxzZSBpKys7XG4gICAgICB9XG4gICB9XG5cbiAgIHN0YXRpYyBjcmVhdGVTd2l0Y2hlcygpIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZFBvaW50cyA9IG5ldyBTZXQoKTtcblxuICAgICAgVHJhY2suYWxsVHJhY2tzLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICBjb25zdCBlbmRfcG9pbnQgPSB0cmFjay5lbmQ7XG4gICAgICAgICBpZiAoIXByb2Nlc3NlZFBvaW50cy5oYXMoZW5kX3BvaW50KSkge1xuICAgICAgICAgICAgU3dpdGNoLnVwZGF0ZVN3aXRjaEF0UG9pbnQoZW5kX3BvaW50KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZFBvaW50cy5hZGQoZW5kX3BvaW50KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgY29uc3Qgc3RhcnRfcG9pbnQgPSB0cmFjay5zdGFydDtcbiAgICAgICAgIGlmICghcHJvY2Vzc2VkUG9pbnRzLmhhcyhzdGFydF9wb2ludCkpIHtcbiAgICAgICAgICAgIFN3aXRjaC51cGRhdGVTd2l0Y2hBdFBvaW50KHN0YXJ0X3BvaW50KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZFBvaW50cy5hZGQoc3RhcnRfcG9pbnQpO1xuICAgICAgICAgfVxuICAgICAgfSk7XG4gICB9XG5cbiAgIHN0YXRpYyByZW1vdmVUcmFjayh0cmFjaykge1xuICAgICAgLy8gR2V0IHN3aXRjaGVzIGJlZm9yZSByZW1vdmluZyB0aGUgdHJhY2tcbiAgICAgIGNvbnN0IHN0YXJ0U3dpdGNoID0gdHJhY2suc3dpdGNoQXRUaGVTdGFydDtcbiAgICAgIGNvbnN0IGVuZFN3aXRjaCA9IHRyYWNrLnN3aXRjaEF0VGhlRW5kO1xuXG4gICAgICAvLyBSZW1vdmUgdHJhY2sgZnJvbSBhbGxUcmFja3MgYXJyYXlcbiAgICAgIEFycmF5VXRpbHMucmVtb3ZlKFRyYWNrLmFsbFRyYWNrcywgdHJhY2spO1xuXG4gICAgICBpZiAodHlwZSh0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0KSA9PSBcIlRyYWNrXCIpIHRyYWNrLnN3aXRjaEF0VGhlU3RhcnQuc3dpdGNoQXRUaGVFbmQgPSBudWxsO1xuICAgICAgaWYgKHR5cGUodHJhY2suc3dpdGNoQXRUaGVFbmQpID09IFwiVHJhY2tcIikgdHJhY2suc3dpdGNoQXRUaGVFbmQuc3dpdGNoQXRUaGVTdGFydCA9IG51bGw7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzd2l0Y2hlcyBhdCB0aGUgZm9ybWVyIHRyYWNrJ3MgZW5kcG9pbnRzXG4gICAgICBTd2l0Y2gudXBkYXRlU3dpdGNoQXRQb2ludCh0cmFjay5zdGFydCwgc3RhcnRTd2l0Y2ggaW5zdGFuY2VvZiBTd2l0Y2ggPyBzdGFydFN3aXRjaCA6IG51bGwpO1xuICAgICAgU3dpdGNoLnVwZGF0ZVN3aXRjaEF0UG9pbnQodHJhY2suZW5kLCBlbmRTd2l0Y2ggaW5zdGFuY2VvZiBTd2l0Y2ggPyBlbmRTd2l0Y2ggOiBudWxsKTtcblxuICAgICAgLy8gUmVtb3ZlIGFueSBzaWduYWxzIG9uIHRoZSB0cmFja1xuICAgICAgdHJhY2suc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgIEFycmF5VXRpbHMucmVtb3ZlKFNpZ25hbC5hbGxTaWduYWxzLCBzaWduYWwpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHN0YXRpYyBjcmVhdGVSYWlsTmV0d29yaygpIHtcbiAgICAgIFRyYWNrLnNwbGl0VHJhY2tzQXRJbnRlcnNlY3Rpb25zKCk7XG4gICAgICBUcmFjay5jbGVhblVwVHJhY2tzKCk7XG4gICAgICBUcmFjay5jcmVhdGVTd2l0Y2hlcygpO1xuICAgfVxuXG4gICAjX3N0YXJ0ID0gbnVsbDtcbiAgICNfZW5kID0gbnVsbDtcbiAgIHNpZ25hbHMgPSBbXTtcblxuICAgc3dpdGNoZXMgPSBbbnVsbCwgbnVsbF07XG4gICBpZCA9IDA7XG5cbiAgIC8vIFZlY3RvciBjYWxjdWxhdGlvbnMgKG1vdmVkIGZyb20gVHJhY2tOb2RlKVxuICAgI192ZWN0b3IgPSBudWxsO1xuICAgI19yYWQgPSBudWxsO1xuICAgI19kZWcgPSBudWxsO1xuICAgI19sZW5ndGggPSBudWxsO1xuICAgI191bml0ID0gbnVsbDtcbiAgICNfc2xvcGUgPSBudWxsO1xuICAgI19zaW4gPSBudWxsO1xuICAgI19jb3MgPSBudWxsO1xuXG4gICBnZXQgaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZDtcbiAgIH1cblxuICAgZ2V0IHN0YXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19zdGFydDtcbiAgIH1cblxuICAgZ2V0IGVuZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiNfZW5kO1xuICAgfVxuXG4gICBnZXQgdmVjdG9yKCkge1xuICAgICAgaWYgKCF0aGlzLiNfdmVjdG9yKSB7XG4gICAgICAgICB0aGlzLiNfdmVjdG9yID0ge1xuICAgICAgICAgICAgeDogdGhpcy4jX2VuZC54IC0gdGhpcy4jX3N0YXJ0LngsXG4gICAgICAgICAgICB5OiB0aGlzLiNfZW5kLnkgLSB0aGlzLiNfc3RhcnQueSxcbiAgICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jX3ZlY3RvcjtcbiAgIH1cblxuICAgZ2V0IHJhZCgpIHtcbiAgICAgIGlmICghdGhpcy4jX3JhZCkgdGhpcy4jX3JhZCA9IE1hdGguYXRhbjIodGhpcy52ZWN0b3IueSwgdGhpcy52ZWN0b3IueCk7XG4gICAgICByZXR1cm4gdGhpcy4jX3JhZDtcbiAgIH1cblxuICAgZ2V0IGRlZygpIHtcbiAgICAgIGlmICghdGhpcy4jX2RlZykgdGhpcy4jX2RlZyA9IHRoaXMucmFkICogKDE4MCAvIE1hdGguUEkpO1xuICAgICAgcmV0dXJuIHRoaXMuI19kZWc7XG4gICB9XG5cbiAgIGdldCBsZW5ndGgoKSB7XG4gICAgICBpZiAoIXRoaXMuI19sZW5ndGgpIHRoaXMuI19sZW5ndGggPSBnZW9tZXRyeS5sZW5ndGgodGhpcy52ZWN0b3IpO1xuICAgICAgcmV0dXJuIHRoaXMuI19sZW5ndGg7XG4gICB9XG5cbiAgIGdldCB1bml0KCkge1xuICAgICAgaWYgKCF0aGlzLiNfdW5pdCkgdGhpcy4jX3VuaXQgPSBuZXcgVjIoZ2VvbWV0cnkudW5pdCh0aGlzLnZlY3RvciwgdGhpcy5sZW5ndGgpKTtcbiAgICAgIHJldHVybiB0aGlzLiNfdW5pdDtcbiAgIH1cblxuICAgZ2V0IHNsb3BlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuI19zbG9wZSA/IHRoaXMuI19zbG9wZSA6ICh0aGlzLiNfc2xvcGUgPSB0aGlzLnZlY3Rvci55IC8gdGhpcy52ZWN0b3IueCk7XG4gICB9XG5cbiAgIGdldCBzaW4oKSB7XG4gICAgICBpZiAoIXRoaXMuI19zaW4pIHRoaXMuI19zaW4gPSBNYXRoLnNpbih0aGlzLnJhZCk7XG4gICAgICByZXR1cm4gdGhpcy4jX3NpbjtcbiAgIH1cblxuICAgZ2V0IGNvcygpIHtcbiAgICAgIGlmICghdGhpcy4jX2NvcykgdGhpcy4jX2NvcyA9IE1hdGguY29zKHRoaXMucmFkKTtcbiAgICAgIHJldHVybiB0aGlzLiNfY29zO1xuICAgfVxuXG4gICAjcmVzZXRDYWNoZSgpIHtcbiAgICAgIHRoaXMuI192ZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy4jX3JhZCA9IG51bGw7XG4gICAgICB0aGlzLiNfZGVnID0gbnVsbDtcbiAgICAgIHRoaXMuI19sZW5ndGggPSBudWxsO1xuICAgICAgdGhpcy4jX3VuaXQgPSBudWxsO1xuICAgICAgdGhpcy4jX3Nsb3BlID0gbnVsbDtcbiAgICAgIHRoaXMuI19zaW4gPSBudWxsO1xuICAgICAgdGhpcy4jX2NvcyA9IG51bGw7XG4gICB9XG5cbiAgIGdldCBzd2l0Y2hlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN3aXRjaGVzO1xuICAgfVxuXG4gICBnZXQgc3dpdGNoQXRUaGVFbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zd2l0Y2hlc1sxXTtcbiAgIH1cblxuICAgc2V0IHN3aXRjaEF0VGhlRW5kKHZhbHVlKSB7XG4gICAgICB0aGlzLnN3aXRjaGVzWzFdID0gdmFsdWU7XG4gICB9XG5cbiAgIGdldCBzd2l0Y2hBdFRoZVN0YXJ0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3dpdGNoZXNbMF07XG4gICB9XG5cbiAgIHNldCBzd2l0Y2hBdFRoZVN0YXJ0KHZhbHVlKSB7XG4gICAgICB0aGlzLnN3aXRjaGVzWzBdID0gdmFsdWU7XG4gICB9XG5cbiAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmICghc3RhcnQgfHwgIWVuZCkgdGhyb3cgbmV3IEVycm9yKFwiVHJhY2sgbXVzdCBoYXZlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXCIpO1xuICAgICAgdGhpcy5pZCA9IFRyYWNrLl9nZXRJRCgpO1xuXG4gICAgICBpZiAoc3RhcnQgaW5zdGFuY2VvZiBQb2ludCkgdGhpcy4jX3N0YXJ0ID0gc3RhcnQ7XG4gICAgICBlbHNlIHRoaXMuI19zdGFydCA9IG5ldyBQb2ludChzdGFydC54LCBzdGFydC55KTtcblxuICAgICAgaWYgKGVuZCBpbnN0YW5jZW9mIFBvaW50KSB0aGlzLiNfZW5kID0gZW5kO1xuICAgICAgZWxzZSB0aGlzLiNfZW5kID0gbmV3IFBvaW50KGVuZC54LCBlbmQueSk7XG4gICB9XG5cbiAgIC8vcmV0dXJucyB0aGUgUG9pbnRcbiAgIGdldFBvaW50RnJvbUttKGttKSB7XG4gICAgICBpZiAoa20gPCAwIHx8IGttID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkttIGV4Y2VlZHMgdHJhY2sgbGVuZ3RoXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnQgPSBnZW9tZXRyeS5hZGQodGhpcy5zdGFydCwgZ2VvbWV0cnkubXVsdGlwbHkodGhpcy51bml0LCBrbSkpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgfVxuXG4gICBnZXRLbWZyb21Qb2ludChwKSB7XG4gICAgICBpZiAocC5lcXVhbHModGhpcy5zdGFydCkpIHtcbiAgICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdlb21ldHJ5LnBvaW50T25MaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kLCBwKSkge1xuICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9pbnQgaXMgbm90IG9uIHRoZSB0cmFjay5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpc3RhbmNlT25UcmFjayA9IGdlb21ldHJ5LmRpc3RhbmNlKHRoaXMuc3RhcnQsIHApO1xuICAgICAgcmV0dXJuIGRpc3RhbmNlT25UcmFjaztcbiAgIH1cblxuICAgLy9yZXR1cm5zIHRoZSBwb2ludCwgaWYgdSBnbyB4IGttIGZyb20gcG9pbnQgYWxvbmcgdGhlIHRyYWNrLCBzbyBwb2ludCBtdXN0IGJlIHRyYWNrLnN0YXJ0IG9yIHRyYWNrLmVuZFxuICAgLy90aGUgZGlyZWN0aW9uIGlzIGF1dG9tYXRpY2x5IG9wdGFpbmVkXG4gICBhbG9uZyhwb2ludCwgeCkge1xuICAgICAgcmV0dXJuIGdlb21ldHJ5LmFkZChwb2ludCwgZ2VvbWV0cnkubXVsdGlwbHkodGhpcy51bml0LCB4KSk7XG4gICB9XG5cbiAgIEFkZFNpZ25hbChzaWduYWwsIGttLCBhYm92ZSwgZmxpcHBlZCkge1xuICAgICAgc2lnbmFsLl9wb3NpdGlvbmluZy5rbSA9IGttO1xuICAgICAgc2lnbmFsLl9wb3NpdGlvbmluZy50cmFjayA9IHRoaXM7XG4gICAgICBzaWduYWwuX3Bvc2l0aW9uaW5nLmFib3ZlID0gYWJvdmU7XG4gICAgICBzaWduYWwuX3Bvc2l0aW9uaW5nLmZsaXBwZWQgPSBmbGlwcGVkO1xuICAgICAgbGV0IGkgPSB0aGlzLnNpZ25hbHMuZmluZEluZGV4KChzKSA9PiBrbSA8IHMuX3Bvc2l0aW9uaW5nLmttKTtcbiAgICAgIGlmIChpICE9IC0xKSB0aGlzLnNpZ25hbHMuc3BsaWNlKGksIDAsIHNpZ25hbCk7XG4gICAgICBlbHNlIHRoaXMuc2lnbmFscy5wdXNoKHNpZ25hbCk7XG4gICB9XG5cbiAgIHJlbW92ZVNpZ25hbChzKSB7XG4gICAgICBsZXQgaSA9IHRoaXMuc2lnbmFscy5pbmRleE9mKHMpO1xuICAgICAgaWYgKGkgIT0gLTEpIHtcbiAgICAgICAgIHRoaXMuc2lnbmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICB9XG5cbiAgIGFkZFN3aXRjaChzdykge1xuICAgICAgLy8gU3RvcmUgc3dpdGNoIGF0IGluZGV4IDAgZm9yIHN0YXJ0IHBvc2l0aW9uLCAxIGZvciBlbmQgcG9zaXRpb25cbiAgICAgIGNvbnN0IGlzQXRFbmQgPSB0aGlzLmVuZC5lcXVhbHMoc3cubG9jYXRpb24pO1xuICAgICAgdGhpcy5zd2l0Y2hlc1tpc0F0RW5kID8gMSA6IDBdID0gc3c7XG4gICB9XG5cbiAgIHN0cmluZ2lmeSgpIHtcbiAgICAgIGNvbnN0IHN3aXRjaERhdGEgPSB0aGlzLnN3aXRjaGVzLm1hcCgocykgPT4ge1xuICAgICAgICAgaWYgKCFzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgIHJldHVybiB7IHR5cGU6IHMuY29uc3RydWN0b3IubmFtZSwgaWQ6IHMuaWQgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIF9jbGFzczogXCJUcmFja1wiLFxuICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgICAgIGVuZDogdGhpcy5lbmQsXG4gICAgICAgICBzaWduYWxzOiB0aGlzLnNpZ25hbHMsXG4gICAgICAgICBzd2l0Y2hlczogc3dpdGNoRGF0YSxcbiAgICAgIH07XG4gICB9XG5cbiAgIHN0YXRpYyBGcm9tT2JqZWN0KG8pIHtcbiAgICAgIGxldCB0ID0gbmV3IFRyYWNrKFBvaW50LmZyb21Qb2ludChvLnN0YXJ0KSwgUG9pbnQuZnJvbVBvaW50KG8uZW5kKSk7XG4gICAgICB0LmlkID0gby5pZDtcbiAgICAgIHQuc2lnbmFscyA9IG8uc2lnbmFscztcbiAgICAgIHQuc3dpdGNoZXNfZGF0YSA9IG8uc3dpdGNoZXM7XG4gICAgICB0LnNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgcy5fcG9zaXRpb25pbmcudHJhY2sgPSB0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdDtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGFuZ2VzIHRoZSBzdGFydCBwb2ludCBvZiB0aGUgdHJhY2sgdG8gdGhlIG5ldyBwb2ludFxuICAgICogQHBhcmFtIHtQb2ludH0gbmV3U3RhcnQgLSBUaGUgbmV3IHN0YXJ0IHBvaW50XG4gICAgKi9cbiAgIHNldE5ld1N0YXJ0KG5ld1N0YXJ0KSB7XG4gICAgICBpZiAoIW5ld1N0YXJ0KSByZXR1cm47XG4gICAgICB0aGlzLiNfc3RhcnQgPSBuZXdTdGFydDtcbiAgICAgIHRoaXMuI3Jlc2V0Q2FjaGUoKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBDaGFuZ2VzIHRoZSBlbmQgcG9pbnQgb2YgdGhlIHRyYWNrIHRvIHRoZSBuZXcgcG9pbnRcbiAgICAqIEBwYXJhbSB7UG9pbnR9IG5ld0VuZCAtIFRoZSBuZXcgZW5kIHBvaW50XG4gICAgKi9cbiAgIHNldE5ld0VuZChuZXdFbmQpIHtcbiAgICAgIGlmICghbmV3RW5kKSByZXR1cm47XG4gICAgICB0aGlzLiNfZW5kID0gbmV3RW5kO1xuICAgICAgdGhpcy4jcmVzZXRDYWNoZSgpO1xuICAgfVxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/track.js\n\n}");

/***/ }),

/***/ "./www/code/trackRendering_basic.js":
/*!******************************************!*\
  !*** ./www/code/trackRendering_basic.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trackRendering_basic: () => (/* binding */ trackRendering_basic)\n/* harmony export */ });\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _application_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./application.js */ \"./www/code/application.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\n\nclass trackRendering_basic {\n   static TRACK_COLOR = \"#111111\";\n   static SWITCH_UI_COLOR = \"gray\";\n   static SWITCH_UI_COLOR_SELECTED = \"#eee\";\n   static STROKE = 6;\n   static HIT_TEST_DISTANCE = 10;\n   static BUMPER_SIZE = 8;\n   static SWITCH_SIZE = 30;\n\n   constructor() {\n      this.SIGNAL_DISTANCE_FROM_TRACK = 18;\n      this.app = _application_js__WEBPACK_IMPORTED_MODULE_7__.Application.getInstance();\n   }\n\n   reDrawEverything() {\n      this.app.containers.tracks.removeAllChildren();\n      this.app.containers.signals.removeAllChildren();\n      this.app.containers.trains.removeAllChildren();\n      this.app.containers.ui.removeAllChildren();\n      this.app.containers.debug.removeAllChildren();\n      this.app.containers.objects.removeAllChildren();\n\n      this.renderAllTracks();\n      this.renderAllSwitches();\n      this.renderAllGenericObjects();\n      this.renderAllSignals();\n      this.app.stage.update();\n   }\n\n   renderAllSignals() {\n      this.app.containers.signals.removeAllChildren();\n      _signal_js__WEBPACK_IMPORTED_MODULE_2__.Signal.allSignals.forEach((signal) => {\n         let container = this.app.containers.signals.addChild(_signal_js__WEBPACK_IMPORTED_MODULE_2__.SignalRenderer.createSignalContainer(signal));\n         this.app.alignSignalContainerWithTrack(container, signal._positioning);\n         if (this.app.selection.isSelectedObject(signal)) {\n            container.shadow = new createjs.Shadow(\"#ff0000\", 0, 0, 3);\n         }\n      });\n   }\n\n   renderAllTracks() {\n      _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks.forEach((t) => {\n         this.renderTrack(this.app.containers.tracks, t);\n      });\n   }\n\n   isSelected(c) {\n      c.color.style = \"#ff0000\";\n   }\n\n   updateSelection() {\n      this.app.containers.tracks.children.forEach((c) => {\n         if (c.data) {\n            if (this.app.selection.isSelectedObject(c.data)) this.isSelected(c);\n            else c.color.style = trackRendering_basic.TRACK_COLOR;\n         }\n      });\n      this.app.containers.signals.children.forEach(function (c) {\n         if (c.data) {\n            if (this.app.selection.isSelectedObject(c.data)) c.shadow = new createjs.Shadow(\"#ff0000\", 0, 0, 3);\n            else c.shadow = null;\n         }\n      });\n      this.app.stage.update();\n   }\n\n   renderAllGenericObjects() {\n      this.app.containers.objects.removeAllChildren();\n      _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects.forEach((o) => {\n         const c = new createjs.Container();\n         c.name = \"object\";\n         c.object = o;\n         c.mouseChildren = false;\n         c.x = o.pos().x;\n         c.y = o.pos().y;\n\n         if (o.type() === _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.OBJECT_TYPE.text) this.renderTextObject(o, c);\n         else if (o.type() === _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.OBJECT_TYPE.plattform) this.renderPlattformObject(o, c);\n         else throw new Error(\"Unknown Object\");\n\n         this.app.containers.objects.addChild(c);\n      });\n   }\n\n   renderTextObject(text_object, container) {\n      var text = new createjs.Text(text_object.content(), \"20px Arial\", \"#000000\");\n      text.textBaseline = \"alphabetic\";\n      const height = text.getMeasuredHeight();\n      const width = text.getMeasuredWidth();\n\n      const hit = new createjs.Shape();\n      hit.graphics.beginFill(\"#000\").mt(0, 0).lt(width, 0).lt(width, -height).lt(0, -height).lt(0, 0);\n\n      text.hitArea = hit;\n\n      container.addChild(text);\n   }\n\n   renderPlattformObject(plattform, container) {\n      const shape = new createjs.Shape();\n      container.addChild(shape);\n      shape.graphics.beginStroke(\"#111111\").beginFill(\"#444\").drawRect(0, 0, plattform.size().width, plattform.size().height);\n\n      var text = new createjs.Text(plattform.content(), \"20px Arial\", \"#eee\");\n      text.textBaseline = \"middle\";\n      text.textAlign = \"center\";\n      text.x = plattform.size().width / 2;\n      text.y = plattform.size().height / 2;\n\n      container.addChild(text);\n   }\n\n   calculateTrackDrawingParameters(track) {\n      let corr_start = track.start,\n         corr_end = track.end;\n      let bumper_start, bumper_end;\n\n      if (!track.switchAtTheStart) {\n         //prellbock beim start\n         const B1 = track.start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(-trackRendering_basic.BUMPER_SIZE));\n         const B2 = track.start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(trackRendering_basic.BUMPER_SIZE));\n         bumper_start = [B1, B2];\n      } else if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_5__.type)(track.switchAtTheStart) == \"Switch\") {\n         corr_start = track.along(track.switchAtTheStart.location, track.switchAtTheStart.size);\n      }\n\n      if (!track.switchAtTheEnd) {\n         //prellbock beim ende\n         const B1 = track.end.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(-trackRendering_basic.BUMPER_SIZE));\n         const B2 = track.end.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(trackRendering_basic.BUMPER_SIZE));\n         bumper_end = [B1, B2];\n      } else if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_5__.type)(track.switchAtTheEnd) == \"Switch\") {\n         corr_end = track.along(track.switchAtTheEnd.location, -track.switchAtTheEnd.size);\n      }\n\n      const p1 = corr_start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(-trackRendering_basic.HIT_TEST_DISTANCE));\n      const p2 = corr_start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(trackRendering_basic.HIT_TEST_DISTANCE));\n      const p3 = corr_end.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(trackRendering_basic.HIT_TEST_DISTANCE));\n      const p4 = corr_end.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(-trackRendering_basic.HIT_TEST_DISTANCE));\n      return {\n         hit_area: [p1, p2, p3, p4],\n         bumper: [bumper_start, bumper_end],\n         start: corr_start,\n         end: corr_end,\n      };\n   }\n\n   renderTrack(container, track) {\n      let params = this.calculateTrackDrawingParameters(track);\n      let shape = new createjs.Shape();\n      shape.name = \"track\";\n      shape.data = track;\n\n      let hit = new createjs.Shape();\n\n      hit.graphics\n         .beginFill(\"#000\")\n         .mt(params.hit_area[0].x, params.hit_area[0].y)\n         .lt(params.hit_area[1].x, params.hit_area[1].y)\n         .lt(params.hit_area[2].x, params.hit_area[2].y)\n         .lt(params.hit_area[3].x, params.hit_area[3].y)\n         .lt(params.hit_area[0].x, params.hit_area[0].y);\n      shape.hitArea = hit;\n\n      //container.addChild(hit);\n      container.addChild(shape);\n\n      shape.graphics.setStrokeStyle(trackRendering_basic.STROKE, \"round\").beginStroke(trackRendering_basic.TRACK_COLOR);\n      shape.color = shape.graphics.command;\n      shape.graphics.moveTo(params.start.x, params.start.y).lineTo(params.end.x, params.end.y);\n      if (params.bumper[0]) {\n         //prellbock beim start\n         shape.graphics.moveTo(params.bumper[0][0].x, params.bumper[0][0].y).lineTo(params.bumper[0][1].x, params.bumper[0][1].y);\n      }\n\n      if (params.bumper[1]) {\n         //prellbock beim ende\n         shape.graphics.moveTo(params.bumper[1][0].x, params.bumper[1][0].y).lineTo(params.bumper[1][1].x, params.bumper[1][1].y);\n      }\n      if (this.app.selection.isSelectedObject(track)) this.isSelected(shape);\n\n      const text = new createjs.Text(track.id, \"Italic 10px Arial\", \"black\");\n      const p = track.along(track.start, track.length / 2).add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit).multiply(15));\n\n      text.x = p.x;\n      text.y = p.y;\n      text.textBaseline = \"alphabetic\";\n      this.app.containers.ui.addChild(text);\n\n      shape.setBounds(\n         params.start.x - trackRendering_basic.HIT_TEST_DISTANCE,\n         params.start.y - trackRendering_basic.HIT_TEST_DISTANCE,\n         params.end.x - params.start.x + trackRendering_basic.HIT_TEST_DISTANCE * 2,\n         params.end.y - params.start.y + trackRendering_basic.HIT_TEST_DISTANCE * 2\n      );\n\n      return shape;\n   }\n\n   static drawTriangle(graphics, color, p1, p2, p3) {\n      graphics.beginFill(color)\n         .mt(p1.x, p1.y)\n         .lt(p2.x, p2.y)\n         .lt(p3.x, p3.y)\n         .lt(p1.x, p1.y);\n   }\n\n   renderAllSwitches() {\n      _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches.forEach((sw) => {\n         if (!sw.track1 || !sw.track2 || !sw.track3 || (sw.type == _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.DKW && !sw.track4)) {\n            console.log(sw);\n            throw new Error(\"switch is falty\");\n         }\n         let switch_shape = new createjs.Shape();\n         switch_shape.name = \"switch\";\n         switch_shape.data = sw;\n         this.app.containers.tracks.addChild(switch_shape);\n\n         // Draw the switch branch tracks\n         switch_shape.graphics.setStrokeStyle(trackRendering_basic.STROKE, \"round\").beginStroke(trackRendering_basic.TRACK_COLOR);\n\n         // Draw all track branches using a loop\n         const maxTracks = sw.type == _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.DKW ? 4 : 3;\n         for (let i = 0; i < maxTracks; i++) {\n            if (sw.track_directions[i]) {\n               let end_point = sw.getBranchEndPoint(i);\n               switch_shape.graphics.moveTo(sw.location.x, sw.location.y).lineTo(end_point.x, end_point.y);\n            }\n         }\n\n         let p1, p2;\n\n         p1 = sw.getBranchEndPoint(1, trackRendering_basic.SWITCH_SIZE);\n         p2 = sw.getBranchEndPoint(2, trackRendering_basic.SWITCH_SIZE);\n         if (p1 && p2) {\n            trackRendering_basic.drawTriangle(switch_shape.graphics, \"black\", sw.location, p1, p2);\n         }\n\n         if (sw.type == _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.DKW) {\n            p1 = sw.getBranchEndPoint(0, trackRendering_basic.SWITCH_SIZE);\n            p2 = sw.getBranchEndPoint(3, trackRendering_basic.SWITCH_SIZE);\n            if (p1 && p2) {\n               trackRendering_basic.drawTriangle(switch_shape.graphics, \"black\", sw.location, p1, p2);\n            }\n         }\n\n         this.renderSwitchUI(sw);\n      });\n   }\n\n   renderSwitchUI(sw) {\n      // Check if a container already exists for this switch\n      let container = this.app.containers.ui.children.find((c) => c.data === sw);\n\n      if (container) {\n         // If container exists, clear it but keep it\n         container.removeAllChildren();\n      } else {\n         // Create a new container if none exists\n         container = new createjs.Container();\n         container.mouseChildren = false;\n         container.name = \"switch\";\n         container.data = sw;\n         this.app.containers.ui.addChild(container);\n      }\n\n      const ui_shape = new createjs.Shape();\n      ui_shape.graphics.setStrokeStyle(trackRendering_basic.STROKE / 2, \"round\");\n      container.addChild(ui_shape);\n\n      const draw_line = function (t, color) {\n         ui_shape.graphics.beginStroke(color);\n         let p1 = sw.getBranchEndPoint(t, trackRendering_basic.SWITCH_SIZE);\n         let p0 = sw.getBranchEndPoint(t, trackRendering_basic.SWITCH_SIZE / 2);\n         ui_shape.graphics.moveTo(p0.x, p0.y).lineTo(p1.x, p1.y);\n      };\n\n      sw.tracks.forEach((t, i) => {\n         if (t)\n            draw_line(\n               i,\n               t === sw.from || t === sw.branch\n                  ? trackRendering_basic.SWITCH_UI_COLOR_SELECTED\n                  : trackRendering_basic.SWITCH_UI_COLOR\n            );\n      });\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d3cvY29kZS90cmFja1JlbmRlcmluZ19iYXNpYy5qcz8yNmYwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay5qcyc7XG5pbXBvcnQgeyBTd2l0Y2ggfSBmcm9tICcuL3N3aXRjaC5qcyc7XG5pbXBvcnQgeyBTaWduYWwsIFNpZ25hbFJlbmRlcmVyIH0gZnJvbSAnLi9zaWduYWwuanMnO1xuaW1wb3J0IHsgVHJhaW4gfSBmcm9tICcuL3RyYWluLmpzJztcbmltcG9ydCB7IEdlbmVyaWNPYmplY3QgfSBmcm9tICcuL2dlbmVyaWNfb2JqZWN0LmpzJztcbmltcG9ydCB7IGdlb21ldHJ5LCB0eXBlIH0gZnJvbSAnLi90b29scy5qcyc7XG5pbXBvcnQgeyBOdW1iZXJVdGlscyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQXBwbGljYXRpb24gfSBmcm9tICcuL2FwcGxpY2F0aW9uLmpzJztcblxuZXhwb3J0IGNsYXNzIHRyYWNrUmVuZGVyaW5nX2Jhc2ljIHtcbiAgIHN0YXRpYyBUUkFDS19DT0xPUiA9IFwiIzExMTExMVwiO1xuICAgc3RhdGljIFNXSVRDSF9VSV9DT0xPUiA9IFwiZ3JheVwiO1xuICAgc3RhdGljIFNXSVRDSF9VSV9DT0xPUl9TRUxFQ1RFRCA9IFwiI2VlZVwiO1xuICAgc3RhdGljIFNUUk9LRSA9IDY7XG4gICBzdGF0aWMgSElUX1RFU1RfRElTVEFOQ0UgPSAxMDtcbiAgIHN0YXRpYyBCVU1QRVJfU0laRSA9IDg7XG4gICBzdGF0aWMgU1dJVENIX1NJWkUgPSAzMDtcblxuICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLlNJR05BTF9ESVNUQU5DRV9GUk9NX1RSQUNLID0gMTg7XG4gICAgICB0aGlzLmFwcCA9IEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCk7XG4gICB9XG5cbiAgIHJlRHJhd0V2ZXJ5dGhpbmcoKSB7XG4gICAgICB0aGlzLmFwcC5jb250YWluZXJzLnRyYWNrcy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5zaWduYWxzLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICB0aGlzLmFwcC5jb250YWluZXJzLnRyYWlucy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy51aS5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5kZWJ1Zy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5vYmplY3RzLnJlbW92ZUFsbENoaWxkcmVuKCk7XG5cbiAgICAgIHRoaXMucmVuZGVyQWxsVHJhY2tzKCk7XG4gICAgICB0aGlzLnJlbmRlckFsbFN3aXRjaGVzKCk7XG4gICAgICB0aGlzLnJlbmRlckFsbEdlbmVyaWNPYmplY3RzKCk7XG4gICAgICB0aGlzLnJlbmRlckFsbFNpZ25hbHMoKTtcbiAgICAgIHRoaXMuYXBwLnN0YWdlLnVwZGF0ZSgpO1xuICAgfVxuXG4gICByZW5kZXJBbGxTaWduYWxzKCkge1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5zaWduYWxzLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICBTaWduYWwuYWxsU2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmFwcC5jb250YWluZXJzLnNpZ25hbHMuYWRkQ2hpbGQoU2lnbmFsUmVuZGVyZXIuY3JlYXRlU2lnbmFsQ29udGFpbmVyKHNpZ25hbCkpO1xuICAgICAgICAgdGhpcy5hcHAuYWxpZ25TaWduYWxDb250YWluZXJXaXRoVHJhY2soY29udGFpbmVyLCBzaWduYWwuX3Bvc2l0aW9uaW5nKTtcbiAgICAgICAgIGlmICh0aGlzLmFwcC5zZWxlY3Rpb24uaXNTZWxlY3RlZE9iamVjdChzaWduYWwpKSB7XG4gICAgICAgICAgICBjb250YWluZXIuc2hhZG93ID0gbmV3IGNyZWF0ZWpzLlNoYWRvdyhcIiNmZjAwMDBcIiwgMCwgMCwgMyk7XG4gICAgICAgICB9XG4gICAgICB9KTtcbiAgIH1cblxuICAgcmVuZGVyQWxsVHJhY2tzKCkge1xuICAgICAgVHJhY2suYWxsVHJhY2tzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgIHRoaXMucmVuZGVyVHJhY2sodGhpcy5hcHAuY29udGFpbmVycy50cmFja3MsIHQpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIGlzU2VsZWN0ZWQoYykge1xuICAgICAgYy5jb2xvci5zdHlsZSA9IFwiI2ZmMDAwMFwiO1xuICAgfVxuXG4gICB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICB0aGlzLmFwcC5jb250YWluZXJzLnRyYWNrcy5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICBpZiAoYy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHAuc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3QoYy5kYXRhKSkgdGhpcy5pc1NlbGVjdGVkKGMpO1xuICAgICAgICAgICAgZWxzZSBjLmNvbG9yLnN0eWxlID0gdHJhY2tSZW5kZXJpbmdfYmFzaWMuVFJBQ0tfQ09MT1I7XG4gICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXBwLmNvbnRhaW5lcnMuc2lnbmFscy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICBpZiAoYy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHAuc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3QoYy5kYXRhKSkgYy5zaGFkb3cgPSBuZXcgY3JlYXRlanMuU2hhZG93KFwiI2ZmMDAwMFwiLCAwLCAwLCAzKTtcbiAgICAgICAgICAgIGVsc2UgYy5zaGFkb3cgPSBudWxsO1xuICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcC5zdGFnZS51cGRhdGUoKTtcbiAgIH1cblxuICAgcmVuZGVyQWxsR2VuZXJpY09iamVjdHMoKSB7XG4gICAgICB0aGlzLmFwcC5jb250YWluZXJzLm9iamVjdHMucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIEdlbmVyaWNPYmplY3QuYWxsX29iamVjdHMuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgY29uc3QgYyA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgIGMubmFtZSA9IFwib2JqZWN0XCI7XG4gICAgICAgICBjLm9iamVjdCA9IG87XG4gICAgICAgICBjLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgIGMueCA9IG8ucG9zKCkueDtcbiAgICAgICAgIGMueSA9IG8ucG9zKCkueTtcblxuICAgICAgICAgaWYgKG8udHlwZSgpID09PSBHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLnRleHQpIHRoaXMucmVuZGVyVGV4dE9iamVjdChvLCBjKTtcbiAgICAgICAgIGVsc2UgaWYgKG8udHlwZSgpID09PSBHZW5lcmljT2JqZWN0Lk9CSkVDVF9UWVBFLnBsYXR0Zm9ybSkgdGhpcy5yZW5kZXJQbGF0dGZvcm1PYmplY3QobywgYyk7XG4gICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gT2JqZWN0XCIpO1xuXG4gICAgICAgICB0aGlzLmFwcC5jb250YWluZXJzLm9iamVjdHMuYWRkQ2hpbGQoYyk7XG4gICAgICB9KTtcbiAgIH1cblxuICAgcmVuZGVyVGV4dE9iamVjdCh0ZXh0X29iamVjdCwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgdGV4dCA9IG5ldyBjcmVhdGVqcy5UZXh0KHRleHRfb2JqZWN0LmNvbnRlbnQoKSwgXCIyMHB4IEFyaWFsXCIsIFwiIzAwMDAwMFwiKTtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0ZXh0LmdldE1lYXN1cmVkSGVpZ2h0KCk7XG4gICAgICBjb25zdCB3aWR0aCA9IHRleHQuZ2V0TWVhc3VyZWRXaWR0aCgpO1xuXG4gICAgICBjb25zdCBoaXQgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIGhpdC5ncmFwaGljcy5iZWdpbkZpbGwoXCIjMDAwXCIpLm10KDAsIDApLmx0KHdpZHRoLCAwKS5sdCh3aWR0aCwgLWhlaWdodCkubHQoMCwgLWhlaWdodCkubHQoMCwgMCk7XG5cbiAgICAgIHRleHQuaGl0QXJlYSA9IGhpdDtcblxuICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRleHQpO1xuICAgfVxuXG4gICByZW5kZXJQbGF0dGZvcm1PYmplY3QocGxhdHRmb3JtLCBjb250YWluZXIpIHtcbiAgICAgIGNvbnN0IHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICBjb250YWluZXIuYWRkQ2hpbGQoc2hhcGUpO1xuICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5TdHJva2UoXCIjMTExMTExXCIpLmJlZ2luRmlsbChcIiM0NDRcIikuZHJhd1JlY3QoMCwgMCwgcGxhdHRmb3JtLnNpemUoKS53aWR0aCwgcGxhdHRmb3JtLnNpemUoKS5oZWlnaHQpO1xuXG4gICAgICB2YXIgdGV4dCA9IG5ldyBjcmVhdGVqcy5UZXh0KHBsYXR0Zm9ybS5jb250ZW50KCksIFwiMjBweCBBcmlhbFwiLCBcIiNlZWVcIik7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICB0ZXh0LnggPSBwbGF0dGZvcm0uc2l6ZSgpLndpZHRoIC8gMjtcbiAgICAgIHRleHQueSA9IHBsYXR0Zm9ybS5zaXplKCkuaGVpZ2h0IC8gMjtcblxuICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRleHQpO1xuICAgfVxuXG4gICBjYWxjdWxhdGVUcmFja0RyYXdpbmdQYXJhbWV0ZXJzKHRyYWNrKSB7XG4gICAgICBsZXQgY29ycl9zdGFydCA9IHRyYWNrLnN0YXJ0LFxuICAgICAgICAgY29ycl9lbmQgPSB0cmFjay5lbmQ7XG4gICAgICBsZXQgYnVtcGVyX3N0YXJ0LCBidW1wZXJfZW5kO1xuXG4gICAgICBpZiAoIXRyYWNrLnN3aXRjaEF0VGhlU3RhcnQpIHtcbiAgICAgICAgIC8vcHJlbGxib2NrIGJlaW0gc3RhcnRcbiAgICAgICAgIGNvbnN0IEIxID0gdHJhY2suc3RhcnQuYWRkKGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdCkubXVsdGlwbHkoLXRyYWNrUmVuZGVyaW5nX2Jhc2ljLkJVTVBFUl9TSVpFKSk7XG4gICAgICAgICBjb25zdCBCMiA9IHRyYWNrLnN0YXJ0LmFkZChnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKHRyYWNrLnVuaXQpLm11bHRpcGx5KHRyYWNrUmVuZGVyaW5nX2Jhc2ljLkJVTVBFUl9TSVpFKSk7XG4gICAgICAgICBidW1wZXJfc3RhcnQgPSBbQjEsIEIyXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSh0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0KSA9PSBcIlN3aXRjaFwiKSB7XG4gICAgICAgICBjb3JyX3N0YXJ0ID0gdHJhY2suYWxvbmcodHJhY2suc3dpdGNoQXRUaGVTdGFydC5sb2NhdGlvbiwgdHJhY2suc3dpdGNoQXRUaGVTdGFydC5zaXplKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFjay5zd2l0Y2hBdFRoZUVuZCkge1xuICAgICAgICAgLy9wcmVsbGJvY2sgYmVpbSBlbmRlXG4gICAgICAgICBjb25zdCBCMSA9IHRyYWNrLmVuZC5hZGQoZ2VvbWV0cnkucGVycGVuZGljdWxhcih0cmFjay51bml0KS5tdWx0aXBseSgtdHJhY2tSZW5kZXJpbmdfYmFzaWMuQlVNUEVSX1NJWkUpKTtcbiAgICAgICAgIGNvbnN0IEIyID0gdHJhY2suZW5kLmFkZChnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKHRyYWNrLnVuaXQpLm11bHRpcGx5KHRyYWNrUmVuZGVyaW5nX2Jhc2ljLkJVTVBFUl9TSVpFKSk7XG4gICAgICAgICBidW1wZXJfZW5kID0gW0IxLCBCMl07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUodHJhY2suc3dpdGNoQXRUaGVFbmQpID09IFwiU3dpdGNoXCIpIHtcbiAgICAgICAgIGNvcnJfZW5kID0gdHJhY2suYWxvbmcodHJhY2suc3dpdGNoQXRUaGVFbmQubG9jYXRpb24sIC10cmFjay5zd2l0Y2hBdFRoZUVuZC5zaXplKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcDEgPSBjb3JyX3N0YXJ0LmFkZChnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKHRyYWNrLnVuaXQpLm11bHRpcGx5KC10cmFja1JlbmRlcmluZ19iYXNpYy5ISVRfVEVTVF9ESVNUQU5DRSkpO1xuICAgICAgY29uc3QgcDIgPSBjb3JyX3N0YXJ0LmFkZChnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKHRyYWNrLnVuaXQpLm11bHRpcGx5KHRyYWNrUmVuZGVyaW5nX2Jhc2ljLkhJVF9URVNUX0RJU1RBTkNFKSk7XG4gICAgICBjb25zdCBwMyA9IGNvcnJfZW5kLmFkZChnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKHRyYWNrLnVuaXQpLm11bHRpcGx5KHRyYWNrUmVuZGVyaW5nX2Jhc2ljLkhJVF9URVNUX0RJU1RBTkNFKSk7XG4gICAgICBjb25zdCBwNCA9IGNvcnJfZW5kLmFkZChnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKHRyYWNrLnVuaXQpLm11bHRpcGx5KC10cmFja1JlbmRlcmluZ19iYXNpYy5ISVRfVEVTVF9ESVNUQU5DRSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIGhpdF9hcmVhOiBbcDEsIHAyLCBwMywgcDRdLFxuICAgICAgICAgYnVtcGVyOiBbYnVtcGVyX3N0YXJ0LCBidW1wZXJfZW5kXSxcbiAgICAgICAgIHN0YXJ0OiBjb3JyX3N0YXJ0LFxuICAgICAgICAgZW5kOiBjb3JyX2VuZCxcbiAgICAgIH07XG4gICB9XG5cbiAgIHJlbmRlclRyYWNrKGNvbnRhaW5lciwgdHJhY2spIHtcbiAgICAgIGxldCBwYXJhbXMgPSB0aGlzLmNhbGN1bGF0ZVRyYWNrRHJhd2luZ1BhcmFtZXRlcnModHJhY2spO1xuICAgICAgbGV0IHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICBzaGFwZS5uYW1lID0gXCJ0cmFja1wiO1xuICAgICAgc2hhcGUuZGF0YSA9IHRyYWNrO1xuXG4gICAgICBsZXQgaGl0ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cbiAgICAgIGhpdC5ncmFwaGljc1xuICAgICAgICAgLmJlZ2luRmlsbChcIiMwMDBcIilcbiAgICAgICAgIC5tdChwYXJhbXMuaGl0X2FyZWFbMF0ueCwgcGFyYW1zLmhpdF9hcmVhWzBdLnkpXG4gICAgICAgICAubHQocGFyYW1zLmhpdF9hcmVhWzFdLngsIHBhcmFtcy5oaXRfYXJlYVsxXS55KVxuICAgICAgICAgLmx0KHBhcmFtcy5oaXRfYXJlYVsyXS54LCBwYXJhbXMuaGl0X2FyZWFbMl0ueSlcbiAgICAgICAgIC5sdChwYXJhbXMuaGl0X2FyZWFbM10ueCwgcGFyYW1zLmhpdF9hcmVhWzNdLnkpXG4gICAgICAgICAubHQocGFyYW1zLmhpdF9hcmVhWzBdLngsIHBhcmFtcy5oaXRfYXJlYVswXS55KTtcbiAgICAgIHNoYXBlLmhpdEFyZWEgPSBoaXQ7XG5cbiAgICAgIC8vY29udGFpbmVyLmFkZENoaWxkKGhpdCk7XG4gICAgICBjb250YWluZXIuYWRkQ2hpbGQoc2hhcGUpO1xuXG4gICAgICBzaGFwZS5ncmFwaGljcy5zZXRTdHJva2VTdHlsZSh0cmFja1JlbmRlcmluZ19iYXNpYy5TVFJPS0UsIFwicm91bmRcIikuYmVnaW5TdHJva2UodHJhY2tSZW5kZXJpbmdfYmFzaWMuVFJBQ0tfQ09MT1IpO1xuICAgICAgc2hhcGUuY29sb3IgPSBzaGFwZS5ncmFwaGljcy5jb21tYW5kO1xuICAgICAgc2hhcGUuZ3JhcGhpY3MubW92ZVRvKHBhcmFtcy5zdGFydC54LCBwYXJhbXMuc3RhcnQueSkubGluZVRvKHBhcmFtcy5lbmQueCwgcGFyYW1zLmVuZC55KTtcbiAgICAgIGlmIChwYXJhbXMuYnVtcGVyWzBdKSB7XG4gICAgICAgICAvL3ByZWxsYm9jayBiZWltIHN0YXJ0XG4gICAgICAgICBzaGFwZS5ncmFwaGljcy5tb3ZlVG8ocGFyYW1zLmJ1bXBlclswXVswXS54LCBwYXJhbXMuYnVtcGVyWzBdWzBdLnkpLmxpbmVUbyhwYXJhbXMuYnVtcGVyWzBdWzFdLngsIHBhcmFtcy5idW1wZXJbMF1bMV0ueSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuYnVtcGVyWzFdKSB7XG4gICAgICAgICAvL3ByZWxsYm9jayBiZWltIGVuZGVcbiAgICAgICAgIHNoYXBlLmdyYXBoaWNzLm1vdmVUbyhwYXJhbXMuYnVtcGVyWzFdWzBdLngsIHBhcmFtcy5idW1wZXJbMV1bMF0ueSkubGluZVRvKHBhcmFtcy5idW1wZXJbMV1bMV0ueCwgcGFyYW1zLmJ1bXBlclsxXVsxXS55KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFwcC5zZWxlY3Rpb24uaXNTZWxlY3RlZE9iamVjdCh0cmFjaykpIHRoaXMuaXNTZWxlY3RlZChzaGFwZSk7XG5cbiAgICAgIGNvbnN0IHRleHQgPSBuZXcgY3JlYXRlanMuVGV4dCh0cmFjay5pZCwgXCJJdGFsaWMgMTBweCBBcmlhbFwiLCBcImJsYWNrXCIpO1xuICAgICAgY29uc3QgcCA9IHRyYWNrLmFsb25nKHRyYWNrLnN0YXJ0LCB0cmFjay5sZW5ndGggLyAyKS5hZGQoZ2VvbWV0cnkucGVycGVuZGljdWxhcih0cmFjay51bml0KS5tdWx0aXBseSgxNSkpO1xuXG4gICAgICB0ZXh0LnggPSBwLng7XG4gICAgICB0ZXh0LnkgPSBwLnk7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy51aS5hZGRDaGlsZCh0ZXh0KTtcblxuICAgICAgc2hhcGUuc2V0Qm91bmRzKFxuICAgICAgICAgcGFyYW1zLnN0YXJ0LnggLSB0cmFja1JlbmRlcmluZ19iYXNpYy5ISVRfVEVTVF9ESVNUQU5DRSxcbiAgICAgICAgIHBhcmFtcy5zdGFydC55IC0gdHJhY2tSZW5kZXJpbmdfYmFzaWMuSElUX1RFU1RfRElTVEFOQ0UsXG4gICAgICAgICBwYXJhbXMuZW5kLnggLSBwYXJhbXMuc3RhcnQueCArIHRyYWNrUmVuZGVyaW5nX2Jhc2ljLkhJVF9URVNUX0RJU1RBTkNFICogMixcbiAgICAgICAgIHBhcmFtcy5lbmQueSAtIHBhcmFtcy5zdGFydC55ICsgdHJhY2tSZW5kZXJpbmdfYmFzaWMuSElUX1RFU1RfRElTVEFOQ0UgKiAyXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gc2hhcGU7XG4gICB9XG5cbiAgIHN0YXRpYyBkcmF3VHJpYW5nbGUoZ3JhcGhpY3MsIGNvbG9yLCBwMSwgcDIsIHAzKSB7XG4gICAgICBncmFwaGljcy5iZWdpbkZpbGwoY29sb3IpXG4gICAgICAgICAubXQocDEueCwgcDEueSlcbiAgICAgICAgIC5sdChwMi54LCBwMi55KVxuICAgICAgICAgLmx0KHAzLngsIHAzLnkpXG4gICAgICAgICAubHQocDEueCwgcDEueSk7XG4gICB9XG5cbiAgIHJlbmRlckFsbFN3aXRjaGVzKCkge1xuICAgICAgU3dpdGNoLmFsbFN3aXRjaGVzLmZvckVhY2goKHN3KSA9PiB7XG4gICAgICAgICBpZiAoIXN3LnRyYWNrMSB8fCAhc3cudHJhY2syIHx8ICFzdy50cmFjazMgfHwgKHN3LnR5cGUgPT0gU3dpdGNoLlNXSVRDSF9UWVBFLkRLVyAmJiAhc3cudHJhY2s0KSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coc3cpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3dpdGNoIGlzIGZhbHR5XCIpO1xuICAgICAgICAgfVxuICAgICAgICAgbGV0IHN3aXRjaF9zaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICAgc3dpdGNoX3NoYXBlLm5hbWUgPSBcInN3aXRjaFwiO1xuICAgICAgICAgc3dpdGNoX3NoYXBlLmRhdGEgPSBzdztcbiAgICAgICAgIHRoaXMuYXBwLmNvbnRhaW5lcnMudHJhY2tzLmFkZENoaWxkKHN3aXRjaF9zaGFwZSk7XG5cbiAgICAgICAgIC8vIERyYXcgdGhlIHN3aXRjaCBicmFuY2ggdHJhY2tzXG4gICAgICAgICBzd2l0Y2hfc2hhcGUuZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUodHJhY2tSZW5kZXJpbmdfYmFzaWMuU1RST0tFLCBcInJvdW5kXCIpLmJlZ2luU3Ryb2tlKHRyYWNrUmVuZGVyaW5nX2Jhc2ljLlRSQUNLX0NPTE9SKTtcblxuICAgICAgICAgLy8gRHJhdyBhbGwgdHJhY2sgYnJhbmNoZXMgdXNpbmcgYSBsb29wXG4gICAgICAgICBjb25zdCBtYXhUcmFja3MgPSBzdy50eXBlID09IFN3aXRjaC5TV0lUQ0hfVFlQRS5ES1cgPyA0IDogMztcbiAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VHJhY2tzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdy50cmFja19kaXJlY3Rpb25zW2ldKSB7XG4gICAgICAgICAgICAgICBsZXQgZW5kX3BvaW50ID0gc3cuZ2V0QnJhbmNoRW5kUG9pbnQoaSk7XG4gICAgICAgICAgICAgICBzd2l0Y2hfc2hhcGUuZ3JhcGhpY3MubW92ZVRvKHN3LmxvY2F0aW9uLngsIHN3LmxvY2F0aW9uLnkpLmxpbmVUbyhlbmRfcG9pbnQueCwgZW5kX3BvaW50LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICBsZXQgcDEsIHAyO1xuXG4gICAgICAgICBwMSA9IHN3LmdldEJyYW5jaEVuZFBvaW50KDEsIHRyYWNrUmVuZGVyaW5nX2Jhc2ljLlNXSVRDSF9TSVpFKTtcbiAgICAgICAgIHAyID0gc3cuZ2V0QnJhbmNoRW5kUG9pbnQoMiwgdHJhY2tSZW5kZXJpbmdfYmFzaWMuU1dJVENIX1NJWkUpO1xuICAgICAgICAgaWYgKHAxICYmIHAyKSB7XG4gICAgICAgICAgICB0cmFja1JlbmRlcmluZ19iYXNpYy5kcmF3VHJpYW5nbGUoc3dpdGNoX3NoYXBlLmdyYXBoaWNzLCBcImJsYWNrXCIsIHN3LmxvY2F0aW9uLCBwMSwgcDIpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAoc3cudHlwZSA9PSBTd2l0Y2guU1dJVENIX1RZUEUuREtXKSB7XG4gICAgICAgICAgICBwMSA9IHN3LmdldEJyYW5jaEVuZFBvaW50KDAsIHRyYWNrUmVuZGVyaW5nX2Jhc2ljLlNXSVRDSF9TSVpFKTtcbiAgICAgICAgICAgIHAyID0gc3cuZ2V0QnJhbmNoRW5kUG9pbnQoMywgdHJhY2tSZW5kZXJpbmdfYmFzaWMuU1dJVENIX1NJWkUpO1xuICAgICAgICAgICAgaWYgKHAxICYmIHAyKSB7XG4gICAgICAgICAgICAgICB0cmFja1JlbmRlcmluZ19iYXNpYy5kcmF3VHJpYW5nbGUoc3dpdGNoX3NoYXBlLmdyYXBoaWNzLCBcImJsYWNrXCIsIHN3LmxvY2F0aW9uLCBwMSwgcDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLnJlbmRlclN3aXRjaFVJKHN3KTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICByZW5kZXJTd2l0Y2hVSShzdykge1xuICAgICAgLy8gQ2hlY2sgaWYgYSBjb250YWluZXIgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgc3dpdGNoXG4gICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5hcHAuY29udGFpbmVycy51aS5jaGlsZHJlbi5maW5kKChjKSA9PiBjLmRhdGEgPT09IHN3KTtcblxuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgLy8gSWYgY29udGFpbmVyIGV4aXN0cywgY2xlYXIgaXQgYnV0IGtlZXAgaXRcbiAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb250YWluZXIgaWYgbm9uZSBleGlzdHNcbiAgICAgICAgIGNvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgIGNvbnRhaW5lci5tb3VzZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICBjb250YWluZXIubmFtZSA9IFwic3dpdGNoXCI7XG4gICAgICAgICBjb250YWluZXIuZGF0YSA9IHN3O1xuICAgICAgICAgdGhpcy5hcHAuY29udGFpbmVycy51aS5hZGRDaGlsZChjb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1aV9zaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgdWlfc2hhcGUuZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUodHJhY2tSZW5kZXJpbmdfYmFzaWMuU1RST0tFIC8gMiwgXCJyb3VuZFwiKTtcbiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh1aV9zaGFwZSk7XG5cbiAgICAgIGNvbnN0IGRyYXdfbGluZSA9IGZ1bmN0aW9uICh0LCBjb2xvcikge1xuICAgICAgICAgdWlfc2hhcGUuZ3JhcGhpY3MuYmVnaW5TdHJva2UoY29sb3IpO1xuICAgICAgICAgbGV0IHAxID0gc3cuZ2V0QnJhbmNoRW5kUG9pbnQodCwgdHJhY2tSZW5kZXJpbmdfYmFzaWMuU1dJVENIX1NJWkUpO1xuICAgICAgICAgbGV0IHAwID0gc3cuZ2V0QnJhbmNoRW5kUG9pbnQodCwgdHJhY2tSZW5kZXJpbmdfYmFzaWMuU1dJVENIX1NJWkUgLyAyKTtcbiAgICAgICAgIHVpX3NoYXBlLmdyYXBoaWNzLm1vdmVUbyhwMC54LCBwMC55KS5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICB9O1xuXG4gICAgICBzdy50cmFja3MuZm9yRWFjaCgodCwgaSkgPT4ge1xuICAgICAgICAgaWYgKHQpXG4gICAgICAgICAgICBkcmF3X2xpbmUoXG4gICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgdCA9PT0gc3cuZnJvbSB8fCB0ID09PSBzdy5icmFuY2hcbiAgICAgICAgICAgICAgICAgID8gdHJhY2tSZW5kZXJpbmdfYmFzaWMuU1dJVENIX1VJX0NPTE9SX1NFTEVDVEVEXG4gICAgICAgICAgICAgICAgICA6IHRyYWNrUmVuZGVyaW5nX2Jhc2ljLlNXSVRDSF9VSV9DT0xPUlxuICAgICAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgfVxufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/trackRendering_basic.js\n\n}");

/***/ }),

/***/ "./www/code/trackRendering_textured.js":
/*!*********************************************!*\
  !*** ./www/code/trackRendering_textured.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   trackRendering_textured: () => (/* binding */ trackRendering_textured)\n/* harmony export */ });\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _switch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./switch.js */ \"./www/code/switch.js\");\n/* harmony import */ var _signal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./signal.js */ \"./www/code/signal.js\");\n/* harmony import */ var _train_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./train.js */ \"./www/code/train.js\");\n/* harmony import */ var _generic_object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./generic_object.js */ \"./www/code/generic_object.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./config.js */ \"./www/code/config.js\");\n/* harmony import */ var _application_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./application.js */ \"./www/code/application.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\n\n\n\nclass trackRendering_textured {\n   static SWITCH_UI_STROKE = 3;\n   static TRACK_SCALE = 0.3;\n   static signale_scale = 0.5;\n   static SCHWELLEN_VARIANTEN = 24;\n   static CURVATURE_4WAY_SWITCH = 70;\n   static RAILS = [\n      [3.2, \"#222\"],\n      [2.8, \"#999\"],\n      [1.4, \"#eee\"],\n   ];\n\n   // Define sleeper pattern for 4-way switch\n   static FOUR_WAY_SLEEPER_PATTERN = [\n      { offset: 1, length: 1.0 }, // Start straight\n      { offset: 1, length: 1.4 }, // Start straight\n      { offset: 1.1, length: 1.7 }, // Begin transition\n      { offset: 1.2, length: 1.9 }, // Peak of curve\n      { offset: 1.4, length: 1.8 }, // Peak of curve\n      { offset: 1.5, length: 1.7 }, // Curve\n      { offset: 1.7, length: 1.65 }, // Curve\n   ];\n\n   constructor() {\n      this.app = _application_js__WEBPACK_IMPORTED_MODULE_9__.Application.getInstance();\n      //cause the class is been loaded before start.js, we have to hack and calculate this constant here\n      trackRendering_textured.CURVE_RADIUS = _config_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG.GRID_SIZE * 1.21;\n\n      this.SIGNAL_DISTANCE_FROM_TRACK = 45;\n\n      this.LOD = 5;\n      this._lastRenderScale = 0;\n\n      // Cache for sleeper shapes and bitmaps\n      this._sleeperCache = {};\n      this._bitmapCache = new Array(trackRendering_textured.SCHWELLEN_VARIANTEN);\n   }\n\n   cleanUp() {\n      if (this._idleCallback) {\n         if (window.requestIdleCallback) cancelIdleCallback(this._idleCallback);\n         else clearTimeout(this._idleCallback);\n      }\n\n      const myIdleCallback =\n         window.requestIdleCallback ||\n         function (callback) {\n            return setTimeout(callback, 1);\n         };\n\n      this._idleCallback = myIdleCallback(\n         function (r) {\n            if (this.app.containers.tracks.renderedTracks.size == 0 || this._rendering != null) return;\n            const bounds = this.calcCanvasSize();\n\n            // Find tracks that are no longer visible\n            const toBeRemoved = [];\n            this.app.containers.tracks.renderedTracks.forEach((track) => {\n               if (!this.TrackVisible(track, bounds)) {\n                  toBeRemoved.push(track);\n               }\n            });\n\n            // Remove tracks and their associated signals\n            toBeRemoved.forEach((track) => {\n               // Remove associated signals\n               const signalsToBeRemoved = this.app.containers.signals.children.filter(\n                  (cs) => cs.data._positioning.track === track\n               );\n               signalsToBeRemoved.forEach((cs) => {\n                  this.app.containers.signals.removeChild(cs);\n               });\n               // Remove track from rendered set\n               this.app.containers.tracks.renderedTracks.delete(track);\n\n               // Remove track elements from both containers\n               const sleepersToRemove = this.app.containers.tracks.children[0].children.filter((c) => c.data === track);\n               const railsToRemove = this.app.containers.tracks.children[1].children.filter((c) => c.data === track);\n\n               sleepersToRemove.forEach((c) => {\n                  delete c.track;\n                  this.app.containers.tracks.children[0].removeChild(c);\n               });\n\n               railsToRemove.forEach((c) => {\n                  delete c.track;\n                  this.app.containers.tracks.children[1].removeChild(c);\n               });\n            });\n\n            // Clean up sleeper cache if it's getting too large (more than 200 entries)\n            if (Object.keys(this._sleeperCache).length > 200) {\n               this._sleeperCache = {};\n            }\n\n            this._idleCallback = null;\n         }.bind(this)\n      );\n   }\n\n   calcCanvasSize() {\n      const stage = this.app.stage;\n      const width = (stage.canvas.width + _config_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG.GRID_SIZE * 2) / stage.scaleX,\n         height = (stage.canvas.height + _config_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG.GRID_SIZE * 2) / stage.scaleY,\n         x = (-stage.x - _config_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG.GRID_SIZE) / stage.scaleX,\n         y = (-stage.y - _config_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG.GRID_SIZE) / stage.scaleY;\n      return { left: x, top: y, right: x + width, bottom: y + height };\n   }\n\n   ///force=false means, each element decides if it needs to be redrawn. If something global changed,\n   ///like the scale, force needs to be true.\n   /// dont_optimize parameter disables the optimasation to only handle and draw elements inside the viewport\n   /// and disables caching. its used by the export to image functionality\n   reDrawEverything(force = false, dont_optimize = false) {\n      if (!_application_js__WEBPACK_IMPORTED_MODULE_9__.Application.getInstance().preLoader.loaded)\n         //stupid code that should prevent drawing, before the preloader is ready\n         setTimeout(() => {\n            this.reDrawEverything(force, dont_optimize);\n         }, 500);\n      else {\n         const containers = this.app.containers;\n         if (this._rendering == undefined) {\n            try {\n               this._rendering = { dont_optimize: dont_optimize };\n               this._rendering.screen_rectangle = this.calcCanvasSize();\n\n               if (force) {\n                  containers.tracks.removeAllChildren();\n                  containers.signals.removeAllChildren();\n                  containers.ui.removeAllChildren();\n                  containers.trains.removeAllChildren();\n                  containers.objects.removeAllChildren();\n                  containers.debug.removeAllChildren();\n                  containers.selection.removeAllChildren();\n\n                  // Clear the overlay container\n                  containers.overlay.removeAllChildren();\n\n                  this.calcRenderValues();\n               } else {\n                  //if we passed the LOD in either direction we have to rerender the tracks\n                  if (_utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.between(this.LOD, this._lastRenderScale, this.app.stage.scale)) {\n                     this._rendering.lodChanged = true;\n                  }\n               }\n\n               try {\n                  this.renderAllTracks(force);\n                  this.renderAllSignals(force);\n                  this.renderAllTrains();\n                  this.renderAllGenericObjects();\n                  this._lastRenderScale = this.app.stage.scale;\n                  if (!dont_optimize) this.cleanUp();\n               } catch (error) {\n                  console.error(\"Error during rendering:\", error);\n                  throw error;\n               } finally {\n                  delete this._rendering;\n                  this.app.stage.update();\n               }\n            } catch (error) {\n               console.error(\"Critical rendering error:\", error);\n               _ui_js__WEBPACK_IMPORTED_MODULE_7__.ui.showErrorToast(error);\n               // Attempt to recover by clearing rendering state\n               delete this._rendering;\n               throw error;\n            }\n         }\n      }\n   }\n\n   calcRenderValues() {\n      this.schwellenImg = this.app.preLoader.getImage(\"schwellen\");\n      this.bumperImg = this.app.preLoader.getImage(\"bumper\");\n      this.sleepersImgWidth = this.schwellenImg.width / trackRendering_textured.SCHWELLEN_VARIANTEN;\n      this.schwellenHöhe = this.schwellenImg.height * trackRendering_textured.TRACK_SCALE;\n      this.schwellenHöhe_2 = this.schwellenHöhe / 2;\n      this.schwellenBreite = this.sleepersImgWidth * trackRendering_textured.TRACK_SCALE;\n      this.schwellenGap = this.schwellenBreite * 1.1; // distance between the sleepers\n      this.sleeperIntervall = this.schwellenBreite + this.schwellenGap;\n      this.rail_offset = this.schwellenHöhe / 4.7; // distance between the rail and the end of the sleeper\n      this.rail_distance = this.schwellenHöhe_2 - this.rail_offset; // distance between the rail and the center of the track\n\n      this.TRAIN_HEIGHT = this.schwellenHöhe - this.rail_offset;\n      this.TRAIN_WIDTH = _config_js__WEBPACK_IMPORTED_MODULE_8__.CONFIG.GRID_SIZE * 0.7;\n\n      this.main_x1 = (Math.sin(Math.PI / 8) * trackRendering_textured.CURVE_RADIUS) / Math.cos(Math.PI / 8);\n   }\n\n   renderAllTrains() {\n      this.app.containers.trains.removeAllChildren();\n\n      // Only render trains that aren't coupled to another train's front\n      // This ensures we only create containers for lead cars\n      _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.allTrains\n         .filter((train) => !train.trainCoupledFront)\n         .forEach((train) => {\n            const c = new createjs.Container();\n            c.name = \"train\";\n            c.train = train;\n            c.mouseChildren = true;\n\n            // Start rendering from the first car (locomotive)\n            this.renderCar(train, c);\n\n            this.app.containers.trains.addChild(c);\n         });\n   }\n\n   renderCar(car, container) {\n      // Create graphics for the car\n      const g = new createjs.Graphics();\n      g.setStrokeStyle(1);\n      g.beginStroke(createjs.Graphics.getRGB(0, 0, 0));\n      g.beginFill(car.color);\n\n      // Use the car's actual length for width instead of fixed TRAIN_WIDTH\n      const carWidth = car.length;\n      const carHeight = this.TRAIN_HEIGHT;\n\n      // Set corner radius based on car type and position in train\n      let corner = [1.5, 1.5, 1.5, 1.5];\n\n      // If this is the first car (locomotive), round the front\n      if (car.type == _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.CAR_TYPES.LOCOMOTIVE) {\n         corner[0] = corner[3] = corner[1] = corner[2] = 8;\n      }\n\n      /* // If this is the last car, round the back\n      if (car.trainCoupledBack == null) {\n         corner[1] = corner[2] = 20;\n      } */\n\n      // Draw car with rounded corners\n      g.drawRoundRectComplex(0, 0, carWidth, carHeight, corner[0], corner[1], corner[2], corner[3]);\n\n      // Create the shape and position it\n      const s = new createjs.Shape(g);\n      s.data = car;\n      s.mouseChildren = false;\n      s.name = \"train\";\n\n      // Get the position on the track based on the car's km position\n      const p = car.track.getPointFromKm(car.pos);\n\n      s.x = p.x;\n      s.y = p.y;\n      s.regX = carWidth / 2;\n      s.regY = carHeight / 2;\n      s.rotation = car.track.deg;\n\n      container.addChild(s);\n      // Add train number if it exists\n      if (car.number && car.type == _train_js__WEBPACK_IMPORTED_MODULE_3__.Train.CAR_TYPES.LOCOMOTIVE) {\n         const text = new createjs.Text(car.number, \"10px Arial\", \"#000000\");\n         text.textAlign = \"center\";\n         text.x = p.x;\n         text.y = p.y;\n         text.textBaseline = \"middle\";\n         container.addChild(text);\n      }\n      // Recursively render coupled cars\n      if (car.trainCoupledBack) {\n         this.renderCar(car.trainCoupledBack, container);\n      }\n   }\n\n   renderAllGenericObjects() {\n      this.app.containers.objects.removeAllChildren();\n      _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.all_objects.forEach((o) => {\n         const c = new createjs.Container();\n         c.name = \"GenericObject\";\n         c.data = o;\n         c.mouseChildren = false;\n         c.x = o.pos().x;\n         c.y = o.pos().y;\n\n         if (o.type() === _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.OBJECT_TYPE.text) this.renderTextObject(o, c);\n         else if (o.type() === _generic_object_js__WEBPACK_IMPORTED_MODULE_4__.GenericObject.OBJECT_TYPE.plattform) this.renderPlattformObject(o, c);\n         else throw new Error(\"Unknown Object\");\n\n         this.app.containers.objects.addChild(c);\n      });\n   }\n\n   renderTextObject(text_object, container) {\n      var text = new createjs.Text(text_object.content(), \"24px Arial\", \"#000000\");\n      text.textBaseline = \"alphabetic\";\n      const height = text.getMeasuredHeight();\n      const width = text.getMeasuredWidth();\n\n      const hit = new createjs.Shape();\n      hit.graphics.beginFill(\"#000\").mt(0, 0).lt(width, 0).lt(width, -height).lt(0, -height).lt(0, 0);\n\n      text.hitArea = hit;\n\n      container.addChild(text);\n   }\n\n   renderPlattformObject(plattform, container) {\n      const shape = new createjs.Shape();\n      container.addChild(shape);\n      const size = plattform.size();\n      shape.graphics.beginStroke(\"#111111\").beginFill(\"#444\").drawRect(0, 0, size.width, size.height);\n      shape.setBounds(0, 0, size.width, size.height);\n\n      var text = new createjs.Text(plattform.content(), \"16px Arial\", \"#eee\");\n      text.textBaseline = \"middle\";\n      text.textAlign = \"center\";\n      text.x = plattform.size().width / 2;\n      text.y = plattform.size().height / 2;\n\n      container.addChild(text);\n   }\n\n   renderAllSignals(force) {\n      this.app.containers.signals.removeAllChildren();\n      _signal_js__WEBPACK_IMPORTED_MODULE_2__.Signal.allSignals.forEach((signal) => {\n         let container = this.app.containers.signals.addChild(_signal_js__WEBPACK_IMPORTED_MODULE_2__.SignalRenderer.createSignalContainer(signal));\n         this.app.alignSignalContainerWithTrack(container, signal._positioning);\n      });\n   }\n\n   renderAllTracks(force) {\n      const containers = this.app.containers;\n      //if we have to force a redraw, we have to create the containers for the sleepers and rails\n      if (force) {\n         const sleepers_container = new createjs.Container();\n         sleepers_container.name = \"global_sleepers\";\n         sleepers_container.mouseChildren = true;\n\n         const rails_container = new createjs.Container();\n         rails_container.name = \"global_rails\";\n         rails_container.mouseChildren = true;\n\n         this._rendering.sleepers_container = sleepers_container;\n         this._rendering.rails_container = rails_container;\n\n         containers.tracks.addChild(sleepers_container);\n         containers.tracks.addChild(rails_container);\n         containers.tracks.renderedTracks = new Set();\n         containers.tracks.renderedSwitches = new Set();\n      } else {\n         this._rendering.sleepers_container = containers.tracks.children[0];\n         this._rendering.rails_container = containers.tracks.children[1];\n      }\n\n      for (const t of _track_js__WEBPACK_IMPORTED_MODULE_0__.Track.allTracks) {\n         if (this.TrackVisible(t)) {\n            //either we have a forced redraw or the track is not rendered yet\n            if (force || !containers.tracks.renderedTracks.has(t)) {\n               this.renderTrack(t);\n               containers.tracks.renderedTracks.add(t);\n            } else if (this._rendering.lodChanged) {\n               this.updateTrack(t);\n            }\n         }\n      }\n\n      for (const sw of _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.allSwitches) {\n         if (this.SwitchVisible(sw)) {\n            if (force || !containers.tracks.renderedSwitches.has(sw)) {\n               this.renderSwitch(sw);\n               containers.tracks.renderedSwitches.add(sw);\n            } else if (this._rendering.lodChanged) {\n               this.updateSwitch(sw);\n            }\n         }\n      }\n   }\n\n   ///calculate start and end points for each node of a track and the control point for the curve\n   ///start and end points of straight segments are adjusted for the curves\n   calculateTrackPoints(track) {\n      const startConnection = track.switchAtTheStart;\n      const endConnection = track.switchAtTheEnd;\n\n      let startPoint = track.start;\n      let endPoint = track.end;\n\n      // Handle the start of the track\n      if (startConnection) {\n         // If there's a connection, shorten the track to make space\n         const size = startConnection instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch ? startConnection.size : _config_js__WEBPACK_IMPORTED_MODULE_8__.COMPUTED.GRID_SIZE_2;\n         startPoint = startPoint.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(track.unit, size));\n      } else {\n         // If there's no connection, extend it for the bumper\n         startPoint = startPoint.sub(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(track.unit, _config_js__WEBPACK_IMPORTED_MODULE_8__.COMPUTED.GRID_SIZE_2));\n      }\n\n      let straightEndPoint = endPoint;\n      let curveEnd = null;\n      let controlPoint = null;\n      let nextUnit = null;\n\n      // Handle the end of the track\n      if (endConnection) {\n         // If there's a connection, shorten the track to make space for the switch or curve\n         const size = endConnection instanceof _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch ? endConnection.size : _config_js__WEBPACK_IMPORTED_MODULE_8__.COMPUTED.GRID_SIZE_2;\n         straightEndPoint = endPoint.sub(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(track.unit, size));\n\n         if (endConnection instanceof _track_js__WEBPACK_IMPORTED_MODULE_0__.Track) {\n            // If the connection is another track, calculate the curve\n            const nextTrack = endConnection;\n            nextUnit = nextTrack.unit;\n            // The curve should end at the *shortened* start of the next track\n            curveEnd = nextTrack.start.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(nextUnit, _config_js__WEBPACK_IMPORTED_MODULE_8__.COMPUTED.GRID_SIZE_2));\n            controlPoint = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(straightEndPoint, track.unit, curveEnd, nextUnit);\n         }\n      } else {\n         // If there's no connection, extend the track for the bumper.\n         straightEndPoint = endPoint.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(track.unit, _config_js__WEBPACK_IMPORTED_MODULE_8__.COMPUTED.GRID_SIZE_2));\n      }\n\n      const centerLine = {\n         track: track,\n         start: startPoint,\n         straightEnd: straightEndPoint, // This is the end of the straight part, before any curve.\n         end: endPoint, // Original end point for reference.\n         unit: track.unit,\n         curveEnd: curveEnd, // End point of the curve.\n         controlPoint: controlPoint, // Control point for the curve.\n         nextUnit: nextUnit, // Unit vector of the next track.\n      };\n\n      this.calculateRailPositions(centerLine);\n      this.calculateSleeperOutline(centerLine);\n\n      return [centerLine];\n   }\n\n   /**\n    * Calculate sleeper outline for a track segment\n    * @param {Object} centerLine - The centerline object to add sleeper outline to\n    */\n   calculateSleeperOutline(centerLine) {\n      const sleeperOffset = this.schwellenHöhe_2;\n      const sleeperOffsetVector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(centerLine.unit.multiply(sleeperOffset));\n\n      centerLine.sleeperOutline = {\n         straight: {\n            inner: {\n               start: centerLine.start.add(sleeperOffsetVector),\n               end: centerLine.straightEnd.add(sleeperOffsetVector),\n            },\n            outer: {\n               start: centerLine.start.sub(sleeperOffsetVector),\n               end: centerLine.straightEnd.sub(sleeperOffsetVector),\n            },\n         },\n      };\n\n      if (centerLine.controlPoint) {\n         const nextSleeperOffsetVector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(centerLine.nextUnit.multiply(sleeperOffset));\n\n         const curveOuterEnd = centerLine.curveEnd.sub(nextSleeperOffsetVector);\n         const curveInnerEnd = centerLine.curveEnd.add(nextSleeperOffsetVector);\n\n         const curveOuterStart = centerLine.sleeperOutline.straight.outer.end;\n         const curveInnerStart = centerLine.sleeperOutline.straight.inner.end;\n\n         const cpOuter = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(curveOuterStart, centerLine.unit, curveOuterEnd, centerLine.nextUnit);\n         const cpInner = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(curveInnerStart, centerLine.unit, curveInnerEnd, centerLine.nextUnit);\n\n         centerLine.sleeperOutline.curve = {\n            outer: { start: curveOuterStart, end: curveOuterEnd, cp: cpOuter },\n            inner: { start: curveInnerStart, end: curveInnerEnd, cp: cpInner },\n         };\n      }\n   }\n\n   /**\n    * Calculate rail positions for a track segment\n    * @param {Object} centerLine - The centerline object to add rail positions to\n    */\n   calculateRailPositions(centerLine) {\n      // Calculate rail offset vectors\n      const railOffsetVector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(centerLine.unit.multiply(this.rail_distance));\n\n      // Calculate rail positions for straight segment\n      centerLine.rails = {\n         straight: {\n            // Inner rail (usually the right side in the direction of travel)\n            inner: {\n               start: centerLine.start.add(railOffsetVector),\n               end: centerLine.straightEnd.add(railOffsetVector),\n            },\n            // Outer rail (usually the left side in the direction of travel)\n            outer: {\n               start: centerLine.start.sub(railOffsetVector),\n               end: centerLine.straightEnd.sub(railOffsetVector),\n            },\n         },\n      };\n\n      // Calculate rail positions for curve if it exists\n      if (centerLine.controlPoint) {\n         const nextRailOffsetVector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(centerLine.nextUnit.multiply(this.rail_distance));\n\n         // Calculate curve endpoints\n         const curveInnerEnd = centerLine.curveEnd.add(nextRailOffsetVector);\n         const curveOuterEnd = centerLine.curveEnd.sub(nextRailOffsetVector);\n\n         // Calculate curve startpoints (same as straight segment endpoints)\n         const curveInnerStart = centerLine.rails.straight.inner.end;\n         const curveOuterStart = centerLine.rails.straight.outer.end;\n\n         // Calculate control points for inner and outer rail curves\n         const cpInner = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(curveInnerStart, centerLine.unit, curveInnerEnd, centerLine.nextUnit);\n         const cpOuter = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(curveOuterStart, centerLine.unit, curveOuterEnd, centerLine.nextUnit);\n\n         // Store curve rail positions\n         centerLine.rails.curve = {\n            inner: {\n               start: curveInnerStart,\n               end: curveInnerEnd,\n               cp: cpInner,\n            },\n            outer: {\n               start: curveOuterStart,\n               end: curveOuterEnd,\n               cp: cpOuter,\n            },\n         };\n      }\n   }\n\n   renderTrack(track) {\n      const points = this.calculateTrackPoints(track);\n\n      const sleepers_container = new createjs.Container();\n      sleepers_container.name = \"track\";\n      sleepers_container.mouseChildren = false;\n      sleepers_container.data = track;\n      this._rendering.sleepers_container.addChild(sleepers_container);\n\n      const hitArea = new createjs.Shape();\n      hitArea.graphics.beginFill(\"#000\"); // Color doesn't matter, only need one fill\n      for (const p of points) {\n         const straight = p.sleeperOutline.straight;\n         hitArea.graphics\n            .moveTo(straight.outer.start.x, straight.outer.start.y)\n            .lineTo(straight.outer.end.x, straight.outer.end.y)\n            .lineTo(straight.inner.end.x, straight.inner.end.y)\n            .lineTo(straight.inner.start.x, straight.inner.start.y)\n            .closePath();\n\n         if (p.sleeperOutline.curve) {\n            const curve = p.sleeperOutline.curve;\n            hitArea.graphics\n               .moveTo(curve.inner.start.x, curve.inner.start.y)\n               .quadraticCurveTo(curve.inner.cp.x, curve.inner.cp.y, curve.inner.end.x, curve.inner.end.y)\n               .lineTo(curve.outer.end.x, curve.outer.end.y)\n               .quadraticCurveTo(curve.outer.cp.x, curve.outer.cp.y, curve.outer.start.x, curve.outer.start.y)\n               .closePath();\n         }\n      }\n      sleepers_container.hitArea = hitArea;\n\n      this.drawTrackSleepers(points, sleepers_container);\n\n      // Draw rails\n      const railShape = this.renderRails(track, points);\n\n      // Get bounds from the rail shape\n      const bounds = railShape.getBounds();\n\n      // Create a track object that combines rail and sleeper information\n      track._renderData = {\n         bounds: bounds,\n         points: points,\n      };\n\n      this.drawBumper(track, this._rendering.rails_container);\n   }\n\n   calculateRailBounds(points) {\n      // Initialize bounds with first point\n      let minX = Infinity,\n         minY = Infinity,\n         maxX = -Infinity,\n         maxY = -Infinity;\n\n      // Helper to update bounds with a point\n      const updateBounds = (point) => {\n         minX = Math.min(minX, point.x);\n         minY = Math.min(minY, point.y);\n         maxX = Math.max(maxX, point.x);\n         maxY = Math.max(maxY, point.y);\n      };\n\n      // Iterate through all points and collect extremes\n      for (const point of points) {\n         // Add all straight segment points to bounds\n         const { inner, outer } = point.rails.straight;\n         updateBounds(inner.start);\n         updateBounds(inner.end);\n         updateBounds(outer.start);\n         updateBounds(outer.end);\n\n         // Handle curve segments\n         if (point.rails.curve) {\n            const curve = point.rails.curve;\n\n            // Add curve endpoints and control points\n            updateBounds(curve.inner.start);\n            updateBounds(curve.inner.end);\n            updateBounds(curve.outer.start);\n            updateBounds(curve.outer.end);\n         }\n      }\n\n      // Add padding for line thickness\n      const padding = trackRendering_textured.RAILS[0][0] * 0.5; // Half of the thickest rail\n      return {\n         x: minX - padding,\n         y: minY - padding,\n         width: maxX - minX + padding * 2,\n         height: maxY - minY + padding * 2,\n      };\n   }\n\n   renderRails(track, points) {\n      const rail_shape = new createjs.Shape();\n      rail_shape.name = \"track\";\n      rail_shape.snapToPixel = true;\n      rail_shape.data = track;\n      this._rendering.rails_container.addChild(rail_shape);\n\n      for (const point of points) {\n         // Use pre-calculated rail positions\n         const { straight, curve } = point.rails;\n\n         trackRendering_textured.RAILS.forEach((rail) => {\n            rail_shape.graphics.setStrokeStyle(rail[0]).beginStroke(rail[1]);\n\n            // Draw straight segments\n            rail_shape.graphics\n               .mt(straight.inner.start.x, straight.inner.start.y)\n               .lt(straight.inner.end.x, straight.inner.end.y)\n               .mt(straight.outer.start.x, straight.outer.start.y)\n               .lt(straight.outer.end.x, straight.outer.end.y);\n\n            // Draw curves if present\n            if (curve) {\n               rail_shape.graphics\n                  .mt(curve.outer.start.x, curve.outer.start.y)\n                  .quadraticCurveTo(curve.outer.cp.x, curve.outer.cp.y, curve.outer.end.x, curve.outer.end.y)\n                  .mt(curve.inner.start.x, curve.inner.start.y)\n                  .quadraticCurveTo(curve.inner.cp.x, curve.inner.cp.y, curve.inner.end.x, curve.inner.end.y);\n            }\n\n            rail_shape.graphics.endStroke();\n         });\n      }\n\n      // Calculate and set bounds for the rail shape\n      const bounds = this.calculateRailBounds(points);\n      rail_shape.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);\n\n      return rail_shape;\n   }\n\n   drawTrackSleepers(points, container) {\n      for (const point of points) {\n         // Draw sleepers for straight segment\n         this.drawSleepers(point.track, point.start, point.straightEnd, container);\n\n         // Draw sleepers for curve if exists\n         if (point.rails.curve) {\n            this.drawSleepersAlongCurve(point.straightEnd, point.curveEnd, point.controlPoint, container);\n         }\n      }\n   }\n\n   drawSleepersAlongCurve(startPoint, endPoint, controlPoint, container) {\n      //the curve is eproximat 11% times longer than the straight line\n      const steps = Math.floor((_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(startPoint, endPoint) * 1.11) / this.sleeperIntervall);\n      const step = 1 / steps;\n      let t = 0.25 / steps,\n         point,\n         angle;\n\n      for (let i = 0; i < steps; i++) {\n         point = this.getPointOnCurve(t, startPoint, controlPoint, endPoint);\n         angle = this.getDegreeOfTangentOnCurve(t, startPoint, controlPoint, endPoint);\n\n         this.drawSleeper(i, point.x, point.y, angle, container);\n         t += step;\n      }\n   }\n\n   drawSleepers(track, startPoint, endPoint, container) {\n      let x = startPoint.x;\n      let y = startPoint.y;\n\n      const l = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(startPoint, endPoint);\n      // Calculate how many sleepers fit\n      const amount = Math.floor(l / this.sleeperIntervall);\n\n      // Calculate the remaining space after fitting full sleepers\n      const remainingSpace = l % this.sleeperIntervall;\n      // Distribute the remaining space evenly between sleepers\n      const adjustedInterval = this.sleeperIntervall + remainingSpace / amount;\n\n      const step_x = track.cos * adjustedInterval,\n         step_y = track.sin * adjustedInterval;\n\n      // Add the end gap\n      x += track.cos * (this.schwellenGap / 2);\n      y += track.sin * (this.schwellenGap / 2);\n\n      for (let i = 0; i < amount; i++) {\n         this.drawSleeper(i, x, y, track.deg, container);\n         // Move to next position using sleeperIntervall\n         y += step_y;\n         x += step_x;\n      }\n   }\n\n   drawSleeper(i, x, y, angle, container, length = this.schwellenHöhe, regY) {\n      if (this.app.stage.scale < this.LOD) {\n         // For simple shapes at low LOD\n         const ry = regY == null ? length / 2 : regY;\n\n         // Create a unique cache key based on the length\n         const cacheKey = `shape_${length}`;\n\n         // Get cached shape or create a new one\n         let sleeperShape = this._sleeperCache[cacheKey];\n         if (!sleeperShape) {\n            sleeperShape = new createjs.Shape();\n            sleeperShape.graphics\n               .setStrokeStyle(0.2, \"round\")\n               .beginStroke(\"black\")\n               .beginFill(\"#99735b\")\n               .r(0, 0, this.schwellenBreite, length)\n               .ef();\n            sleeperShape.setBounds(0, 0, this.schwellenBreite, length);\n            // Store in cache\n            this._sleeperCache[cacheKey] = sleeperShape;\n         }\n\n         // Clone the cached shape for this instance\n         let sleeper = sleeperShape.clone();\n         sleeper.x = x;\n         sleeper.y = y;\n         sleeper.rotation = angle;\n         sleeper.regY = ry;\n         sleeper.regX = 0;\n\n         container.addChild(sleeper);\n      } else {\n         // Use bitmap rendering at higher LOD\n         i = i % trackRendering_textured.SCHWELLEN_VARIANTEN;\n         const scaleY = length / this.schwellenHöhe;\n         const ry = regY == null ? this.schwellenImg.height / 2 : regY / (trackRendering_textured.TRACK_SCALE * scaleY);\n\n         // Check if we have a cached bitmap for this index\n         if (!this._bitmapCache[i]) {\n            // Create the sourceRect for this index\n            const sourceRect = new createjs.Rectangle(\n               (i * this.schwellenImg.width) / trackRendering_textured.SCHWELLEN_VARIANTEN,\n               0,\n               this.sleepersImgWidth,\n               this.schwellenImg.height\n            );\n\n            // Create and cache the bitmap\n            const bitmap = new createjs.Bitmap(this.schwellenImg);\n            bitmap.sourceRect = sourceRect;\n            this._bitmapCache[i] = bitmap;\n         }\n\n         // Clone the cached bitmap\n         const sleeperBitmap = this._bitmapCache[i].clone();\n\n         // Set position and transformation properties\n         sleeperBitmap.x = x;\n         sleeperBitmap.y = y;\n         sleeperBitmap.regY = ry;\n         sleeperBitmap.regX = 0;\n         sleeperBitmap.scale = trackRendering_textured.TRACK_SCALE;\n         sleeperBitmap.scaleY = trackRendering_textured.TRACK_SCALE * scaleY;\n         sleeperBitmap.rotation = angle;\n\n         container.addChild(sleeperBitmap);\n      }\n   }\n\n   getPointOnCurve(t, p0, cp, p1) {\n      const oneMinusT = 1 - t;\n      const tSquared = t * t;\n      const oneMinusTSquared = oneMinusT * oneMinusT;\n      const twoTimesT = 2 * oneMinusT * t;\n\n      return new _tools_js__WEBPACK_IMPORTED_MODULE_5__.Point(\n         oneMinusTSquared * p0.x + twoTimesT * cp.x + tSquared * p1.x,\n         oneMinusTSquared * p0.y + twoTimesT * cp.y + tSquared * p1.y\n      );\n   }\n\n   getDegreeOfTangentOnCurve(t, p0, cp, p1) {\n      const mt = 1 - t;\n      const dx = 2 * (mt * (cp.x - p0.x) + t * (p1.x - cp.x));\n      const dy = 2 * (mt * (cp.y - p0.y) + t * (p1.y - cp.y));\n      return Math.atan2(dy, dx) * (180 / Math.PI);\n   }\n\n   drawBumper(track, track_container) {\n      if (track.switchAtTheEnd == null) {\n         track_container.addChild(\n            new createjs.Bitmap(this.bumperImg).set({\n               y: track.end.y,\n               x: track.end.x,\n               scale: trackRendering_textured.TRACK_SCALE,\n               scaleX: -trackRendering_textured.TRACK_SCALE,\n               rotation: track.deg,\n               regY: this.bumperImg.height / 2,\n               regX: this.bumperImg.width,\n            })\n         );\n      }\n\n      if (track.switchAtTheStart == null) {\n         track_container.addChild(\n            new createjs.Bitmap(this.bumperImg).set({\n               y: track.start.y,\n               x: track.start.x,\n               scale: trackRendering_textured.TRACK_SCALE,\n               scaleX: trackRendering_textured.TRACK_SCALE,\n               rotation: track.deg,\n               regY: this.bumperImg.height / 2,\n               regX: this.bumperImg.width,\n            })\n         );\n      }\n   }\n\n   updateTrack(track) {\n      // Find the sleepers container for this track\n      const sleepersContainer = this._rendering.sleepers_container.children.find((c) => c.data === track);\n      if (!sleepersContainer) return;\n\n      // Remove existing sleepers\n      sleepersContainer.removeAllChildren();\n\n      // Calculate points and redraw sleepers with current LOD\n      const points = this.calculateTrackPoints(track);\n      this.drawTrackSleepers(points, sleepersContainer);\n\n      if (track == track.switchAtTheEnd?.t1) {\n         const switchSleepersContainer = this._rendering.sleepers_container.children.find((c) => c.data === track.switchAtTheEnd);\n         const switchRenderingParameter = this.getSwitchRenderingParameter(track.switchAtTheEnd);\n         this.drawSleepersOnSwitch(track.switchAtTheEnd, switchRenderingParameter, switchSleepersContainer);\n      }\n\n      if (track == track.switchAtTheStart?.t1) {\n         const switchSleepersContainer = this._rendering.sleepers_container.children.find(\n            (c) => c.data === track.switchAtTheStart\n         );\n         const switchRenderingParameter = this.getSwitchRenderingParameter(track.switchAtTheStart);\n         this.drawSleepersOnSwitch(track.switchAtTheStart, switchRenderingParameter, switchSleepersContainer);\n      }\n   }\n\n   updateSwitch(sw) {\n      // Find the sleepers container for this switch\n      const sleepersContainer = this._rendering.sleepers_container.children.find((c) => c.data === sw);\n      if (!sleepersContainer) return;\n\n      // Get rendering parameters\n      const switchRenderingParameter = this.getSwitchRenderingParameter(sw);\n\n      // Redraw sleepers with current LOD\n      this.drawSleepersOnSwitch(sw, switchRenderingParameter, sleepersContainer);\n   }\n\n   /**\n    * Creates a shape for a track endpoint\n    * @param {Point} point - The point where the endpoint should be\n    * @param {Track} track - The track this endpoint belongs to\n    * @param {string} endpointType - Either \"start\" or \"end\"\n    * @returns {createjs.Shape} The created shape\n    */\n   createEndpointShape(point, track, endpointType) {\n      const RECT_SIZE = 8;\n      const shape = new createjs.Shape();\n\n      // Set properties to identify the shape\n      shape.name = \"track_endpoint\";\n      shape.endpoint = endpointType;\n      shape.track = track;\n\n      // Create hit area\n      const hitArea = new createjs.Shape();\n      hitArea.graphics.beginFill(\"#000\").drawRect(point.x - RECT_SIZE / 2, point.y - RECT_SIZE / 2, RECT_SIZE, RECT_SIZE);\n      shape.hitArea = hitArea;\n\n      // Draw rectangle\n      shape.graphics\n         .setStrokeStyle(2)\n         .beginStroke(\"#ff0000\")\n         .drawRect(point.x - RECT_SIZE / 2, point.y - RECT_SIZE / 2, RECT_SIZE, RECT_SIZE);\n\n      return shape;\n   }\n\n   /**\n    * Draws selection rectangles at the start and end points of a track\n    * @param {Track} track - The track to draw selection rectangles for\n    */\n   drawTrackEndpoints(track) {\n      // Create and add shapes for start and end points\n      this.app.containers.selection.addChild(this.createEndpointShape(track.start, track, \"start\"));\n      this.app.containers.selection.addChild(this.createEndpointShape(track.end, track, \"end\"));\n   }\n\n   updateSelection() {\n      this.app.containers.selection.removeAllChildren();\n\n      if (this.app.selection.type == \"Track\") {\n         this.app.containers.tracks.children[0].children.forEach((c) => {\n            if (selection.isSelectedObject(c.data)) {\n               this.visualizeTrackBounds(c);\n               this.drawTrackEndpoints(c.data);\n            }\n         });\n      } else if (this.app.selection.type == \"Signal\") {\n         this.app.containers.signals.children.forEach((c) => {\n            if (c.data) {\n               if (selection.isSelectedObject(c.data)) this.visualizeTrackBounds(c);\n            }\n         });\n      } else if (this.app.selection.type == \"GenericObject\") {\n         this.app.containers.objects.children.forEach((c) => {\n            if (c.data) {\n               if (selection.isSelectedObject(c.data)) this.visualizeTrackBounds(c);\n            }\n         });\n      }\n      this.app.stage.update();\n   }\n\n   drawSleepersOnSwitch(sw, switchRenderingParameter, container) {\n      const { mainTrack, straightBranch, curvedBranch, curvedBranch2, flipped, mirrored } = switchRenderingParameter;\n\n      if (container == null) {\n         container = new createjs.Container();\n         container.name = \"switch_sleepers\";\n         container.data = sw;\n         container.mouseChildren = false;\n         this._rendering.sleepers_container.addChild(container);\n      } else {\n         container.removeAllChildren();\n      }\n\n      const deg = sw.track1.deg;\n\n      const back2front = _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.is(sw.type, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_RIGHT, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_LEFT);\n\n      if (curvedBranch2 == null) {\n         const cp = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n            mainTrack.sleepers.outer,\n            mainTrack.unit,\n            curvedBranch.sleepers.outer,\n            curvedBranch.unit\n         );\n\n         const length = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(mainTrack.sleepers.inner, straightBranch.sleepers.inner); //length of the straight part + half of the gap, to minimize the gap the to next track\n         const length2 = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(mainTrack.sleepers.outer, curvedBranch.sleepers.outer); //almost the length of the curve\n\n         const amount_on_straight_rail = Math.floor(length / this.sleeperIntervall);\n         const amount_on_curved_rail = Math.floor(length2 / (this.sleeperIntervall * 1.15));\n         const new_intervall = (this.sleeperIntervall + (length % this.sleeperIntervall) / amount_on_straight_rail) * mirrored; //new intervall to minimize the gap and using the leftover from the division\n         let p1, t, sleeper_length;\n\n         if (back2front) p1 = mainTrack.sleepers.inner.sub(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(mainTrack.unit, this.sleeperIntervall));\n         else p1 = mainTrack.sleepers.inner.add(_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(mainTrack.unit, (this.schwellenGap / 2) * mirrored));\n\n         const step_vector = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(mainTrack.unit, new_intervall);\n\n         for (let i = 0; i < amount_on_curved_rail; i++) {\n            t = i / amount_on_curved_rail + 0.4 / amount_on_curved_rail;\n\n            sleeper_length = Math.max(\n               _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(this.getPointOnCurve(t, mainTrack.sleepers.outer, cp, curvedBranch.sleepers.outer), p1),\n               this.schwellenHöhe\n            );\n\n            this.drawSleeper(i, p1.x, p1.y, deg, container, -sleeper_length * flipped, 0);\n            p1 = p1.add(step_vector);\n         }\n\n         for (let i = amount_on_curved_rail; i < amount_on_straight_rail; i++) {\n            t = (this.sleeperIntervall * i) / length2;\n            //subtract the sleeper intervall to create a gap to the next sleeper\n            sleeper_length = Math.max(\n               _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.distance(\n                  _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n                     curvedBranch.sleepers.outer,\n                     _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(curvedBranch.unit),\n                     p1,\n                     _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(mainTrack.unit)\n                  ),\n                  p1\n               ),\n               this.schwellenHöhe\n            );\n\n            this.drawSleeper(i, p1.x, p1.y, deg, container, -sleeper_length * flipped, 0);\n            p1 = p1.add(step_vector);\n         }\n      } else {\n         // Calculate starting point and offset vector\n         let centerPoint = straightBranch.position.add(mainTrack.unit.multiply(this.sleeperIntervall / 4));\n         const step_vector = mainTrack.unit.multiply(this.sleeperIntervall);\n\n         // Create a full symmetric pattern from the half pattern\n         const pattern = trackRendering_textured.FOUR_WAY_SLEEPER_PATTERN;\n         const reversed_pattern = pattern.slice(0, -1).reverse(); //remove the last element because its right on the point of the switch\n         const point_symmetric_pattern = reversed_pattern.map((p) => ({ offset: 2 * p.length - p.offset, length: p.length }));\n         const fullPattern = [...pattern, ...point_symmetric_pattern];\n\n         // Draw sleepers using the pattern\n         fullPattern.forEach((data, i) => {\n            this.drawSleeper(\n               i,\n               centerPoint.x,\n               centerPoint.y,\n               deg,\n               container,\n               data.length * this.schwellenHöhe,\n               data.offset * this.schwellenHöhe_2\n            );\n            centerPoint = centerPoint.add(step_vector);\n         });\n      }\n   }\n\n   renderSwitch(sw, force) {\n      const switchRenderingParameter = this.getSwitchRenderingParameter(sw);\n\n      const shape = new createjs.Shape();\n      shape.data = sw;\n      shape.snapToPixel = true;\n      this._rendering.rails_container.addChild(shape);\n\n      // Draw track based on the number of tracks\n      if (switchRenderingParameter.curvedBranch2 == null) {\n         this.renderThreeWaySwitch(shape, switchRenderingParameter);\n      } else {\n         this.renderFourWaySwitch(shape, switchRenderingParameter);\n      }\n\n      this.drawSleepersOnSwitch(sw, switchRenderingParameter);\n      this.renderSwitchUI(sw);\n   }\n\n   getSwitchRenderingParameter(sw) {\n      const flipped = _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.is(sw.type, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_RIGHT, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.TO_RIGHT) ? -1 : 1;\n      const mirrored = _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.is(sw.type, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_LEFT, _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.SWITCH_TYPE.FROM_RIGHT) ? -1 : 1;\n\n      // Calculate track data for each track\n      const calcTrackData = (index) => {\n         let track = sw.tracks[index];\n         let unit = sw.track_directions[index];\n         if (!unit) {\n            // This can happen if calculateParameters hasn't been called on the switch.\n            // For robustness, we can calculate it here, but it's better to ensure it's calculated in the switch class.\n            console.warn(\"Switch track_directions not calculated, calculating on the fly.\");\n            sw.calculateParameters();\n            unit = sw.track_directions[index];\n         }\n\n         const railOffset = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit.multiply(this.rail_distance * flipped));\n         const sleeperOffset = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.perpendicular(track.unit.multiply(this.schwellenHöhe_2 * flipped));\n         // The position should be on the track, at a certain distance from the switch location.\n         const position = sw.location.add(unit.multiply(sw.size));\n\n         return {\n            unit: track.unit,\n            position: position,\n            rails: {\n               inner: position.add(railOffset),\n               outer: position.sub(railOffset),\n            },\n            sleepers: {\n               inner: position.add(sleeperOffset),\n               outer: position.sub(sleeperOffset),\n            },\n         };\n      };\n\n      const mainTrack = calcTrackData(0);\n      const straightBranch = calcTrackData(1);\n      const curvedBranch = calcTrackData(2);\n      const curvedBranch2 = sw.track4 ? calcTrackData(3) : null;\n\n      return { mainTrack, straightBranch, curvedBranch, curvedBranch2, flipped, mirrored };\n   }\n\n   renderThreeWaySwitch(shape, switchRenderingParameter) {\n      const g = shape.graphics;\n      const { mainTrack, straightBranch, curvedBranch, flipped, mirrored } = switchRenderingParameter;\n\n      // Calculate intersection points once - reuse for all rail sizes\n      const intersections = {\n         outerCurve: _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n            mainTrack.rails.outer,\n            mainTrack.unit,\n            curvedBranch.rails.outer,\n            curvedBranch.unit\n         ),\n\n         frog: _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n            straightBranch.rails.outer,\n            straightBranch.unit,\n            curvedBranch.rails.inner,\n            curvedBranch.unit\n         ),\n      };\n\n      // Calculate inner curve control point using the already calculated frog point\n      intersections.innerCurve = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.getIntersectionPointX(\n         mainTrack.rails.inner,\n         mainTrack.unit,\n         intersections.frog,\n         curvedBranch.unit\n      );\n\n      // Pre-calculate all herzstück (frog) points\n      const frogOffset = -trackRendering_textured.RAILS[0][0] * mirrored; //thats the distance between the frog and the point blades\n      const guardRailLength = 10 * mirrored;\n      const frogPoints = {\n         curveEnd: _tools_js__WEBPACK_IMPORTED_MODULE_5__.Point.fromPoint(intersections.frog).add(curvedBranch.unit.multiply(frogOffset)),\n         straightStart: _tools_js__WEBPACK_IMPORTED_MODULE_5__.Point.fromPoint(intersections.frog).add(straightBranch.unit.multiply(frogOffset)),\n      };\n\n      // Calculate end points using the pre-calculated points\n      frogPoints.straightEnd = frogPoints.curveEnd.add(straightBranch.unit.multiply(guardRailLength));\n      frogPoints.curveStart = frogPoints.straightStart.add(curvedBranch.unit.multiply(guardRailLength));\n\n      // Draw all rails with different thicknesses in one pass\n      for (const rail of trackRendering_textured.RAILS) {\n         g.setStrokeStyle(rail[0]).beginStroke(rail[1]);\n\n         // Outer curved branch\n         g.mt(mainTrack.rails.outer.x, mainTrack.rails.outer.y).quadraticCurveTo(\n            intersections.outerCurve.x,\n            intersections.outerCurve.y,\n            curvedBranch.rails.outer.x,\n            curvedBranch.rails.outer.y\n         );\n\n         // Inner curved branch with frog connection\n         g.mt(mainTrack.rails.inner.x, mainTrack.rails.inner.y)\n            .quadraticCurveTo(\n               intersections.innerCurve.x - flipped,\n               intersections.innerCurve.y - flipped,\n               frogPoints.curveEnd.x,\n               frogPoints.curveEnd.y\n            )\n            .lt(frogPoints.straightEnd.x, frogPoints.straightEnd.y);\n\n         // Frog point and connecting rails\n         g.mt(straightBranch.rails.outer.x, straightBranch.rails.outer.y)\n            .lt(intersections.frog.x, intersections.frog.y)\n            .lt(curvedBranch.rails.inner.x, curvedBranch.rails.inner.y);\n\n         // Straight connection\n         g.mt(mainTrack.rails.inner.x, mainTrack.rails.inner.y).lt(straightBranch.rails.inner.x, straightBranch.rails.inner.y);\n\n         // Guard rail\n         g.mt(frogPoints.curveStart.x, frogPoints.curveStart.y)\n            .lt(frogPoints.straightStart.x, frogPoints.straightStart.y)\n            .lt(mainTrack.rails.outer.x, mainTrack.rails.outer.y + 2 * flipped); //TODO  we can implement switching the switch here\n\n         g.endStroke();\n      }\n   }\n\n   renderFourWaySwitch(shape, switchRenderingParameter) {\n      const { mainTrack, straightBranch, curvedBranch, curvedBranch2 } = switchRenderingParameter;\n\n      const drawRail = (graphics, startTrack, endTrack, railSide) => {\n         // railSide: 'inner' or 'outer'\n\n         const startPoint = startTrack.rails[railSide];\n         const endPoint = endTrack.rails[railSide];\n\n         const cp1 = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.add(startPoint, _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(startTrack.unit, trackRendering_textured.CURVATURE_4WAY_SWITCH));\n         const cp2 = _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.add(endPoint, _tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.multiply(endTrack.unit, -trackRendering_textured.CURVATURE_4WAY_SWITCH));\n\n         graphics.mt(startPoint.x, startPoint.y).bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, endPoint.x, endPoint.y);\n      };\n\n      const g = shape.graphics;\n\n      // Draw all rails with different thicknesses\n      for (const rail of trackRendering_textured.RAILS) {\n         g.setStrokeStyle(rail[0]).beginStroke(rail[1]);\n\n         // Draw using the helper method for consistent curve rendering\n         drawRail(g, straightBranch, curvedBranch2, \"outer\");\n         drawRail(g, curvedBranch, mainTrack, \"inner\");\n         drawRail(g, straightBranch, curvedBranch2, \"inner\");\n         drawRail(g, curvedBranch, mainTrack, \"outer\");\n\n         // Draw straight connections\n         g.mt(mainTrack.rails.inner.x, mainTrack.rails.inner.y).lt(straightBranch.rails.inner.x, straightBranch.rails.inner.y);\n\n         g.mt(mainTrack.rails.outer.x, mainTrack.rails.outer.y).lt(straightBranch.rails.outer.x, straightBranch.rails.outer.y);\n\n         g.mt(curvedBranch.rails.inner.x, curvedBranch.rails.inner.y).lt(\n            curvedBranch2.rails.inner.x,\n            curvedBranch2.rails.inner.y\n         );\n\n         g.mt(curvedBranch.rails.outer.x, curvedBranch.rails.outer.y).lt(\n            curvedBranch2.rails.outer.x,\n            curvedBranch2.rails.outer.y\n         );\n\n         g.endStroke();\n      }\n   }\n\n   renderSwitchUI(sw) {\n      const drawArrow = (graphics, length, size) => {\n         graphics\n            .mt(0, 0)\n            .lt(length, 0)\n            .mt(length - size, -size / 2)\n            .lt(length, 0)\n            .lt(length - size, size / 2);\n      };\n\n      // Check if a container already exists for this switch\n      let container =  this.app.containers.ui.children.find((c) => c.data === sw);\n\n      if (container) {\n         // If container exists, clear it but keep it\n         container.removeAllChildren();\n      } else {\n         // Create a new container if none exists\n         container = new createjs.Container();\n         container.mouseChildren = false;\n         container.name = \"switch\";\n         container.data = sw;\n         this.app.containers.ui.addChild(container);\n      }\n\n      // Add arrows for both tracks\n      [sw.from, sw.branch].forEach((t) => {\n         const arrow = new createjs.Shape();\n         container.addChild(arrow);\n\n         arrow.graphics.setStrokeStyle(trackRendering_textured.SWITCH_UI_STROKE, \"round\").beginStroke(\"#333\");\n         drawArrow(arrow.graphics, 20, 5);\n         arrow.x = sw.location.x;\n         arrow.y = sw.location.y;\n         arrow.rotation = _switch_js__WEBPACK_IMPORTED_MODULE_1__.Switch.findAngle(sw.location, t.end.equals(sw.location) ? t.start : t.end);\n      });\n   }\n\n   PointVisible(p1) {\n      if (this._rendering?.dont_optimize) return true;\n      const screen_rectangle = this._rendering.screen_rectangle;\n\n      return (\n         _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.between(p1.x, screen_rectangle.left, screen_rectangle.right) &&\n         _utils_js__WEBPACK_IMPORTED_MODULE_6__.NumberUtils.between(p1.y, screen_rectangle.top, screen_rectangle.bottom)\n      );\n   }\n\n   TrackVisible(track, screen_rectangle = this._rendering.screen_rectangle) {\n      if (this._rendering?.dont_optimize) return true;\n\n      const isInside = (point, rect) =>\n         point.x > rect.left && point.x < rect.right && point.y > rect.top && point.y < rect.bottom;\n\n      //first the easy part, if either on of its end points is visible\n      if (isInside(track.start, screen_rectangle) || isInside(track.end, screen_rectangle)) return true; //\n\n      //now we have to make sure, if the track is going through the whole screen\n      //we check, if the track intersects one of the screen borders\n\n      //left\n      let p1 = { x: screen_rectangle.left, y: screen_rectangle.top },\n         p2 = { x: screen_rectangle.left, y: screen_rectangle.bottom };\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.doLineSegmentsIntersect(p1, p2, track.start, track.end)) return true;\n      //bottom\n      p1 = p2;\n      p2 = { x: screen_rectangle.right, y: screen_rectangle.bottom };\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.doLineSegmentsIntersect(p1, p2, track.start, track.end)) return true;\n      //right\n      p1 = p2;\n      p2 = { x: screen_rectangle.right, y: screen_rectangle.top };\n      if (_tools_js__WEBPACK_IMPORTED_MODULE_5__.geometry.doLineSegmentsIntersect(p1, p2, track.start, track.end)) return true;\n      //top we do not need to check all borders\n      /* p1 = p2;\n      p2 = { x: x, y: y };\n      if (geometry.doLineSegmentsIntersect(p1, p2, track.start, track.end)) return true; */\n\n      return false;\n   }\n\n   SwitchVisible(sw) {\n      if (this._rendering?.dont_optimize) return true;\n      const screen_rectangle = this._rendering.screen_rectangle;\n\n      // Check if switch location is visible\n      if (this.PointVisible(sw.location)) return true;\n\n      // Check if any of the switch's tracks are visible\n      const tracks = [sw.track1, sw.track2, sw.track3, sw.track4].filter((t) => t);\n      return tracks.some((track) => this.TrackVisible(track, screen_rectangle));\n   }\n\n   /**\n    * Visualize track bounds for debugging\n    * @param {Object} container - The container to visualize bounds for\n    */\n   visualizeTrackBounds(container) {\n      const bounds = container.getTransformedBounds();\n      const object = container.data;\n\n      if (bounds == null) throw new Error(\"Bounds are null\");\n\n      // Add padding to bounds\n      const padding = 5;\n      bounds.x -= padding;\n      bounds.y -= padding;\n      bounds.width += padding * 2;\n      bounds.height += padding * 2;\n\n      // Create a shape for the bounds visualization\n      const boundsShape = new createjs.Shape();\n      boundsShape.name = \"selection\";\n      boundsShape.mouseEnabled = false;\n      boundsShape.data = object;\n\n      // Draw the bounds rectangle\n      boundsShape.graphics\n         .setStrokeStyle(2)\n         .setStrokeDash([5, 5])\n         .beginStroke(\"rgba(0, 0, 0, 0.7)\")\n         .drawRect(bounds.x, bounds.y, bounds.width, bounds.height)\n         .endStroke();\n\n      this.app.containers.selection.addChild(boundsShape);\n   }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS90cmFja1JlbmRlcmluZ190ZXh0dXJlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFhOztBQUViO0FBQ21DO0FBQ0U7QUFDZ0I7QUFDbEI7QUFDaUI7QUFDUDtBQUNKO0FBQ1o7QUFDa0I7QUFDQTs7QUFFeEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUSx3QkFBd0I7QUFDaEMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSwwQkFBMEI7QUFDbEMsUUFBUSwyQkFBMkI7QUFDbkM7O0FBRUE7QUFDQSxpQkFBaUIsd0RBQVc7QUFDNUI7QUFDQSw2Q0FBNkMsOENBQU07O0FBRW5EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyw4Q0FBTTtBQUNoRCx5Q0FBeUMsOENBQU07QUFDL0MseUJBQXlCLDhDQUFNO0FBQy9CLHlCQUF5Qiw4Q0FBTTtBQUMvQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVc7QUFDdEI7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFNO0FBQ2hDLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGtEQUFXO0FBQ3BCLFNBQVMsa0RBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5R0FBeUc7O0FBRXpHO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbURBQW1EO0FBQ3BFLGdCQUFnQjtBQUNoQixVQUFVLCtDQUFRO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVSwrQ0FBUTtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVUsK0NBQVE7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYix5RkFBeUY7O0FBRXpGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nbGVpc3BsYW5lZGl0b3IvLi93d3cvY29kZS90cmFja1JlbmRlcmluZ190ZXh0dXJlZC5qcz9mNzRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSBcIi4vdHJhY2suanNcIjtcbmltcG9ydCB7IFN3aXRjaCB9IGZyb20gXCIuL3N3aXRjaC5qc1wiO1xuaW1wb3J0IHsgU2lnbmFsLCBTaWduYWxSZW5kZXJlciB9IGZyb20gXCIuL3NpZ25hbC5qc1wiO1xuaW1wb3J0IHsgVHJhaW4gfSBmcm9tIFwiLi90cmFpbi5qc1wiO1xuaW1wb3J0IHsgR2VuZXJpY09iamVjdCB9IGZyb20gXCIuL2dlbmVyaWNfb2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBnZW9tZXRyeSwgUG9pbnQgfSBmcm9tIFwiLi90b29scy5qc1wiO1xuaW1wb3J0IHsgTnVtYmVyVXRpbHMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgdWkgfSBmcm9tIFwiLi91aS5qc1wiO1xuaW1wb3J0IHsgQ09ORklHLCBDT01QVVRFRCB9IGZyb20gXCIuL2NvbmZpZy5qc1wiO1xuaW1wb3J0IHsgQXBwbGljYXRpb24gfSBmcm9tIFwiLi9hcHBsaWNhdGlvbi5qc1wiO1xuXG5leHBvcnQgY2xhc3MgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQge1xuICAgc3RhdGljIFNXSVRDSF9VSV9TVFJPS0UgPSAzO1xuICAgc3RhdGljIFRSQUNLX1NDQUxFID0gMC4zO1xuICAgc3RhdGljIHNpZ25hbGVfc2NhbGUgPSAwLjU7XG4gICBzdGF0aWMgU0NIV0VMTEVOX1ZBUklBTlRFTiA9IDI0O1xuICAgc3RhdGljIENVUlZBVFVSRV80V0FZX1NXSVRDSCA9IDcwO1xuICAgc3RhdGljIFJBSUxTID0gW1xuICAgICAgWzMuMiwgXCIjMjIyXCJdLFxuICAgICAgWzIuOCwgXCIjOTk5XCJdLFxuICAgICAgWzEuNCwgXCIjZWVlXCJdLFxuICAgXTtcblxuICAgLy8gRGVmaW5lIHNsZWVwZXIgcGF0dGVybiBmb3IgNC13YXkgc3dpdGNoXG4gICBzdGF0aWMgRk9VUl9XQVlfU0xFRVBFUl9QQVRURVJOID0gW1xuICAgICAgeyBvZmZzZXQ6IDEsIGxlbmd0aDogMS4wIH0sIC8vIFN0YXJ0IHN0cmFpZ2h0XG4gICAgICB7IG9mZnNldDogMSwgbGVuZ3RoOiAxLjQgfSwgLy8gU3RhcnQgc3RyYWlnaHRcbiAgICAgIHsgb2Zmc2V0OiAxLjEsIGxlbmd0aDogMS43IH0sIC8vIEJlZ2luIHRyYW5zaXRpb25cbiAgICAgIHsgb2Zmc2V0OiAxLjIsIGxlbmd0aDogMS45IH0sIC8vIFBlYWsgb2YgY3VydmVcbiAgICAgIHsgb2Zmc2V0OiAxLjQsIGxlbmd0aDogMS44IH0sIC8vIFBlYWsgb2YgY3VydmVcbiAgICAgIHsgb2Zmc2V0OiAxLjUsIGxlbmd0aDogMS43IH0sIC8vIEN1cnZlXG4gICAgICB7IG9mZnNldDogMS43LCBsZW5ndGg6IDEuNjUgfSwgLy8gQ3VydmVcbiAgIF07XG5cbiAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5hcHAgPSBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpO1xuICAgICAgLy9jYXVzZSB0aGUgY2xhc3MgaXMgYmVlbiBsb2FkZWQgYmVmb3JlIHN0YXJ0LmpzLCB3ZSBoYXZlIHRvIGhhY2sgYW5kIGNhbGN1bGF0ZSB0aGlzIGNvbnN0YW50IGhlcmVcbiAgICAgIHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLkNVUlZFX1JBRElVUyA9IENPTkZJRy5HUklEX1NJWkUgKiAxLjIxO1xuXG4gICAgICB0aGlzLlNJR05BTF9ESVNUQU5DRV9GUk9NX1RSQUNLID0gNDU7XG5cbiAgICAgIHRoaXMuTE9EID0gNTtcbiAgICAgIHRoaXMuX2xhc3RSZW5kZXJTY2FsZSA9IDA7XG5cbiAgICAgIC8vIENhY2hlIGZvciBzbGVlcGVyIHNoYXBlcyBhbmQgYml0bWFwc1xuICAgICAgdGhpcy5fc2xlZXBlckNhY2hlID0ge307XG4gICAgICB0aGlzLl9iaXRtYXBDYWNoZSA9IG5ldyBBcnJheSh0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5TQ0hXRUxMRU5fVkFSSUFOVEVOKTtcbiAgIH1cblxuICAgY2xlYW5VcCgpIHtcbiAgICAgIGlmICh0aGlzLl9pZGxlQ2FsbGJhY2spIHtcbiAgICAgICAgIGlmICh3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaykgY2FuY2VsSWRsZUNhbGxiYWNrKHRoaXMuX2lkbGVDYWxsYmFjayk7XG4gICAgICAgICBlbHNlIGNsZWFyVGltZW91dCh0aGlzLl9pZGxlQ2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBteUlkbGVDYWxsYmFjayA9XG4gICAgICAgICB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayB8fFxuICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMSk7XG4gICAgICAgICB9O1xuXG4gICAgICB0aGlzLl9pZGxlQ2FsbGJhY2sgPSBteUlkbGVDYWxsYmFjayhcbiAgICAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHAuY29udGFpbmVycy50cmFja3MucmVuZGVyZWRUcmFja3Muc2l6ZSA9PSAwIHx8IHRoaXMuX3JlbmRlcmluZyAhPSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmNhbGNDYW52YXNTaXplKCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdHJhY2tzIHRoYXQgYXJlIG5vIGxvbmdlciB2aXNpYmxlXG4gICAgICAgICAgICBjb25zdCB0b0JlUmVtb3ZlZCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hcHAuY29udGFpbmVycy50cmFja3MucmVuZGVyZWRUcmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgIGlmICghdGhpcy5UcmFja1Zpc2libGUodHJhY2ssIGJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICAgIHRvQmVSZW1vdmVkLnB1c2godHJhY2spO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFja3MgYW5kIHRoZWlyIGFzc29jaWF0ZWQgc2lnbmFsc1xuICAgICAgICAgICAgdG9CZVJlbW92ZWQuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhc3NvY2lhdGVkIHNpZ25hbHNcbiAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbHNUb0JlUmVtb3ZlZCA9IHRoaXMuYXBwLmNvbnRhaW5lcnMuc2lnbmFscy5jaGlsZHJlbi5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAoY3MpID0+IGNzLmRhdGEuX3Bvc2l0aW9uaW5nLnRyYWNrID09PSB0cmFja1xuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgIHNpZ25hbHNUb0JlUmVtb3ZlZC5mb3JFYWNoKChjcykgPT4ge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5zaWduYWxzLnJlbW92ZUNoaWxkKGNzKTtcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWNrIGZyb20gcmVuZGVyZWQgc2V0XG4gICAgICAgICAgICAgICB0aGlzLmFwcC5jb250YWluZXJzLnRyYWNrcy5yZW5kZXJlZFRyYWNrcy5kZWxldGUodHJhY2spO1xuXG4gICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhY2sgZWxlbWVudHMgZnJvbSBib3RoIGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgIGNvbnN0IHNsZWVwZXJzVG9SZW1vdmUgPSB0aGlzLmFwcC5jb250YWluZXJzLnRyYWNrcy5jaGlsZHJlblswXS5jaGlsZHJlbi5maWx0ZXIoKGMpID0+IGMuZGF0YSA9PT0gdHJhY2spO1xuICAgICAgICAgICAgICAgY29uc3QgcmFpbHNUb1JlbW92ZSA9IHRoaXMuYXBwLmNvbnRhaW5lcnMudHJhY2tzLmNoaWxkcmVuWzFdLmNoaWxkcmVuLmZpbHRlcigoYykgPT4gYy5kYXRhID09PSB0cmFjayk7XG5cbiAgICAgICAgICAgICAgIHNsZWVwZXJzVG9SZW1vdmUuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGMudHJhY2s7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFwcC5jb250YWluZXJzLnRyYWNrcy5jaGlsZHJlblswXS5yZW1vdmVDaGlsZChjKTtcbiAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICByYWlsc1RvUmVtb3ZlLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjLnRyYWNrO1xuICAgICAgICAgICAgICAgICAgdGhpcy5hcHAuY29udGFpbmVycy50cmFja3MuY2hpbGRyZW5bMV0ucmVtb3ZlQ2hpbGQoYyk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBzbGVlcGVyIGNhY2hlIGlmIGl0J3MgZ2V0dGluZyB0b28gbGFyZ2UgKG1vcmUgdGhhbiAyMDAgZW50cmllcylcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zbGVlcGVyQ2FjaGUpLmxlbmd0aCA+IDIwMCkge1xuICAgICAgICAgICAgICAgdGhpcy5fc2xlZXBlckNhY2hlID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lkbGVDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICk7XG4gICB9XG5cbiAgIGNhbGNDYW52YXNTaXplKCkge1xuICAgICAgY29uc3Qgc3RhZ2UgPSB0aGlzLmFwcC5zdGFnZTtcbiAgICAgIGNvbnN0IHdpZHRoID0gKHN0YWdlLmNhbnZhcy53aWR0aCArIENPTkZJRy5HUklEX1NJWkUgKiAyKSAvIHN0YWdlLnNjYWxlWCxcbiAgICAgICAgIGhlaWdodCA9IChzdGFnZS5jYW52YXMuaGVpZ2h0ICsgQ09ORklHLkdSSURfU0laRSAqIDIpIC8gc3RhZ2Uuc2NhbGVZLFxuICAgICAgICAgeCA9ICgtc3RhZ2UueCAtIENPTkZJRy5HUklEX1NJWkUpIC8gc3RhZ2Uuc2NhbGVYLFxuICAgICAgICAgeSA9ICgtc3RhZ2UueSAtIENPTkZJRy5HUklEX1NJWkUpIC8gc3RhZ2Uuc2NhbGVZO1xuICAgICAgcmV0dXJuIHsgbGVmdDogeCwgdG9wOiB5LCByaWdodDogeCArIHdpZHRoLCBib3R0b206IHkgKyBoZWlnaHQgfTtcbiAgIH1cblxuICAgLy8vZm9yY2U9ZmFsc2UgbWVhbnMsIGVhY2ggZWxlbWVudCBkZWNpZGVzIGlmIGl0IG5lZWRzIHRvIGJlIHJlZHJhd24uIElmIHNvbWV0aGluZyBnbG9iYWwgY2hhbmdlZCxcbiAgIC8vL2xpa2UgdGhlIHNjYWxlLCBmb3JjZSBuZWVkcyB0byBiZSB0cnVlLlxuICAgLy8vIGRvbnRfb3B0aW1pemUgcGFyYW1ldGVyIGRpc2FibGVzIHRoZSBvcHRpbWFzYXRpb24gdG8gb25seSBoYW5kbGUgYW5kIGRyYXcgZWxlbWVudHMgaW5zaWRlIHRoZSB2aWV3cG9ydFxuICAgLy8vIGFuZCBkaXNhYmxlcyBjYWNoaW5nLiBpdHMgdXNlZCBieSB0aGUgZXhwb3J0IHRvIGltYWdlIGZ1bmN0aW9uYWxpdHlcbiAgIHJlRHJhd0V2ZXJ5dGhpbmcoZm9yY2UgPSBmYWxzZSwgZG9udF9vcHRpbWl6ZSA9IGZhbHNlKSB7XG4gICAgICBpZiAoIUFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkucHJlTG9hZGVyLmxvYWRlZClcbiAgICAgICAgIC8vc3R1cGlkIGNvZGUgdGhhdCBzaG91bGQgcHJldmVudCBkcmF3aW5nLCBiZWZvcmUgdGhlIHByZWxvYWRlciBpcyByZWFkeVxuICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlRHJhd0V2ZXJ5dGhpbmcoZm9yY2UsIGRvbnRfb3B0aW1pemUpO1xuICAgICAgICAgfSwgNTAwKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICAgY29uc3QgY29udGFpbmVycyA9IHRoaXMuYXBwLmNvbnRhaW5lcnM7XG4gICAgICAgICBpZiAodGhpcy5fcmVuZGVyaW5nID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmluZyA9IHsgZG9udF9vcHRpbWl6ZTogZG9udF9vcHRpbWl6ZSB9O1xuICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyaW5nLnNjcmVlbl9yZWN0YW5nbGUgPSB0aGlzLmNhbGNDYW52YXNTaXplKCk7XG5cbiAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgY29udGFpbmVycy50cmFja3MucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcnMuc2lnbmFscy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgY29udGFpbmVycy51aS5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgY29udGFpbmVycy50cmFpbnMucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcnMub2JqZWN0cy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgY29udGFpbmVycy5kZWJ1Zy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgY29udGFpbmVycy5zZWxlY3Rpb24ucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblxuICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIG92ZXJsYXkgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICBjb250YWluZXJzLm92ZXJsYXkucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjUmVuZGVyVmFsdWVzKCk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBwYXNzZWQgdGhlIExPRCBpbiBlaXRoZXIgZGlyZWN0aW9uIHdlIGhhdmUgdG8gcmVyZW5kZXIgdGhlIHRyYWNrc1xuICAgICAgICAgICAgICAgICAgaWYgKE51bWJlclV0aWxzLmJldHdlZW4odGhpcy5MT0QsIHRoaXMuX2xhc3RSZW5kZXJTY2FsZSwgdGhpcy5hcHAuc3RhZ2Uuc2NhbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJpbmcubG9kQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckFsbFRyYWNrcyhmb3JjZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckFsbFNpZ25hbHMoZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJBbGxUcmFpbnMoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQWxsR2VuZXJpY09iamVjdHMoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RSZW5kZXJTY2FsZSA9IHRoaXMuYXBwLnN0YWdlLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgaWYgKCFkb250X29wdGltaXplKSB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHJlbmRlcmluZzpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlcmluZztcbiAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDcml0aWNhbCByZW5kZXJpbmcgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgIHVpLnNob3dFcnJvclRvYXN0KGVycm9yKTtcbiAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gcmVjb3ZlciBieSBjbGVhcmluZyByZW5kZXJpbmcgc3RhdGVcbiAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJpbmc7XG4gICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cbiAgIH1cblxuICAgY2FsY1JlbmRlclZhbHVlcygpIHtcbiAgICAgIHRoaXMuc2Nod2VsbGVuSW1nID0gdGhpcy5hcHAucHJlTG9hZGVyLmdldEltYWdlKFwic2Nod2VsbGVuXCIpO1xuICAgICAgdGhpcy5idW1wZXJJbWcgPSB0aGlzLmFwcC5wcmVMb2FkZXIuZ2V0SW1hZ2UoXCJidW1wZXJcIik7XG4gICAgICB0aGlzLnNsZWVwZXJzSW1nV2lkdGggPSB0aGlzLnNjaHdlbGxlbkltZy53aWR0aCAvIHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlNDSFdFTExFTl9WQVJJQU5URU47XG4gICAgICB0aGlzLnNjaHdlbGxlbkjDtmhlID0gdGhpcy5zY2h3ZWxsZW5JbWcuaGVpZ2h0ICogdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuVFJBQ0tfU0NBTEU7XG4gICAgICB0aGlzLnNjaHdlbGxlbkjDtmhlXzIgPSB0aGlzLnNjaHdlbGxlbkjDtmhlIC8gMjtcbiAgICAgIHRoaXMuc2Nod2VsbGVuQnJlaXRlID0gdGhpcy5zbGVlcGVyc0ltZ1dpZHRoICogdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuVFJBQ0tfU0NBTEU7XG4gICAgICB0aGlzLnNjaHdlbGxlbkdhcCA9IHRoaXMuc2Nod2VsbGVuQnJlaXRlICogMS4xOyAvLyBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBzbGVlcGVyc1xuICAgICAgdGhpcy5zbGVlcGVySW50ZXJ2YWxsID0gdGhpcy5zY2h3ZWxsZW5CcmVpdGUgKyB0aGlzLnNjaHdlbGxlbkdhcDtcbiAgICAgIHRoaXMucmFpbF9vZmZzZXQgPSB0aGlzLnNjaHdlbGxlbkjDtmhlIC8gNC43OyAvLyBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYWlsIGFuZCB0aGUgZW5kIG9mIHRoZSBzbGVlcGVyXG4gICAgICB0aGlzLnJhaWxfZGlzdGFuY2UgPSB0aGlzLnNjaHdlbGxlbkjDtmhlXzIgLSB0aGlzLnJhaWxfb2Zmc2V0OyAvLyBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYWlsIGFuZCB0aGUgY2VudGVyIG9mIHRoZSB0cmFja1xuXG4gICAgICB0aGlzLlRSQUlOX0hFSUdIVCA9IHRoaXMuc2Nod2VsbGVuSMO2aGUgLSB0aGlzLnJhaWxfb2Zmc2V0O1xuICAgICAgdGhpcy5UUkFJTl9XSURUSCA9IENPTkZJRy5HUklEX1NJWkUgKiAwLjc7XG5cbiAgICAgIHRoaXMubWFpbl94MSA9IChNYXRoLnNpbihNYXRoLlBJIC8gOCkgKiB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5DVVJWRV9SQURJVVMpIC8gTWF0aC5jb3MoTWF0aC5QSSAvIDgpO1xuICAgfVxuXG4gICByZW5kZXJBbGxUcmFpbnMoKSB7XG4gICAgICB0aGlzLmFwcC5jb250YWluZXJzLnRyYWlucy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICAvLyBPbmx5IHJlbmRlciB0cmFpbnMgdGhhdCBhcmVuJ3QgY291cGxlZCB0byBhbm90aGVyIHRyYWluJ3MgZnJvbnRcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBvbmx5IGNyZWF0ZSBjb250YWluZXJzIGZvciBsZWFkIGNhcnNcbiAgICAgIFRyYWluLmFsbFRyYWluc1xuICAgICAgICAgLmZpbHRlcigodHJhaW4pID0+ICF0cmFpbi50cmFpbkNvdXBsZWRGcm9udClcbiAgICAgICAgIC5mb3JFYWNoKCh0cmFpbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgYyA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgICAgIGMubmFtZSA9IFwidHJhaW5cIjtcbiAgICAgICAgICAgIGMudHJhaW4gPSB0cmFpbjtcbiAgICAgICAgICAgIGMubW91c2VDaGlsZHJlbiA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHJlbmRlcmluZyBmcm9tIHRoZSBmaXJzdCBjYXIgKGxvY29tb3RpdmUpXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNhcih0cmFpbiwgYyk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwLmNvbnRhaW5lcnMudHJhaW5zLmFkZENoaWxkKGMpO1xuICAgICAgICAgfSk7XG4gICB9XG5cbiAgIHJlbmRlckNhcihjYXIsIGNvbnRhaW5lcikge1xuICAgICAgLy8gQ3JlYXRlIGdyYXBoaWNzIGZvciB0aGUgY2FyXG4gICAgICBjb25zdCBnID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCk7XG4gICAgICBnLnNldFN0cm9rZVN0eWxlKDEpO1xuICAgICAgZy5iZWdpblN0cm9rZShjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoMCwgMCwgMCkpO1xuICAgICAgZy5iZWdpbkZpbGwoY2FyLmNvbG9yKTtcblxuICAgICAgLy8gVXNlIHRoZSBjYXIncyBhY3R1YWwgbGVuZ3RoIGZvciB3aWR0aCBpbnN0ZWFkIG9mIGZpeGVkIFRSQUlOX1dJRFRIXG4gICAgICBjb25zdCBjYXJXaWR0aCA9IGNhci5sZW5ndGg7XG4gICAgICBjb25zdCBjYXJIZWlnaHQgPSB0aGlzLlRSQUlOX0hFSUdIVDtcblxuICAgICAgLy8gU2V0IGNvcm5lciByYWRpdXMgYmFzZWQgb24gY2FyIHR5cGUgYW5kIHBvc2l0aW9uIGluIHRyYWluXG4gICAgICBsZXQgY29ybmVyID0gWzEuNSwgMS41LCAxLjUsIDEuNV07XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IGNhciAobG9jb21vdGl2ZSksIHJvdW5kIHRoZSBmcm9udFxuICAgICAgaWYgKGNhci50eXBlID09IFRyYWluLkNBUl9UWVBFUy5MT0NPTU9USVZFKSB7XG4gICAgICAgICBjb3JuZXJbMF0gPSBjb3JuZXJbM10gPSBjb3JuZXJbMV0gPSBjb3JuZXJbMl0gPSA4O1xuICAgICAgfVxuXG4gICAgICAvKiAvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IGNhciwgcm91bmQgdGhlIGJhY2tcbiAgICAgIGlmIChjYXIudHJhaW5Db3VwbGVkQmFjayA9PSBudWxsKSB7XG4gICAgICAgICBjb3JuZXJbMV0gPSBjb3JuZXJbMl0gPSAyMDtcbiAgICAgIH0gKi9cblxuICAgICAgLy8gRHJhdyBjYXIgd2l0aCByb3VuZGVkIGNvcm5lcnNcbiAgICAgIGcuZHJhd1JvdW5kUmVjdENvbXBsZXgoMCwgMCwgY2FyV2lkdGgsIGNhckhlaWdodCwgY29ybmVyWzBdLCBjb3JuZXJbMV0sIGNvcm5lclsyXSwgY29ybmVyWzNdKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBzaGFwZSBhbmQgcG9zaXRpb24gaXRcbiAgICAgIGNvbnN0IHMgPSBuZXcgY3JlYXRlanMuU2hhcGUoZyk7XG4gICAgICBzLmRhdGEgPSBjYXI7XG4gICAgICBzLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIHMubmFtZSA9IFwidHJhaW5cIjtcblxuICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvbiB0aGUgdHJhY2sgYmFzZWQgb24gdGhlIGNhcidzIGttIHBvc2l0aW9uXG4gICAgICBjb25zdCBwID0gY2FyLnRyYWNrLmdldFBvaW50RnJvbUttKGNhci5wb3MpO1xuXG4gICAgICBzLnggPSBwLng7XG4gICAgICBzLnkgPSBwLnk7XG4gICAgICBzLnJlZ1ggPSBjYXJXaWR0aCAvIDI7XG4gICAgICBzLnJlZ1kgPSBjYXJIZWlnaHQgLyAyO1xuICAgICAgcy5yb3RhdGlvbiA9IGNhci50cmFjay5kZWc7XG5cbiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzKTtcbiAgICAgIC8vIEFkZCB0cmFpbiBudW1iZXIgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoY2FyLm51bWJlciAmJiBjYXIudHlwZSA9PSBUcmFpbi5DQVJfVFlQRVMuTE9DT01PVElWRSkge1xuICAgICAgICAgY29uc3QgdGV4dCA9IG5ldyBjcmVhdGVqcy5UZXh0KGNhci5udW1iZXIsIFwiMTBweCBBcmlhbFwiLCBcIiMwMDAwMDBcIik7XG4gICAgICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICB0ZXh0LnggPSBwLng7XG4gICAgICAgICB0ZXh0LnkgPSBwLnk7XG4gICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGV4dCk7XG4gICAgICB9XG4gICAgICAvLyBSZWN1cnNpdmVseSByZW5kZXIgY291cGxlZCBjYXJzXG4gICAgICBpZiAoY2FyLnRyYWluQ291cGxlZEJhY2spIHtcbiAgICAgICAgIHRoaXMucmVuZGVyQ2FyKGNhci50cmFpbkNvdXBsZWRCYWNrLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgfVxuXG4gICByZW5kZXJBbGxHZW5lcmljT2JqZWN0cygpIHtcbiAgICAgIHRoaXMuYXBwLmNvbnRhaW5lcnMub2JqZWN0cy5yZW1vdmVBbGxDaGlsZHJlbigpO1xuICAgICAgR2VuZXJpY09iamVjdC5hbGxfb2JqZWN0cy5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICBjb25zdCBjID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgYy5uYW1lID0gXCJHZW5lcmljT2JqZWN0XCI7XG4gICAgICAgICBjLmRhdGEgPSBvO1xuICAgICAgICAgYy5tb3VzZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICBjLnggPSBvLnBvcygpLng7XG4gICAgICAgICBjLnkgPSBvLnBvcygpLnk7XG5cbiAgICAgICAgIGlmIChvLnR5cGUoKSA9PT0gR2VuZXJpY09iamVjdC5PQkpFQ1RfVFlQRS50ZXh0KSB0aGlzLnJlbmRlclRleHRPYmplY3QobywgYyk7XG4gICAgICAgICBlbHNlIGlmIChvLnR5cGUoKSA9PT0gR2VuZXJpY09iamVjdC5PQkpFQ1RfVFlQRS5wbGF0dGZvcm0pIHRoaXMucmVuZGVyUGxhdHRmb3JtT2JqZWN0KG8sIGMpO1xuICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIE9iamVjdFwiKTtcblxuICAgICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5vYmplY3RzLmFkZENoaWxkKGMpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHJlbmRlclRleHRPYmplY3QodGV4dF9vYmplY3QsIGNvbnRhaW5lcikge1xuICAgICAgdmFyIHRleHQgPSBuZXcgY3JlYXRlanMuVGV4dCh0ZXh0X29iamVjdC5jb250ZW50KCksIFwiMjRweCBBcmlhbFwiLCBcIiMwMDAwMDBcIik7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdGV4dC5nZXRNZWFzdXJlZEhlaWdodCgpO1xuICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0LmdldE1lYXN1cmVkV2lkdGgoKTtcblxuICAgICAgY29uc3QgaGl0ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICBoaXQuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiIzAwMFwiKS5tdCgwLCAwKS5sdCh3aWR0aCwgMCkubHQod2lkdGgsIC1oZWlnaHQpLmx0KDAsIC1oZWlnaHQpLmx0KDAsIDApO1xuXG4gICAgICB0ZXh0LmhpdEFyZWEgPSBoaXQ7XG5cbiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0ZXh0KTtcbiAgIH1cblxuICAgcmVuZGVyUGxhdHRmb3JtT2JqZWN0KHBsYXR0Zm9ybSwgY29udGFpbmVyKSB7XG4gICAgICBjb25zdCBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgY29udGFpbmVyLmFkZENoaWxkKHNoYXBlKTtcbiAgICAgIGNvbnN0IHNpemUgPSBwbGF0dGZvcm0uc2l6ZSgpO1xuICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5TdHJva2UoXCIjMTExMTExXCIpLmJlZ2luRmlsbChcIiM0NDRcIikuZHJhd1JlY3QoMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgc2hhcGUuc2V0Qm91bmRzKDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblxuICAgICAgdmFyIHRleHQgPSBuZXcgY3JlYXRlanMuVGV4dChwbGF0dGZvcm0uY29udGVudCgpLCBcIjE2cHggQXJpYWxcIiwgXCIjZWVlXCIpO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgdGV4dC54ID0gcGxhdHRmb3JtLnNpemUoKS53aWR0aCAvIDI7XG4gICAgICB0ZXh0LnkgPSBwbGF0dGZvcm0uc2l6ZSgpLmhlaWdodCAvIDI7XG5cbiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0ZXh0KTtcbiAgIH1cblxuICAgcmVuZGVyQWxsU2lnbmFscyhmb3JjZSkge1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5zaWduYWxzLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICBTaWduYWwuYWxsU2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHtcbiAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmFwcC5jb250YWluZXJzLnNpZ25hbHMuYWRkQ2hpbGQoU2lnbmFsUmVuZGVyZXIuY3JlYXRlU2lnbmFsQ29udGFpbmVyKHNpZ25hbCkpO1xuICAgICAgICAgdGhpcy5hcHAuYWxpZ25TaWduYWxDb250YWluZXJXaXRoVHJhY2soY29udGFpbmVyLCBzaWduYWwuX3Bvc2l0aW9uaW5nKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICByZW5kZXJBbGxUcmFja3MoZm9yY2UpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lcnMgPSB0aGlzLmFwcC5jb250YWluZXJzO1xuICAgICAgLy9pZiB3ZSBoYXZlIHRvIGZvcmNlIGEgcmVkcmF3LCB3ZSBoYXZlIHRvIGNyZWF0ZSB0aGUgY29udGFpbmVycyBmb3IgdGhlIHNsZWVwZXJzIGFuZCByYWlsc1xuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICBjb25zdCBzbGVlcGVyc19jb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gICAgICAgICBzbGVlcGVyc19jb250YWluZXIubmFtZSA9IFwiZ2xvYmFsX3NsZWVwZXJzXCI7XG4gICAgICAgICBzbGVlcGVyc19jb250YWluZXIubW91c2VDaGlsZHJlbiA9IHRydWU7XG5cbiAgICAgICAgIGNvbnN0IHJhaWxzX2NvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgICAgIHJhaWxzX2NvbnRhaW5lci5uYW1lID0gXCJnbG9iYWxfcmFpbHNcIjtcbiAgICAgICAgIHJhaWxzX2NvbnRhaW5lci5tb3VzZUNoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICAgdGhpcy5fcmVuZGVyaW5nLnNsZWVwZXJzX2NvbnRhaW5lciA9IHNsZWVwZXJzX2NvbnRhaW5lcjtcbiAgICAgICAgIHRoaXMuX3JlbmRlcmluZy5yYWlsc19jb250YWluZXIgPSByYWlsc19jb250YWluZXI7XG5cbiAgICAgICAgIGNvbnRhaW5lcnMudHJhY2tzLmFkZENoaWxkKHNsZWVwZXJzX2NvbnRhaW5lcik7XG4gICAgICAgICBjb250YWluZXJzLnRyYWNrcy5hZGRDaGlsZChyYWlsc19jb250YWluZXIpO1xuICAgICAgICAgY29udGFpbmVycy50cmFja3MucmVuZGVyZWRUcmFja3MgPSBuZXcgU2V0KCk7XG4gICAgICAgICBjb250YWluZXJzLnRyYWNrcy5yZW5kZXJlZFN3aXRjaGVzID0gbmV3IFNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHRoaXMuX3JlbmRlcmluZy5zbGVlcGVyc19jb250YWluZXIgPSBjb250YWluZXJzLnRyYWNrcy5jaGlsZHJlblswXTtcbiAgICAgICAgIHRoaXMuX3JlbmRlcmluZy5yYWlsc19jb250YWluZXIgPSBjb250YWluZXJzLnRyYWNrcy5jaGlsZHJlblsxXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB0IG9mIFRyYWNrLmFsbFRyYWNrcykge1xuICAgICAgICAgaWYgKHRoaXMuVHJhY2tWaXNpYmxlKHQpKSB7XG4gICAgICAgICAgICAvL2VpdGhlciB3ZSBoYXZlIGEgZm9yY2VkIHJlZHJhdyBvciB0aGUgdHJhY2sgaXMgbm90IHJlbmRlcmVkIHlldFxuICAgICAgICAgICAgaWYgKGZvcmNlIHx8ICFjb250YWluZXJzLnRyYWNrcy5yZW5kZXJlZFRyYWNrcy5oYXModCkpIHtcbiAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVHJhY2sodCk7XG4gICAgICAgICAgICAgICBjb250YWluZXJzLnRyYWNrcy5yZW5kZXJlZFRyYWNrcy5hZGQodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3JlbmRlcmluZy5sb2RDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYWNrKHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHN3IG9mIFN3aXRjaC5hbGxTd2l0Y2hlcykge1xuICAgICAgICAgaWYgKHRoaXMuU3dpdGNoVmlzaWJsZShzdykpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSB8fCAhY29udGFpbmVycy50cmFja3MucmVuZGVyZWRTd2l0Y2hlcy5oYXMoc3cpKSB7XG4gICAgICAgICAgICAgICB0aGlzLnJlbmRlclN3aXRjaChzdyk7XG4gICAgICAgICAgICAgICBjb250YWluZXJzLnRyYWNrcy5yZW5kZXJlZFN3aXRjaGVzLmFkZChzdyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3JlbmRlcmluZy5sb2RDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN3aXRjaChzdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICB9XG4gICB9XG5cbiAgIC8vL2NhbGN1bGF0ZSBzdGFydCBhbmQgZW5kIHBvaW50cyBmb3IgZWFjaCBub2RlIG9mIGEgdHJhY2sgYW5kIHRoZSBjb250cm9sIHBvaW50IGZvciB0aGUgY3VydmVcbiAgIC8vL3N0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIHN0cmFpZ2h0IHNlZ21lbnRzIGFyZSBhZGp1c3RlZCBmb3IgdGhlIGN1cnZlc1xuICAgY2FsY3VsYXRlVHJhY2tQb2ludHModHJhY2spIHtcbiAgICAgIGNvbnN0IHN0YXJ0Q29ubmVjdGlvbiA9IHRyYWNrLnN3aXRjaEF0VGhlU3RhcnQ7XG4gICAgICBjb25zdCBlbmRDb25uZWN0aW9uID0gdHJhY2suc3dpdGNoQXRUaGVFbmQ7XG5cbiAgICAgIGxldCBzdGFydFBvaW50ID0gdHJhY2suc3RhcnQ7XG4gICAgICBsZXQgZW5kUG9pbnQgPSB0cmFjay5lbmQ7XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrXG4gICAgICBpZiAoc3RhcnRDb25uZWN0aW9uKSB7XG4gICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY29ubmVjdGlvbiwgc2hvcnRlbiB0aGUgdHJhY2sgdG8gbWFrZSBzcGFjZVxuICAgICAgICAgY29uc3Qgc2l6ZSA9IHN0YXJ0Q29ubmVjdGlvbiBpbnN0YW5jZW9mIFN3aXRjaCA/IHN0YXJ0Q29ubmVjdGlvbi5zaXplIDogQ09NUFVURUQuR1JJRF9TSVpFXzI7XG4gICAgICAgICBzdGFydFBvaW50ID0gc3RhcnRQb2ludC5hZGQoZ2VvbWV0cnkubXVsdGlwbHkodHJhY2sudW5pdCwgc2l6ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY29ubmVjdGlvbiwgZXh0ZW5kIGl0IGZvciB0aGUgYnVtcGVyXG4gICAgICAgICBzdGFydFBvaW50ID0gc3RhcnRQb2ludC5zdWIoZ2VvbWV0cnkubXVsdGlwbHkodHJhY2sudW5pdCwgQ09NUFVURUQuR1JJRF9TSVpFXzIpKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHN0cmFpZ2h0RW5kUG9pbnQgPSBlbmRQb2ludDtcbiAgICAgIGxldCBjdXJ2ZUVuZCA9IG51bGw7XG4gICAgICBsZXQgY29udHJvbFBvaW50ID0gbnVsbDtcbiAgICAgIGxldCBuZXh0VW5pdCA9IG51bGw7XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgZW5kIG9mIHRoZSB0cmFja1xuICAgICAgaWYgKGVuZENvbm5lY3Rpb24pIHtcbiAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb25uZWN0aW9uLCBzaG9ydGVuIHRoZSB0cmFjayB0byBtYWtlIHNwYWNlIGZvciB0aGUgc3dpdGNoIG9yIGN1cnZlXG4gICAgICAgICBjb25zdCBzaXplID0gZW5kQ29ubmVjdGlvbiBpbnN0YW5jZW9mIFN3aXRjaCA/IGVuZENvbm5lY3Rpb24uc2l6ZSA6IENPTVBVVEVELkdSSURfU0laRV8yO1xuICAgICAgICAgc3RyYWlnaHRFbmRQb2ludCA9IGVuZFBvaW50LnN1YihnZW9tZXRyeS5tdWx0aXBseSh0cmFjay51bml0LCBzaXplKSk7XG5cbiAgICAgICAgIGlmIChlbmRDb25uZWN0aW9uIGluc3RhbmNlb2YgVHJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzIGFub3RoZXIgdHJhY2ssIGNhbGN1bGF0ZSB0aGUgY3VydmVcbiAgICAgICAgICAgIGNvbnN0IG5leHRUcmFjayA9IGVuZENvbm5lY3Rpb247XG4gICAgICAgICAgICBuZXh0VW5pdCA9IG5leHRUcmFjay51bml0O1xuICAgICAgICAgICAgLy8gVGhlIGN1cnZlIHNob3VsZCBlbmQgYXQgdGhlICpzaG9ydGVuZWQqIHN0YXJ0IG9mIHRoZSBuZXh0IHRyYWNrXG4gICAgICAgICAgICBjdXJ2ZUVuZCA9IG5leHRUcmFjay5zdGFydC5hZGQoZ2VvbWV0cnkubXVsdGlwbHkobmV4dFVuaXQsIENPTVBVVEVELkdSSURfU0laRV8yKSk7XG4gICAgICAgICAgICBjb250cm9sUG9pbnQgPSBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludFgoc3RyYWlnaHRFbmRQb2ludCwgdHJhY2sudW5pdCwgY3VydmVFbmQsIG5leHRVbml0KTtcbiAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGNvbm5lY3Rpb24sIGV4dGVuZCB0aGUgdHJhY2sgZm9yIHRoZSBidW1wZXIuXG4gICAgICAgICBzdHJhaWdodEVuZFBvaW50ID0gZW5kUG9pbnQuYWRkKGdlb21ldHJ5Lm11bHRpcGx5KHRyYWNrLnVuaXQsIENPTVBVVEVELkdSSURfU0laRV8yKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNlbnRlckxpbmUgPSB7XG4gICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgICBzdGFydDogc3RhcnRQb2ludCxcbiAgICAgICAgIHN0cmFpZ2h0RW5kOiBzdHJhaWdodEVuZFBvaW50LCAvLyBUaGlzIGlzIHRoZSBlbmQgb2YgdGhlIHN0cmFpZ2h0IHBhcnQsIGJlZm9yZSBhbnkgY3VydmUuXG4gICAgICAgICBlbmQ6IGVuZFBvaW50LCAvLyBPcmlnaW5hbCBlbmQgcG9pbnQgZm9yIHJlZmVyZW5jZS5cbiAgICAgICAgIHVuaXQ6IHRyYWNrLnVuaXQsXG4gICAgICAgICBjdXJ2ZUVuZDogY3VydmVFbmQsIC8vIEVuZCBwb2ludCBvZiB0aGUgY3VydmUuXG4gICAgICAgICBjb250cm9sUG9pbnQ6IGNvbnRyb2xQb2ludCwgLy8gQ29udHJvbCBwb2ludCBmb3IgdGhlIGN1cnZlLlxuICAgICAgICAgbmV4dFVuaXQ6IG5leHRVbml0LCAvLyBVbml0IHZlY3RvciBvZiB0aGUgbmV4dCB0cmFjay5cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY2FsY3VsYXRlUmFpbFBvc2l0aW9ucyhjZW50ZXJMaW5lKTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlU2xlZXBlck91dGxpbmUoY2VudGVyTGluZSk7XG5cbiAgICAgIHJldHVybiBbY2VudGVyTGluZV07XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ2FsY3VsYXRlIHNsZWVwZXIgb3V0bGluZSBmb3IgYSB0cmFjayBzZWdtZW50XG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2VudGVyTGluZSAtIFRoZSBjZW50ZXJsaW5lIG9iamVjdCB0byBhZGQgc2xlZXBlciBvdXRsaW5lIHRvXG4gICAgKi9cbiAgIGNhbGN1bGF0ZVNsZWVwZXJPdXRsaW5lKGNlbnRlckxpbmUpIHtcbiAgICAgIGNvbnN0IHNsZWVwZXJPZmZzZXQgPSB0aGlzLnNjaHdlbGxlbkjDtmhlXzI7XG4gICAgICBjb25zdCBzbGVlcGVyT2Zmc2V0VmVjdG9yID0gZ2VvbWV0cnkucGVycGVuZGljdWxhcihjZW50ZXJMaW5lLnVuaXQubXVsdGlwbHkoc2xlZXBlck9mZnNldCkpO1xuXG4gICAgICBjZW50ZXJMaW5lLnNsZWVwZXJPdXRsaW5lID0ge1xuICAgICAgICAgc3RyYWlnaHQ6IHtcbiAgICAgICAgICAgIGlubmVyOiB7XG4gICAgICAgICAgICAgICBzdGFydDogY2VudGVyTGluZS5zdGFydC5hZGQoc2xlZXBlck9mZnNldFZlY3RvciksXG4gICAgICAgICAgICAgICBlbmQ6IGNlbnRlckxpbmUuc3RyYWlnaHRFbmQuYWRkKHNsZWVwZXJPZmZzZXRWZWN0b3IpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG91dGVyOiB7XG4gICAgICAgICAgICAgICBzdGFydDogY2VudGVyTGluZS5zdGFydC5zdWIoc2xlZXBlck9mZnNldFZlY3RvciksXG4gICAgICAgICAgICAgICBlbmQ6IGNlbnRlckxpbmUuc3RyYWlnaHRFbmQuc3ViKHNsZWVwZXJPZmZzZXRWZWN0b3IpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBpZiAoY2VudGVyTGluZS5jb250cm9sUG9pbnQpIHtcbiAgICAgICAgIGNvbnN0IG5leHRTbGVlcGVyT2Zmc2V0VmVjdG9yID0gZ2VvbWV0cnkucGVycGVuZGljdWxhcihjZW50ZXJMaW5lLm5leHRVbml0Lm11bHRpcGx5KHNsZWVwZXJPZmZzZXQpKTtcblxuICAgICAgICAgY29uc3QgY3VydmVPdXRlckVuZCA9IGNlbnRlckxpbmUuY3VydmVFbmQuc3ViKG5leHRTbGVlcGVyT2Zmc2V0VmVjdG9yKTtcbiAgICAgICAgIGNvbnN0IGN1cnZlSW5uZXJFbmQgPSBjZW50ZXJMaW5lLmN1cnZlRW5kLmFkZChuZXh0U2xlZXBlck9mZnNldFZlY3Rvcik7XG5cbiAgICAgICAgIGNvbnN0IGN1cnZlT3V0ZXJTdGFydCA9IGNlbnRlckxpbmUuc2xlZXBlck91dGxpbmUuc3RyYWlnaHQub3V0ZXIuZW5kO1xuICAgICAgICAgY29uc3QgY3VydmVJbm5lclN0YXJ0ID0gY2VudGVyTGluZS5zbGVlcGVyT3V0bGluZS5zdHJhaWdodC5pbm5lci5lbmQ7XG5cbiAgICAgICAgIGNvbnN0IGNwT3V0ZXIgPSBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludFgoY3VydmVPdXRlclN0YXJ0LCBjZW50ZXJMaW5lLnVuaXQsIGN1cnZlT3V0ZXJFbmQsIGNlbnRlckxpbmUubmV4dFVuaXQpO1xuICAgICAgICAgY29uc3QgY3BJbm5lciA9IGdlb21ldHJ5LmdldEludGVyc2VjdGlvblBvaW50WChjdXJ2ZUlubmVyU3RhcnQsIGNlbnRlckxpbmUudW5pdCwgY3VydmVJbm5lckVuZCwgY2VudGVyTGluZS5uZXh0VW5pdCk7XG5cbiAgICAgICAgIGNlbnRlckxpbmUuc2xlZXBlck91dGxpbmUuY3VydmUgPSB7XG4gICAgICAgICAgICBvdXRlcjogeyBzdGFydDogY3VydmVPdXRlclN0YXJ0LCBlbmQ6IGN1cnZlT3V0ZXJFbmQsIGNwOiBjcE91dGVyIH0sXG4gICAgICAgICAgICBpbm5lcjogeyBzdGFydDogY3VydmVJbm5lclN0YXJ0LCBlbmQ6IGN1cnZlSW5uZXJFbmQsIGNwOiBjcElubmVyIH0sXG4gICAgICAgICB9O1xuICAgICAgfVxuICAgfVxuXG4gICAvKipcbiAgICAqIENhbGN1bGF0ZSByYWlsIHBvc2l0aW9ucyBmb3IgYSB0cmFjayBzZWdtZW50XG4gICAgKiBAcGFyYW0ge09iamVjdH0gY2VudGVyTGluZSAtIFRoZSBjZW50ZXJsaW5lIG9iamVjdCB0byBhZGQgcmFpbCBwb3NpdGlvbnMgdG9cbiAgICAqL1xuICAgY2FsY3VsYXRlUmFpbFBvc2l0aW9ucyhjZW50ZXJMaW5lKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgcmFpbCBvZmZzZXQgdmVjdG9yc1xuICAgICAgY29uc3QgcmFpbE9mZnNldFZlY3RvciA9IGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIoY2VudGVyTGluZS51bml0Lm11bHRpcGx5KHRoaXMucmFpbF9kaXN0YW5jZSkpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgcmFpbCBwb3NpdGlvbnMgZm9yIHN0cmFpZ2h0IHNlZ21lbnRcbiAgICAgIGNlbnRlckxpbmUucmFpbHMgPSB7XG4gICAgICAgICBzdHJhaWdodDoge1xuICAgICAgICAgICAgLy8gSW5uZXIgcmFpbCAodXN1YWxseSB0aGUgcmlnaHQgc2lkZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRyYXZlbClcbiAgICAgICAgICAgIGlubmVyOiB7XG4gICAgICAgICAgICAgICBzdGFydDogY2VudGVyTGluZS5zdGFydC5hZGQocmFpbE9mZnNldFZlY3RvciksXG4gICAgICAgICAgICAgICBlbmQ6IGNlbnRlckxpbmUuc3RyYWlnaHRFbmQuYWRkKHJhaWxPZmZzZXRWZWN0b3IpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIE91dGVyIHJhaWwgKHVzdWFsbHkgdGhlIGxlZnQgc2lkZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRyYXZlbClcbiAgICAgICAgICAgIG91dGVyOiB7XG4gICAgICAgICAgICAgICBzdGFydDogY2VudGVyTGluZS5zdGFydC5zdWIocmFpbE9mZnNldFZlY3RvciksXG4gICAgICAgICAgICAgICBlbmQ6IGNlbnRlckxpbmUuc3RyYWlnaHRFbmQuc3ViKHJhaWxPZmZzZXRWZWN0b3IpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICAvLyBDYWxjdWxhdGUgcmFpbCBwb3NpdGlvbnMgZm9yIGN1cnZlIGlmIGl0IGV4aXN0c1xuICAgICAgaWYgKGNlbnRlckxpbmUuY29udHJvbFBvaW50KSB7XG4gICAgICAgICBjb25zdCBuZXh0UmFpbE9mZnNldFZlY3RvciA9IGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIoY2VudGVyTGluZS5uZXh0VW5pdC5tdWx0aXBseSh0aGlzLnJhaWxfZGlzdGFuY2UpKTtcblxuICAgICAgICAgLy8gQ2FsY3VsYXRlIGN1cnZlIGVuZHBvaW50c1xuICAgICAgICAgY29uc3QgY3VydmVJbm5lckVuZCA9IGNlbnRlckxpbmUuY3VydmVFbmQuYWRkKG5leHRSYWlsT2Zmc2V0VmVjdG9yKTtcbiAgICAgICAgIGNvbnN0IGN1cnZlT3V0ZXJFbmQgPSBjZW50ZXJMaW5lLmN1cnZlRW5kLnN1YihuZXh0UmFpbE9mZnNldFZlY3Rvcik7XG5cbiAgICAgICAgIC8vIENhbGN1bGF0ZSBjdXJ2ZSBzdGFydHBvaW50cyAoc2FtZSBhcyBzdHJhaWdodCBzZWdtZW50IGVuZHBvaW50cylcbiAgICAgICAgIGNvbnN0IGN1cnZlSW5uZXJTdGFydCA9IGNlbnRlckxpbmUucmFpbHMuc3RyYWlnaHQuaW5uZXIuZW5kO1xuICAgICAgICAgY29uc3QgY3VydmVPdXRlclN0YXJ0ID0gY2VudGVyTGluZS5yYWlscy5zdHJhaWdodC5vdXRlci5lbmQ7XG5cbiAgICAgICAgIC8vIENhbGN1bGF0ZSBjb250cm9sIHBvaW50cyBmb3IgaW5uZXIgYW5kIG91dGVyIHJhaWwgY3VydmVzXG4gICAgICAgICBjb25zdCBjcElubmVyID0gZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uUG9pbnRYKGN1cnZlSW5uZXJTdGFydCwgY2VudGVyTGluZS51bml0LCBjdXJ2ZUlubmVyRW5kLCBjZW50ZXJMaW5lLm5leHRVbml0KTtcbiAgICAgICAgIGNvbnN0IGNwT3V0ZXIgPSBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludFgoY3VydmVPdXRlclN0YXJ0LCBjZW50ZXJMaW5lLnVuaXQsIGN1cnZlT3V0ZXJFbmQsIGNlbnRlckxpbmUubmV4dFVuaXQpO1xuXG4gICAgICAgICAvLyBTdG9yZSBjdXJ2ZSByYWlsIHBvc2l0aW9uc1xuICAgICAgICAgY2VudGVyTGluZS5yYWlscy5jdXJ2ZSA9IHtcbiAgICAgICAgICAgIGlubmVyOiB7XG4gICAgICAgICAgICAgICBzdGFydDogY3VydmVJbm5lclN0YXJ0LFxuICAgICAgICAgICAgICAgZW5kOiBjdXJ2ZUlubmVyRW5kLFxuICAgICAgICAgICAgICAgY3A6IGNwSW5uZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3V0ZXI6IHtcbiAgICAgICAgICAgICAgIHN0YXJ0OiBjdXJ2ZU91dGVyU3RhcnQsXG4gICAgICAgICAgICAgICBlbmQ6IGN1cnZlT3V0ZXJFbmQsXG4gICAgICAgICAgICAgICBjcDogY3BPdXRlcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9O1xuICAgICAgfVxuICAgfVxuXG4gICByZW5kZXJUcmFjayh0cmFjaykge1xuICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5jYWxjdWxhdGVUcmFja1BvaW50cyh0cmFjayk7XG5cbiAgICAgIGNvbnN0IHNsZWVwZXJzX2NvbnRhaW5lciA9IG5ldyBjcmVhdGVqcy5Db250YWluZXIoKTtcbiAgICAgIHNsZWVwZXJzX2NvbnRhaW5lci5uYW1lID0gXCJ0cmFja1wiO1xuICAgICAgc2xlZXBlcnNfY29udGFpbmVyLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIHNsZWVwZXJzX2NvbnRhaW5lci5kYXRhID0gdHJhY2s7XG4gICAgICB0aGlzLl9yZW5kZXJpbmcuc2xlZXBlcnNfY29udGFpbmVyLmFkZENoaWxkKHNsZWVwZXJzX2NvbnRhaW5lcik7XG5cbiAgICAgIGNvbnN0IGhpdEFyZWEgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgIGhpdEFyZWEuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiIzAwMFwiKTsgLy8gQ29sb3IgZG9lc24ndCBtYXR0ZXIsIG9ubHkgbmVlZCBvbmUgZmlsbFxuICAgICAgZm9yIChjb25zdCBwIG9mIHBvaW50cykge1xuICAgICAgICAgY29uc3Qgc3RyYWlnaHQgPSBwLnNsZWVwZXJPdXRsaW5lLnN0cmFpZ2h0O1xuICAgICAgICAgaGl0QXJlYS5ncmFwaGljc1xuICAgICAgICAgICAgLm1vdmVUbyhzdHJhaWdodC5vdXRlci5zdGFydC54LCBzdHJhaWdodC5vdXRlci5zdGFydC55KVxuICAgICAgICAgICAgLmxpbmVUbyhzdHJhaWdodC5vdXRlci5lbmQueCwgc3RyYWlnaHQub3V0ZXIuZW5kLnkpXG4gICAgICAgICAgICAubGluZVRvKHN0cmFpZ2h0LmlubmVyLmVuZC54LCBzdHJhaWdodC5pbm5lci5lbmQueSlcbiAgICAgICAgICAgIC5saW5lVG8oc3RyYWlnaHQuaW5uZXIuc3RhcnQueCwgc3RyYWlnaHQuaW5uZXIuc3RhcnQueSlcbiAgICAgICAgICAgIC5jbG9zZVBhdGgoKTtcblxuICAgICAgICAgaWYgKHAuc2xlZXBlck91dGxpbmUuY3VydmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnZlID0gcC5zbGVlcGVyT3V0bGluZS5jdXJ2ZTtcbiAgICAgICAgICAgIGhpdEFyZWEuZ3JhcGhpY3NcbiAgICAgICAgICAgICAgIC5tb3ZlVG8oY3VydmUuaW5uZXIuc3RhcnQueCwgY3VydmUuaW5uZXIuc3RhcnQueSlcbiAgICAgICAgICAgICAgIC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlLmlubmVyLmNwLngsIGN1cnZlLmlubmVyLmNwLnksIGN1cnZlLmlubmVyLmVuZC54LCBjdXJ2ZS5pbm5lci5lbmQueSlcbiAgICAgICAgICAgICAgIC5saW5lVG8oY3VydmUub3V0ZXIuZW5kLngsIGN1cnZlLm91dGVyLmVuZC55KVxuICAgICAgICAgICAgICAgLnF1YWRyYXRpY0N1cnZlVG8oY3VydmUub3V0ZXIuY3AueCwgY3VydmUub3V0ZXIuY3AueSwgY3VydmUub3V0ZXIuc3RhcnQueCwgY3VydmUub3V0ZXIuc3RhcnQueSlcbiAgICAgICAgICAgICAgIC5jbG9zZVBhdGgoKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNsZWVwZXJzX2NvbnRhaW5lci5oaXRBcmVhID0gaGl0QXJlYTtcblxuICAgICAgdGhpcy5kcmF3VHJhY2tTbGVlcGVycyhwb2ludHMsIHNsZWVwZXJzX2NvbnRhaW5lcik7XG5cbiAgICAgIC8vIERyYXcgcmFpbHNcbiAgICAgIGNvbnN0IHJhaWxTaGFwZSA9IHRoaXMucmVuZGVyUmFpbHModHJhY2ssIHBvaW50cyk7XG5cbiAgICAgIC8vIEdldCBib3VuZHMgZnJvbSB0aGUgcmFpbCBzaGFwZVxuICAgICAgY29uc3QgYm91bmRzID0gcmFpbFNoYXBlLmdldEJvdW5kcygpO1xuXG4gICAgICAvLyBDcmVhdGUgYSB0cmFjayBvYmplY3QgdGhhdCBjb21iaW5lcyByYWlsIGFuZCBzbGVlcGVyIGluZm9ybWF0aW9uXG4gICAgICB0cmFjay5fcmVuZGVyRGF0YSA9IHtcbiAgICAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmRyYXdCdW1wZXIodHJhY2ssIHRoaXMuX3JlbmRlcmluZy5yYWlsc19jb250YWluZXIpO1xuICAgfVxuXG4gICBjYWxjdWxhdGVSYWlsQm91bmRzKHBvaW50cykge1xuICAgICAgLy8gSW5pdGlhbGl6ZSBib3VuZHMgd2l0aCBmaXJzdCBwb2ludFxuICAgICAgbGV0IG1pblggPSBJbmZpbml0eSxcbiAgICAgICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICAgICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgICAvLyBIZWxwZXIgdG8gdXBkYXRlIGJvdW5kcyB3aXRoIGEgcG9pbnRcbiAgICAgIGNvbnN0IHVwZGF0ZUJvdW5kcyA9IChwb2ludCkgPT4ge1xuICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHBvaW50LngpO1xuICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHBvaW50LnkpO1xuICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHBvaW50LngpO1xuICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHBvaW50LnkpO1xuICAgICAgfTtcblxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBwb2ludHMgYW5kIGNvbGxlY3QgZXh0cmVtZXNcbiAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgICAvLyBBZGQgYWxsIHN0cmFpZ2h0IHNlZ21lbnQgcG9pbnRzIHRvIGJvdW5kc1xuICAgICAgICAgY29uc3QgeyBpbm5lciwgb3V0ZXIgfSA9IHBvaW50LnJhaWxzLnN0cmFpZ2h0O1xuICAgICAgICAgdXBkYXRlQm91bmRzKGlubmVyLnN0YXJ0KTtcbiAgICAgICAgIHVwZGF0ZUJvdW5kcyhpbm5lci5lbmQpO1xuICAgICAgICAgdXBkYXRlQm91bmRzKG91dGVyLnN0YXJ0KTtcbiAgICAgICAgIHVwZGF0ZUJvdW5kcyhvdXRlci5lbmQpO1xuXG4gICAgICAgICAvLyBIYW5kbGUgY3VydmUgc2VnbWVudHNcbiAgICAgICAgIGlmIChwb2ludC5yYWlscy5jdXJ2ZSkge1xuICAgICAgICAgICAgY29uc3QgY3VydmUgPSBwb2ludC5yYWlscy5jdXJ2ZTtcblxuICAgICAgICAgICAgLy8gQWRkIGN1cnZlIGVuZHBvaW50cyBhbmQgY29udHJvbCBwb2ludHNcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhjdXJ2ZS5pbm5lci5zdGFydCk7XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHMoY3VydmUuaW5uZXIuZW5kKTtcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhjdXJ2ZS5vdXRlci5zdGFydCk7XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHMoY3VydmUub3V0ZXIuZW5kKTtcbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHBhZGRpbmcgZm9yIGxpbmUgdGhpY2tuZXNzXG4gICAgICBjb25zdCBwYWRkaW5nID0gdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuUkFJTFNbMF1bMF0gKiAwLjU7IC8vIEhhbGYgb2YgdGhlIHRoaWNrZXN0IHJhaWxcbiAgICAgIHJldHVybiB7XG4gICAgICAgICB4OiBtaW5YIC0gcGFkZGluZyxcbiAgICAgICAgIHk6IG1pblkgLSBwYWRkaW5nLFxuICAgICAgICAgd2lkdGg6IG1heFggLSBtaW5YICsgcGFkZGluZyAqIDIsXG4gICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZICsgcGFkZGluZyAqIDIsXG4gICAgICB9O1xuICAgfVxuXG4gICByZW5kZXJSYWlscyh0cmFjaywgcG9pbnRzKSB7XG4gICAgICBjb25zdCByYWlsX3NoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICByYWlsX3NoYXBlLm5hbWUgPSBcInRyYWNrXCI7XG4gICAgICByYWlsX3NoYXBlLnNuYXBUb1BpeGVsID0gdHJ1ZTtcbiAgICAgIHJhaWxfc2hhcGUuZGF0YSA9IHRyYWNrO1xuICAgICAgdGhpcy5fcmVuZGVyaW5nLnJhaWxzX2NvbnRhaW5lci5hZGRDaGlsZChyYWlsX3NoYXBlKTtcblxuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgICAgIC8vIFVzZSBwcmUtY2FsY3VsYXRlZCByYWlsIHBvc2l0aW9uc1xuICAgICAgICAgY29uc3QgeyBzdHJhaWdodCwgY3VydmUgfSA9IHBvaW50LnJhaWxzO1xuXG4gICAgICAgICB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5SQUlMUy5mb3JFYWNoKChyYWlsKSA9PiB7XG4gICAgICAgICAgICByYWlsX3NoYXBlLmdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKHJhaWxbMF0pLmJlZ2luU3Ryb2tlKHJhaWxbMV0pO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHN0cmFpZ2h0IHNlZ21lbnRzXG4gICAgICAgICAgICByYWlsX3NoYXBlLmdyYXBoaWNzXG4gICAgICAgICAgICAgICAubXQoc3RyYWlnaHQuaW5uZXIuc3RhcnQueCwgc3RyYWlnaHQuaW5uZXIuc3RhcnQueSlcbiAgICAgICAgICAgICAgIC5sdChzdHJhaWdodC5pbm5lci5lbmQueCwgc3RyYWlnaHQuaW5uZXIuZW5kLnkpXG4gICAgICAgICAgICAgICAubXQoc3RyYWlnaHQub3V0ZXIuc3RhcnQueCwgc3RyYWlnaHQub3V0ZXIuc3RhcnQueSlcbiAgICAgICAgICAgICAgIC5sdChzdHJhaWdodC5vdXRlci5lbmQueCwgc3RyYWlnaHQub3V0ZXIuZW5kLnkpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IGN1cnZlcyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoY3VydmUpIHtcbiAgICAgICAgICAgICAgIHJhaWxfc2hhcGUuZ3JhcGhpY3NcbiAgICAgICAgICAgICAgICAgIC5tdChjdXJ2ZS5vdXRlci5zdGFydC54LCBjdXJ2ZS5vdXRlci5zdGFydC55KVxuICAgICAgICAgICAgICAgICAgLnF1YWRyYXRpY0N1cnZlVG8oY3VydmUub3V0ZXIuY3AueCwgY3VydmUub3V0ZXIuY3AueSwgY3VydmUub3V0ZXIuZW5kLngsIGN1cnZlLm91dGVyLmVuZC55KVxuICAgICAgICAgICAgICAgICAgLm10KGN1cnZlLmlubmVyLnN0YXJ0LngsIGN1cnZlLmlubmVyLnN0YXJ0LnkpXG4gICAgICAgICAgICAgICAgICAucXVhZHJhdGljQ3VydmVUbyhjdXJ2ZS5pbm5lci5jcC54LCBjdXJ2ZS5pbm5lci5jcC55LCBjdXJ2ZS5pbm5lci5lbmQueCwgY3VydmUuaW5uZXIuZW5kLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYWlsX3NoYXBlLmdyYXBoaWNzLmVuZFN0cm9rZSgpO1xuICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhbmQgc2V0IGJvdW5kcyBmb3IgdGhlIHJhaWwgc2hhcGVcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuY2FsY3VsYXRlUmFpbEJvdW5kcyhwb2ludHMpO1xuICAgICAgcmFpbF9zaGFwZS5zZXRCb3VuZHMoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuXG4gICAgICByZXR1cm4gcmFpbF9zaGFwZTtcbiAgIH1cblxuICAgZHJhd1RyYWNrU2xlZXBlcnMocG9pbnRzLCBjb250YWluZXIpIHtcbiAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICAgICAvLyBEcmF3IHNsZWVwZXJzIGZvciBzdHJhaWdodCBzZWdtZW50XG4gICAgICAgICB0aGlzLmRyYXdTbGVlcGVycyhwb2ludC50cmFjaywgcG9pbnQuc3RhcnQsIHBvaW50LnN0cmFpZ2h0RW5kLCBjb250YWluZXIpO1xuXG4gICAgICAgICAvLyBEcmF3IHNsZWVwZXJzIGZvciBjdXJ2ZSBpZiBleGlzdHNcbiAgICAgICAgIGlmIChwb2ludC5yYWlscy5jdXJ2ZSkge1xuICAgICAgICAgICAgdGhpcy5kcmF3U2xlZXBlcnNBbG9uZ0N1cnZlKHBvaW50LnN0cmFpZ2h0RW5kLCBwb2ludC5jdXJ2ZUVuZCwgcG9pbnQuY29udHJvbFBvaW50LCBjb250YWluZXIpO1xuICAgICAgICAgfVxuICAgICAgfVxuICAgfVxuXG4gICBkcmF3U2xlZXBlcnNBbG9uZ0N1cnZlKHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBjb250cm9sUG9pbnQsIGNvbnRhaW5lcikge1xuICAgICAgLy90aGUgY3VydmUgaXMgZXByb3hpbWF0IDExJSB0aW1lcyBsb25nZXIgdGhhbiB0aGUgc3RyYWlnaHQgbGluZVxuICAgICAgY29uc3Qgc3RlcHMgPSBNYXRoLmZsb29yKChnZW9tZXRyeS5kaXN0YW5jZShzdGFydFBvaW50LCBlbmRQb2ludCkgKiAxLjExKSAvIHRoaXMuc2xlZXBlckludGVydmFsbCk7XG4gICAgICBjb25zdCBzdGVwID0gMSAvIHN0ZXBzO1xuICAgICAgbGV0IHQgPSAwLjI1IC8gc3RlcHMsXG4gICAgICAgICBwb2ludCxcbiAgICAgICAgIGFuZ2xlO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcbiAgICAgICAgIHBvaW50ID0gdGhpcy5nZXRQb2ludE9uQ3VydmUodCwgc3RhcnRQb2ludCwgY29udHJvbFBvaW50LCBlbmRQb2ludCk7XG4gICAgICAgICBhbmdsZSA9IHRoaXMuZ2V0RGVncmVlT2ZUYW5nZW50T25DdXJ2ZSh0LCBzdGFydFBvaW50LCBjb250cm9sUG9pbnQsIGVuZFBvaW50KTtcblxuICAgICAgICAgdGhpcy5kcmF3U2xlZXBlcihpLCBwb2ludC54LCBwb2ludC55LCBhbmdsZSwgY29udGFpbmVyKTtcbiAgICAgICAgIHQgKz0gc3RlcDtcbiAgICAgIH1cbiAgIH1cblxuICAgZHJhd1NsZWVwZXJzKHRyYWNrLCBzdGFydFBvaW50LCBlbmRQb2ludCwgY29udGFpbmVyKSB7XG4gICAgICBsZXQgeCA9IHN0YXJ0UG9pbnQueDtcbiAgICAgIGxldCB5ID0gc3RhcnRQb2ludC55O1xuXG4gICAgICBjb25zdCBsID0gZ2VvbWV0cnkuZGlzdGFuY2Uoc3RhcnRQb2ludCwgZW5kUG9pbnQpO1xuICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBtYW55IHNsZWVwZXJzIGZpdFxuICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcihsIC8gdGhpcy5zbGVlcGVySW50ZXJ2YWxsKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZW1haW5pbmcgc3BhY2UgYWZ0ZXIgZml0dGluZyBmdWxsIHNsZWVwZXJzXG4gICAgICBjb25zdCByZW1haW5pbmdTcGFjZSA9IGwgJSB0aGlzLnNsZWVwZXJJbnRlcnZhbGw7XG4gICAgICAvLyBEaXN0cmlidXRlIHRoZSByZW1haW5pbmcgc3BhY2UgZXZlbmx5IGJldHdlZW4gc2xlZXBlcnNcbiAgICAgIGNvbnN0IGFkanVzdGVkSW50ZXJ2YWwgPSB0aGlzLnNsZWVwZXJJbnRlcnZhbGwgKyByZW1haW5pbmdTcGFjZSAvIGFtb3VudDtcblxuICAgICAgY29uc3Qgc3RlcF94ID0gdHJhY2suY29zICogYWRqdXN0ZWRJbnRlcnZhbCxcbiAgICAgICAgIHN0ZXBfeSA9IHRyYWNrLnNpbiAqIGFkanVzdGVkSW50ZXJ2YWw7XG5cbiAgICAgIC8vIEFkZCB0aGUgZW5kIGdhcFxuICAgICAgeCArPSB0cmFjay5jb3MgKiAodGhpcy5zY2h3ZWxsZW5HYXAgLyAyKTtcbiAgICAgIHkgKz0gdHJhY2suc2luICogKHRoaXMuc2Nod2VsbGVuR2FwIC8gMik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgICAgIHRoaXMuZHJhd1NsZWVwZXIoaSwgeCwgeSwgdHJhY2suZGVnLCBjb250YWluZXIpO1xuICAgICAgICAgLy8gTW92ZSB0byBuZXh0IHBvc2l0aW9uIHVzaW5nIHNsZWVwZXJJbnRlcnZhbGxcbiAgICAgICAgIHkgKz0gc3RlcF95O1xuICAgICAgICAgeCArPSBzdGVwX3g7XG4gICAgICB9XG4gICB9XG5cbiAgIGRyYXdTbGVlcGVyKGksIHgsIHksIGFuZ2xlLCBjb250YWluZXIsIGxlbmd0aCA9IHRoaXMuc2Nod2VsbGVuSMO2aGUsIHJlZ1kpIHtcbiAgICAgIGlmICh0aGlzLmFwcC5zdGFnZS5zY2FsZSA8IHRoaXMuTE9EKSB7XG4gICAgICAgICAvLyBGb3Igc2ltcGxlIHNoYXBlcyBhdCBsb3cgTE9EXG4gICAgICAgICBjb25zdCByeSA9IHJlZ1kgPT0gbnVsbCA/IGxlbmd0aCAvIDIgOiByZWdZO1xuXG4gICAgICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgY2FjaGUga2V5IGJhc2VkIG9uIHRoZSBsZW5ndGhcbiAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYHNoYXBlXyR7bGVuZ3RofWA7XG5cbiAgICAgICAgIC8vIEdldCBjYWNoZWQgc2hhcGUgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgbGV0IHNsZWVwZXJTaGFwZSA9IHRoaXMuX3NsZWVwZXJDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICBpZiAoIXNsZWVwZXJTaGFwZSkge1xuICAgICAgICAgICAgc2xlZXBlclNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICAgICAgICBzbGVlcGVyU2hhcGUuZ3JhcGhpY3NcbiAgICAgICAgICAgICAgIC5zZXRTdHJva2VTdHlsZSgwLjIsIFwicm91bmRcIilcbiAgICAgICAgICAgICAgIC5iZWdpblN0cm9rZShcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAuYmVnaW5GaWxsKFwiIzk5NzM1YlwiKVxuICAgICAgICAgICAgICAgLnIoMCwgMCwgdGhpcy5zY2h3ZWxsZW5CcmVpdGUsIGxlbmd0aClcbiAgICAgICAgICAgICAgIC5lZigpO1xuICAgICAgICAgICAgc2xlZXBlclNoYXBlLnNldEJvdW5kcygwLCAwLCB0aGlzLnNjaHdlbGxlbkJyZWl0ZSwgbGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIFN0b3JlIGluIGNhY2hlXG4gICAgICAgICAgICB0aGlzLl9zbGVlcGVyQ2FjaGVbY2FjaGVLZXldID0gc2xlZXBlclNoYXBlO1xuICAgICAgICAgfVxuXG4gICAgICAgICAvLyBDbG9uZSB0aGUgY2FjaGVkIHNoYXBlIGZvciB0aGlzIGluc3RhbmNlXG4gICAgICAgICBsZXQgc2xlZXBlciA9IHNsZWVwZXJTaGFwZS5jbG9uZSgpO1xuICAgICAgICAgc2xlZXBlci54ID0geDtcbiAgICAgICAgIHNsZWVwZXIueSA9IHk7XG4gICAgICAgICBzbGVlcGVyLnJvdGF0aW9uID0gYW5nbGU7XG4gICAgICAgICBzbGVlcGVyLnJlZ1kgPSByeTtcbiAgICAgICAgIHNsZWVwZXIucmVnWCA9IDA7XG5cbiAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChzbGVlcGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAvLyBVc2UgYml0bWFwIHJlbmRlcmluZyBhdCBoaWdoZXIgTE9EXG4gICAgICAgICBpID0gaSAlIHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlNDSFdFTExFTl9WQVJJQU5URU47XG4gICAgICAgICBjb25zdCBzY2FsZVkgPSBsZW5ndGggLyB0aGlzLnNjaHdlbGxlbkjDtmhlO1xuICAgICAgICAgY29uc3QgcnkgPSByZWdZID09IG51bGwgPyB0aGlzLnNjaHdlbGxlbkltZy5oZWlnaHQgLyAyIDogcmVnWSAvICh0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5UUkFDS19TQ0FMRSAqIHNjYWxlWSk7XG5cbiAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZWQgYml0bWFwIGZvciB0aGlzIGluZGV4XG4gICAgICAgICBpZiAoIXRoaXMuX2JpdG1hcENhY2hlW2ldKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNvdXJjZVJlY3QgZm9yIHRoaXMgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgKGkgKiB0aGlzLnNjaHdlbGxlbkltZy53aWR0aCkgLyB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5TQ0hXRUxMRU5fVkFSSUFOVEVOLFxuICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgIHRoaXMuc2xlZXBlcnNJbWdXaWR0aCxcbiAgICAgICAgICAgICAgIHRoaXMuc2Nod2VsbGVuSW1nLmhlaWdodFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBjYWNoZSB0aGUgYml0bWFwXG4gICAgICAgICAgICBjb25zdCBiaXRtYXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKHRoaXMuc2Nod2VsbGVuSW1nKTtcbiAgICAgICAgICAgIGJpdG1hcC5zb3VyY2VSZWN0ID0gc291cmNlUmVjdDtcbiAgICAgICAgICAgIHRoaXMuX2JpdG1hcENhY2hlW2ldID0gYml0bWFwO1xuICAgICAgICAgfVxuXG4gICAgICAgICAvLyBDbG9uZSB0aGUgY2FjaGVkIGJpdG1hcFxuICAgICAgICAgY29uc3Qgc2xlZXBlckJpdG1hcCA9IHRoaXMuX2JpdG1hcENhY2hlW2ldLmNsb25lKCk7XG5cbiAgICAgICAgIC8vIFNldCBwb3NpdGlvbiBhbmQgdHJhbnNmb3JtYXRpb24gcHJvcGVydGllc1xuICAgICAgICAgc2xlZXBlckJpdG1hcC54ID0geDtcbiAgICAgICAgIHNsZWVwZXJCaXRtYXAueSA9IHk7XG4gICAgICAgICBzbGVlcGVyQml0bWFwLnJlZ1kgPSByeTtcbiAgICAgICAgIHNsZWVwZXJCaXRtYXAucmVnWCA9IDA7XG4gICAgICAgICBzbGVlcGVyQml0bWFwLnNjYWxlID0gdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuVFJBQ0tfU0NBTEU7XG4gICAgICAgICBzbGVlcGVyQml0bWFwLnNjYWxlWSA9IHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlRSQUNLX1NDQUxFICogc2NhbGVZO1xuICAgICAgICAgc2xlZXBlckJpdG1hcC5yb3RhdGlvbiA9IGFuZ2xlO1xuXG4gICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQoc2xlZXBlckJpdG1hcCk7XG4gICAgICB9XG4gICB9XG5cbiAgIGdldFBvaW50T25DdXJ2ZSh0LCBwMCwgY3AsIHAxKSB7XG4gICAgICBjb25zdCBvbmVNaW51c1QgPSAxIC0gdDtcbiAgICAgIGNvbnN0IHRTcXVhcmVkID0gdCAqIHQ7XG4gICAgICBjb25zdCBvbmVNaW51c1RTcXVhcmVkID0gb25lTWludXNUICogb25lTWludXNUO1xuICAgICAgY29uc3QgdHdvVGltZXNUID0gMiAqIG9uZU1pbnVzVCAqIHQ7XG5cbiAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICBvbmVNaW51c1RTcXVhcmVkICogcDAueCArIHR3b1RpbWVzVCAqIGNwLnggKyB0U3F1YXJlZCAqIHAxLngsXG4gICAgICAgICBvbmVNaW51c1RTcXVhcmVkICogcDAueSArIHR3b1RpbWVzVCAqIGNwLnkgKyB0U3F1YXJlZCAqIHAxLnlcbiAgICAgICk7XG4gICB9XG5cbiAgIGdldERlZ3JlZU9mVGFuZ2VudE9uQ3VydmUodCwgcDAsIGNwLCBwMSkge1xuICAgICAgY29uc3QgbXQgPSAxIC0gdDtcbiAgICAgIGNvbnN0IGR4ID0gMiAqIChtdCAqIChjcC54IC0gcDAueCkgKyB0ICogKHAxLnggLSBjcC54KSk7XG4gICAgICBjb25zdCBkeSA9IDIgKiAobXQgKiAoY3AueSAtIHAwLnkpICsgdCAqIChwMS55IC0gY3AueSkpO1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIoZHksIGR4KSAqICgxODAgLyBNYXRoLlBJKTtcbiAgIH1cblxuICAgZHJhd0J1bXBlcih0cmFjaywgdHJhY2tfY29udGFpbmVyKSB7XG4gICAgICBpZiAodHJhY2suc3dpdGNoQXRUaGVFbmQgPT0gbnVsbCkge1xuICAgICAgICAgdHJhY2tfY29udGFpbmVyLmFkZENoaWxkKFxuICAgICAgICAgICAgbmV3IGNyZWF0ZWpzLkJpdG1hcCh0aGlzLmJ1bXBlckltZykuc2V0KHtcbiAgICAgICAgICAgICAgIHk6IHRyYWNrLmVuZC55LFxuICAgICAgICAgICAgICAgeDogdHJhY2suZW5kLngsXG4gICAgICAgICAgICAgICBzY2FsZTogdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuVFJBQ0tfU0NBTEUsXG4gICAgICAgICAgICAgICBzY2FsZVg6IC10cmFja1JlbmRlcmluZ190ZXh0dXJlZC5UUkFDS19TQ0FMRSxcbiAgICAgICAgICAgICAgIHJvdGF0aW9uOiB0cmFjay5kZWcsXG4gICAgICAgICAgICAgICByZWdZOiB0aGlzLmJ1bXBlckltZy5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgcmVnWDogdGhpcy5idW1wZXJJbWcud2lkdGgsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYWNrLnN3aXRjaEF0VGhlU3RhcnQgPT0gbnVsbCkge1xuICAgICAgICAgdHJhY2tfY29udGFpbmVyLmFkZENoaWxkKFxuICAgICAgICAgICAgbmV3IGNyZWF0ZWpzLkJpdG1hcCh0aGlzLmJ1bXBlckltZykuc2V0KHtcbiAgICAgICAgICAgICAgIHk6IHRyYWNrLnN0YXJ0LnksXG4gICAgICAgICAgICAgICB4OiB0cmFjay5zdGFydC54LFxuICAgICAgICAgICAgICAgc2NhbGU6IHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlRSQUNLX1NDQUxFLFxuICAgICAgICAgICAgICAgc2NhbGVYOiB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5UUkFDS19TQ0FMRSxcbiAgICAgICAgICAgICAgIHJvdGF0aW9uOiB0cmFjay5kZWcsXG4gICAgICAgICAgICAgICByZWdZOiB0aGlzLmJ1bXBlckltZy5oZWlnaHQgLyAyLFxuICAgICAgICAgICAgICAgcmVnWDogdGhpcy5idW1wZXJJbWcud2lkdGgsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgKTtcbiAgICAgIH1cbiAgIH1cblxuICAgdXBkYXRlVHJhY2sodHJhY2spIHtcbiAgICAgIC8vIEZpbmQgdGhlIHNsZWVwZXJzIGNvbnRhaW5lciBmb3IgdGhpcyB0cmFja1xuICAgICAgY29uc3Qgc2xlZXBlcnNDb250YWluZXIgPSB0aGlzLl9yZW5kZXJpbmcuc2xlZXBlcnNfY29udGFpbmVyLmNoaWxkcmVuLmZpbmQoKGMpID0+IGMuZGF0YSA9PT0gdHJhY2spO1xuICAgICAgaWYgKCFzbGVlcGVyc0NvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgICAvLyBSZW1vdmUgZXhpc3Rpbmcgc2xlZXBlcnNcbiAgICAgIHNsZWVwZXJzQ29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwb2ludHMgYW5kIHJlZHJhdyBzbGVlcGVycyB3aXRoIGN1cnJlbnQgTE9EXG4gICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmNhbGN1bGF0ZVRyYWNrUG9pbnRzKHRyYWNrKTtcbiAgICAgIHRoaXMuZHJhd1RyYWNrU2xlZXBlcnMocG9pbnRzLCBzbGVlcGVyc0NvbnRhaW5lcik7XG5cbiAgICAgIGlmICh0cmFjayA9PSB0cmFjay5zd2l0Y2hBdFRoZUVuZD8udDEpIHtcbiAgICAgICAgIGNvbnN0IHN3aXRjaFNsZWVwZXJzQ29udGFpbmVyID0gdGhpcy5fcmVuZGVyaW5nLnNsZWVwZXJzX2NvbnRhaW5lci5jaGlsZHJlbi5maW5kKChjKSA9PiBjLmRhdGEgPT09IHRyYWNrLnN3aXRjaEF0VGhlRW5kKTtcbiAgICAgICAgIGNvbnN0IHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlciA9IHRoaXMuZ2V0U3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyKHRyYWNrLnN3aXRjaEF0VGhlRW5kKTtcbiAgICAgICAgIHRoaXMuZHJhd1NsZWVwZXJzT25Td2l0Y2godHJhY2suc3dpdGNoQXRUaGVFbmQsIHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlciwgc3dpdGNoU2xlZXBlcnNDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2sgPT0gdHJhY2suc3dpdGNoQXRUaGVTdGFydD8udDEpIHtcbiAgICAgICAgIGNvbnN0IHN3aXRjaFNsZWVwZXJzQ29udGFpbmVyID0gdGhpcy5fcmVuZGVyaW5nLnNsZWVwZXJzX2NvbnRhaW5lci5jaGlsZHJlbi5maW5kKFxuICAgICAgICAgICAgKGMpID0+IGMuZGF0YSA9PT0gdHJhY2suc3dpdGNoQXRUaGVTdGFydFxuICAgICAgICAgKTtcbiAgICAgICAgIGNvbnN0IHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlciA9IHRoaXMuZ2V0U3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyKHRyYWNrLnN3aXRjaEF0VGhlU3RhcnQpO1xuICAgICAgICAgdGhpcy5kcmF3U2xlZXBlcnNPblN3aXRjaCh0cmFjay5zd2l0Y2hBdFRoZVN0YXJ0LCBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIsIHN3aXRjaFNsZWVwZXJzQ29udGFpbmVyKTtcbiAgICAgIH1cbiAgIH1cblxuICAgdXBkYXRlU3dpdGNoKHN3KSB7XG4gICAgICAvLyBGaW5kIHRoZSBzbGVlcGVycyBjb250YWluZXIgZm9yIHRoaXMgc3dpdGNoXG4gICAgICBjb25zdCBzbGVlcGVyc0NvbnRhaW5lciA9IHRoaXMuX3JlbmRlcmluZy5zbGVlcGVyc19jb250YWluZXIuY2hpbGRyZW4uZmluZCgoYykgPT4gYy5kYXRhID09PSBzdyk7XG4gICAgICBpZiAoIXNsZWVwZXJzQ29udGFpbmVyKSByZXR1cm47XG5cbiAgICAgIC8vIEdldCByZW5kZXJpbmcgcGFyYW1ldGVyc1xuICAgICAgY29uc3Qgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyID0gdGhpcy5nZXRTd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIoc3cpO1xuXG4gICAgICAvLyBSZWRyYXcgc2xlZXBlcnMgd2l0aCBjdXJyZW50IExPRFxuICAgICAgdGhpcy5kcmF3U2xlZXBlcnNPblN3aXRjaChzdywgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyLCBzbGVlcGVyc0NvbnRhaW5lcik7XG4gICB9XG5cbiAgIC8qKlxuICAgICogQ3JlYXRlcyBhIHNoYXBlIGZvciBhIHRyYWNrIGVuZHBvaW50XG4gICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIFRoZSBwb2ludCB3aGVyZSB0aGUgZW5kcG9pbnQgc2hvdWxkIGJlXG4gICAgKiBAcGFyYW0ge1RyYWNrfSB0cmFjayAtIFRoZSB0cmFjayB0aGlzIGVuZHBvaW50IGJlbG9uZ3MgdG9cbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludFR5cGUgLSBFaXRoZXIgXCJzdGFydFwiIG9yIFwiZW5kXCJcbiAgICAqIEByZXR1cm5zIHtjcmVhdGVqcy5TaGFwZX0gVGhlIGNyZWF0ZWQgc2hhcGVcbiAgICAqL1xuICAgY3JlYXRlRW5kcG9pbnRTaGFwZShwb2ludCwgdHJhY2ssIGVuZHBvaW50VHlwZSkge1xuICAgICAgY29uc3QgUkVDVF9TSVpFID0gODtcbiAgICAgIGNvbnN0IHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cbiAgICAgIC8vIFNldCBwcm9wZXJ0aWVzIHRvIGlkZW50aWZ5IHRoZSBzaGFwZVxuICAgICAgc2hhcGUubmFtZSA9IFwidHJhY2tfZW5kcG9pbnRcIjtcbiAgICAgIHNoYXBlLmVuZHBvaW50ID0gZW5kcG9pbnRUeXBlO1xuICAgICAgc2hhcGUudHJhY2sgPSB0cmFjaztcblxuICAgICAgLy8gQ3JlYXRlIGhpdCBhcmVhXG4gICAgICBjb25zdCBoaXRBcmVhID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICBoaXRBcmVhLmdyYXBoaWNzLmJlZ2luRmlsbChcIiMwMDBcIikuZHJhd1JlY3QocG9pbnQueCAtIFJFQ1RfU0laRSAvIDIsIHBvaW50LnkgLSBSRUNUX1NJWkUgLyAyLCBSRUNUX1NJWkUsIFJFQ1RfU0laRSk7XG4gICAgICBzaGFwZS5oaXRBcmVhID0gaGl0QXJlYTtcblxuICAgICAgLy8gRHJhdyByZWN0YW5nbGVcbiAgICAgIHNoYXBlLmdyYXBoaWNzXG4gICAgICAgICAuc2V0U3Ryb2tlU3R5bGUoMilcbiAgICAgICAgIC5iZWdpblN0cm9rZShcIiNmZjAwMDBcIilcbiAgICAgICAgIC5kcmF3UmVjdChwb2ludC54IC0gUkVDVF9TSVpFIC8gMiwgcG9pbnQueSAtIFJFQ1RfU0laRSAvIDIsIFJFQ1RfU0laRSwgUkVDVF9TSVpFKTtcblxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgfVxuXG4gICAvKipcbiAgICAqIERyYXdzIHNlbGVjdGlvbiByZWN0YW5nbGVzIGF0IHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBvZiBhIHRyYWNrXG4gICAgKiBAcGFyYW0ge1RyYWNrfSB0cmFjayAtIFRoZSB0cmFjayB0byBkcmF3IHNlbGVjdGlvbiByZWN0YW5nbGVzIGZvclxuICAgICovXG4gICBkcmF3VHJhY2tFbmRwb2ludHModHJhY2spIHtcbiAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHNoYXBlcyBmb3Igc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICAgIHRoaXMuYXBwLmNvbnRhaW5lcnMuc2VsZWN0aW9uLmFkZENoaWxkKHRoaXMuY3JlYXRlRW5kcG9pbnRTaGFwZSh0cmFjay5zdGFydCwgdHJhY2ssIFwic3RhcnRcIikpO1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5zZWxlY3Rpb24uYWRkQ2hpbGQodGhpcy5jcmVhdGVFbmRwb2ludFNoYXBlKHRyYWNrLmVuZCwgdHJhY2ssIFwiZW5kXCIpKTtcbiAgIH1cblxuICAgdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5zZWxlY3Rpb24ucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcblxuICAgICAgaWYgKHRoaXMuYXBwLnNlbGVjdGlvbi50eXBlID09IFwiVHJhY2tcIikge1xuICAgICAgICAgdGhpcy5hcHAuY29udGFpbmVycy50cmFja3MuY2hpbGRyZW5bMF0uY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5pc1NlbGVjdGVkT2JqZWN0KGMuZGF0YSkpIHtcbiAgICAgICAgICAgICAgIHRoaXMudmlzdWFsaXplVHJhY2tCb3VuZHMoYyk7XG4gICAgICAgICAgICAgICB0aGlzLmRyYXdUcmFja0VuZHBvaW50cyhjLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXBwLnNlbGVjdGlvbi50eXBlID09IFwiU2lnbmFsXCIpIHtcbiAgICAgICAgIHRoaXMuYXBwLmNvbnRhaW5lcnMuc2lnbmFscy5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYy5kYXRhKSB7XG4gICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmlzU2VsZWN0ZWRPYmplY3QoYy5kYXRhKSkgdGhpcy52aXN1YWxpemVUcmFja0JvdW5kcyhjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmFwcC5zZWxlY3Rpb24udHlwZSA9PSBcIkdlbmVyaWNPYmplY3RcIikge1xuICAgICAgICAgdGhpcy5hcHAuY29udGFpbmVycy5vYmplY3RzLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGlmIChjLmRhdGEpIHtcbiAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uaXNTZWxlY3RlZE9iamVjdChjLmRhdGEpKSB0aGlzLnZpc3VhbGl6ZVRyYWNrQm91bmRzKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcC5zdGFnZS51cGRhdGUoKTtcbiAgIH1cblxuICAgZHJhd1NsZWVwZXJzT25Td2l0Y2goc3csIHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlciwgY29udGFpbmVyKSB7XG4gICAgICBjb25zdCB7IG1haW5UcmFjaywgc3RyYWlnaHRCcmFuY2gsIGN1cnZlZEJyYW5jaCwgY3VydmVkQnJhbmNoMiwgZmxpcHBlZCwgbWlycm9yZWQgfSA9IHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlcjtcblxuICAgICAgaWYgKGNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICBjb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XG4gICAgICAgICBjb250YWluZXIubmFtZSA9IFwic3dpdGNoX3NsZWVwZXJzXCI7XG4gICAgICAgICBjb250YWluZXIuZGF0YSA9IHN3O1xuICAgICAgICAgY29udGFpbmVyLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgIHRoaXMuX3JlbmRlcmluZy5zbGVlcGVyc19jb250YWluZXIuYWRkQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBjb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVnID0gc3cudHJhY2sxLmRlZztcblxuICAgICAgY29uc3QgYmFjazJmcm9udCA9IE51bWJlclV0aWxzLmlzKHN3LnR5cGUsIFN3aXRjaC5TV0lUQ0hfVFlQRS5GUk9NX1JJR0hULCBTd2l0Y2guU1dJVENIX1RZUEUuRlJPTV9MRUZUKTtcblxuICAgICAgaWYgKGN1cnZlZEJyYW5jaDIgPT0gbnVsbCkge1xuICAgICAgICAgY29uc3QgY3AgPSBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludFgoXG4gICAgICAgICAgICBtYWluVHJhY2suc2xlZXBlcnMub3V0ZXIsXG4gICAgICAgICAgICBtYWluVHJhY2sudW5pdCxcbiAgICAgICAgICAgIGN1cnZlZEJyYW5jaC5zbGVlcGVycy5vdXRlcixcbiAgICAgICAgICAgIGN1cnZlZEJyYW5jaC51bml0XG4gICAgICAgICApO1xuXG4gICAgICAgICBjb25zdCBsZW5ndGggPSBnZW9tZXRyeS5kaXN0YW5jZShtYWluVHJhY2suc2xlZXBlcnMuaW5uZXIsIHN0cmFpZ2h0QnJhbmNoLnNsZWVwZXJzLmlubmVyKTsgLy9sZW5ndGggb2YgdGhlIHN0cmFpZ2h0IHBhcnQgKyBoYWxmIG9mIHRoZSBnYXAsIHRvIG1pbmltaXplIHRoZSBnYXAgdGhlIHRvIG5leHQgdHJhY2tcbiAgICAgICAgIGNvbnN0IGxlbmd0aDIgPSBnZW9tZXRyeS5kaXN0YW5jZShtYWluVHJhY2suc2xlZXBlcnMub3V0ZXIsIGN1cnZlZEJyYW5jaC5zbGVlcGVycy5vdXRlcik7IC8vYWxtb3N0IHRoZSBsZW5ndGggb2YgdGhlIGN1cnZlXG5cbiAgICAgICAgIGNvbnN0IGFtb3VudF9vbl9zdHJhaWdodF9yYWlsID0gTWF0aC5mbG9vcihsZW5ndGggLyB0aGlzLnNsZWVwZXJJbnRlcnZhbGwpO1xuICAgICAgICAgY29uc3QgYW1vdW50X29uX2N1cnZlZF9yYWlsID0gTWF0aC5mbG9vcihsZW5ndGgyIC8gKHRoaXMuc2xlZXBlckludGVydmFsbCAqIDEuMTUpKTtcbiAgICAgICAgIGNvbnN0IG5ld19pbnRlcnZhbGwgPSAodGhpcy5zbGVlcGVySW50ZXJ2YWxsICsgKGxlbmd0aCAlIHRoaXMuc2xlZXBlckludGVydmFsbCkgLyBhbW91bnRfb25fc3RyYWlnaHRfcmFpbCkgKiBtaXJyb3JlZDsgLy9uZXcgaW50ZXJ2YWxsIHRvIG1pbmltaXplIHRoZSBnYXAgYW5kIHVzaW5nIHRoZSBsZWZ0b3ZlciBmcm9tIHRoZSBkaXZpc2lvblxuICAgICAgICAgbGV0IHAxLCB0LCBzbGVlcGVyX2xlbmd0aDtcblxuICAgICAgICAgaWYgKGJhY2syZnJvbnQpIHAxID0gbWFpblRyYWNrLnNsZWVwZXJzLmlubmVyLnN1YihnZW9tZXRyeS5tdWx0aXBseShtYWluVHJhY2sudW5pdCwgdGhpcy5zbGVlcGVySW50ZXJ2YWxsKSk7XG4gICAgICAgICBlbHNlIHAxID0gbWFpblRyYWNrLnNsZWVwZXJzLmlubmVyLmFkZChnZW9tZXRyeS5tdWx0aXBseShtYWluVHJhY2sudW5pdCwgKHRoaXMuc2Nod2VsbGVuR2FwIC8gMikgKiBtaXJyb3JlZCkpO1xuXG4gICAgICAgICBjb25zdCBzdGVwX3ZlY3RvciA9IGdlb21ldHJ5Lm11bHRpcGx5KG1haW5UcmFjay51bml0LCBuZXdfaW50ZXJ2YWxsKTtcblxuICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnRfb25fY3VydmVkX3JhaWw7IGkrKykge1xuICAgICAgICAgICAgdCA9IGkgLyBhbW91bnRfb25fY3VydmVkX3JhaWwgKyAwLjQgLyBhbW91bnRfb25fY3VydmVkX3JhaWw7XG5cbiAgICAgICAgICAgIHNsZWVwZXJfbGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICBnZW9tZXRyeS5kaXN0YW5jZSh0aGlzLmdldFBvaW50T25DdXJ2ZSh0LCBtYWluVHJhY2suc2xlZXBlcnMub3V0ZXIsIGNwLCBjdXJ2ZWRCcmFuY2guc2xlZXBlcnMub3V0ZXIpLCBwMSksXG4gICAgICAgICAgICAgICB0aGlzLnNjaHdlbGxlbkjDtmhlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLmRyYXdTbGVlcGVyKGksIHAxLngsIHAxLnksIGRlZywgY29udGFpbmVyLCAtc2xlZXBlcl9sZW5ndGggKiBmbGlwcGVkLCAwKTtcbiAgICAgICAgICAgIHAxID0gcDEuYWRkKHN0ZXBfdmVjdG9yKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZm9yIChsZXQgaSA9IGFtb3VudF9vbl9jdXJ2ZWRfcmFpbDsgaSA8IGFtb3VudF9vbl9zdHJhaWdodF9yYWlsOyBpKyspIHtcbiAgICAgICAgICAgIHQgPSAodGhpcy5zbGVlcGVySW50ZXJ2YWxsICogaSkgLyBsZW5ndGgyO1xuICAgICAgICAgICAgLy9zdWJ0cmFjdCB0aGUgc2xlZXBlciBpbnRlcnZhbGwgdG8gY3JlYXRlIGEgZ2FwIHRvIHRoZSBuZXh0IHNsZWVwZXJcbiAgICAgICAgICAgIHNsZWVwZXJfbGVuZ3RoID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICBnZW9tZXRyeS5kaXN0YW5jZShcbiAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LmdldEludGVyc2VjdGlvblBvaW50WChcbiAgICAgICAgICAgICAgICAgICAgIGN1cnZlZEJyYW5jaC5zbGVlcGVycy5vdXRlcixcbiAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIoY3VydmVkQnJhbmNoLnVuaXQpLFxuICAgICAgICAgICAgICAgICAgICAgcDEsXG4gICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5wZXJwZW5kaWN1bGFyKG1haW5UcmFjay51bml0KVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHAxXG4gICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgdGhpcy5zY2h3ZWxsZW5Iw7ZoZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5kcmF3U2xlZXBlcihpLCBwMS54LCBwMS55LCBkZWcsIGNvbnRhaW5lciwgLXNsZWVwZXJfbGVuZ3RoICogZmxpcHBlZCwgMCk7XG4gICAgICAgICAgICBwMSA9IHAxLmFkZChzdGVwX3ZlY3Rvcik7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gQ2FsY3VsYXRlIHN0YXJ0aW5nIHBvaW50IGFuZCBvZmZzZXQgdmVjdG9yXG4gICAgICAgICBsZXQgY2VudGVyUG9pbnQgPSBzdHJhaWdodEJyYW5jaC5wb3NpdGlvbi5hZGQobWFpblRyYWNrLnVuaXQubXVsdGlwbHkodGhpcy5zbGVlcGVySW50ZXJ2YWxsIC8gNCkpO1xuICAgICAgICAgY29uc3Qgc3RlcF92ZWN0b3IgPSBtYWluVHJhY2sudW5pdC5tdWx0aXBseSh0aGlzLnNsZWVwZXJJbnRlcnZhbGwpO1xuXG4gICAgICAgICAvLyBDcmVhdGUgYSBmdWxsIHN5bW1ldHJpYyBwYXR0ZXJuIGZyb20gdGhlIGhhbGYgcGF0dGVyblxuICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLkZPVVJfV0FZX1NMRUVQRVJfUEFUVEVSTjtcbiAgICAgICAgIGNvbnN0IHJldmVyc2VkX3BhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDAsIC0xKS5yZXZlcnNlKCk7IC8vcmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgYmVjYXVzZSBpdHMgcmlnaHQgb24gdGhlIHBvaW50IG9mIHRoZSBzd2l0Y2hcbiAgICAgICAgIGNvbnN0IHBvaW50X3N5bW1ldHJpY19wYXR0ZXJuID0gcmV2ZXJzZWRfcGF0dGVybi5tYXAoKHApID0+ICh7IG9mZnNldDogMiAqIHAubGVuZ3RoIC0gcC5vZmZzZXQsIGxlbmd0aDogcC5sZW5ndGggfSkpO1xuICAgICAgICAgY29uc3QgZnVsbFBhdHRlcm4gPSBbLi4ucGF0dGVybiwgLi4ucG9pbnRfc3ltbWV0cmljX3BhdHRlcm5dO1xuXG4gICAgICAgICAvLyBEcmF3IHNsZWVwZXJzIHVzaW5nIHRoZSBwYXR0ZXJuXG4gICAgICAgICBmdWxsUGF0dGVybi5mb3JFYWNoKChkYXRhLCBpKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyYXdTbGVlcGVyKFxuICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgIGNlbnRlclBvaW50LngsXG4gICAgICAgICAgICAgICBjZW50ZXJQb2ludC55LFxuICAgICAgICAgICAgICAgZGVnLFxuICAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggKiB0aGlzLnNjaHdlbGxlbkjDtmhlLFxuICAgICAgICAgICAgICAgZGF0YS5vZmZzZXQgKiB0aGlzLnNjaHdlbGxlbkjDtmhlXzJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjZW50ZXJQb2ludCA9IGNlbnRlclBvaW50LmFkZChzdGVwX3ZlY3Rvcik7XG4gICAgICAgICB9KTtcbiAgICAgIH1cbiAgIH1cblxuICAgcmVuZGVyU3dpdGNoKHN3LCBmb3JjZSkge1xuICAgICAgY29uc3Qgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyID0gdGhpcy5nZXRTd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIoc3cpO1xuXG4gICAgICBjb25zdCBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgc2hhcGUuZGF0YSA9IHN3O1xuICAgICAgc2hhcGUuc25hcFRvUGl4ZWwgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVuZGVyaW5nLnJhaWxzX2NvbnRhaW5lci5hZGRDaGlsZChzaGFwZSk7XG5cbiAgICAgIC8vIERyYXcgdHJhY2sgYmFzZWQgb24gdGhlIG51bWJlciBvZiB0cmFja3NcbiAgICAgIGlmIChzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIuY3VydmVkQnJhbmNoMiA9PSBudWxsKSB7XG4gICAgICAgICB0aGlzLnJlbmRlclRocmVlV2F5U3dpdGNoKHNoYXBlLCBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHRoaXMucmVuZGVyRm91cldheVN3aXRjaChzaGFwZSwgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3U2xlZXBlcnNPblN3aXRjaChzdywgc3dpdGNoUmVuZGVyaW5nUGFyYW1ldGVyKTtcbiAgICAgIHRoaXMucmVuZGVyU3dpdGNoVUkoc3cpO1xuICAgfVxuXG4gICBnZXRTd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIoc3cpIHtcbiAgICAgIGNvbnN0IGZsaXBwZWQgPSBOdW1iZXJVdGlscy5pcyhzdy50eXBlLCBTd2l0Y2guU1dJVENIX1RZUEUuRlJPTV9SSUdIVCwgU3dpdGNoLlNXSVRDSF9UWVBFLlRPX1JJR0hUKSA/IC0xIDogMTtcbiAgICAgIGNvbnN0IG1pcnJvcmVkID0gTnVtYmVyVXRpbHMuaXMoc3cudHlwZSwgU3dpdGNoLlNXSVRDSF9UWVBFLkZST01fTEVGVCwgU3dpdGNoLlNXSVRDSF9UWVBFLkZST01fUklHSFQpID8gLTEgOiAxO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdHJhY2sgZGF0YSBmb3IgZWFjaCB0cmFja1xuICAgICAgY29uc3QgY2FsY1RyYWNrRGF0YSA9IChpbmRleCkgPT4ge1xuICAgICAgICAgbGV0IHRyYWNrID0gc3cudHJhY2tzW2luZGV4XTtcbiAgICAgICAgIGxldCB1bml0ID0gc3cudHJhY2tfZGlyZWN0aW9uc1tpbmRleF07XG4gICAgICAgICBpZiAoIXVuaXQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBjYWxjdWxhdGVQYXJhbWV0ZXJzIGhhc24ndCBiZWVuIGNhbGxlZCBvbiB0aGUgc3dpdGNoLlxuICAgICAgICAgICAgLy8gRm9yIHJvYnVzdG5lc3MsIHdlIGNhbiBjYWxjdWxhdGUgaXQgaGVyZSwgYnV0IGl0J3MgYmV0dGVyIHRvIGVuc3VyZSBpdCdzIGNhbGN1bGF0ZWQgaW4gdGhlIHN3aXRjaCBjbGFzcy5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN3aXRjaCB0cmFja19kaXJlY3Rpb25zIG5vdCBjYWxjdWxhdGVkLCBjYWxjdWxhdGluZyBvbiB0aGUgZmx5LlwiKTtcbiAgICAgICAgICAgIHN3LmNhbGN1bGF0ZVBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIHVuaXQgPSBzdy50cmFja19kaXJlY3Rpb25zW2luZGV4XTtcbiAgICAgICAgIH1cblxuICAgICAgICAgY29uc3QgcmFpbE9mZnNldCA9IGdlb21ldHJ5LnBlcnBlbmRpY3VsYXIodHJhY2sudW5pdC5tdWx0aXBseSh0aGlzLnJhaWxfZGlzdGFuY2UgKiBmbGlwcGVkKSk7XG4gICAgICAgICBjb25zdCBzbGVlcGVyT2Zmc2V0ID0gZ2VvbWV0cnkucGVycGVuZGljdWxhcih0cmFjay51bml0Lm11bHRpcGx5KHRoaXMuc2Nod2VsbGVuSMO2aGVfMiAqIGZsaXBwZWQpKTtcbiAgICAgICAgIC8vIFRoZSBwb3NpdGlvbiBzaG91bGQgYmUgb24gdGhlIHRyYWNrLCBhdCBhIGNlcnRhaW4gZGlzdGFuY2UgZnJvbSB0aGUgc3dpdGNoIGxvY2F0aW9uLlxuICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzdy5sb2NhdGlvbi5hZGQodW5pdC5tdWx0aXBseShzdy5zaXplKSk7XG5cbiAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bml0OiB0cmFjay51bml0LFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgICAgcmFpbHM6IHtcbiAgICAgICAgICAgICAgIGlubmVyOiBwb3NpdGlvbi5hZGQocmFpbE9mZnNldCksXG4gICAgICAgICAgICAgICBvdXRlcjogcG9zaXRpb24uc3ViKHJhaWxPZmZzZXQpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsZWVwZXJzOiB7XG4gICAgICAgICAgICAgICBpbm5lcjogcG9zaXRpb24uYWRkKHNsZWVwZXJPZmZzZXQpLFxuICAgICAgICAgICAgICAgb3V0ZXI6IHBvc2l0aW9uLnN1YihzbGVlcGVyT2Zmc2V0KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgbWFpblRyYWNrID0gY2FsY1RyYWNrRGF0YSgwKTtcbiAgICAgIGNvbnN0IHN0cmFpZ2h0QnJhbmNoID0gY2FsY1RyYWNrRGF0YSgxKTtcbiAgICAgIGNvbnN0IGN1cnZlZEJyYW5jaCA9IGNhbGNUcmFja0RhdGEoMik7XG4gICAgICBjb25zdCBjdXJ2ZWRCcmFuY2gyID0gc3cudHJhY2s0ID8gY2FsY1RyYWNrRGF0YSgzKSA6IG51bGw7XG5cbiAgICAgIHJldHVybiB7IG1haW5UcmFjaywgc3RyYWlnaHRCcmFuY2gsIGN1cnZlZEJyYW5jaCwgY3VydmVkQnJhbmNoMiwgZmxpcHBlZCwgbWlycm9yZWQgfTtcbiAgIH1cblxuICAgcmVuZGVyVGhyZWVXYXlTd2l0Y2goc2hhcGUsIHN3aXRjaFJlbmRlcmluZ1BhcmFtZXRlcikge1xuICAgICAgY29uc3QgZyA9IHNoYXBlLmdyYXBoaWNzO1xuICAgICAgY29uc3QgeyBtYWluVHJhY2ssIHN0cmFpZ2h0QnJhbmNoLCBjdXJ2ZWRCcmFuY2gsIGZsaXBwZWQsIG1pcnJvcmVkIH0gPSBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXI7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzIG9uY2UgLSByZXVzZSBmb3IgYWxsIHJhaWwgc2l6ZXNcbiAgICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSB7XG4gICAgICAgICBvdXRlckN1cnZlOiBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludFgoXG4gICAgICAgICAgICBtYWluVHJhY2sucmFpbHMub3V0ZXIsXG4gICAgICAgICAgICBtYWluVHJhY2sudW5pdCxcbiAgICAgICAgICAgIGN1cnZlZEJyYW5jaC5yYWlscy5vdXRlcixcbiAgICAgICAgICAgIGN1cnZlZEJyYW5jaC51bml0XG4gICAgICAgICApLFxuXG4gICAgICAgICBmcm9nOiBnZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb25Qb2ludFgoXG4gICAgICAgICAgICBzdHJhaWdodEJyYW5jaC5yYWlscy5vdXRlcixcbiAgICAgICAgICAgIHN0cmFpZ2h0QnJhbmNoLnVuaXQsXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2gucmFpbHMuaW5uZXIsXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2gudW5pdFxuICAgICAgICAgKSxcbiAgICAgIH07XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBpbm5lciBjdXJ2ZSBjb250cm9sIHBvaW50IHVzaW5nIHRoZSBhbHJlYWR5IGNhbGN1bGF0ZWQgZnJvZyBwb2ludFxuICAgICAgaW50ZXJzZWN0aW9ucy5pbm5lckN1cnZlID0gZ2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uUG9pbnRYKFxuICAgICAgICAgbWFpblRyYWNrLnJhaWxzLmlubmVyLFxuICAgICAgICAgbWFpblRyYWNrLnVuaXQsXG4gICAgICAgICBpbnRlcnNlY3Rpb25zLmZyb2csXG4gICAgICAgICBjdXJ2ZWRCcmFuY2gudW5pdFxuICAgICAgKTtcblxuICAgICAgLy8gUHJlLWNhbGN1bGF0ZSBhbGwgaGVyenN0w7xjayAoZnJvZykgcG9pbnRzXG4gICAgICBjb25zdCBmcm9nT2Zmc2V0ID0gLXRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLlJBSUxTWzBdWzBdICogbWlycm9yZWQ7IC8vdGhhdHMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGZyb2cgYW5kIHRoZSBwb2ludCBibGFkZXNcbiAgICAgIGNvbnN0IGd1YXJkUmFpbExlbmd0aCA9IDEwICogbWlycm9yZWQ7XG4gICAgICBjb25zdCBmcm9nUG9pbnRzID0ge1xuICAgICAgICAgY3VydmVFbmQ6IFBvaW50LmZyb21Qb2ludChpbnRlcnNlY3Rpb25zLmZyb2cpLmFkZChjdXJ2ZWRCcmFuY2gudW5pdC5tdWx0aXBseShmcm9nT2Zmc2V0KSksXG4gICAgICAgICBzdHJhaWdodFN0YXJ0OiBQb2ludC5mcm9tUG9pbnQoaW50ZXJzZWN0aW9ucy5mcm9nKS5hZGQoc3RyYWlnaHRCcmFuY2gudW5pdC5tdWx0aXBseShmcm9nT2Zmc2V0KSksXG4gICAgICB9O1xuXG4gICAgICAvLyBDYWxjdWxhdGUgZW5kIHBvaW50cyB1c2luZyB0aGUgcHJlLWNhbGN1bGF0ZWQgcG9pbnRzXG4gICAgICBmcm9nUG9pbnRzLnN0cmFpZ2h0RW5kID0gZnJvZ1BvaW50cy5jdXJ2ZUVuZC5hZGQoc3RyYWlnaHRCcmFuY2gudW5pdC5tdWx0aXBseShndWFyZFJhaWxMZW5ndGgpKTtcbiAgICAgIGZyb2dQb2ludHMuY3VydmVTdGFydCA9IGZyb2dQb2ludHMuc3RyYWlnaHRTdGFydC5hZGQoY3VydmVkQnJhbmNoLnVuaXQubXVsdGlwbHkoZ3VhcmRSYWlsTGVuZ3RoKSk7XG5cbiAgICAgIC8vIERyYXcgYWxsIHJhaWxzIHdpdGggZGlmZmVyZW50IHRoaWNrbmVzc2VzIGluIG9uZSBwYXNzXG4gICAgICBmb3IgKGNvbnN0IHJhaWwgb2YgdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuUkFJTFMpIHtcbiAgICAgICAgIGcuc2V0U3Ryb2tlU3R5bGUocmFpbFswXSkuYmVnaW5TdHJva2UocmFpbFsxXSk7XG5cbiAgICAgICAgIC8vIE91dGVyIGN1cnZlZCBicmFuY2hcbiAgICAgICAgIGcubXQobWFpblRyYWNrLnJhaWxzLm91dGVyLngsIG1haW5UcmFjay5yYWlscy5vdXRlci55KS5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5vdXRlckN1cnZlLngsXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zLm91dGVyQ3VydmUueSxcbiAgICAgICAgICAgIGN1cnZlZEJyYW5jaC5yYWlscy5vdXRlci54LFxuICAgICAgICAgICAgY3VydmVkQnJhbmNoLnJhaWxzLm91dGVyLnlcbiAgICAgICAgICk7XG5cbiAgICAgICAgIC8vIElubmVyIGN1cnZlZCBicmFuY2ggd2l0aCBmcm9nIGNvbm5lY3Rpb25cbiAgICAgICAgIGcubXQobWFpblRyYWNrLnJhaWxzLmlubmVyLngsIG1haW5UcmFjay5yYWlscy5pbm5lci55KVxuICAgICAgICAgICAgLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zLmlubmVyQ3VydmUueCAtIGZsaXBwZWQsXG4gICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zLmlubmVyQ3VydmUueSAtIGZsaXBwZWQsXG4gICAgICAgICAgICAgICBmcm9nUG9pbnRzLmN1cnZlRW5kLngsXG4gICAgICAgICAgICAgICBmcm9nUG9pbnRzLmN1cnZlRW5kLnlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5sdChmcm9nUG9pbnRzLnN0cmFpZ2h0RW5kLngsIGZyb2dQb2ludHMuc3RyYWlnaHRFbmQueSk7XG5cbiAgICAgICAgIC8vIEZyb2cgcG9pbnQgYW5kIGNvbm5lY3RpbmcgcmFpbHNcbiAgICAgICAgIGcubXQoc3RyYWlnaHRCcmFuY2gucmFpbHMub3V0ZXIueCwgc3RyYWlnaHRCcmFuY2gucmFpbHMub3V0ZXIueSlcbiAgICAgICAgICAgIC5sdChpbnRlcnNlY3Rpb25zLmZyb2cueCwgaW50ZXJzZWN0aW9ucy5mcm9nLnkpXG4gICAgICAgICAgICAubHQoY3VydmVkQnJhbmNoLnJhaWxzLmlubmVyLngsIGN1cnZlZEJyYW5jaC5yYWlscy5pbm5lci55KTtcblxuICAgICAgICAgLy8gU3RyYWlnaHQgY29ubmVjdGlvblxuICAgICAgICAgZy5tdChtYWluVHJhY2sucmFpbHMuaW5uZXIueCwgbWFpblRyYWNrLnJhaWxzLmlubmVyLnkpLmx0KHN0cmFpZ2h0QnJhbmNoLnJhaWxzLmlubmVyLngsIHN0cmFpZ2h0QnJhbmNoLnJhaWxzLmlubmVyLnkpO1xuXG4gICAgICAgICAvLyBHdWFyZCByYWlsXG4gICAgICAgICBnLm10KGZyb2dQb2ludHMuY3VydmVTdGFydC54LCBmcm9nUG9pbnRzLmN1cnZlU3RhcnQueSlcbiAgICAgICAgICAgIC5sdChmcm9nUG9pbnRzLnN0cmFpZ2h0U3RhcnQueCwgZnJvZ1BvaW50cy5zdHJhaWdodFN0YXJ0LnkpXG4gICAgICAgICAgICAubHQobWFpblRyYWNrLnJhaWxzLm91dGVyLngsIG1haW5UcmFjay5yYWlscy5vdXRlci55ICsgMiAqIGZsaXBwZWQpOyAvL1RPRE8gIHdlIGNhbiBpbXBsZW1lbnQgc3dpdGNoaW5nIHRoZSBzd2l0Y2ggaGVyZVxuXG4gICAgICAgICBnLmVuZFN0cm9rZSgpO1xuICAgICAgfVxuICAgfVxuXG4gICByZW5kZXJGb3VyV2F5U3dpdGNoKHNoYXBlLCBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXIpIHtcbiAgICAgIGNvbnN0IHsgbWFpblRyYWNrLCBzdHJhaWdodEJyYW5jaCwgY3VydmVkQnJhbmNoLCBjdXJ2ZWRCcmFuY2gyIH0gPSBzd2l0Y2hSZW5kZXJpbmdQYXJhbWV0ZXI7XG5cbiAgICAgIGNvbnN0IGRyYXdSYWlsID0gKGdyYXBoaWNzLCBzdGFydFRyYWNrLCBlbmRUcmFjaywgcmFpbFNpZGUpID0+IHtcbiAgICAgICAgIC8vIHJhaWxTaWRlOiAnaW5uZXInIG9yICdvdXRlcidcblxuICAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IHN0YXJ0VHJhY2sucmFpbHNbcmFpbFNpZGVdO1xuICAgICAgICAgY29uc3QgZW5kUG9pbnQgPSBlbmRUcmFjay5yYWlsc1tyYWlsU2lkZV07XG5cbiAgICAgICAgIGNvbnN0IGNwMSA9IGdlb21ldHJ5LmFkZChzdGFydFBvaW50LCBnZW9tZXRyeS5tdWx0aXBseShzdGFydFRyYWNrLnVuaXQsIHRyYWNrUmVuZGVyaW5nX3RleHR1cmVkLkNVUlZBVFVSRV80V0FZX1NXSVRDSCkpO1xuICAgICAgICAgY29uc3QgY3AyID0gZ2VvbWV0cnkuYWRkKGVuZFBvaW50LCBnZW9tZXRyeS5tdWx0aXBseShlbmRUcmFjay51bml0LCAtdHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuQ1VSVkFUVVJFXzRXQVlfU1dJVENIKSk7XG5cbiAgICAgICAgIGdyYXBoaWNzLm10KHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55KS5iZXppZXJDdXJ2ZVRvKGNwMS54LCBjcDEueSwgY3AyLngsIGNwMi55LCBlbmRQb2ludC54LCBlbmRQb2ludC55KTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGcgPSBzaGFwZS5ncmFwaGljcztcblxuICAgICAgLy8gRHJhdyBhbGwgcmFpbHMgd2l0aCBkaWZmZXJlbnQgdGhpY2tuZXNzZXNcbiAgICAgIGZvciAoY29uc3QgcmFpbCBvZiB0cmFja1JlbmRlcmluZ190ZXh0dXJlZC5SQUlMUykge1xuICAgICAgICAgZy5zZXRTdHJva2VTdHlsZShyYWlsWzBdKS5iZWdpblN0cm9rZShyYWlsWzFdKTtcblxuICAgICAgICAgLy8gRHJhdyB1c2luZyB0aGUgaGVscGVyIG1ldGhvZCBmb3IgY29uc2lzdGVudCBjdXJ2ZSByZW5kZXJpbmdcbiAgICAgICAgIGRyYXdSYWlsKGcsIHN0cmFpZ2h0QnJhbmNoLCBjdXJ2ZWRCcmFuY2gyLCBcIm91dGVyXCIpO1xuICAgICAgICAgZHJhd1JhaWwoZywgY3VydmVkQnJhbmNoLCBtYWluVHJhY2ssIFwiaW5uZXJcIik7XG4gICAgICAgICBkcmF3UmFpbChnLCBzdHJhaWdodEJyYW5jaCwgY3VydmVkQnJhbmNoMiwgXCJpbm5lclwiKTtcbiAgICAgICAgIGRyYXdSYWlsKGcsIGN1cnZlZEJyYW5jaCwgbWFpblRyYWNrLCBcIm91dGVyXCIpO1xuXG4gICAgICAgICAvLyBEcmF3IHN0cmFpZ2h0IGNvbm5lY3Rpb25zXG4gICAgICAgICBnLm10KG1haW5UcmFjay5yYWlscy5pbm5lci54LCBtYWluVHJhY2sucmFpbHMuaW5uZXIueSkubHQoc3RyYWlnaHRCcmFuY2gucmFpbHMuaW5uZXIueCwgc3RyYWlnaHRCcmFuY2gucmFpbHMuaW5uZXIueSk7XG5cbiAgICAgICAgIGcubXQobWFpblRyYWNrLnJhaWxzLm91dGVyLngsIG1haW5UcmFjay5yYWlscy5vdXRlci55KS5sdChzdHJhaWdodEJyYW5jaC5yYWlscy5vdXRlci54LCBzdHJhaWdodEJyYW5jaC5yYWlscy5vdXRlci55KTtcblxuICAgICAgICAgZy5tdChjdXJ2ZWRCcmFuY2gucmFpbHMuaW5uZXIueCwgY3VydmVkQnJhbmNoLnJhaWxzLmlubmVyLnkpLmx0KFxuICAgICAgICAgICAgY3VydmVkQnJhbmNoMi5yYWlscy5pbm5lci54LFxuICAgICAgICAgICAgY3VydmVkQnJhbmNoMi5yYWlscy5pbm5lci55XG4gICAgICAgICApO1xuXG4gICAgICAgICBnLm10KGN1cnZlZEJyYW5jaC5yYWlscy5vdXRlci54LCBjdXJ2ZWRCcmFuY2gucmFpbHMub3V0ZXIueSkubHQoXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2gyLnJhaWxzLm91dGVyLngsXG4gICAgICAgICAgICBjdXJ2ZWRCcmFuY2gyLnJhaWxzLm91dGVyLnlcbiAgICAgICAgICk7XG5cbiAgICAgICAgIGcuZW5kU3Ryb2tlKCk7XG4gICAgICB9XG4gICB9XG5cbiAgIHJlbmRlclN3aXRjaFVJKHN3KSB7XG4gICAgICBjb25zdCBkcmF3QXJyb3cgPSAoZ3JhcGhpY3MsIGxlbmd0aCwgc2l6ZSkgPT4ge1xuICAgICAgICAgZ3JhcGhpY3NcbiAgICAgICAgICAgIC5tdCgwLCAwKVxuICAgICAgICAgICAgLmx0KGxlbmd0aCwgMClcbiAgICAgICAgICAgIC5tdChsZW5ndGggLSBzaXplLCAtc2l6ZSAvIDIpXG4gICAgICAgICAgICAubHQobGVuZ3RoLCAwKVxuICAgICAgICAgICAgLmx0KGxlbmd0aCAtIHNpemUsIHNpemUgLyAyKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIENoZWNrIGlmIGEgY29udGFpbmVyIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHN3aXRjaFxuICAgICAgbGV0IGNvbnRhaW5lciA9ICB0aGlzLmFwcC5jb250YWluZXJzLnVpLmNoaWxkcmVuLmZpbmQoKGMpID0+IGMuZGF0YSA9PT0gc3cpO1xuXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAvLyBJZiBjb250YWluZXIgZXhpc3RzLCBjbGVhciBpdCBidXQga2VlcCBpdFxuICAgICAgICAgY29udGFpbmVyLnJlbW92ZUFsbENoaWxkcmVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNvbnRhaW5lciBpZiBub25lIGV4aXN0c1xuICAgICAgICAgY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xuICAgICAgICAgY29udGFpbmVyLm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgIGNvbnRhaW5lci5uYW1lID0gXCJzd2l0Y2hcIjtcbiAgICAgICAgIGNvbnRhaW5lci5kYXRhID0gc3c7XG4gICAgICAgICB0aGlzLmFwcC5jb250YWluZXJzLnVpLmFkZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhcnJvd3MgZm9yIGJvdGggdHJhY2tzXG4gICAgICBbc3cuZnJvbSwgc3cuYnJhbmNoXS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICBjb25zdCBhcnJvdyA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKGFycm93KTtcblxuICAgICAgICAgYXJyb3cuZ3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUodHJhY2tSZW5kZXJpbmdfdGV4dHVyZWQuU1dJVENIX1VJX1NUUk9LRSwgXCJyb3VuZFwiKS5iZWdpblN0cm9rZShcIiMzMzNcIik7XG4gICAgICAgICBkcmF3QXJyb3coYXJyb3cuZ3JhcGhpY3MsIDIwLCA1KTtcbiAgICAgICAgIGFycm93LnggPSBzdy5sb2NhdGlvbi54O1xuICAgICAgICAgYXJyb3cueSA9IHN3LmxvY2F0aW9uLnk7XG4gICAgICAgICBhcnJvdy5yb3RhdGlvbiA9IFN3aXRjaC5maW5kQW5nbGUoc3cubG9jYXRpb24sIHQuZW5kLmVxdWFscyhzdy5sb2NhdGlvbikgPyB0LnN0YXJ0IDogdC5lbmQpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIFBvaW50VmlzaWJsZShwMSkge1xuICAgICAgaWYgKHRoaXMuX3JlbmRlcmluZz8uZG9udF9vcHRpbWl6ZSkgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBzY3JlZW5fcmVjdGFuZ2xlID0gdGhpcy5fcmVuZGVyaW5nLnNjcmVlbl9yZWN0YW5nbGU7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICBOdW1iZXJVdGlscy5iZXR3ZWVuKHAxLngsIHNjcmVlbl9yZWN0YW5nbGUubGVmdCwgc2NyZWVuX3JlY3RhbmdsZS5yaWdodCkgJiZcbiAgICAgICAgIE51bWJlclV0aWxzLmJldHdlZW4ocDEueSwgc2NyZWVuX3JlY3RhbmdsZS50b3AsIHNjcmVlbl9yZWN0YW5nbGUuYm90dG9tKVxuICAgICAgKTtcbiAgIH1cblxuICAgVHJhY2tWaXNpYmxlKHRyYWNrLCBzY3JlZW5fcmVjdGFuZ2xlID0gdGhpcy5fcmVuZGVyaW5nLnNjcmVlbl9yZWN0YW5nbGUpIHtcbiAgICAgIGlmICh0aGlzLl9yZW5kZXJpbmc/LmRvbnRfb3B0aW1pemUpIHJldHVybiB0cnVlO1xuXG4gICAgICBjb25zdCBpc0luc2lkZSA9IChwb2ludCwgcmVjdCkgPT5cbiAgICAgICAgIHBvaW50LnggPiByZWN0LmxlZnQgJiYgcG9pbnQueCA8IHJlY3QucmlnaHQgJiYgcG9pbnQueSA+IHJlY3QudG9wICYmIHBvaW50LnkgPCByZWN0LmJvdHRvbTtcblxuICAgICAgLy9maXJzdCB0aGUgZWFzeSBwYXJ0LCBpZiBlaXRoZXIgb24gb2YgaXRzIGVuZCBwb2ludHMgaXMgdmlzaWJsZVxuICAgICAgaWYgKGlzSW5zaWRlKHRyYWNrLnN0YXJ0LCBzY3JlZW5fcmVjdGFuZ2xlKSB8fCBpc0luc2lkZSh0cmFjay5lbmQsIHNjcmVlbl9yZWN0YW5nbGUpKSByZXR1cm4gdHJ1ZTsgLy9cblxuICAgICAgLy9ub3cgd2UgaGF2ZSB0byBtYWtlIHN1cmUsIGlmIHRoZSB0cmFjayBpcyBnb2luZyB0aHJvdWdoIHRoZSB3aG9sZSBzY3JlZW5cbiAgICAgIC8vd2UgY2hlY2ssIGlmIHRoZSB0cmFjayBpbnRlcnNlY3RzIG9uZSBvZiB0aGUgc2NyZWVuIGJvcmRlcnNcblxuICAgICAgLy9sZWZ0XG4gICAgICBsZXQgcDEgPSB7IHg6IHNjcmVlbl9yZWN0YW5nbGUubGVmdCwgeTogc2NyZWVuX3JlY3RhbmdsZS50b3AgfSxcbiAgICAgICAgIHAyID0geyB4OiBzY3JlZW5fcmVjdGFuZ2xlLmxlZnQsIHk6IHNjcmVlbl9yZWN0YW5nbGUuYm90dG9tIH07XG4gICAgICBpZiAoZ2VvbWV0cnkuZG9MaW5lU2VnbWVudHNJbnRlcnNlY3QocDEsIHAyLCB0cmFjay5zdGFydCwgdHJhY2suZW5kKSkgcmV0dXJuIHRydWU7XG4gICAgICAvL2JvdHRvbVxuICAgICAgcDEgPSBwMjtcbiAgICAgIHAyID0geyB4OiBzY3JlZW5fcmVjdGFuZ2xlLnJpZ2h0LCB5OiBzY3JlZW5fcmVjdGFuZ2xlLmJvdHRvbSB9O1xuICAgICAgaWYgKGdlb21ldHJ5LmRvTGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCkpIHJldHVybiB0cnVlO1xuICAgICAgLy9yaWdodFxuICAgICAgcDEgPSBwMjtcbiAgICAgIHAyID0geyB4OiBzY3JlZW5fcmVjdGFuZ2xlLnJpZ2h0LCB5OiBzY3JlZW5fcmVjdGFuZ2xlLnRvcCB9O1xuICAgICAgaWYgKGdlb21ldHJ5LmRvTGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCkpIHJldHVybiB0cnVlO1xuICAgICAgLy90b3Agd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgYWxsIGJvcmRlcnNcbiAgICAgIC8qIHAxID0gcDI7XG4gICAgICBwMiA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgaWYgKGdlb21ldHJ5LmRvTGluZVNlZ21lbnRzSW50ZXJzZWN0KHAxLCBwMiwgdHJhY2suc3RhcnQsIHRyYWNrLmVuZCkpIHJldHVybiB0cnVlOyAqL1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG5cbiAgIFN3aXRjaFZpc2libGUoc3cpIHtcbiAgICAgIGlmICh0aGlzLl9yZW5kZXJpbmc/LmRvbnRfb3B0aW1pemUpIHJldHVybiB0cnVlO1xuICAgICAgY29uc3Qgc2NyZWVuX3JlY3RhbmdsZSA9IHRoaXMuX3JlbmRlcmluZy5zY3JlZW5fcmVjdGFuZ2xlO1xuXG4gICAgICAvLyBDaGVjayBpZiBzd2l0Y2ggbG9jYXRpb24gaXMgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuUG9pbnRWaXNpYmxlKHN3LmxvY2F0aW9uKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgc3dpdGNoJ3MgdHJhY2tzIGFyZSB2aXNpYmxlXG4gICAgICBjb25zdCB0cmFja3MgPSBbc3cudHJhY2sxLCBzdy50cmFjazIsIHN3LnRyYWNrMywgc3cudHJhY2s0XS5maWx0ZXIoKHQpID0+IHQpO1xuICAgICAgcmV0dXJuIHRyYWNrcy5zb21lKCh0cmFjaykgPT4gdGhpcy5UcmFja1Zpc2libGUodHJhY2ssIHNjcmVlbl9yZWN0YW5nbGUpKTtcbiAgIH1cblxuICAgLyoqXG4gICAgKiBWaXN1YWxpemUgdHJhY2sgYm91bmRzIGZvciBkZWJ1Z2dpbmdcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRvIHZpc3VhbGl6ZSBib3VuZHMgZm9yXG4gICAgKi9cbiAgIHZpc3VhbGl6ZVRyYWNrQm91bmRzKGNvbnRhaW5lcikge1xuICAgICAgY29uc3QgYm91bmRzID0gY29udGFpbmVyLmdldFRyYW5zZm9ybWVkQm91bmRzKCk7XG4gICAgICBjb25zdCBvYmplY3QgPSBjb250YWluZXIuZGF0YTtcblxuICAgICAgaWYgKGJvdW5kcyA9PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZHMgYXJlIG51bGxcIik7XG5cbiAgICAgIC8vIEFkZCBwYWRkaW5nIHRvIGJvdW5kc1xuICAgICAgY29uc3QgcGFkZGluZyA9IDU7XG4gICAgICBib3VuZHMueCAtPSBwYWRkaW5nO1xuICAgICAgYm91bmRzLnkgLT0gcGFkZGluZztcbiAgICAgIGJvdW5kcy53aWR0aCArPSBwYWRkaW5nICogMjtcbiAgICAgIGJvdW5kcy5oZWlnaHQgKz0gcGFkZGluZyAqIDI7XG5cbiAgICAgIC8vIENyZWF0ZSBhIHNoYXBlIGZvciB0aGUgYm91bmRzIHZpc3VhbGl6YXRpb25cbiAgICAgIGNvbnN0IGJvdW5kc1NoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICBib3VuZHNTaGFwZS5uYW1lID0gXCJzZWxlY3Rpb25cIjtcbiAgICAgIGJvdW5kc1NoYXBlLm1vdXNlRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgYm91bmRzU2hhcGUuZGF0YSA9IG9iamVjdDtcblxuICAgICAgLy8gRHJhdyB0aGUgYm91bmRzIHJlY3RhbmdsZVxuICAgICAgYm91bmRzU2hhcGUuZ3JhcGhpY3NcbiAgICAgICAgIC5zZXRTdHJva2VTdHlsZSgyKVxuICAgICAgICAgLnNldFN0cm9rZURhc2goWzUsIDVdKVxuICAgICAgICAgLmJlZ2luU3Ryb2tlKFwicmdiYSgwLCAwLCAwLCAwLjcpXCIpXG4gICAgICAgICAuZHJhd1JlY3QoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpXG4gICAgICAgICAuZW5kU3Ryb2tlKCk7XG5cbiAgICAgIHRoaXMuYXBwLmNvbnRhaW5lcnMuc2VsZWN0aW9uLmFkZENoaWxkKGJvdW5kc1NoYXBlKTtcbiAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/trackRendering_textured.js\n\n}");

/***/ }),

/***/ "./www/code/train.js":
/*!***************************!*\
  !*** ./www/code/train.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Train: () => (/* binding */ Train)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./www/code/utils.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ \"./www/code/storage.js\");\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui.js */ \"./www/code/ui.js\");\n/* harmony import */ var _track_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./track.js */ \"./www/code/track.js\");\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n/* harmony import */ var _application_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./application.js */ \"./www/code/application.js\");\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config.js */ \"./www/code/config.js\");\n\n\n// ES6 Module imports\n\n\n\n\n\n\n\n\nclass Train {\n   static allTrains = [];\n   static nextId = 0;\n   static movingTrains = new Set(); // To track which trains are currently moving\n   static movementTimer = null; // Timer for automatic movement\n   static MOVEMENT_INTERVAL = 50; // Milliseconds between movement updates\n   static MOVEMENT_SPEED = 2; // Units to move per update\n\n   static CAR_TYPES = {\n      LOCOMOTIVE: \"locomotive\",\n      PASSENGER: \"passenger\",\n      MULTIPLE_UNIT_CAR: \"multiple_unit_car\",\n      MULTIPLE_UNIT_HEAD_FRONT: \"multiple_unit_head_front\",\n      MULTIPLE_UNIT_HEAD_BACK: \"multiple_unit_head_back\",\n   };\n\n   static getNextId() {\n      return Train.nextId++;\n   }\n\n   // Constants for different car types\n   static LOCO_LENGTH = 80;\n   static PASSENGER_LENGTH = 100;\n   static MULTIPLE_UNIT_CAR_LENGTH = 50;\n   static MULTIPLE_UNIT_HEAD_FRONT_LENGTH = 50;\n   static MULTIPLE_UNIT_HEAD_BACK_LENGTH = 50;\n\n   // Car spacing\n   static CAR_SPACING = 5;\n\n   static addTrain(track, km, color = \"#ff0000\", type = Train.CAR_TYPES.LOCOMOTIVE, number = \"\") {\n      const train = new Train();\n      train.track = track;\n      train.pos = km;\n      train._color = color;\n      train._type = type;\n      train._number = number;\n\n      Train.allTrains.push(train);\n      return train;\n   }\n\n   static initEditTrainMenu(train) {\n      $(\"#colorInputTrain\")\n         .off()\n         .val(train.color)\n         .on(\"change\", function (e) {\n            train.color = $(this).val();\n            _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().renderer.renderAllTrains();\n            _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n         });\n\n      $(\"#inputZugnummer\")\n         .off()\n         .val(train.number)\n         .on(\"change\", function (e) {\n            train.number = $(this).val();\n            _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().renderer.renderAllTrains();\n            _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n         });\n\n      $(\"#selectTrainType\")\n         .off()\n         .val(train.type)\n         .on(\"change\", function (e) {\n            train.type = $(this).val();\n            _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().renderer.renderAllTrains();\n            _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().stage.update();\n            _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n         });\n\n      $(\"#btnRemoveTrain\")\n         .off()\n         .click(() => Train.deleteTrain(train));\n\n      $(\"#btnCoupleTrain\")\n         .off()\n         .click(() => {\n            // Set global state for coupling mode\n            if (_application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().customMouseMode === _config_js__WEBPACK_IMPORTED_MODULE_6__.CUSTOM_MOUSE_ACTION.NONE) {\n               // First check if there are any coupling points available\n               if (Train.showCouplingPoints(train)) {\n                  // Add active class to button\n                  $(\"#btnCoupleTrain\").addClass(\"active\");\n\n                  _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().customMouseMode = _config_js__WEBPACK_IMPORTED_MODULE_6__.CUSTOM_MOUSE_ACTION.TRAIN_COUPLE;\n\n                  // Show coupling message\n                  $(\"#couplingMessage\")\n                     .text(\"Klicke auf einen Kupplungspunkt um Züge zu kuppeln oder überall anders um abzubrechen\")\n                     .show();\n               } else {\n                  // Points are already cleared and message shown by showCouplingPoints\n               }\n            } else {\n               Train.exitCouplingMode();\n            }\n         });\n\n      $(\"#btnUncoupleTrain\")\n         .off()\n         .click(() => {\n            // Set global state for decoupling mode\n            if (_application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().customMouseMode === _config_js__WEBPACK_IMPORTED_MODULE_6__.CUSTOM_MOUSE_ACTION.NONE) {\n               // First check if there are any decoupling points available\n               if (Train.showDecouplingPoints(train)) {\n                  // Add active class to button\n                  $(\"#btnUncoupleTrain\").addClass(\"active\");\n\n                  _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().customMouseMode = _config_js__WEBPACK_IMPORTED_MODULE_6__.CUSTOM_MOUSE_ACTION.TRAIN_DECOUPLE;\n\n                  // Show decoupling message\n                  $(\"#couplingMessage\")\n                     .text(\"Klicke zwischen Wagen um Züge zu entkuppeln oder überall anders um abzubrechen\")\n                     .show();\n               } else {\n                  // Points are already cleared and message shown by showDecouplingPoints\n               }\n            } else {\n               Train.exitDecouplingMode();\n            }\n         });\n         \n      // Only show movement controls for locomotives (first car of a train)\n      const isLocomotive = train.type === Train.CAR_TYPES.LOCOMOTIVE;\n      $(\"#trainMovementControls\").toggle(isLocomotive);\n      \n      if (isLocomotive) {\n         // Initialize movement direction buttons\n         if (!train.movementDirection) {\n            train.movementDirection = 1; // Default to forward\n         }\n         \n         // Update button states based on current direction\n         $(\"#btnDirectionForward\").toggleClass(\"active\", train.movementDirection > 0);\n         $(\"#btnDirectionBackward\").toggleClass(\"active\", train.movementDirection < 0);\n         \n         // Update start/stop button based on movement state\n         const isMoving = Train.movingTrains.has(train);\n         $(\"#btnStartStopTrain\")\n            .toggleClass(\"btn-success\", !isMoving)\n            .toggleClass(\"btn-danger\", isMoving)\n            .html(isMoving ? '<i class=\"bi bi-stop-fill\"></i> Stop' : '<i class=\"bi bi-play-fill\"></i> Start');\n         \n         // Set up direction button handlers\n         $(\"#btnDirectionForward\")\n            .off()\n            .click(() => {\n               train.movementDirection = 1;\n               $(\"#btnDirectionForward\").addClass(\"active\");\n               $(\"#btnDirectionBackward\").removeClass(\"active\");\n            });\n            \n         $(\"#btnDirectionBackward\")\n            .off()\n            .click(() => {\n               train.movementDirection = -1;\n               $(\"#btnDirectionBackward\").addClass(\"active\");\n               $(\"#btnDirectionForward\").removeClass(\"active\");\n            });\n            \n         // Set up start/stop button handler\n         $(\"#btnStartStopTrain\")\n            .off()\n            .click(() => {\n               if (Train.movingTrains.has(train)) {\n                  // Stop the train\n                  Train.stopTrain(train);\n               } else {\n                  // Start the train\n                  Train.startTrain(train);\n               }\n            });\n      }\n   }\n\n   static deleteTrain(train) {\n      // Stop the train if it's moving\n      if (Train.movingTrains.has(train)) {\n         Train.stopTrain(train);\n      }  \n\n      // Get the last car in the train that will be deleted\n      let currentCar = train;\n      while (currentCar.trainCoupledBack) {\n         currentCar = currentCar.trainCoupledBack;\n      }\n\n      // Remove all cars in this train from allTrains\n      while (currentCar) {\n         _utils_js__WEBPACK_IMPORTED_MODULE_0__.ArrayUtils.remove(this.allTrains, currentCar);\n         //save the next car before removing all references to other objects\n         const nextCar = currentCar.trainCoupledFront;\n         currentCar.trainCoupledFront = null;\n         currentCar.trainCoupledBack = null;\n         currentCar.track = null;\n         currentCar = nextCar;\n      }\n\n      renderer.renderAllTrains();\n      stage.update();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n   }\n\n   static moveTrain(train, movementX) {\n      // Find the head of the train (first car with no front coupling)\n      let firstCar = train;\n      while (firstCar.trainCoupledFront != null) {\n         firstCar = firstCar.trainCoupledFront;\n      }\n\n      // Find the last car\n      let lastCar = firstCar;\n      while (lastCar.trainCoupledBack != null) {\n         lastCar = lastCar.trainCoupledBack;\n      }\n\n      if (!Train.movementPossible(firstCar, movementX) || !Train.movementPossible(lastCar, movementX)) return;\n\n      // Move each car starting from the first\n      let car = firstCar;\n      let new_pos;\n      let currentTrack;\n\n      currentTrack = car.track;\n\n\n      // Calculate new position using the node's unit vector\n      new_pos = car.pos + movementX / stage.scale / car.track.cos;\n\n      while (car) {\n         if (car != firstCar) {\n            // Calculate position based on previous car and car length\n            // Take into account the spacing between cars (5 units)\n            const prevCar = car.trainCoupledFront;\n            const spacing = 5; // Gap between cars\n            new_pos = prevCar.pos + prevCar.length / 2 + spacing + car.length / 2;\n         }\n\n         let newTrack;\n         if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.outoff(new_pos, 0, currentTrack.length)) {\n            const sw = new_pos <= 0 ? currentTrack.switchAtTheStart : currentTrack.switchAtTheEnd;\n\n            if (sw) {\n               if ((0,_tools_js__WEBPACK_IMPORTED_MODULE_4__.type)(sw) == \"Track\") newTrack = sw;\n               else if (sw.from == currentTrack) newTrack = sw.branch;\n               else if (sw.branch == currentTrack) newTrack = sw.from;\n\n               if (newTrack) {\n                  car.track = newTrack;\n                  car.pos = new_pos <= 0 ? newTrack.length + new_pos : new_pos - currentTrack.length;\n                  currentTrack = newTrack;\n                  new_pos = car.pos;\n               }\n            }\n         } else {\n            car.track = currentTrack;\n            car.pos = new_pos;\n         }\n\n         car = car.trainCoupledBack;\n      }\n   }\n\n   static movementPossible(train, movementX) {\n      const currentTrack = train.track;\n\n      // Calculate new position using the node's unit vector\n      let new_pos = train.pos + movementX / stage.scale / train.track.cos;\n\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.outoff(new_pos, 0 + train.length / 2, currentTrack.length - train.length / 2)) {\n         const sw = new_pos <= 0 + train.length / 2 ? currentTrack.switchAtTheStart : currentTrack.switchAtTheEnd;\n\n         return sw != null && ((0,_tools_js__WEBPACK_IMPORTED_MODULE_4__.type)(sw) == \"Track\" || sw.from == currentTrack || sw.branch == currentTrack);\n      } else return true;\n   }\n\n   static FromObject(o) {\n      const train = new Train();\n      train._id = o._id;\n      Train.nextId = Math.max(Train.nextId, o._id + 1);\n      train._color = o.color;\n      train._coordinates = _tools_js__WEBPACK_IMPORTED_MODULE_4__.Point.fromPoint(o.coordinates);\n      train._type = o.type || Train.CAR_TYPES.LOCOMOTIVE;\n      train._number = o.number || \"\";\n      train.trainCoupledBackId = o.trainCoupledBackId;\n      train.trainCoupledFrontId = o.trainCoupledFrontId;\n      return train;\n   }\n\n   _id = Train.getNextId();\n   _track = null;\n   _pos = null;\n   _coordinates = null;\n   _color = \"#000000\";\n   _number = \"\";\n   _type = Train.CAR_TYPES.LOCOMOTIVE;\n   trainCoupledBack = null;\n   trainCoupledFront = null;\n\n   get track() {\n      return this._track;\n   }\n\n   set track(t) {\n      this._track = t;\n   }\n\n   get pos() {\n      return this._pos;\n   }\n\n   set pos(km) {\n      this._pos = km;\n      if (this._track) this._coordinates = this._track.getPointFromKm(km);\n   }\n\n   get color() {\n      return this._color;\n   }\n\n   set color(c) {\n      this._color = c;\n   }\n\n   get number() {\n      return this._number;\n   }\n\n   set number(n) {\n      this._number = n;\n   }\n\n   get type() {\n      return this._type;\n   }\n\n   set type(t) {\n      this._type = t;\n   }\n\n   get length() {\n      switch (this._type) {\n         case Train.CAR_TYPES.LOCOMOTIVE:\n            return Train.LOCO_LENGTH;\n         case Train.CAR_TYPES.PASSENGER:\n            return Train.PASSENGER_LENGTH;\n         case Train.CAR_TYPES.MULTIPLE_UNIT_CAR:\n            return Train.MULTIPLE_UNIT_CAR_LENGTH;\n         case Train.CAR_TYPES.MULTIPLE_UNIT_HEAD_FRONT:\n            return Train.MULTIPLE_UNIT_HEAD_FRONT_LENGTH;\n         case Train.CAR_TYPES.MULTIPLE_UNIT_HEAD_BACK:\n            return Train.MULTIPLE_UNIT_HEAD_BACK_LENGTH;\n         default:\n            return Train.PASSENGER_LENGTH; // Default to passenger length if type is unknown\n      }\n   }\n\n   coupleBack(train) {\n      if (train === this) return; // Can't couple to self\n\n      // First uncouple the train from any previous connections\n      if (train.trainCoupledFront) {\n         train.trainCoupledFront.trainCoupledBack = null;\n         train.trainCoupledFront = null;\n      }\n\n      this.trainCoupledBack = train;\n      train.trainCoupledFront = this;\n   }\n\n   uncouple() {\n      if (this.trainCoupledBack) {\n         this.trainCoupledBack.trainCoupledFront = null;\n         this.trainCoupledBack = null;\n      }\n   }\n\n   // Find the locomotive (head) of this train\n   getLocomotive() {\n      let loco = this;\n      while (loco.trainCoupledFront) {\n         loco = loco.trainCoupledFront;\n      }\n      return loco;\n   }\n\n   // Count all cars in this train\n   getCarCount() {\n      let count = 1;\n      let car = this.trainCoupledBack;\n      while (car) {\n         count++;\n         car = car.trainCoupledBack;\n      }\n      return count;\n   }\n\n   restore() {\n      const t = _track_js__WEBPACK_IMPORTED_MODULE_3__.Track.findTrackByPoint(this._coordinates);\n      if (t) {\n         this.track = t;\n         this.pos = t.getKmfromPoint(this._coordinates);\n      }\n\n      if (this.trainCoupledFrontId) {\n         const frontCar = Train.allTrains.find((t) => t._id === this.trainCoupledFrontId);\n         if (frontCar) {\n            this.trainCoupledFront = frontCar;\n         }\n\n         \n      }\n\n      if (this.trainCoupledBackId) {\n         const backCar = Train.allTrains.find((t) => t._id === this.trainCoupledBackId);\n         if (backCar) {\n            this.trainCoupledBack = backCar;\n         }\n\n         \n      }\n   }\n\n   stringify() {\n      return {\n         _class: \"Train\",\n         _id: this._id,\n         coordinates: this._coordinates,\n         color: this._color,\n         number: this._number,\n         type: this._type,\n         trainCoupledBackId: this.trainCoupledBack ? this.trainCoupledBack._id : null,\n         trainCoupledFrontId: this.trainCoupledFront ? this.trainCoupledFront._id : null,\n      };\n   }\n\n   static showDecouplingPoints(train) {\n      // Clear any existing overlay\n      _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().containers.overlay.removeAllChildren();\n\n      // Find the first car in the train\n      let firstCar = train;\n      while (firstCar.trainCoupledFront) {\n         firstCar = firstCar.trainCoupledFront;\n      }\n\n      // Start with the first car\n      let currentCar = firstCar;\n      let decouplingPointsFound = 0;\n\n      // Add decoupling points between each car\n      while (currentCar && currentCar.trainCoupledBack) {\n         const nextCar = currentCar.trainCoupledBack;\n\n         // Get positions of the two cars\n         const currentPos = currentCar.track.getPointFromKm(currentCar.pos);\n         const nextPos = nextCar.track.getPointFromKm(nextCar.pos);\n\n         // Calculate midpoint between cars for decoupling point\n         const midX = (currentPos.x + nextPos.x) / 2;\n         const midY = (currentPos.y + nextPos.y) / 2;\n\n         // Create a decoupling point (circle)\n         const decouplingPoint = new createjs.Shape();\n         decouplingPoint.graphics.beginFill(\"#ff0000\").drawCircle(0, 0, 6);\n         decouplingPoint.x = midX;\n         decouplingPoint.y = midY;\n         // Store the cars to decouple in the shape's data\n         decouplingPoint.data = {\n            carToDeCoupleFrom: currentCar,\n            carToDeCouple: nextCar,\n         };\n         decouplingPoint.name = \"decouplingPoint\";\n\n         // Add to overlay container\n         overlay.addChild(decouplingPoint);\n         decouplingPointsFound++;\n\n         // Move to the next car\n         currentCar = nextCar;\n      }\n\n      // If no decoupling points found, show a message\n      if (decouplingPointsFound === 0) {\n         // Show a message\n         _ui_js__WEBPACK_IMPORTED_MODULE_2__.ui.showInfoToast(\"Keine Wagen in der Nähe zum entkuppeln gefunden, dieser Zug hat nur einen Wagen\");\n         return false;\n      } else {\n         stage.update();\n         return true;\n      }\n   }\n\n   static handleDecouplingClick(data) {\n      if (!data) throw new Error(\"No train provided\");\n      // Decouple at this point\n      data.carToDeCoupleFrom.uncouple();\n\n      // Exit decoupling mode\n      Train.exitDecouplingMode();\n\n      // Update display\n      renderer.renderAllTrains();\n      stage.update();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n   }\n\n   static exitDecouplingMode() {\n      // Remove decoupling points\n      _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().containers.overlay.removeAllChildren();\n\n      // Reset custom action mode\n      _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().customMouseMode = _config_js__WEBPACK_IMPORTED_MODULE_6__.CUSTOM_MOUSE_ACTION.NONE;\n\n      // Hide message with a small delay to ensure it's fully shown first\n      setTimeout(() => {\n         $(\"#couplingMessage\").hide();\n      }, 50);\n\n      // Deactivate any active buttons\n      $(\"#btnUncoupleTrain\").removeClass(\"active\");\n\n      _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().stage.update();\n   }\n\n   static showCouplingPoints(train) {\n      // Clear any existing overlay\n      _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().containers.overlay.removeAllChildren();\n\n      // Get the head and tail of the train\n      let firstCar = train;\n      while (firstCar.trainCoupledFront) {\n         firstCar = firstCar.trainCoupledFront;\n      }\n\n      let lastCar = train;\n      while (lastCar.trainCoupledBack) {\n         lastCar = lastCar.trainCoupledBack;\n      }\n\n      // Get positions of the train ends\n      const firstCarPos = firstCar.pos;\n      const lastCarPos = lastCar.pos;\n      let distance = 0;\n      let couplingPointsFound = 0;\n\n      // Check all other trains for possible coupling points\n      Train.allTrains.forEach((otherCar) => {\n         // Skip cars in the same train\n         if (\n            otherCar === firstCar ||\n            otherCar === lastCar ||\n            (otherCar.trainCoupledFront != null && otherCar.trainCoupledBack != null) ||\n            otherCar.track != train.track\n         ) {\n            return;\n         }\n\n         // Get positions of the other train ends\n         const otherCarPos = otherCar.pos;\n\n         // Check distance between train ends (front to front)\n         const maxCouplingDistance = 80; // Maximum distance for coupling\n\n         // Check front of our train to back of other train\n         if (otherCar.trainCoupledBack == null) {\n            distance = firstCarPos - otherCarPos;\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.between(distance, 0, maxCouplingDistance)) {\n               addCouplingPoint(otherCar, firstCar);\n               couplingPointsFound++;\n            }\n         }\n\n         // Check back of our train to front of other train\n         if (otherCar.trainCoupledFront == null) {\n            distance = otherCarPos - lastCarPos;\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.NumberUtils.between(distance, 0, maxCouplingDistance)) {\n               addCouplingPoint(lastCar, otherCar);\n               couplingPointsFound++;\n            }\n         }\n      });\n\n      // If no coupling points found, show a message\n      if (couplingPointsFound === 0) {\n         // Show a message\n         _ui_js__WEBPACK_IMPORTED_MODULE_2__.ui.showInfoToast(\"Keine Wagen in der Nähe zum kuppeln gefunden\");\n         return false;\n      } else {\n         _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().stage.update();\n         return true;\n      }\n\n      // Helper function to add a coupling point\n      function addCouplingPoint(car1, car2) {\n         // Calculate midpoint between cars for coupling point\n         const car1Pos = car1.track.getPointFromKm(car1.pos);\n         const car2Pos = car2.track.getPointFromKm(car2.pos);\n         const midX = (car1Pos.x + car2Pos.x) / 2;\n         const midY = (car1Pos.y + car2Pos.y) / 2;\n\n         // Create a coupling point (circle)\n         const couplingPoint = new createjs.Shape();\n         couplingPoint.graphics.beginFill(\"#00ff00\").drawCircle(0, 0, 6);\n         couplingPoint.x = midX;\n         couplingPoint.y = midY;\n\n         // Store the cars to couple in the shape's data\n         couplingPoint.data = {\n            car1: car1,\n            car2: car2,\n         };\n         couplingPoint.name = \"couplingPoint\";\n\n         // Add to overlay container\n         _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().containers.overlay.addChild(couplingPoint);\n      }\n   }\n\n   static handleCouplingClick(data) {\n      if (!data) throw new Error(\"No train data provided\");\n\n      // Determine which cars to couple\n      data.car1.coupleBack(data.car2);\n\n      // Exit coupling mode\n      Train.exitCouplingMode();\n\n      // Update display\n      renderer.renderAllTrains();\n      stage.update();\n      _storage_js__WEBPACK_IMPORTED_MODULE_1__.STORAGE.save();\n   }\n\n   static exitCouplingMode() {\n      // Remove coupling points\n      _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().containers.overlay.removeAllChildren();\n\n      // Reset custom action mode\n      _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().customMouseMode = _config_js__WEBPACK_IMPORTED_MODULE_6__.CUSTOM_MOUSE_ACTION.NONE;\n\n      $(\"#couplingMessage\").hide();\n\n      // Deactivate any active buttons\n      $(\"#btnCoupleTrain\").removeClass(\"active\");\n\n      _application_js__WEBPACK_IMPORTED_MODULE_5__.Application.getInstance().stage.update();\n   }\n\n   // Add new methods for automatic train movement\n\n   static startTrain(train) {\n      // Add train to the set of moving trains\n      Train.movingTrains.add(train);\n      \n      // Update button state\n      $(\"#btnStartStopTrain\")\n         .removeClass(\"btn-success\")\n         .addClass(\"btn-danger\")\n         .html('<i class=\"bi bi-stop-fill\"></i> Stop');\n      \n      // Start movement timer if not already running\n      if (!Train.movementTimer) {\n         Train.movementTimer = setInterval(Train.updateMovingTrains, Train.MOVEMENT_INTERVAL);\n      }\n   }\n   \n   static stopTrain(train) {\n      // Remove train from the set of moving trains\n      Train.movingTrains.delete(train);\n      \n      // Update button state\n      $(\"#btnStartStopTrain\")\n         .removeClass(\"btn-danger\")\n         .addClass(\"btn-success\")\n         .html('<i class=\"bi bi-play-fill\"></i> Start');\n      \n      // If no trains are moving, stop the timer\n      if (Train.movingTrains.size === 0 && Train.movementTimer) {\n         clearInterval(Train.movementTimer);\n         Train.movementTimer = null;\n      }\n   }\n   \n   static stopAllTrains() {\n      // Stop all moving trains\n      for (const train of Train.movingTrains) {\n         Train.stopTrain(train);\n      }\n      \n      // Clear the set of moving trains\n      Train.movingTrains.clear();\n      \n      // Stop the timer\n      if (Train.movementTimer) {\n         clearInterval(Train.movementTimer);\n         Train.movementTimer = null;\n      }\n   }\n   \n   static updateMovingTrains() {\n      let needsUpdate = false;\n      \n      // Move each train in the set of moving trains\n      for (const train of Train.movingTrains) {\n         // Calculate movement amount based on direction and speed\n         const movementAmount = train.movementDirection * Train.MOVEMENT_SPEED;\n         \n         // Check if movement is possible\n         const firstCar = train.getLocomotive();\n         const lastCar = Train.getLastCar(firstCar);\n         \n         if (Train.movementPossible(firstCar, movementAmount) && \n             Train.movementPossible(lastCar, movementAmount)) {\n            // Move the train\n            Train.moveTrain(firstCar, movementAmount);\n            needsUpdate = true;\n         } else {\n            // Stop the train if movement is not possible\n            Train.stopTrain(train);\n            _ui_js__WEBPACK_IMPORTED_MODULE_2__.ui.showInfoToast(\"Zug kann nicht weiter fahren\");\n         }\n      }\n      \n      // Update the display if any trains moved\n      if (needsUpdate) {\n         renderer.renderAllTrains();\n         stage.update();\n      }\n   }\n   \n   static getLastCar(train) {\n      let lastCar = train;\n      while (lastCar.trainCoupledBack) {\n         lastCar = lastCar.trainCoupledBack;\n      }\n      return lastCar;\n   }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRDQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsNENBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSx3REFBVzs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0NBQUU7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0RBQU87QUFDYjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSx3REFBVzs7QUFFakI7QUFDQSxNQUFNLHdEQUFXLGlDQUFpQywyREFBbUI7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxNQUFNLHdEQUFXO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHdEQUFXOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNDQUFFO0FBQ1g7QUFDQSxRQUFRO0FBQ1IsU0FBUyx3REFBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx3REFBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0RBQU87QUFDYjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSx3REFBVzs7QUFFakI7QUFDQSxNQUFNLHdEQUFXLGlDQUFpQywyREFBbUI7O0FBRXJFOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSx3REFBVztBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFlBQVksc0NBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nbGVpc3BsYW5lZGl0b3IvLi93d3cvY29kZS90cmFpbi5qcz80YzU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyBFUzYgTW9kdWxlIGltcG9ydHNcbmltcG9ydCB7IEFycmF5VXRpbHMsIE51bWJlclV0aWxzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBTVE9SQUdFIH0gZnJvbSAnLi9zdG9yYWdlLmpzJztcbmltcG9ydCB7IHVpIH0gZnJvbSAnLi91aS5qcyc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vdHJhY2suanMnO1xuaW1wb3J0IHsgUG9pbnQsIHR5cGUgfSBmcm9tICcuL3Rvb2xzLmpzJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uIH0gZnJvbSAnLi9hcHBsaWNhdGlvbi5qcyc7XG5pbXBvcnQgeyBDVVNUT01fTU9VU0VfQUNUSU9OIH0gZnJvbSAnLi9jb25maWcuanMnO1xuXG5leHBvcnQgY2xhc3MgVHJhaW4ge1xuICAgc3RhdGljIGFsbFRyYWlucyA9IFtdO1xuICAgc3RhdGljIG5leHRJZCA9IDA7XG4gICBzdGF0aWMgbW92aW5nVHJhaW5zID0gbmV3IFNldCgpOyAvLyBUbyB0cmFjayB3aGljaCB0cmFpbnMgYXJlIGN1cnJlbnRseSBtb3ZpbmdcbiAgIHN0YXRpYyBtb3ZlbWVudFRpbWVyID0gbnVsbDsgLy8gVGltZXIgZm9yIGF1dG9tYXRpYyBtb3ZlbWVudFxuICAgc3RhdGljIE1PVkVNRU5UX0lOVEVSVkFMID0gNTA7IC8vIE1pbGxpc2Vjb25kcyBiZXR3ZWVuIG1vdmVtZW50IHVwZGF0ZXNcbiAgIHN0YXRpYyBNT1ZFTUVOVF9TUEVFRCA9IDI7IC8vIFVuaXRzIHRvIG1vdmUgcGVyIHVwZGF0ZVxuXG4gICBzdGF0aWMgQ0FSX1RZUEVTID0ge1xuICAgICAgTE9DT01PVElWRTogXCJsb2NvbW90aXZlXCIsXG4gICAgICBQQVNTRU5HRVI6IFwicGFzc2VuZ2VyXCIsXG4gICAgICBNVUxUSVBMRV9VTklUX0NBUjogXCJtdWx0aXBsZV91bml0X2NhclwiLFxuICAgICAgTVVMVElQTEVfVU5JVF9IRUFEX0ZST05UOiBcIm11bHRpcGxlX3VuaXRfaGVhZF9mcm9udFwiLFxuICAgICAgTVVMVElQTEVfVU5JVF9IRUFEX0JBQ0s6IFwibXVsdGlwbGVfdW5pdF9oZWFkX2JhY2tcIixcbiAgIH07XG5cbiAgIHN0YXRpYyBnZXROZXh0SWQoKSB7XG4gICAgICByZXR1cm4gVHJhaW4ubmV4dElkKys7XG4gICB9XG5cbiAgIC8vIENvbnN0YW50cyBmb3IgZGlmZmVyZW50IGNhciB0eXBlc1xuICAgc3RhdGljIExPQ09fTEVOR1RIID0gODA7XG4gICBzdGF0aWMgUEFTU0VOR0VSX0xFTkdUSCA9IDEwMDtcbiAgIHN0YXRpYyBNVUxUSVBMRV9VTklUX0NBUl9MRU5HVEggPSA1MDtcbiAgIHN0YXRpYyBNVUxUSVBMRV9VTklUX0hFQURfRlJPTlRfTEVOR1RIID0gNTA7XG4gICBzdGF0aWMgTVVMVElQTEVfVU5JVF9IRUFEX0JBQ0tfTEVOR1RIID0gNTA7XG5cbiAgIC8vIENhciBzcGFjaW5nXG4gICBzdGF0aWMgQ0FSX1NQQUNJTkcgPSA1O1xuXG4gICBzdGF0aWMgYWRkVHJhaW4odHJhY2ssIGttLCBjb2xvciA9IFwiI2ZmMDAwMFwiLCB0eXBlID0gVHJhaW4uQ0FSX1RZUEVTLkxPQ09NT1RJVkUsIG51bWJlciA9IFwiXCIpIHtcbiAgICAgIGNvbnN0IHRyYWluID0gbmV3IFRyYWluKCk7XG4gICAgICB0cmFpbi50cmFjayA9IHRyYWNrO1xuICAgICAgdHJhaW4ucG9zID0ga207XG4gICAgICB0cmFpbi5fY29sb3IgPSBjb2xvcjtcbiAgICAgIHRyYWluLl90eXBlID0gdHlwZTtcbiAgICAgIHRyYWluLl9udW1iZXIgPSBudW1iZXI7XG5cbiAgICAgIFRyYWluLmFsbFRyYWlucy5wdXNoKHRyYWluKTtcbiAgICAgIHJldHVybiB0cmFpbjtcbiAgIH1cblxuICAgc3RhdGljIGluaXRFZGl0VHJhaW5NZW51KHRyYWluKSB7XG4gICAgICAkKFwiI2NvbG9ySW5wdXRUcmFpblwiKVxuICAgICAgICAgLm9mZigpXG4gICAgICAgICAudmFsKHRyYWluLmNvbG9yKVxuICAgICAgICAgLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0cmFpbi5jb2xvciA9ICQodGhpcykudmFsKCk7XG4gICAgICAgICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnJlbmRlcmVyLnJlbmRlckFsbFRyYWlucygpO1xuICAgICAgICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICQoXCIjaW5wdXRadWdudW1tZXJcIilcbiAgICAgICAgIC5vZmYoKVxuICAgICAgICAgLnZhbCh0cmFpbi5udW1iZXIpXG4gICAgICAgICAub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRyYWluLm51bWJlciA9ICQodGhpcykudmFsKCk7XG4gICAgICAgICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnJlbmRlcmVyLnJlbmRlckFsbFRyYWlucygpO1xuICAgICAgICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICQoXCIjc2VsZWN0VHJhaW5UeXBlXCIpXG4gICAgICAgICAub2ZmKClcbiAgICAgICAgIC52YWwodHJhaW4udHlwZSlcbiAgICAgICAgIC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdHJhaW4udHlwZSA9ICQodGhpcykudmFsKCk7XG4gICAgICAgICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnJlbmRlcmVyLnJlbmRlckFsbFRyYWlucygpO1xuICAgICAgICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICQoXCIjYnRuUmVtb3ZlVHJhaW5cIilcbiAgICAgICAgIC5vZmYoKVxuICAgICAgICAgLmNsaWNrKCgpID0+IFRyYWluLmRlbGV0ZVRyYWluKHRyYWluKSk7XG5cbiAgICAgICQoXCIjYnRuQ291cGxlVHJhaW5cIilcbiAgICAgICAgIC5vZmYoKVxuICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFNldCBnbG9iYWwgc3RhdGUgZm9yIGNvdXBsaW5nIG1vZGVcbiAgICAgICAgICAgIGlmIChBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLmN1c3RvbU1vdXNlTW9kZSA9PT0gQ1VTVE9NX01PVVNFX0FDVElPTi5OT05FKSB7XG4gICAgICAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGNvdXBsaW5nIHBvaW50cyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgIGlmIChUcmFpbi5zaG93Q291cGxpbmdQb2ludHModHJhaW4pKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZGQgYWN0aXZlIGNsYXNzIHRvIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgJChcIiNidG5Db3VwbGVUcmFpblwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcblxuICAgICAgICAgICAgICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5jdXN0b21Nb3VzZU1vZGUgPSBDVVNUT01fTU9VU0VfQUNUSU9OLlRSQUlOX0NPVVBMRTtcblxuICAgICAgICAgICAgICAgICAgLy8gU2hvdyBjb3VwbGluZyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAkKFwiI2NvdXBsaW5nTWVzc2FnZVwiKVxuICAgICAgICAgICAgICAgICAgICAgLnRleHQoXCJLbGlja2UgYXVmIGVpbmVuIEt1cHBsdW5nc3B1bmt0IHVtIFrDvGdlIHp1IGt1cHBlbG4gb2RlciDDvGJlcmFsbCBhbmRlcnMgdW0gYWJ6dWJyZWNoZW5cIilcbiAgICAgICAgICAgICAgICAgICAgIC5zaG93KCk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gUG9pbnRzIGFyZSBhbHJlYWR5IGNsZWFyZWQgYW5kIG1lc3NhZ2Ugc2hvd24gYnkgc2hvd0NvdXBsaW5nUG9pbnRzXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgVHJhaW4uZXhpdENvdXBsaW5nTW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfSk7XG5cbiAgICAgICQoXCIjYnRuVW5jb3VwbGVUcmFpblwiKVxuICAgICAgICAgLm9mZigpXG4gICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0IGdsb2JhbCBzdGF0ZSBmb3IgZGVjb3VwbGluZyBtb2RlXG4gICAgICAgICAgICBpZiAoQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5jdXN0b21Nb3VzZU1vZGUgPT09IENVU1RPTV9NT1VTRV9BQ1RJT04uTk9ORSkge1xuICAgICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBkZWNvdXBsaW5nIHBvaW50cyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgIGlmIChUcmFpbi5zaG93RGVjb3VwbGluZ1BvaW50cyh0cmFpbikpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkZCBhY3RpdmUgY2xhc3MgdG8gYnV0dG9uXG4gICAgICAgICAgICAgICAgICAkKFwiI2J0blVuY291cGxlVHJhaW5cIikuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XG5cbiAgICAgICAgICAgICAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuY3VzdG9tTW91c2VNb2RlID0gQ1VTVE9NX01PVVNFX0FDVElPTi5UUkFJTl9ERUNPVVBMRTtcblxuICAgICAgICAgICAgICAgICAgLy8gU2hvdyBkZWNvdXBsaW5nIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICQoXCIjY291cGxpbmdNZXNzYWdlXCIpXG4gICAgICAgICAgICAgICAgICAgICAudGV4dChcIktsaWNrZSB6d2lzY2hlbiBXYWdlbiB1bSBaw7xnZSB6dSBlbnRrdXBwZWxuIG9kZXIgw7xiZXJhbGwgYW5kZXJzIHVtIGFienVicmVjaGVuXCIpXG4gICAgICAgICAgICAgICAgICAgICAuc2hvdygpO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFBvaW50cyBhcmUgYWxyZWFkeSBjbGVhcmVkIGFuZCBtZXNzYWdlIHNob3duIGJ5IHNob3dEZWNvdXBsaW5nUG9pbnRzXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgVHJhaW4uZXhpdERlY291cGxpbmdNb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9KTtcbiAgICAgICAgIFxuICAgICAgLy8gT25seSBzaG93IG1vdmVtZW50IGNvbnRyb2xzIGZvciBsb2NvbW90aXZlcyAoZmlyc3QgY2FyIG9mIGEgdHJhaW4pXG4gICAgICBjb25zdCBpc0xvY29tb3RpdmUgPSB0cmFpbi50eXBlID09PSBUcmFpbi5DQVJfVFlQRVMuTE9DT01PVElWRTtcbiAgICAgICQoXCIjdHJhaW5Nb3ZlbWVudENvbnRyb2xzXCIpLnRvZ2dsZShpc0xvY29tb3RpdmUpO1xuICAgICAgXG4gICAgICBpZiAoaXNMb2NvbW90aXZlKSB7XG4gICAgICAgICAvLyBJbml0aWFsaXplIG1vdmVtZW50IGRpcmVjdGlvbiBidXR0b25zXG4gICAgICAgICBpZiAoIXRyYWluLm1vdmVtZW50RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB0cmFpbi5tb3ZlbWVudERpcmVjdGlvbiA9IDE7IC8vIERlZmF1bHQgdG8gZm9yd2FyZFxuICAgICAgICAgfVxuICAgICAgICAgXG4gICAgICAgICAvLyBVcGRhdGUgYnV0dG9uIHN0YXRlcyBiYXNlZCBvbiBjdXJyZW50IGRpcmVjdGlvblxuICAgICAgICAgJChcIiNidG5EaXJlY3Rpb25Gb3J3YXJkXCIpLnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIsIHRyYWluLm1vdmVtZW50RGlyZWN0aW9uID4gMCk7XG4gICAgICAgICAkKFwiI2J0bkRpcmVjdGlvbkJhY2t3YXJkXCIpLnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIsIHRyYWluLm1vdmVtZW50RGlyZWN0aW9uIDwgMCk7XG4gICAgICAgICBcbiAgICAgICAgIC8vIFVwZGF0ZSBzdGFydC9zdG9wIGJ1dHRvbiBiYXNlZCBvbiBtb3ZlbWVudCBzdGF0ZVxuICAgICAgICAgY29uc3QgaXNNb3ZpbmcgPSBUcmFpbi5tb3ZpbmdUcmFpbnMuaGFzKHRyYWluKTtcbiAgICAgICAgICQoXCIjYnRuU3RhcnRTdG9wVHJhaW5cIilcbiAgICAgICAgICAgIC50b2dnbGVDbGFzcyhcImJ0bi1zdWNjZXNzXCIsICFpc01vdmluZylcbiAgICAgICAgICAgIC50b2dnbGVDbGFzcyhcImJ0bi1kYW5nZXJcIiwgaXNNb3ZpbmcpXG4gICAgICAgICAgICAuaHRtbChpc01vdmluZyA/ICc8aSBjbGFzcz1cImJpIGJpLXN0b3AtZmlsbFwiPjwvaT4gU3RvcCcgOiAnPGkgY2xhc3M9XCJiaSBiaS1wbGF5LWZpbGxcIj48L2k+IFN0YXJ0Jyk7XG4gICAgICAgICBcbiAgICAgICAgIC8vIFNldCB1cCBkaXJlY3Rpb24gYnV0dG9uIGhhbmRsZXJzXG4gICAgICAgICAkKFwiI2J0bkRpcmVjdGlvbkZvcndhcmRcIilcbiAgICAgICAgICAgIC5vZmYoKVxuICAgICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgIHRyYWluLm1vdmVtZW50RGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgICAgICQoXCIjYnRuRGlyZWN0aW9uRm9yd2FyZFwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICQoXCIjYnRuRGlyZWN0aW9uQmFja3dhcmRcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgJChcIiNidG5EaXJlY3Rpb25CYWNrd2FyZFwiKVxuICAgICAgICAgICAgLm9mZigpXG4gICAgICAgICAgICAuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgdHJhaW4ubW92ZW1lbnREaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgICAgICQoXCIjYnRuRGlyZWN0aW9uQmFja3dhcmRcIikuYWRkQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAkKFwiI2J0bkRpcmVjdGlvbkZvcndhcmRcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgLy8gU2V0IHVwIHN0YXJ0L3N0b3AgYnV0dG9uIGhhbmRsZXJcbiAgICAgICAgICQoXCIjYnRuU3RhcnRTdG9wVHJhaW5cIilcbiAgICAgICAgICAgIC5vZmYoKVxuICAgICAgICAgICAgLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgIGlmIChUcmFpbi5tb3ZpbmdUcmFpbnMuaGFzKHRyYWluKSkge1xuICAgICAgICAgICAgICAgICAgLy8gU3RvcCB0aGUgdHJhaW5cbiAgICAgICAgICAgICAgICAgIFRyYWluLnN0b3BUcmFpbih0cmFpbik7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRyYWluXG4gICAgICAgICAgICAgICAgICBUcmFpbi5zdGFydFRyYWluKHRyYWluKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgfVxuXG4gICBzdGF0aWMgZGVsZXRlVHJhaW4odHJhaW4pIHtcbiAgICAgIC8vIFN0b3AgdGhlIHRyYWluIGlmIGl0J3MgbW92aW5nXG4gICAgICBpZiAoVHJhaW4ubW92aW5nVHJhaW5zLmhhcyh0cmFpbikpIHtcbiAgICAgICAgIFRyYWluLnN0b3BUcmFpbih0cmFpbik7XG4gICAgICB9ICBcblxuICAgICAgLy8gR2V0IHRoZSBsYXN0IGNhciBpbiB0aGUgdHJhaW4gdGhhdCB3aWxsIGJlIGRlbGV0ZWRcbiAgICAgIGxldCBjdXJyZW50Q2FyID0gdHJhaW47XG4gICAgICB3aGlsZSAoY3VycmVudENhci50cmFpbkNvdXBsZWRCYWNrKSB7XG4gICAgICAgICBjdXJyZW50Q2FyID0gY3VycmVudENhci50cmFpbkNvdXBsZWRCYWNrO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgYWxsIGNhcnMgaW4gdGhpcyB0cmFpbiBmcm9tIGFsbFRyYWluc1xuICAgICAgd2hpbGUgKGN1cnJlbnRDYXIpIHtcbiAgICAgICAgIEFycmF5VXRpbHMucmVtb3ZlKHRoaXMuYWxsVHJhaW5zLCBjdXJyZW50Q2FyKTtcbiAgICAgICAgIC8vc2F2ZSB0aGUgbmV4dCBjYXIgYmVmb3JlIHJlbW92aW5nIGFsbCByZWZlcmVuY2VzIHRvIG90aGVyIG9iamVjdHNcbiAgICAgICAgIGNvbnN0IG5leHRDYXIgPSBjdXJyZW50Q2FyLnRyYWluQ291cGxlZEZyb250O1xuICAgICAgICAgY3VycmVudENhci50cmFpbkNvdXBsZWRGcm9udCA9IG51bGw7XG4gICAgICAgICBjdXJyZW50Q2FyLnRyYWluQ291cGxlZEJhY2sgPSBudWxsO1xuICAgICAgICAgY3VycmVudENhci50cmFjayA9IG51bGw7XG4gICAgICAgICBjdXJyZW50Q2FyID0gbmV4dENhcjtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXIucmVuZGVyQWxsVHJhaW5zKCk7XG4gICAgICBzdGFnZS51cGRhdGUoKTtcbiAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgfVxuXG4gICBzdGF0aWMgbW92ZVRyYWluKHRyYWluLCBtb3ZlbWVudFgpIHtcbiAgICAgIC8vIEZpbmQgdGhlIGhlYWQgb2YgdGhlIHRyYWluIChmaXJzdCBjYXIgd2l0aCBubyBmcm9udCBjb3VwbGluZylcbiAgICAgIGxldCBmaXJzdENhciA9IHRyYWluO1xuICAgICAgd2hpbGUgKGZpcnN0Q2FyLnRyYWluQ291cGxlZEZyb250ICE9IG51bGwpIHtcbiAgICAgICAgIGZpcnN0Q2FyID0gZmlyc3RDYXIudHJhaW5Db3VwbGVkRnJvbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgdGhlIGxhc3QgY2FyXG4gICAgICBsZXQgbGFzdENhciA9IGZpcnN0Q2FyO1xuICAgICAgd2hpbGUgKGxhc3RDYXIudHJhaW5Db3VwbGVkQmFjayAhPSBudWxsKSB7XG4gICAgICAgICBsYXN0Q2FyID0gbGFzdENhci50cmFpbkNvdXBsZWRCYWNrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIVRyYWluLm1vdmVtZW50UG9zc2libGUoZmlyc3RDYXIsIG1vdmVtZW50WCkgfHwgIVRyYWluLm1vdmVtZW50UG9zc2libGUobGFzdENhciwgbW92ZW1lbnRYKSkgcmV0dXJuO1xuXG4gICAgICAvLyBNb3ZlIGVhY2ggY2FyIHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0XG4gICAgICBsZXQgY2FyID0gZmlyc3RDYXI7XG4gICAgICBsZXQgbmV3X3BvcztcbiAgICAgIGxldCBjdXJyZW50VHJhY2s7XG5cbiAgICAgIGN1cnJlbnRUcmFjayA9IGNhci50cmFjaztcblxuXG4gICAgICAvLyBDYWxjdWxhdGUgbmV3IHBvc2l0aW9uIHVzaW5nIHRoZSBub2RlJ3MgdW5pdCB2ZWN0b3JcbiAgICAgIG5ld19wb3MgPSBjYXIucG9zICsgbW92ZW1lbnRYIC8gc3RhZ2Uuc2NhbGUgLyBjYXIudHJhY2suY29zO1xuXG4gICAgICB3aGlsZSAoY2FyKSB7XG4gICAgICAgICBpZiAoY2FyICE9IGZpcnN0Q2FyKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gYmFzZWQgb24gcHJldmlvdXMgY2FyIGFuZCBjYXIgbGVuZ3RoXG4gICAgICAgICAgICAvLyBUYWtlIGludG8gYWNjb3VudCB0aGUgc3BhY2luZyBiZXR3ZWVuIGNhcnMgKDUgdW5pdHMpXG4gICAgICAgICAgICBjb25zdCBwcmV2Q2FyID0gY2FyLnRyYWluQ291cGxlZEZyb250O1xuICAgICAgICAgICAgY29uc3Qgc3BhY2luZyA9IDU7IC8vIEdhcCBiZXR3ZWVuIGNhcnNcbiAgICAgICAgICAgIG5ld19wb3MgPSBwcmV2Q2FyLnBvcyArIHByZXZDYXIubGVuZ3RoIC8gMiArIHNwYWNpbmcgKyBjYXIubGVuZ3RoIC8gMjtcbiAgICAgICAgIH1cblxuICAgICAgICAgbGV0IG5ld1RyYWNrO1xuICAgICAgICAgaWYgKE51bWJlclV0aWxzLm91dG9mZihuZXdfcG9zLCAwLCBjdXJyZW50VHJhY2subGVuZ3RoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3cgPSBuZXdfcG9zIDw9IDAgPyBjdXJyZW50VHJhY2suc3dpdGNoQXRUaGVTdGFydCA6IGN1cnJlbnRUcmFjay5zd2l0Y2hBdFRoZUVuZDtcblxuICAgICAgICAgICAgaWYgKHN3KSB7XG4gICAgICAgICAgICAgICBpZiAodHlwZShzdykgPT0gXCJUcmFja1wiKSBuZXdUcmFjayA9IHN3O1xuICAgICAgICAgICAgICAgZWxzZSBpZiAoc3cuZnJvbSA9PSBjdXJyZW50VHJhY2spIG5ld1RyYWNrID0gc3cuYnJhbmNoO1xuICAgICAgICAgICAgICAgZWxzZSBpZiAoc3cuYnJhbmNoID09IGN1cnJlbnRUcmFjaykgbmV3VHJhY2sgPSBzdy5mcm9tO1xuXG4gICAgICAgICAgICAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgICAgICAgICAgICAgIGNhci50cmFjayA9IG5ld1RyYWNrO1xuICAgICAgICAgICAgICAgICAgY2FyLnBvcyA9IG5ld19wb3MgPD0gMCA/IG5ld1RyYWNrLmxlbmd0aCArIG5ld19wb3MgOiBuZXdfcG9zIC0gY3VycmVudFRyYWNrLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjayA9IG5ld1RyYWNrO1xuICAgICAgICAgICAgICAgICAgbmV3X3BvcyA9IGNhci5wb3M7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FyLnRyYWNrID0gY3VycmVudFRyYWNrO1xuICAgICAgICAgICAgY2FyLnBvcyA9IG5ld19wb3M7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGNhciA9IGNhci50cmFpbkNvdXBsZWRCYWNrO1xuICAgICAgfVxuICAgfVxuXG4gICBzdGF0aWMgbW92ZW1lbnRQb3NzaWJsZSh0cmFpbiwgbW92ZW1lbnRYKSB7XG4gICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0cmFpbi50cmFjaztcblxuICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBwb3NpdGlvbiB1c2luZyB0aGUgbm9kZSdzIHVuaXQgdmVjdG9yXG4gICAgICBsZXQgbmV3X3BvcyA9IHRyYWluLnBvcyArIG1vdmVtZW50WCAvIHN0YWdlLnNjYWxlIC8gdHJhaW4udHJhY2suY29zO1xuXG4gICAgICBpZiAoTnVtYmVyVXRpbHMub3V0b2ZmKG5ld19wb3MsIDAgKyB0cmFpbi5sZW5ndGggLyAyLCBjdXJyZW50VHJhY2subGVuZ3RoIC0gdHJhaW4ubGVuZ3RoIC8gMikpIHtcbiAgICAgICAgIGNvbnN0IHN3ID0gbmV3X3BvcyA8PSAwICsgdHJhaW4ubGVuZ3RoIC8gMiA/IGN1cnJlbnRUcmFjay5zd2l0Y2hBdFRoZVN0YXJ0IDogY3VycmVudFRyYWNrLnN3aXRjaEF0VGhlRW5kO1xuXG4gICAgICAgICByZXR1cm4gc3cgIT0gbnVsbCAmJiAodHlwZShzdykgPT0gXCJUcmFja1wiIHx8IHN3LmZyb20gPT0gY3VycmVudFRyYWNrIHx8IHN3LmJyYW5jaCA9PSBjdXJyZW50VHJhY2spO1xuICAgICAgfSBlbHNlIHJldHVybiB0cnVlO1xuICAgfVxuXG4gICBzdGF0aWMgRnJvbU9iamVjdChvKSB7XG4gICAgICBjb25zdCB0cmFpbiA9IG5ldyBUcmFpbigpO1xuICAgICAgdHJhaW4uX2lkID0gby5faWQ7XG4gICAgICBUcmFpbi5uZXh0SWQgPSBNYXRoLm1heChUcmFpbi5uZXh0SWQsIG8uX2lkICsgMSk7XG4gICAgICB0cmFpbi5fY29sb3IgPSBvLmNvbG9yO1xuICAgICAgdHJhaW4uX2Nvb3JkaW5hdGVzID0gUG9pbnQuZnJvbVBvaW50KG8uY29vcmRpbmF0ZXMpO1xuICAgICAgdHJhaW4uX3R5cGUgPSBvLnR5cGUgfHwgVHJhaW4uQ0FSX1RZUEVTLkxPQ09NT1RJVkU7XG4gICAgICB0cmFpbi5fbnVtYmVyID0gby5udW1iZXIgfHwgXCJcIjtcbiAgICAgIHRyYWluLnRyYWluQ291cGxlZEJhY2tJZCA9IG8udHJhaW5Db3VwbGVkQmFja0lkO1xuICAgICAgdHJhaW4udHJhaW5Db3VwbGVkRnJvbnRJZCA9IG8udHJhaW5Db3VwbGVkRnJvbnRJZDtcbiAgICAgIHJldHVybiB0cmFpbjtcbiAgIH1cblxuICAgX2lkID0gVHJhaW4uZ2V0TmV4dElkKCk7XG4gICBfdHJhY2sgPSBudWxsO1xuICAgX3BvcyA9IG51bGw7XG4gICBfY29vcmRpbmF0ZXMgPSBudWxsO1xuICAgX2NvbG9yID0gXCIjMDAwMDAwXCI7XG4gICBfbnVtYmVyID0gXCJcIjtcbiAgIF90eXBlID0gVHJhaW4uQ0FSX1RZUEVTLkxPQ09NT1RJVkU7XG4gICB0cmFpbkNvdXBsZWRCYWNrID0gbnVsbDtcbiAgIHRyYWluQ291cGxlZEZyb250ID0gbnVsbDtcblxuICAgZ2V0IHRyYWNrKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrO1xuICAgfVxuXG4gICBzZXQgdHJhY2sodCkge1xuICAgICAgdGhpcy5fdHJhY2sgPSB0O1xuICAgfVxuXG4gICBnZXQgcG9zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BvcztcbiAgIH1cblxuICAgc2V0IHBvcyhrbSkge1xuICAgICAgdGhpcy5fcG9zID0ga207XG4gICAgICBpZiAodGhpcy5fdHJhY2spIHRoaXMuX2Nvb3JkaW5hdGVzID0gdGhpcy5fdHJhY2suZ2V0UG9pbnRGcm9tS20oa20pO1xuICAgfVxuXG4gICBnZXQgY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICB9XG5cbiAgIHNldCBjb2xvcihjKSB7XG4gICAgICB0aGlzLl9jb2xvciA9IGM7XG4gICB9XG5cbiAgIGdldCBudW1iZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbnVtYmVyO1xuICAgfVxuXG4gICBzZXQgbnVtYmVyKG4pIHtcbiAgICAgIHRoaXMuX251bWJlciA9IG47XG4gICB9XG5cbiAgIGdldCB0eXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICB9XG5cbiAgIHNldCB0eXBlKHQpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB0O1xuICAgfVxuXG4gICBnZXQgbGVuZ3RoKCkge1xuICAgICAgc3dpdGNoICh0aGlzLl90eXBlKSB7XG4gICAgICAgICBjYXNlIFRyYWluLkNBUl9UWVBFUy5MT0NPTU9USVZFOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWluLkxPQ09fTEVOR1RIO1xuICAgICAgICAgY2FzZSBUcmFpbi5DQVJfVFlQRVMuUEFTU0VOR0VSOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWluLlBBU1NFTkdFUl9MRU5HVEg7XG4gICAgICAgICBjYXNlIFRyYWluLkNBUl9UWVBFUy5NVUxUSVBMRV9VTklUX0NBUjpcbiAgICAgICAgICAgIHJldHVybiBUcmFpbi5NVUxUSVBMRV9VTklUX0NBUl9MRU5HVEg7XG4gICAgICAgICBjYXNlIFRyYWluLkNBUl9UWVBFUy5NVUxUSVBMRV9VTklUX0hFQURfRlJPTlQ6XG4gICAgICAgICAgICByZXR1cm4gVHJhaW4uTVVMVElQTEVfVU5JVF9IRUFEX0ZST05UX0xFTkdUSDtcbiAgICAgICAgIGNhc2UgVHJhaW4uQ0FSX1RZUEVTLk1VTFRJUExFX1VOSVRfSEVBRF9CQUNLOlxuICAgICAgICAgICAgcmV0dXJuIFRyYWluLk1VTFRJUExFX1VOSVRfSEVBRF9CQUNLX0xFTkdUSDtcbiAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gVHJhaW4uUEFTU0VOR0VSX0xFTkdUSDsgLy8gRGVmYXVsdCB0byBwYXNzZW5nZXIgbGVuZ3RoIGlmIHR5cGUgaXMgdW5rbm93blxuICAgICAgfVxuICAgfVxuXG4gICBjb3VwbGVCYWNrKHRyYWluKSB7XG4gICAgICBpZiAodHJhaW4gPT09IHRoaXMpIHJldHVybjsgLy8gQ2FuJ3QgY291cGxlIHRvIHNlbGZcblxuICAgICAgLy8gRmlyc3QgdW5jb3VwbGUgdGhlIHRyYWluIGZyb20gYW55IHByZXZpb3VzIGNvbm5lY3Rpb25zXG4gICAgICBpZiAodHJhaW4udHJhaW5Db3VwbGVkRnJvbnQpIHtcbiAgICAgICAgIHRyYWluLnRyYWluQ291cGxlZEZyb250LnRyYWluQ291cGxlZEJhY2sgPSBudWxsO1xuICAgICAgICAgdHJhaW4udHJhaW5Db3VwbGVkRnJvbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYWluQ291cGxlZEJhY2sgPSB0cmFpbjtcbiAgICAgIHRyYWluLnRyYWluQ291cGxlZEZyb250ID0gdGhpcztcbiAgIH1cblxuICAgdW5jb3VwbGUoKSB7XG4gICAgICBpZiAodGhpcy50cmFpbkNvdXBsZWRCYWNrKSB7XG4gICAgICAgICB0aGlzLnRyYWluQ291cGxlZEJhY2sudHJhaW5Db3VwbGVkRnJvbnQgPSBudWxsO1xuICAgICAgICAgdGhpcy50cmFpbkNvdXBsZWRCYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgIH1cblxuICAgLy8gRmluZCB0aGUgbG9jb21vdGl2ZSAoaGVhZCkgb2YgdGhpcyB0cmFpblxuICAgZ2V0TG9jb21vdGl2ZSgpIHtcbiAgICAgIGxldCBsb2NvID0gdGhpcztcbiAgICAgIHdoaWxlIChsb2NvLnRyYWluQ291cGxlZEZyb250KSB7XG4gICAgICAgICBsb2NvID0gbG9jby50cmFpbkNvdXBsZWRGcm9udDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2NvO1xuICAgfVxuXG4gICAvLyBDb3VudCBhbGwgY2FycyBpbiB0aGlzIHRyYWluXG4gICBnZXRDYXJDb3VudCgpIHtcbiAgICAgIGxldCBjb3VudCA9IDE7XG4gICAgICBsZXQgY2FyID0gdGhpcy50cmFpbkNvdXBsZWRCYWNrO1xuICAgICAgd2hpbGUgKGNhcikge1xuICAgICAgICAgY291bnQrKztcbiAgICAgICAgIGNhciA9IGNhci50cmFpbkNvdXBsZWRCYWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgfVxuXG4gICByZXN0b3JlKCkge1xuICAgICAgY29uc3QgdCA9IFRyYWNrLmZpbmRUcmFja0J5UG9pbnQodGhpcy5fY29vcmRpbmF0ZXMpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgIHRoaXMudHJhY2sgPSB0O1xuICAgICAgICAgdGhpcy5wb3MgPSB0LmdldEttZnJvbVBvaW50KHRoaXMuX2Nvb3JkaW5hdGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHJhaW5Db3VwbGVkRnJvbnRJZCkge1xuICAgICAgICAgY29uc3QgZnJvbnRDYXIgPSBUcmFpbi5hbGxUcmFpbnMuZmluZCgodCkgPT4gdC5faWQgPT09IHRoaXMudHJhaW5Db3VwbGVkRnJvbnRJZCk7XG4gICAgICAgICBpZiAoZnJvbnRDYXIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaW5Db3VwbGVkRnJvbnQgPSBmcm9udENhcjtcbiAgICAgICAgIH1cblxuICAgICAgICAgXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRyYWluQ291cGxlZEJhY2tJZCkge1xuICAgICAgICAgY29uc3QgYmFja0NhciA9IFRyYWluLmFsbFRyYWlucy5maW5kKCh0KSA9PiB0Ll9pZCA9PT0gdGhpcy50cmFpbkNvdXBsZWRCYWNrSWQpO1xuICAgICAgICAgaWYgKGJhY2tDYXIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaW5Db3VwbGVkQmFjayA9IGJhY2tDYXI7XG4gICAgICAgICB9XG5cbiAgICAgICAgIFxuICAgICAgfVxuICAgfVxuXG4gICBzdHJpbmdpZnkoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgX2NsYXNzOiBcIlRyYWluXCIsXG4gICAgICAgICBfaWQ6IHRoaXMuX2lkLFxuICAgICAgICAgY29vcmRpbmF0ZXM6IHRoaXMuX2Nvb3JkaW5hdGVzLFxuICAgICAgICAgY29sb3I6IHRoaXMuX2NvbG9yLFxuICAgICAgICAgbnVtYmVyOiB0aGlzLl9udW1iZXIsXG4gICAgICAgICB0eXBlOiB0aGlzLl90eXBlLFxuICAgICAgICAgdHJhaW5Db3VwbGVkQmFja0lkOiB0aGlzLnRyYWluQ291cGxlZEJhY2sgPyB0aGlzLnRyYWluQ291cGxlZEJhY2suX2lkIDogbnVsbCxcbiAgICAgICAgIHRyYWluQ291cGxlZEZyb250SWQ6IHRoaXMudHJhaW5Db3VwbGVkRnJvbnQgPyB0aGlzLnRyYWluQ291cGxlZEZyb250Ll9pZCA6IG51bGwsXG4gICAgICB9O1xuICAgfVxuXG4gICBzdGF0aWMgc2hvd0RlY291cGxpbmdQb2ludHModHJhaW4pIHtcbiAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBvdmVybGF5XG4gICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLmNvbnRhaW5lcnMub3ZlcmxheS5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBjYXIgaW4gdGhlIHRyYWluXG4gICAgICBsZXQgZmlyc3RDYXIgPSB0cmFpbjtcbiAgICAgIHdoaWxlIChmaXJzdENhci50cmFpbkNvdXBsZWRGcm9udCkge1xuICAgICAgICAgZmlyc3RDYXIgPSBmaXJzdENhci50cmFpbkNvdXBsZWRGcm9udDtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgZmlyc3QgY2FyXG4gICAgICBsZXQgY3VycmVudENhciA9IGZpcnN0Q2FyO1xuICAgICAgbGV0IGRlY291cGxpbmdQb2ludHNGb3VuZCA9IDA7XG5cbiAgICAgIC8vIEFkZCBkZWNvdXBsaW5nIHBvaW50cyBiZXR3ZWVuIGVhY2ggY2FyXG4gICAgICB3aGlsZSAoY3VycmVudENhciAmJiBjdXJyZW50Q2FyLnRyYWluQ291cGxlZEJhY2spIHtcbiAgICAgICAgIGNvbnN0IG5leHRDYXIgPSBjdXJyZW50Q2FyLnRyYWluQ291cGxlZEJhY2s7XG5cbiAgICAgICAgIC8vIEdldCBwb3NpdGlvbnMgb2YgdGhlIHR3byBjYXJzXG4gICAgICAgICBjb25zdCBjdXJyZW50UG9zID0gY3VycmVudENhci50cmFjay5nZXRQb2ludEZyb21LbShjdXJyZW50Q2FyLnBvcyk7XG4gICAgICAgICBjb25zdCBuZXh0UG9zID0gbmV4dENhci50cmFjay5nZXRQb2ludEZyb21LbShuZXh0Q2FyLnBvcyk7XG5cbiAgICAgICAgIC8vIENhbGN1bGF0ZSBtaWRwb2ludCBiZXR3ZWVuIGNhcnMgZm9yIGRlY291cGxpbmcgcG9pbnRcbiAgICAgICAgIGNvbnN0IG1pZFggPSAoY3VycmVudFBvcy54ICsgbmV4dFBvcy54KSAvIDI7XG4gICAgICAgICBjb25zdCBtaWRZID0gKGN1cnJlbnRQb3MueSArIG5leHRQb3MueSkgLyAyO1xuXG4gICAgICAgICAvLyBDcmVhdGUgYSBkZWNvdXBsaW5nIHBvaW50IChjaXJjbGUpXG4gICAgICAgICBjb25zdCBkZWNvdXBsaW5nUG9pbnQgPSBuZXcgY3JlYXRlanMuU2hhcGUoKTtcbiAgICAgICAgIGRlY291cGxpbmdQb2ludC5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwgMCwgNik7XG4gICAgICAgICBkZWNvdXBsaW5nUG9pbnQueCA9IG1pZFg7XG4gICAgICAgICBkZWNvdXBsaW5nUG9pbnQueSA9IG1pZFk7XG4gICAgICAgICAvLyBTdG9yZSB0aGUgY2FycyB0byBkZWNvdXBsZSBpbiB0aGUgc2hhcGUncyBkYXRhXG4gICAgICAgICBkZWNvdXBsaW5nUG9pbnQuZGF0YSA9IHtcbiAgICAgICAgICAgIGNhclRvRGVDb3VwbGVGcm9tOiBjdXJyZW50Q2FyLFxuICAgICAgICAgICAgY2FyVG9EZUNvdXBsZTogbmV4dENhcixcbiAgICAgICAgIH07XG4gICAgICAgICBkZWNvdXBsaW5nUG9pbnQubmFtZSA9IFwiZGVjb3VwbGluZ1BvaW50XCI7XG5cbiAgICAgICAgIC8vIEFkZCB0byBvdmVybGF5IGNvbnRhaW5lclxuICAgICAgICAgb3ZlcmxheS5hZGRDaGlsZChkZWNvdXBsaW5nUG9pbnQpO1xuICAgICAgICAgZGVjb3VwbGluZ1BvaW50c0ZvdW5kKys7XG5cbiAgICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgY2FyXG4gICAgICAgICBjdXJyZW50Q2FyID0gbmV4dENhcjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gZGVjb3VwbGluZyBwb2ludHMgZm91bmQsIHNob3cgYSBtZXNzYWdlXG4gICAgICBpZiAoZGVjb3VwbGluZ1BvaW50c0ZvdW5kID09PSAwKSB7XG4gICAgICAgICAvLyBTaG93IGEgbWVzc2FnZVxuICAgICAgICAgdWkuc2hvd0luZm9Ub2FzdChcIktlaW5lIFdhZ2VuIGluIGRlciBOw6RoZSB6dW0gZW50a3VwcGVsbiBnZWZ1bmRlbiwgZGllc2VyIFp1ZyBoYXQgbnVyIGVpbmVuIFdhZ2VuXCIpO1xuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICB9XG5cbiAgIHN0YXRpYyBoYW5kbGVEZWNvdXBsaW5nQ2xpY2soZGF0YSkge1xuICAgICAgaWYgKCFkYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB0cmFpbiBwcm92aWRlZFwiKTtcbiAgICAgIC8vIERlY291cGxlIGF0IHRoaXMgcG9pbnRcbiAgICAgIGRhdGEuY2FyVG9EZUNvdXBsZUZyb20udW5jb3VwbGUoKTtcblxuICAgICAgLy8gRXhpdCBkZWNvdXBsaW5nIG1vZGVcbiAgICAgIFRyYWluLmV4aXREZWNvdXBsaW5nTW9kZSgpO1xuXG4gICAgICAvLyBVcGRhdGUgZGlzcGxheVxuICAgICAgcmVuZGVyZXIucmVuZGVyQWxsVHJhaW5zKCk7XG4gICAgICBzdGFnZS51cGRhdGUoKTtcbiAgICAgIFNUT1JBR0Uuc2F2ZSgpO1xuICAgfVxuXG4gICBzdGF0aWMgZXhpdERlY291cGxpbmdNb2RlKCkge1xuICAgICAgLy8gUmVtb3ZlIGRlY291cGxpbmcgcG9pbnRzXG4gICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLmNvbnRhaW5lcnMub3ZlcmxheS5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICAvLyBSZXNldCBjdXN0b20gYWN0aW9uIG1vZGVcbiAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuY3VzdG9tTW91c2VNb2RlID0gQ1VTVE9NX01PVVNFX0FDVElPTi5OT05FO1xuXG4gICAgICAvLyBIaWRlIG1lc3NhZ2Ugd2l0aCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBpdCdzIGZ1bGx5IHNob3duIGZpcnN0XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICQoXCIjY291cGxpbmdNZXNzYWdlXCIpLmhpZGUoKTtcbiAgICAgIH0sIDUwKTtcblxuICAgICAgLy8gRGVhY3RpdmF0ZSBhbnkgYWN0aXZlIGJ1dHRvbnNcbiAgICAgICQoXCIjYnRuVW5jb3VwbGVUcmFpblwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcblxuICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5zdGFnZS51cGRhdGUoKTtcbiAgIH1cblxuICAgc3RhdGljIHNob3dDb3VwbGluZ1BvaW50cyh0cmFpbikge1xuICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIG92ZXJsYXlcbiAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuY29udGFpbmVycy5vdmVybGF5LnJlbW92ZUFsbENoaWxkcmVuKCk7XG5cbiAgICAgIC8vIEdldCB0aGUgaGVhZCBhbmQgdGFpbCBvZiB0aGUgdHJhaW5cbiAgICAgIGxldCBmaXJzdENhciA9IHRyYWluO1xuICAgICAgd2hpbGUgKGZpcnN0Q2FyLnRyYWluQ291cGxlZEZyb250KSB7XG4gICAgICAgICBmaXJzdENhciA9IGZpcnN0Q2FyLnRyYWluQ291cGxlZEZyb250O1xuICAgICAgfVxuXG4gICAgICBsZXQgbGFzdENhciA9IHRyYWluO1xuICAgICAgd2hpbGUgKGxhc3RDYXIudHJhaW5Db3VwbGVkQmFjaykge1xuICAgICAgICAgbGFzdENhciA9IGxhc3RDYXIudHJhaW5Db3VwbGVkQmFjaztcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHBvc2l0aW9ucyBvZiB0aGUgdHJhaW4gZW5kc1xuICAgICAgY29uc3QgZmlyc3RDYXJQb3MgPSBmaXJzdENhci5wb3M7XG4gICAgICBjb25zdCBsYXN0Q2FyUG9zID0gbGFzdENhci5wb3M7XG4gICAgICBsZXQgZGlzdGFuY2UgPSAwO1xuICAgICAgbGV0IGNvdXBsaW5nUG9pbnRzRm91bmQgPSAwO1xuXG4gICAgICAvLyBDaGVjayBhbGwgb3RoZXIgdHJhaW5zIGZvciBwb3NzaWJsZSBjb3VwbGluZyBwb2ludHNcbiAgICAgIFRyYWluLmFsbFRyYWlucy5mb3JFYWNoKChvdGhlckNhcikgPT4ge1xuICAgICAgICAgLy8gU2tpcCBjYXJzIGluIHRoZSBzYW1lIHRyYWluXG4gICAgICAgICBpZiAoXG4gICAgICAgICAgICBvdGhlckNhciA9PT0gZmlyc3RDYXIgfHxcbiAgICAgICAgICAgIG90aGVyQ2FyID09PSBsYXN0Q2FyIHx8XG4gICAgICAgICAgICAob3RoZXJDYXIudHJhaW5Db3VwbGVkRnJvbnQgIT0gbnVsbCAmJiBvdGhlckNhci50cmFpbkNvdXBsZWRCYWNrICE9IG51bGwpIHx8XG4gICAgICAgICAgICBvdGhlckNhci50cmFjayAhPSB0cmFpbi50cmFja1xuICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIEdldCBwb3NpdGlvbnMgb2YgdGhlIG90aGVyIHRyYWluIGVuZHNcbiAgICAgICAgIGNvbnN0IG90aGVyQ2FyUG9zID0gb3RoZXJDYXIucG9zO1xuXG4gICAgICAgICAvLyBDaGVjayBkaXN0YW5jZSBiZXR3ZWVuIHRyYWluIGVuZHMgKGZyb250IHRvIGZyb250KVxuICAgICAgICAgY29uc3QgbWF4Q291cGxpbmdEaXN0YW5jZSA9IDgwOyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZvciBjb3VwbGluZ1xuXG4gICAgICAgICAvLyBDaGVjayBmcm9udCBvZiBvdXIgdHJhaW4gdG8gYmFjayBvZiBvdGhlciB0cmFpblxuICAgICAgICAgaWYgKG90aGVyQ2FyLnRyYWluQ291cGxlZEJhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBmaXJzdENhclBvcyAtIG90aGVyQ2FyUG9zO1xuICAgICAgICAgICAgaWYgKE51bWJlclV0aWxzLmJldHdlZW4oZGlzdGFuY2UsIDAsIG1heENvdXBsaW5nRGlzdGFuY2UpKSB7XG4gICAgICAgICAgICAgICBhZGRDb3VwbGluZ1BvaW50KG90aGVyQ2FyLCBmaXJzdENhcik7XG4gICAgICAgICAgICAgICBjb3VwbGluZ1BvaW50c0ZvdW5kKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIC8vIENoZWNrIGJhY2sgb2Ygb3VyIHRyYWluIHRvIGZyb250IG9mIG90aGVyIHRyYWluXG4gICAgICAgICBpZiAob3RoZXJDYXIudHJhaW5Db3VwbGVkRnJvbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBvdGhlckNhclBvcyAtIGxhc3RDYXJQb3M7XG4gICAgICAgICAgICBpZiAoTnVtYmVyVXRpbHMuYmV0d2VlbihkaXN0YW5jZSwgMCwgbWF4Q291cGxpbmdEaXN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgIGFkZENvdXBsaW5nUG9pbnQobGFzdENhciwgb3RoZXJDYXIpO1xuICAgICAgICAgICAgICAgY291cGxpbmdQb2ludHNGb3VuZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIG5vIGNvdXBsaW5nIHBvaW50cyBmb3VuZCwgc2hvdyBhIG1lc3NhZ2VcbiAgICAgIGlmIChjb3VwbGluZ1BvaW50c0ZvdW5kID09PSAwKSB7XG4gICAgICAgICAvLyBTaG93IGEgbWVzc2FnZVxuICAgICAgICAgdWkuc2hvd0luZm9Ub2FzdChcIktlaW5lIFdhZ2VuIGluIGRlciBOw6RoZSB6dW0ga3VwcGVsbiBnZWZ1bmRlblwiKTtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnN0YWdlLnVwZGF0ZSgpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgYSBjb3VwbGluZyBwb2ludFxuICAgICAgZnVuY3Rpb24gYWRkQ291cGxpbmdQb2ludChjYXIxLCBjYXIyKSB7XG4gICAgICAgICAvLyBDYWxjdWxhdGUgbWlkcG9pbnQgYmV0d2VlbiBjYXJzIGZvciBjb3VwbGluZyBwb2ludFxuICAgICAgICAgY29uc3QgY2FyMVBvcyA9IGNhcjEudHJhY2suZ2V0UG9pbnRGcm9tS20oY2FyMS5wb3MpO1xuICAgICAgICAgY29uc3QgY2FyMlBvcyA9IGNhcjIudHJhY2suZ2V0UG9pbnRGcm9tS20oY2FyMi5wb3MpO1xuICAgICAgICAgY29uc3QgbWlkWCA9IChjYXIxUG9zLnggKyBjYXIyUG9zLngpIC8gMjtcbiAgICAgICAgIGNvbnN0IG1pZFkgPSAoY2FyMVBvcy55ICsgY2FyMlBvcy55KSAvIDI7XG5cbiAgICAgICAgIC8vIENyZWF0ZSBhIGNvdXBsaW5nIHBvaW50IChjaXJjbGUpXG4gICAgICAgICBjb25zdCBjb3VwbGluZ1BvaW50ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG4gICAgICAgICBjb3VwbGluZ1BvaW50LmdyYXBoaWNzLmJlZ2luRmlsbChcIiMwMGZmMDBcIikuZHJhd0NpcmNsZSgwLCAwLCA2KTtcbiAgICAgICAgIGNvdXBsaW5nUG9pbnQueCA9IG1pZFg7XG4gICAgICAgICBjb3VwbGluZ1BvaW50LnkgPSBtaWRZO1xuXG4gICAgICAgICAvLyBTdG9yZSB0aGUgY2FycyB0byBjb3VwbGUgaW4gdGhlIHNoYXBlJ3MgZGF0YVxuICAgICAgICAgY291cGxpbmdQb2ludC5kYXRhID0ge1xuICAgICAgICAgICAgY2FyMTogY2FyMSxcbiAgICAgICAgICAgIGNhcjI6IGNhcjIsXG4gICAgICAgICB9O1xuICAgICAgICAgY291cGxpbmdQb2ludC5uYW1lID0gXCJjb3VwbGluZ1BvaW50XCI7XG5cbiAgICAgICAgIC8vIEFkZCB0byBvdmVybGF5IGNvbnRhaW5lclxuICAgICAgICAgQXBwbGljYXRpb24uZ2V0SW5zdGFuY2UoKS5jb250YWluZXJzLm92ZXJsYXkuYWRkQ2hpbGQoY291cGxpbmdQb2ludCk7XG4gICAgICB9XG4gICB9XG5cbiAgIHN0YXRpYyBoYW5kbGVDb3VwbGluZ0NsaWNrKGRhdGEpIHtcbiAgICAgIGlmICghZGF0YSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gdHJhaW4gZGF0YSBwcm92aWRlZFwiKTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNhcnMgdG8gY291cGxlXG4gICAgICBkYXRhLmNhcjEuY291cGxlQmFjayhkYXRhLmNhcjIpO1xuXG4gICAgICAvLyBFeGl0IGNvdXBsaW5nIG1vZGVcbiAgICAgIFRyYWluLmV4aXRDb3VwbGluZ01vZGUoKTtcblxuICAgICAgLy8gVXBkYXRlIGRpc3BsYXlcbiAgICAgIHJlbmRlcmVyLnJlbmRlckFsbFRyYWlucygpO1xuICAgICAgc3RhZ2UudXBkYXRlKCk7XG4gICAgICBTVE9SQUdFLnNhdmUoKTtcbiAgIH1cblxuICAgc3RhdGljIGV4aXRDb3VwbGluZ01vZGUoKSB7XG4gICAgICAvLyBSZW1vdmUgY291cGxpbmcgcG9pbnRzXG4gICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLmNvbnRhaW5lcnMub3ZlcmxheS5yZW1vdmVBbGxDaGlsZHJlbigpO1xuXG4gICAgICAvLyBSZXNldCBjdXN0b20gYWN0aW9uIG1vZGVcbiAgICAgIEFwcGxpY2F0aW9uLmdldEluc3RhbmNlKCkuY3VzdG9tTW91c2VNb2RlID0gQ1VTVE9NX01PVVNFX0FDVElPTi5OT05FO1xuXG4gICAgICAkKFwiI2NvdXBsaW5nTWVzc2FnZVwiKS5oaWRlKCk7XG5cbiAgICAgIC8vIERlYWN0aXZhdGUgYW55IGFjdGl2ZSBidXR0b25zXG4gICAgICAkKFwiI2J0bkNvdXBsZVRyYWluXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xuXG4gICAgICBBcHBsaWNhdGlvbi5nZXRJbnN0YW5jZSgpLnN0YWdlLnVwZGF0ZSgpO1xuICAgfVxuXG4gICAvLyBBZGQgbmV3IG1ldGhvZHMgZm9yIGF1dG9tYXRpYyB0cmFpbiBtb3ZlbWVudFxuXG4gICBzdGF0aWMgc3RhcnRUcmFpbih0cmFpbikge1xuICAgICAgLy8gQWRkIHRyYWluIHRvIHRoZSBzZXQgb2YgbW92aW5nIHRyYWluc1xuICAgICAgVHJhaW4ubW92aW5nVHJhaW5zLmFkZCh0cmFpbik7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBidXR0b24gc3RhdGVcbiAgICAgICQoXCIjYnRuU3RhcnRTdG9wVHJhaW5cIilcbiAgICAgICAgIC5yZW1vdmVDbGFzcyhcImJ0bi1zdWNjZXNzXCIpXG4gICAgICAgICAuYWRkQ2xhc3MoXCJidG4tZGFuZ2VyXCIpXG4gICAgICAgICAuaHRtbCgnPGkgY2xhc3M9XCJiaSBiaS1zdG9wLWZpbGxcIj48L2k+IFN0b3AnKTtcbiAgICAgIFxuICAgICAgLy8gU3RhcnQgbW92ZW1lbnQgdGltZXIgaWYgbm90IGFscmVhZHkgcnVubmluZ1xuICAgICAgaWYgKCFUcmFpbi5tb3ZlbWVudFRpbWVyKSB7XG4gICAgICAgICBUcmFpbi5tb3ZlbWVudFRpbWVyID0gc2V0SW50ZXJ2YWwoVHJhaW4udXBkYXRlTW92aW5nVHJhaW5zLCBUcmFpbi5NT1ZFTUVOVF9JTlRFUlZBTCk7XG4gICAgICB9XG4gICB9XG4gICBcbiAgIHN0YXRpYyBzdG9wVHJhaW4odHJhaW4pIHtcbiAgICAgIC8vIFJlbW92ZSB0cmFpbiBmcm9tIHRoZSBzZXQgb2YgbW92aW5nIHRyYWluc1xuICAgICAgVHJhaW4ubW92aW5nVHJhaW5zLmRlbGV0ZSh0cmFpbik7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBidXR0b24gc3RhdGVcbiAgICAgICQoXCIjYnRuU3RhcnRTdG9wVHJhaW5cIilcbiAgICAgICAgIC5yZW1vdmVDbGFzcyhcImJ0bi1kYW5nZXJcIilcbiAgICAgICAgIC5hZGRDbGFzcyhcImJ0bi1zdWNjZXNzXCIpXG4gICAgICAgICAuaHRtbCgnPGkgY2xhc3M9XCJiaSBiaS1wbGF5LWZpbGxcIj48L2k+IFN0YXJ0Jyk7XG4gICAgICBcbiAgICAgIC8vIElmIG5vIHRyYWlucyBhcmUgbW92aW5nLCBzdG9wIHRoZSB0aW1lclxuICAgICAgaWYgKFRyYWluLm1vdmluZ1RyYWlucy5zaXplID09PSAwICYmIFRyYWluLm1vdmVtZW50VGltZXIpIHtcbiAgICAgICAgIGNsZWFySW50ZXJ2YWwoVHJhaW4ubW92ZW1lbnRUaW1lcik7XG4gICAgICAgICBUcmFpbi5tb3ZlbWVudFRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgIH1cbiAgIFxuICAgc3RhdGljIHN0b3BBbGxUcmFpbnMoKSB7XG4gICAgICAvLyBTdG9wIGFsbCBtb3ZpbmcgdHJhaW5zXG4gICAgICBmb3IgKGNvbnN0IHRyYWluIG9mIFRyYWluLm1vdmluZ1RyYWlucykge1xuICAgICAgICAgVHJhaW4uc3RvcFRyYWluKHRyYWluKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgdGhlIHNldCBvZiBtb3ZpbmcgdHJhaW5zXG4gICAgICBUcmFpbi5tb3ZpbmdUcmFpbnMuY2xlYXIoKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcCB0aGUgdGltZXJcbiAgICAgIGlmIChUcmFpbi5tb3ZlbWVudFRpbWVyKSB7XG4gICAgICAgICBjbGVhckludGVydmFsKFRyYWluLm1vdmVtZW50VGltZXIpO1xuICAgICAgICAgVHJhaW4ubW92ZW1lbnRUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICB9XG4gICBcbiAgIHN0YXRpYyB1cGRhdGVNb3ZpbmdUcmFpbnMoKSB7XG4gICAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gTW92ZSBlYWNoIHRyYWluIGluIHRoZSBzZXQgb2YgbW92aW5nIHRyYWluc1xuICAgICAgZm9yIChjb25zdCB0cmFpbiBvZiBUcmFpbi5tb3ZpbmdUcmFpbnMpIHtcbiAgICAgICAgIC8vIENhbGN1bGF0ZSBtb3ZlbWVudCBhbW91bnQgYmFzZWQgb24gZGlyZWN0aW9uIGFuZCBzcGVlZFxuICAgICAgICAgY29uc3QgbW92ZW1lbnRBbW91bnQgPSB0cmFpbi5tb3ZlbWVudERpcmVjdGlvbiAqIFRyYWluLk1PVkVNRU5UX1NQRUVEO1xuICAgICAgICAgXG4gICAgICAgICAvLyBDaGVjayBpZiBtb3ZlbWVudCBpcyBwb3NzaWJsZVxuICAgICAgICAgY29uc3QgZmlyc3RDYXIgPSB0cmFpbi5nZXRMb2NvbW90aXZlKCk7XG4gICAgICAgICBjb25zdCBsYXN0Q2FyID0gVHJhaW4uZ2V0TGFzdENhcihmaXJzdENhcik7XG4gICAgICAgICBcbiAgICAgICAgIGlmIChUcmFpbi5tb3ZlbWVudFBvc3NpYmxlKGZpcnN0Q2FyLCBtb3ZlbWVudEFtb3VudCkgJiYgXG4gICAgICAgICAgICAgVHJhaW4ubW92ZW1lbnRQb3NzaWJsZShsYXN0Q2FyLCBtb3ZlbWVudEFtb3VudCkpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgdGhlIHRyYWluXG4gICAgICAgICAgICBUcmFpbi5tb3ZlVHJhaW4oZmlyc3RDYXIsIG1vdmVtZW50QW1vdW50KTtcbiAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdG9wIHRoZSB0cmFpbiBpZiBtb3ZlbWVudCBpcyBub3QgcG9zc2libGVcbiAgICAgICAgICAgIFRyYWluLnN0b3BUcmFpbih0cmFpbik7XG4gICAgICAgICAgICB1aS5zaG93SW5mb1RvYXN0KFwiWnVnIGthbm4gbmljaHQgd2VpdGVyIGZhaHJlblwiKTtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSBkaXNwbGF5IGlmIGFueSB0cmFpbnMgbW92ZWRcbiAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICAgcmVuZGVyZXIucmVuZGVyQWxsVHJhaW5zKCk7XG4gICAgICAgICBzdGFnZS51cGRhdGUoKTtcbiAgICAgIH1cbiAgIH1cbiAgIFxuICAgc3RhdGljIGdldExhc3RDYXIodHJhaW4pIHtcbiAgICAgIGxldCBsYXN0Q2FyID0gdHJhaW47XG4gICAgICB3aGlsZSAobGFzdENhci50cmFpbkNvdXBsZWRCYWNrKSB7XG4gICAgICAgICBsYXN0Q2FyID0gbGFzdENhci50cmFpbkNvdXBsZWRCYWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RDYXI7XG4gICB9XG59XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./www/code/train.js\n\n}");

/***/ }),

/***/ "./www/code/ui.js":
/*!************************!*\
  !*** ./www/code/ui.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ui: () => (/* binding */ ui)\n/* harmony export */ });\n/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools.js */ \"./www/code/tools.js\");\n\n\n\n\nconst ui = {\n    create_toggleButton: function (text) {\n       return $(\"<button>\", {\n          type: \"button\",\n          id: \"btn_\" + text.replace(\" \", \"_\"),\n          class: \"btn btn-primary btn-sm\",\n       }).html(text);\n    },\n    \n    create_buttonGroup: function (items) {\n       return $(\"<div>\", { class: \"btn-group\", role: \"group\" }).append(items);\n    },\n\n    create_buttonToolbar: function (items) {\n        return ui.div(\"btn-toolbar\", items).attr(\"role\", \"toolbar\");\n     },\n    \n    div: function (c, i) {\n       return $(\"<div>\", { class: c }).append(i);\n    },\n \n    showModalDialog: function (content, ok_function) {\n       // Create modal div\n       let modal_div = $(\"<div/>\", {\n          id: \"myModal\",\n          class: \"modal fade\",\n          role: \"dialog\",\n       }).append(\n          ui.div(\"modal-dialog  modal-xl modal-dialog-centered\").append(\n             ui.div(\"modal-content\").append([\n                ui.div(\"modal-header\").append([\n                   $(\"<h4/>\", {\n                      class: \"modal-title\",\n                      text: \"Als Bild speichern\",\n                   }),\n                   $(\"<button/>\", {\n                      type: \"button\",\n                      class: \"btn-close\",\n                      \"data-bs-dismiss\": \"modal\",\n                   }),\n                ]),\n                ui.div(\"modal-body\").append(content),\n                ui.div(\"modal-footer\").append(\n                   $(\"<button/>\", {\n                      type: \"button\",\n                      class: \"btn btn-default\",\n                      \"data-dismiss\": \"modal\",\n                      text: \"Herunterladen\",\n                      click: ok_function,\n                   })\n                ),\n             ])\n          )\n       );\n       modal_div.appendTo(\"body\");\n \n       let modal = new bootstrap.Modal(modal_div[0]);\n       modal.show();\n       return modal;\n    },// Function to create a toast element\n    createToast: function (title, txt) {   \n       return ui\n          .div(\"toast\")\n          .attr({ role: \"alert\", \"aria-live\": \"assertive\", \"aria-atomic\": \"true\" })\n          .append([\n             $(\"<div>\")\n                .addClass(\"toast-header\")\n                .append([\n                   $(\"<strong>\").addClass(\"me-auto\").text(title),\n                   $(\"<button>\").attr({ type: \"button\", \"data-bs-dismiss\": \"toast\", \"aria-label\": \"Close\" }).addClass(\"btn-close\"),\n                ]),\n             $(\"<div>\")\n                .addClass(\"toast-body\")\n                .append([$(\"<p>\", { text: txt })]),\n          ]);\n    },\n    \n    getToastContainer: function () {\n       let container = $(\"#toast-container\");\n       if (container.length === 0) {\n          container = ui.div(\"toast-container\").attr(\"id\", \"toast-container\").css({ position: \"fixed\", bottom: \"0\", right: \"0\" });\n          $(\"body\").append(container);\n       }\n       return container;\n    },\n    \n    // Function to show the toast\n    showErrorToast: function (error) {\n       console.error(error);\n       const toast = ui.createToast(\"Ups, Da gabs einen Fehler\", error.message);\n       ui.getToastContainer().prepend(ui.div(\"p-3\").append(toast));\n       $(toast).toast({ autohide: true, delay: 10000 }).toast(\"show\");\n       $(toast).on(\"hidden.bs.toast\", function () {\n          $(this).parent().remove();\n       });\n    },\n    \n    showInfoToast: function (txt) {\n       console.info(txt);\n       const toast = ui.createToast(\"Information:\", txt);\n       ui.getToastContainer().prepend(ui.div(\"p-3\").append(toast));\n       $(toast).toast({ autohide: true, delay: 10000 }).toast(\"show\");\n       $(toast).on(\"hidden.bs.toast\", function () {\n          $(this).parent().remove();\n       });\n    },\n    create_DropDownItem(text, value) {\n        return $(\"<a>\", {\n           class: \"dropdown-item\",\n           text: text,\n           href: \"#\",\n           value: value ?? text,\n        });\n     },\n  \n     createAccordionItem(title, parent, items, open = false) {\n        let id = (0,_tools_js__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();\n        return ui.div(\"accordion-item\", [\n           $(\"<h2>\", { class: \"accordion-header\" }).append(\n              $(\"<button>\", { class: \"accordion-button  user-select-none\", type: \"button\" })\n                 .attr(\"data-bs-toggle\", \"collapse\")\n                 .attr(\"data-bs-target\", \"#\" + id)\n                 .text(title)\n                 .toggleClass(\"collapsed\", !open)\n           ),\n           ui\n              .div(\"accordion-collapse collapse\", ui.div(\"accordion-body\", items))\n              .attr(\"id\", id)\n              .attr(\"data-bs-parent\", parent)\n              .toggleClass(\"show\", open),\n        ]);\n     },\n  \n     create_DropDown(items, text, onChange) {\n        return ui\n           .div(\"dropdown d-grid\", [\n              $(\"<button>\", {\n                 class: \"btn btn-primary dropdown-toggle btn-sm\",\n                 type: \"button\",\n                 text: text,\n                 id: \"btn_\" + text.replace(\" \", \"_\"),\n              }).attr(\"data-bs-toggle\", \"dropdown\"),\n              ui.div(\n                 \"dropdown-menu\",\n                 items.map((item) => ui.create_DropDownItem(...item.split(\"|\")))\n              ),\n           ])\n           .on(\"hide.bs.dropdown\", (e) => {\n              if (e.clickEvent?.target && e.clickEvent?.target.nodeName == \"A\") {\n                 const value = $(e.clickEvent.target).attr(\"value\");\n                 $(e.currentTarget).attr(\"value\", value);\n                 if (onChange) onChange(value);\n              }\n           })\n           .on(\"show.bs.dropdown\", (e) => {\n              const targetValue = $(e.currentTarget).attr(\"value\");\n              if (!targetValue) return;\n              $(\".dropdown-item\", e.currentTarget)\n                 .removeClass(\"active\")\n                 .each(function () {\n                    if ($(this).attr(\"value\") === targetValue) {\n                       $(this).addClass(\"active\");\n                    }\n                 });\n           });\n     },\n  \n     createSwitchStructure(mainLabel, subLabels, onchange) {\n        let [text, value, enabled] = mainLabel;\n        if (!enabled && subLabels.length == 0) return null;\n        let $mainDiv;\n        $mainDiv = ui.div(\"\", [\n           enabled == null || enabled\n              ? ui.div(\"form-check form-switch\", [\n                   $(\"<input/>\", {\n                      class: \"form-check-input\",\n                      type: \"checkbox\",\n                      role: \"switch\",\n                      id: \"switch_\" + text,\n                   })\n                      .on(\"change\", function () {\n                         const isChecked = $(this).is(\":checked\");\n                         /* $(\"input\", $mainDiv.children()[1]).prop(\"disabled\", !isChecked); */\n                         if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                      })\n                      .attr(\"value\", value ?? text)\n                      .attr(\"data-master_switch\", \"\"),\n  \n                   $(\"<label/>\", {\n                      class: \"form-check-label\",\n                      for: \"switch_\" + text,\n                      text: text,\n                   }),\n                ])\n              : $(\"<label/>\", {\n                   text: text,\n                }),\n  \n           ui.div(\n              \"ps-3\",\n              subLabels\n                 .filter((x) => x[2] == null || x[2] == true)\n                 .map(function (label) {\n                    [text, value, enabled] = label;\n                    return ui.div(\"form-check form-switch\", [\n                       $(\"<input/>\", {\n                          class: \"form-check-input\",\n                          type: \"checkbox\",\n                          role: \"switch\",\n                          id: \"switch_\" + text,\n                          checked: true, // Default to checked as per your example\n                       })\n                          .on(\"change\", function () {\n                             const isChecked = $(this).is(\":checked\");\n                             if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                          })\n                          .attr(\"value\", value ?? text),\n                       $(\"<label/>\", {\n                          class: \"form-check-label\",\n                          for: \"switch_\" + text,\n                          text: text,\n                       }),\n                    ]);\n                 })\n           ),\n        ]);\n        return $mainDiv;\n     },\n     createOptionGroup(header, options, inputType = \"radio\", onchange) {\n        return ui.div(\"\", [\n           $(\"<label>\").text(header),\n           ui.div(\n              \"ps-3\",\n              options.map(function (option) {\n                 let [text, value, enabled] = option;\n                 let id = \"input_\" + text;\n                 // Create the div for each form-check-inline\n                 return ui.div(\"form-check form-check-inline\", [\n                    $(\"<input>\")\n                       .addClass(\"form-check-input\")\n                       .attr(\"id\", id)\n                       .attr(\"name\", \"OptionGroup_\" + header)\n                       .attr(\"type\", inputType)\n                       .attr(\"value\", value ?? text)\n                       .attr(\"disabled\", enabled != null && !enabled)\n                       .on(\"change\", function () {\n                          const isChecked = $(this).is(\":checked\");\n                          if (onchange) onchange($(this).attr(\"value\"), isChecked);\n                       }),\n                    $(\"<label>\").addClass(\"form-check-label\").attr(\"for\", id).text(text),\n                 ]);\n              })\n           ),\n        ]);\n     },\n };\n\n // Backward compatibility: Still expose utilities on window during transition\n// TODO: Remove this once all files are converted to modules\nif (typeof window !== 'undefined') {\n    window.ui = ui;\n }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS91aS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhOztBQUV1Qjs7QUFFN0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQWdFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUVBQW1FO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXO0FBQy9DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDRDQUE0QztBQUNoSTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpQkFBaUIsaURBQU07QUFDdkI7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xELDhCQUE4Qiw2REFBNkQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2xlaXNwbGFuZWRpdG9yLy4vd3d3L2NvZGUvdWkuanM/OTE3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgdXVpZHY0IH0gZnJvbSAnLi90b29scy5qcyc7XG5cbmV4cG9ydCBjb25zdCB1aSA9IHtcbiAgICBjcmVhdGVfdG9nZ2xlQnV0dG9uOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgIHJldHVybiAkKFwiPGJ1dHRvbj5cIiwge1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgaWQ6IFwiYnRuX1wiICsgdGV4dC5yZXBsYWNlKFwiIFwiLCBcIl9cIiksXG4gICAgICAgICAgY2xhc3M6IFwiYnRuIGJ0bi1wcmltYXJ5IGJ0bi1zbVwiLFxuICAgICAgIH0pLmh0bWwodGV4dCk7XG4gICAgfSxcbiAgICBcbiAgICBjcmVhdGVfYnV0dG9uR3JvdXA6IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgIHJldHVybiAkKFwiPGRpdj5cIiwgeyBjbGFzczogXCJidG4tZ3JvdXBcIiwgcm9sZTogXCJncm91cFwiIH0pLmFwcGVuZChpdGVtcyk7XG4gICAgfSxcblxuICAgIGNyZWF0ZV9idXR0b25Ub29sYmFyOiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIHVpLmRpdihcImJ0bi10b29sYmFyXCIsIGl0ZW1zKS5hdHRyKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgIH0sXG4gICAgXG4gICAgZGl2OiBmdW5jdGlvbiAoYywgaSkge1xuICAgICAgIHJldHVybiAkKFwiPGRpdj5cIiwgeyBjbGFzczogYyB9KS5hcHBlbmQoaSk7XG4gICAgfSxcbiBcbiAgICBzaG93TW9kYWxEaWFsb2c6IGZ1bmN0aW9uIChjb250ZW50LCBva19mdW5jdGlvbikge1xuICAgICAgIC8vIENyZWF0ZSBtb2RhbCBkaXZcbiAgICAgICBsZXQgbW9kYWxfZGl2ID0gJChcIjxkaXYvPlwiLCB7XG4gICAgICAgICAgaWQ6IFwibXlNb2RhbFwiLFxuICAgICAgICAgIGNsYXNzOiBcIm1vZGFsIGZhZGVcIixcbiAgICAgICAgICByb2xlOiBcImRpYWxvZ1wiLFxuICAgICAgIH0pLmFwcGVuZChcbiAgICAgICAgICB1aS5kaXYoXCJtb2RhbC1kaWFsb2cgIG1vZGFsLXhsIG1vZGFsLWRpYWxvZy1jZW50ZXJlZFwiKS5hcHBlbmQoXG4gICAgICAgICAgICAgdWkuZGl2KFwibW9kYWwtY29udGVudFwiKS5hcHBlbmQoW1xuICAgICAgICAgICAgICAgIHVpLmRpdihcIm1vZGFsLWhlYWRlclwiKS5hcHBlbmQoW1xuICAgICAgICAgICAgICAgICAgICQoXCI8aDQvPlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwibW9kYWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIkFscyBCaWxkIHNwZWljaGVyblwiLFxuICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICQoXCI8YnV0dG9uLz5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiYnRuLWNsb3NlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJkYXRhLWJzLWRpc21pc3NcIjogXCJtb2RhbFwiLFxuICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIHVpLmRpdihcIm1vZGFsLWJvZHlcIikuYXBwZW5kKGNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIHVpLmRpdihcIm1vZGFsLWZvb3RlclwiKS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgJChcIjxidXR0b24vPlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJidG4gYnRuLWRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImRhdGEtZGlzbWlzc1wiOiBcIm1vZGFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCJIZXJ1bnRlcmxhZGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IG9rX2Z1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICBdKVxuICAgICAgICAgIClcbiAgICAgICApO1xuICAgICAgIG1vZGFsX2Rpdi5hcHBlbmRUbyhcImJvZHlcIik7XG4gXG4gICAgICAgbGV0IG1vZGFsID0gbmV3IGJvb3RzdHJhcC5Nb2RhbChtb2RhbF9kaXZbMF0pO1xuICAgICAgIG1vZGFsLnNob3coKTtcbiAgICAgICByZXR1cm4gbW9kYWw7XG4gICAgfSwvLyBGdW5jdGlvbiB0byBjcmVhdGUgYSB0b2FzdCBlbGVtZW50XG4gICAgY3JlYXRlVG9hc3Q6IGZ1bmN0aW9uICh0aXRsZSwgdHh0KSB7ICAgXG4gICAgICAgcmV0dXJuIHVpXG4gICAgICAgICAgLmRpdihcInRvYXN0XCIpXG4gICAgICAgICAgLmF0dHIoeyByb2xlOiBcImFsZXJ0XCIsIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIgfSlcbiAgICAgICAgICAuYXBwZW5kKFtcbiAgICAgICAgICAgICAkKFwiPGRpdj5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJ0b2FzdC1oZWFkZXJcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFtcbiAgICAgICAgICAgICAgICAgICAkKFwiPHN0cm9uZz5cIikuYWRkQ2xhc3MoXCJtZS1hdXRvXCIpLnRleHQodGl0bGUpLFxuICAgICAgICAgICAgICAgICAgICQoXCI8YnV0dG9uPlwiKS5hdHRyKHsgdHlwZTogXCJidXR0b25cIiwgXCJkYXRhLWJzLWRpc21pc3NcIjogXCJ0b2FzdFwiLCBcImFyaWEtbGFiZWxcIjogXCJDbG9zZVwiIH0pLmFkZENsYXNzKFwiYnRuLWNsb3NlXCIpLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICQoXCI8ZGl2PlwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInRvYXN0LWJvZHlcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFskKFwiPHA+XCIsIHsgdGV4dDogdHh0IH0pXSksXG4gICAgICAgICAgXSk7XG4gICAgfSxcbiAgICBcbiAgICBnZXRUb2FzdENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgIGxldCBjb250YWluZXIgPSAkKFwiI3RvYXN0LWNvbnRhaW5lclwiKTtcbiAgICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRhaW5lciA9IHVpLmRpdihcInRvYXN0LWNvbnRhaW5lclwiKS5hdHRyKFwiaWRcIiwgXCJ0b2FzdC1jb250YWluZXJcIikuY3NzKHsgcG9zaXRpb246IFwiZml4ZWRcIiwgYm90dG9tOiBcIjBcIiwgcmlnaHQ6IFwiMFwiIH0pO1xuICAgICAgICAgICQoXCJib2R5XCIpLmFwcGVuZChjb250YWluZXIpO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG4gICAgXG4gICAgLy8gRnVuY3Rpb24gdG8gc2hvdyB0aGUgdG9hc3RcbiAgICBzaG93RXJyb3JUb2FzdDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgY29uc3QgdG9hc3QgPSB1aS5jcmVhdGVUb2FzdChcIlVwcywgRGEgZ2FicyBlaW5lbiBGZWhsZXJcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgdWkuZ2V0VG9hc3RDb250YWluZXIoKS5wcmVwZW5kKHVpLmRpdihcInAtM1wiKS5hcHBlbmQodG9hc3QpKTtcbiAgICAgICAkKHRvYXN0KS50b2FzdCh7IGF1dG9oaWRlOiB0cnVlLCBkZWxheTogMTAwMDAgfSkudG9hc3QoXCJzaG93XCIpO1xuICAgICAgICQodG9hc3QpLm9uKFwiaGlkZGVuLmJzLnRvYXN0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLnJlbW92ZSgpO1xuICAgICAgIH0pO1xuICAgIH0sXG4gICAgXG4gICAgc2hvd0luZm9Ub2FzdDogZnVuY3Rpb24gKHR4dCkge1xuICAgICAgIGNvbnNvbGUuaW5mbyh0eHQpO1xuICAgICAgIGNvbnN0IHRvYXN0ID0gdWkuY3JlYXRlVG9hc3QoXCJJbmZvcm1hdGlvbjpcIiwgdHh0KTtcbiAgICAgICB1aS5nZXRUb2FzdENvbnRhaW5lcigpLnByZXBlbmQodWkuZGl2KFwicC0zXCIpLmFwcGVuZCh0b2FzdCkpO1xuICAgICAgICQodG9hc3QpLnRvYXN0KHsgYXV0b2hpZGU6IHRydWUsIGRlbGF5OiAxMDAwMCB9KS50b2FzdChcInNob3dcIik7XG4gICAgICAgJCh0b2FzdCkub24oXCJoaWRkZW4uYnMudG9hc3RcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQodGhpcykucGFyZW50KCkucmVtb3ZlKCk7XG4gICAgICAgfSk7XG4gICAgfSxcbiAgICBjcmVhdGVfRHJvcERvd25JdGVtKHRleHQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAkKFwiPGE+XCIsIHtcbiAgICAgICAgICAgY2xhc3M6IFwiZHJvcGRvd24taXRlbVwiLFxuICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICBocmVmOiBcIiNcIixcbiAgICAgICAgICAgdmFsdWU6IHZhbHVlID8/IHRleHQsXG4gICAgICAgIH0pO1xuICAgICB9LFxuICBcbiAgICAgY3JlYXRlQWNjb3JkaW9uSXRlbSh0aXRsZSwgcGFyZW50LCBpdGVtcywgb3BlbiA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpZCA9IHV1aWR2NCgpO1xuICAgICAgICByZXR1cm4gdWkuZGl2KFwiYWNjb3JkaW9uLWl0ZW1cIiwgW1xuICAgICAgICAgICAkKFwiPGgyPlwiLCB7IGNsYXNzOiBcImFjY29yZGlvbi1oZWFkZXJcIiB9KS5hcHBlbmQoXG4gICAgICAgICAgICAgICQoXCI8YnV0dG9uPlwiLCB7IGNsYXNzOiBcImFjY29yZGlvbi1idXR0b24gIHVzZXItc2VsZWN0LW5vbmVcIiwgdHlwZTogXCJidXR0b25cIiB9KVxuICAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtYnMtdG9nZ2xlXCIsIFwiY29sbGFwc2VcIilcbiAgICAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLWJzLXRhcmdldFwiLCBcIiNcIiArIGlkKVxuICAgICAgICAgICAgICAgICAudGV4dCh0aXRsZSlcbiAgICAgICAgICAgICAgICAgLnRvZ2dsZUNsYXNzKFwiY29sbGFwc2VkXCIsICFvcGVuKVxuICAgICAgICAgICApLFxuICAgICAgICAgICB1aVxuICAgICAgICAgICAgICAuZGl2KFwiYWNjb3JkaW9uLWNvbGxhcHNlIGNvbGxhcHNlXCIsIHVpLmRpdihcImFjY29yZGlvbi1ib2R5XCIsIGl0ZW1zKSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBpZClcbiAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLWJzLXBhcmVudFwiLCBwYXJlbnQpXG4gICAgICAgICAgICAgIC50b2dnbGVDbGFzcyhcInNob3dcIiwgb3BlbiksXG4gICAgICAgIF0pO1xuICAgICB9LFxuICBcbiAgICAgY3JlYXRlX0Ryb3BEb3duKGl0ZW1zLCB0ZXh0LCBvbkNoYW5nZSkge1xuICAgICAgICByZXR1cm4gdWlcbiAgICAgICAgICAgLmRpdihcImRyb3Bkb3duIGQtZ3JpZFwiLCBbXG4gICAgICAgICAgICAgICQoXCI8YnV0dG9uPlwiLCB7XG4gICAgICAgICAgICAgICAgIGNsYXNzOiBcImJ0biBidG4tcHJpbWFyeSBkcm9wZG93bi10b2dnbGUgYnRuLXNtXCIsXG4gICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgIGlkOiBcImJ0bl9cIiArIHRleHQucmVwbGFjZShcIiBcIiwgXCJfXCIpLFxuICAgICAgICAgICAgICB9KS5hdHRyKFwiZGF0YS1icy10b2dnbGVcIiwgXCJkcm9wZG93blwiKSxcbiAgICAgICAgICAgICAgdWkuZGl2KFxuICAgICAgICAgICAgICAgICBcImRyb3Bkb3duLW1lbnVcIixcbiAgICAgICAgICAgICAgICAgaXRlbXMubWFwKChpdGVtKSA9PiB1aS5jcmVhdGVfRHJvcERvd25JdGVtKC4uLml0ZW0uc3BsaXQoXCJ8XCIpKSlcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgXSlcbiAgICAgICAgICAgLm9uKFwiaGlkZS5icy5kcm9wZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZS5jbGlja0V2ZW50Py50YXJnZXQgJiYgZS5jbGlja0V2ZW50Py50YXJnZXQubm9kZU5hbWUgPT0gXCJBXCIpIHtcbiAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAkKGUuY2xpY2tFdmVudC50YXJnZXQpLmF0dHIoXCJ2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmF0dHIoXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgIGlmIChvbkNoYW5nZSkgb25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pXG4gICAgICAgICAgIC5vbihcInNob3cuYnMuZHJvcGRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSAkKGUuY3VycmVudFRhcmdldCkuYXR0cihcInZhbHVlXCIpO1xuICAgICAgICAgICAgICBpZiAoIXRhcmdldFZhbHVlKSByZXR1cm47XG4gICAgICAgICAgICAgICQoXCIuZHJvcGRvd24taXRlbVwiLCBlLmN1cnJlbnRUYXJnZXQpXG4gICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKVxuICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmF0dHIoXCJ2YWx1ZVwiKSA9PT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgfSk7XG4gICAgIH0sXG4gIFxuICAgICBjcmVhdGVTd2l0Y2hTdHJ1Y3R1cmUobWFpbkxhYmVsLCBzdWJMYWJlbHMsIG9uY2hhbmdlKSB7XG4gICAgICAgIGxldCBbdGV4dCwgdmFsdWUsIGVuYWJsZWRdID0gbWFpbkxhYmVsO1xuICAgICAgICBpZiAoIWVuYWJsZWQgJiYgc3ViTGFiZWxzLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0ICRtYWluRGl2O1xuICAgICAgICAkbWFpbkRpdiA9IHVpLmRpdihcIlwiLCBbXG4gICAgICAgICAgIGVuYWJsZWQgPT0gbnVsbCB8fCBlbmFibGVkXG4gICAgICAgICAgICAgID8gdWkuZGl2KFwiZm9ybS1jaGVjayBmb3JtLXN3aXRjaFwiLCBbXG4gICAgICAgICAgICAgICAgICAgJChcIjxpbnB1dC8+XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJmb3JtLWNoZWNrLWlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwic3dpdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IFwic3dpdGNoX1wiICsgdGV4dCxcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDaGVja2VkID0gJCh0aGlzKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8qICQoXCJpbnB1dFwiLCAkbWFpbkRpdi5jaGlsZHJlbigpWzFdKS5wcm9wKFwiZGlzYWJsZWRcIiwgIWlzQ2hlY2tlZCk7ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uY2hhbmdlKSBvbmNoYW5nZSgkKHRoaXMpLmF0dHIoXCJ2YWx1ZVwiKSwgaXNDaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidmFsdWVcIiwgdmFsdWUgPz8gdGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtbWFzdGVyX3N3aXRjaFwiLCBcIlwiKSxcbiAgXG4gICAgICAgICAgICAgICAgICAgJChcIjxsYWJlbC8+XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJmb3JtLWNoZWNrLWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZm9yOiBcInN3aXRjaF9cIiArIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICA6ICQoXCI8bGFiZWwvPlwiLCB7XG4gICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgXG4gICAgICAgICAgIHVpLmRpdihcbiAgICAgICAgICAgICAgXCJwcy0zXCIsXG4gICAgICAgICAgICAgIHN1YkxhYmVsc1xuICAgICAgICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiB4WzJdID09IG51bGwgfHwgeFsyXSA9PSB0cnVlKVxuICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBbdGV4dCwgdmFsdWUsIGVuYWJsZWRdID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1aS5kaXYoXCJmb3JtLWNoZWNrIGZvcm0tc3dpdGNoXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgJChcIjxpbnB1dC8+XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiZm9ybS1jaGVjay1pbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwic3dpdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInN3aXRjaF9cIiArIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRydWUsIC8vIERlZmF1bHQgdG8gY2hlY2tlZCBhcyBwZXIgeW91ciBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2hlY2tlZCA9ICQodGhpcykuaXMoXCI6Y2hlY2tlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uY2hhbmdlKSBvbmNoYW5nZSgkKHRoaXMpLmF0dHIoXCJ2YWx1ZVwiKSwgaXNDaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCB2YWx1ZSA/PyB0ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgJChcIjxsYWJlbC8+XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiZm9ybS1jaGVjay1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3I6IFwic3dpdGNoX1wiICsgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICApLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuICRtYWluRGl2O1xuICAgICB9LFxuICAgICBjcmVhdGVPcHRpb25Hcm91cChoZWFkZXIsIG9wdGlvbnMsIGlucHV0VHlwZSA9IFwicmFkaW9cIiwgb25jaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHVpLmRpdihcIlwiLCBbXG4gICAgICAgICAgICQoXCI8bGFiZWw+XCIpLnRleHQoaGVhZGVyKSxcbiAgICAgICAgICAgdWkuZGl2KFxuICAgICAgICAgICAgICBcInBzLTNcIixcbiAgICAgICAgICAgICAgb3B0aW9ucy5tYXAoZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICBsZXQgW3RleHQsIHZhbHVlLCBlbmFibGVkXSA9IG9wdGlvbjtcbiAgICAgICAgICAgICAgICAgbGV0IGlkID0gXCJpbnB1dF9cIiArIHRleHQ7XG4gICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZGl2IGZvciBlYWNoIGZvcm0tY2hlY2staW5saW5lXG4gICAgICAgICAgICAgICAgIHJldHVybiB1aS5kaXYoXCJmb3JtLWNoZWNrIGZvcm0tY2hlY2staW5saW5lXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgJChcIjxpbnB1dD5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZm9ybS1jaGVjay1pbnB1dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIGlkKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIm5hbWVcIiwgXCJPcHRpb25Hcm91cF9cIiArIGhlYWRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0eXBlXCIsIGlucHV0VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCB2YWx1ZSA/PyB0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImRpc2FibGVkXCIsIGVuYWJsZWQgIT0gbnVsbCAmJiAhZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDaGVja2VkID0gJCh0aGlzKS5pcyhcIjpjaGVja2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25jaGFuZ2UpIG9uY2hhbmdlKCQodGhpcykuYXR0cihcInZhbHVlXCIpLCBpc0NoZWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgJChcIjxsYWJlbD5cIikuYWRkQ2xhc3MoXCJmb3JtLWNoZWNrLWxhYmVsXCIpLmF0dHIoXCJmb3JcIiwgaWQpLnRleHQodGV4dCksXG4gICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICApLFxuICAgICAgICBdKTtcbiAgICAgfSxcbiB9O1xuXG4gLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogU3RpbGwgZXhwb3NlIHV0aWxpdGllcyBvbiB3aW5kb3cgZHVyaW5nIHRyYW5zaXRpb25cbi8vIFRPRE86IFJlbW92ZSB0aGlzIG9uY2UgYWxsIGZpbGVzIGFyZSBjb252ZXJ0ZWQgdG8gbW9kdWxlc1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LnVpID0gdWk7XG4gfSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/ui.js\n\n}");

/***/ }),

/***/ "./www/code/utils.js":
/*!***************************!*\
  !*** ./www/code/utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayUtils: () => (/* binding */ ArrayUtils),\n/* harmony export */   NumberUtils: () => (/* binding */ NumberUtils)\n/* harmony export */ });\n\n\n// Number utilities\nconst NumberUtils = {\n   /**\n    * Check if a value is between two other values (inclusive)\n    * @param {number} value - The value to check\n    * @param {number} a - First boundary\n    * @param {number} b - Second boundary  \n    * @returns {boolean} True if value is between a and b\n    */\n   between(value, a, b) {\n      const min = Math.min(a, b);\n      const max = Math.max(a, b);\n      return value >= min && value <= max;\n   },\n\n   /**\n    * Check if a value is outside the range of two other values\n    * @param {number} value - The value to check\n    * @param {number} a - First boundary\n    * @param {number} b - Second boundary\n    * @returns {boolean} True if value is outside the range\n    */\n   outoff(value, a, b) {\n      return !this.between(value, a, b);\n   },\n\n   /**\n    * Check if a value equals any of the provided arguments\n    * @param {number} value - The value to check\n    * @param {...number} args - Values to compare against\n    * @returns {boolean} True if value matches any argument\n    */\n   is(value, ...args) {\n      return args.includes(value);\n   },\n\n   /**\n    * Round a number to specified decimal places\n    * @param {number} value - The number to round\n    * @param {number} places - Number of decimal places\n    * @returns {number} Rounded number\n    */\n   round(value, places) {\n      return Number(Math.round(value + \"e\" + places) + \"e-\" + places);\n   },\n\n   /**\n    * Check if a value is close to a multiple of another value within tolerance\n    * @param {number} value - The value to check\n    * @param {number} multiple - The multiple to check against\n    * @param {number} tolerance - Allowed tolerance\n    * @returns {boolean} True if value is close to a multiple\n    */\n   closeToBy(value, multiple, tolerance) {\n      const mod = value % multiple;\n      return Math.min(mod, multiple - mod) < tolerance;\n   },\n\n   /**\n    * Constrain a value between min and max\n    * @param {number} min - Minimum value\n    * @param {number} value - Value to constrain\n    * @param {number} max - Maximum value\n    * @returns {number} Constrained value\n    */\n   minmax(min, value, max) {\n      return Math.max(min, Math.min(max, value));\n   },\n\n   /**\n    * Generate random integer between 0 and max (inclusive)\n    * @param {number} max - Maximum value\n    * @returns {number} Random integer\n    */\n   randomInt(max) {\n      return Math.floor(Math.random() * (max + 1));\n   }\n};\n\n// Array utilities\nconst ArrayUtils = {\n   /**\n    * Remove an item from an array\n    * @param {Array} array - The array to modify\n    * @param {*} item - The item to remove\n    * @returns {boolean} True if item was found and removed\n    */\n   remove(array, item) {\n      const index = array.indexOf(item);\n      if (index !== -1) {\n         array.splice(index, 1);\n         return true;\n      }\n      return false;\n   },\n\n\n\n   /**\n    * Get the last element of an array\n    * @param {Array} array - The array\n    * @returns {*} Last element or undefined if empty\n    */\n   last(array) {\n      return array[array.length - 1];\n   },\n\n   /**\n    * Get the first element of an array\n    * @param {Array} array - The array\n    * @returns {*} First element or undefined if empty\n    */\n   first(array) {\n      return array[0];\n   },\n\n   /**\n    * Remove all null and undefined values from array\n    * @param {Array} array - The array to clean\n    * @returns {Array} Array with null/undefined values removed\n    */\n   cleanUp(array) {\n      return array.filter(item => item != null);\n   },\n\n   /**\n    * Get a random element from the array\n    * @param {Array} array - The array\n    * @returns {*} Random element or undefined if empty\n    */\n   random(array) {\n      return array[Math.floor(Math.random() * array.length)];\n   },\n\n   /**\n    * Count elements that appear more than once\n    * @param {Array} array - The array to analyze\n    * @returns {number} Count of non-unique elements\n    */\n   countNonUnique(array) {\n      const counts = {};\n      let nonUniqueCount = 0;\n      \n      for (const item of array) {\n         if (counts[item] === 1) {\n            nonUniqueCount++; // Only increment on second occurrence\n         }\n         counts[item] = (counts[item] || 0) + 1;\n      }\n      return nonUniqueCount;\n   },\n\n   /**\n    * Add element to array only if it doesn't already exist\n    * @param {Array} array - The array to modify\n    * @param {*} element - The element to add\n    * @returns {boolean} True if element was added, false if it already existed\n    */\n   pushUnique(array, element) {\n      if (array.indexOf(element) === -1) {\n         array.push(element);\n         return true;\n      }\n      return false;\n   },\n\n   /**\n    * Group array items by a property path\n    * @param {Array} array - The array to group\n    * @param {string} propertyPath - Dot-separated property path\n    * @returns {Array} Array of grouped arrays, sorted by group size descending\n    */\n   groupBy(array, propertyPath) {\n      const groups = array.reduce((storage, item) => {\n         const property = propertyPath.split('.').reduce((acc, key) => acc[key], item);\n         const group = property;\n         \n         storage[group] = storage[group] || [];\n         storage[group].push(item);\n         return storage;\n      }, {});\n\n      return Object.keys(groups)\n         .map(key => groups[key])\n         .sort((a, b) => b.length - a.length);\n   },\n\n   /**\n    * Return a copy of the array without the specified item\n    * @param {Array} array - The source array\n    * @param {*} item - The item to exclude\n    * @returns {Array} New array without the item\n    */\n   without(array, item) {\n      return array.filter(element => element !== item);\n   }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3cvY29kZS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhOztBQUViO0FBQ087QUFDUDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFdBQVc7QUFDekIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsR0FBRztBQUNqQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7OztBQUlKO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsR0FBRztBQUNqQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLEdBQUc7QUFDakIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dsZWlzcGxhbmVkaXRvci8uL3d3dy9jb2RlL3V0aWxzLmpzP2E0MjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE51bWJlciB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBOdW1iZXJVdGlscyA9IHtcbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBiZXR3ZWVuIHR3byBvdGhlciB2YWx1ZXMgKGluY2x1c2l2ZSlcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGEgLSBGaXJzdCBib3VuZGFyeVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBTZWNvbmQgYm91bmRhcnkgIFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYmV0d2VlbiBhIGFuZCBiXG4gICAgKi9cbiAgIGJldHdlZW4odmFsdWUsIGEsIGIpIHtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKGEsIGIpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoYSwgYik7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heDtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBvdXRzaWRlIHRoZSByYW5nZSBvZiB0d28gb3RoZXIgdmFsdWVzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gRmlyc3QgYm91bmRhcnlcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gU2Vjb25kIGJvdW5kYXJ5XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBvdXRzaWRlIHRoZSByYW5nZVxuICAgICovXG4gICBvdXRvZmYodmFsdWUsIGEsIGIpIHtcbiAgICAgIHJldHVybiAhdGhpcy5iZXR3ZWVuKHZhbHVlLCBhLCBiKTtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBlcXVhbHMgYW55IG9mIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICogQHBhcmFtIHsuLi5udW1iZXJ9IGFyZ3MgLSBWYWx1ZXMgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBtYXRjaGVzIGFueSBhcmd1bWVudFxuICAgICovXG4gICBpcyh2YWx1ZSwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIGFyZ3MuaW5jbHVkZXModmFsdWUpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBSb3VuZCBhIG51bWJlciB0byBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gcm91bmRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwbGFjZXMgLSBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJvdW5kZWQgbnVtYmVyXG4gICAgKi9cbiAgIHJvdW5kKHZhbHVlLCBwbGFjZXMpIHtcbiAgICAgIHJldHVybiBOdW1iZXIoTWF0aC5yb3VuZCh2YWx1ZSArIFwiZVwiICsgcGxhY2VzKSArIFwiZS1cIiArIHBsYWNlcyk7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZSBvZiBhbm90aGVyIHZhbHVlIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxlIC0gVGhlIG11bHRpcGxlIHRvIGNoZWNrIGFnYWluc3RcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgLSBBbGxvd2VkIHRvbGVyYW5jZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZVxuICAgICovXG4gICBjbG9zZVRvQnkodmFsdWUsIG11bHRpcGxlLCB0b2xlcmFuY2UpIHtcbiAgICAgIGNvbnN0IG1vZCA9IHZhbHVlICUgbXVsdGlwbGU7XG4gICAgICByZXR1cm4gTWF0aC5taW4obW9kLCBtdWx0aXBsZSAtIG1vZCkgPCB0b2xlcmFuY2U7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIENvbnN0cmFpbiBhIHZhbHVlIGJldHdlZW4gbWluIGFuZCBtYXhcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSBNaW5pbXVtIHZhbHVlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBWYWx1ZSB0byBjb25zdHJhaW5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBNYXhpbXVtIHZhbHVlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDb25zdHJhaW5lZCB2YWx1ZVxuICAgICovXG4gICBtaW5tYXgobWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIEdlbmVyYXRlIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgbWF4IChpbmNsdXNpdmUpXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gTWF4aW11bSB2YWx1ZVxuICAgICogQHJldHVybnMge251bWJlcn0gUmFuZG9tIGludGVnZXJcbiAgICAqL1xuICAgcmFuZG9tSW50KG1heCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggKyAxKSk7XG4gICB9XG59O1xuXG4vLyBBcnJheSB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBBcnJheVV0aWxzID0ge1xuICAgLyoqXG4gICAgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBtb2RpZnlcbiAgICAqIEBwYXJhbSB7Kn0gaXRlbSAtIFRoZSBpdGVtIHRvIHJlbW92ZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWRcbiAgICAqL1xuICAgcmVtb3ZlKGFycmF5LCBpdGVtKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9LFxuXG5cblxuICAgLyoqXG4gICAgKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheVxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXlcbiAgICAqIEByZXR1cm5zIHsqfSBMYXN0IGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIGVtcHR5XG4gICAgKi9cbiAgIGxhc3QoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgIH0sXG5cbiAgIC8qKlxuICAgICogR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5XG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheVxuICAgICogQHJldHVybnMgeyp9IEZpcnN0IGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIGVtcHR5XG4gICAgKi9cbiAgIGZpcnN0KGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXlbMF07XG4gICB9LFxuXG4gICAvKipcbiAgICAqIFJlbW92ZSBhbGwgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIGFycmF5XG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBjbGVhblxuICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlcyByZW1vdmVkXG4gICAgKi9cbiAgIGNsZWFuVXAoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoaXRlbSA9PiBpdGVtICE9IG51bGwpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBHZXQgYSByYW5kb20gZWxlbWVudCBmcm9tIHRoZSBhcnJheVxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXlcbiAgICAqIEByZXR1cm5zIHsqfSBSYW5kb20gZWxlbWVudCBvciB1bmRlZmluZWQgaWYgZW1wdHlcbiAgICAqL1xuICAgcmFuZG9tKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXlbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyYXkubGVuZ3RoKV07XG4gICB9LFxuXG4gICAvKipcbiAgICAqIENvdW50IGVsZW1lbnRzIHRoYXQgYXBwZWFyIG1vcmUgdGhhbiBvbmNlXG4gICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byBhbmFseXplXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDb3VudCBvZiBub24tdW5pcXVlIGVsZW1lbnRzXG4gICAgKi9cbiAgIGNvdW50Tm9uVW5pcXVlKGFycmF5KSB7XG4gICAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICAgIGxldCBub25VbmlxdWVDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnJheSkge1xuICAgICAgICAgaWYgKGNvdW50c1tpdGVtXSA9PT0gMSkge1xuICAgICAgICAgICAgbm9uVW5pcXVlQ291bnQrKzsgLy8gT25seSBpbmNyZW1lbnQgb24gc2Vjb25kIG9jY3VycmVuY2VcbiAgICAgICAgIH1cbiAgICAgICAgIGNvdW50c1tpdGVtXSA9IChjb3VudHNbaXRlbV0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vblVuaXF1ZUNvdW50O1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBBZGQgZWxlbWVudCB0byBhcnJheSBvbmx5IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gbW9kaWZ5XG4gICAgKiBAcGFyYW0geyp9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBhZGRcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGVsZW1lbnQgd2FzIGFkZGVkLCBmYWxzZSBpZiBpdCBhbHJlYWR5IGV4aXN0ZWRcbiAgICAqL1xuICAgcHVzaFVuaXF1ZShhcnJheSwgZWxlbWVudCkge1xuICAgICAgaWYgKGFycmF5LmluZGV4T2YoZWxlbWVudCkgPT09IC0xKSB7XG4gICAgICAgICBhcnJheS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICB9LFxuXG4gICAvKipcbiAgICAqIEdyb3VwIGFycmF5IGl0ZW1zIGJ5IGEgcHJvcGVydHkgcGF0aFxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gZ3JvdXBcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVBhdGggLSBEb3Qtc2VwYXJhdGVkIHByb3BlcnR5IHBhdGhcbiAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZ3JvdXBlZCBhcnJheXMsIHNvcnRlZCBieSBncm91cCBzaXplIGRlc2NlbmRpbmdcbiAgICAqL1xuICAgZ3JvdXBCeShhcnJheSwgcHJvcGVydHlQYXRoKSB7XG4gICAgICBjb25zdCBncm91cHMgPSBhcnJheS5yZWR1Y2UoKHN0b3JhZ2UsIGl0ZW0pID0+IHtcbiAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcGVydHlQYXRoLnNwbGl0KCcuJykucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGl0ZW0pO1xuICAgICAgICAgY29uc3QgZ3JvdXAgPSBwcm9wZXJ0eTtcbiAgICAgICAgIFxuICAgICAgICAgc3RvcmFnZVtncm91cF0gPSBzdG9yYWdlW2dyb3VwXSB8fCBbXTtcbiAgICAgICAgIHN0b3JhZ2VbZ3JvdXBdLnB1c2goaXRlbSk7XG4gICAgICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGdyb3VwcylcbiAgICAgICAgIC5tYXAoa2V5ID0+IGdyb3Vwc1trZXldKVxuICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBhcnJheSB3aXRob3V0IHRoZSBzcGVjaWZpZWQgaXRlbVxuICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBUaGUgc291cmNlIGFycmF5XG4gICAgKiBAcGFyYW0geyp9IGl0ZW0gLSBUaGUgaXRlbSB0byBleGNsdWRlXG4gICAgKiBAcmV0dXJucyB7QXJyYXl9IE5ldyBhcnJheSB3aXRob3V0IHRoZSBpdGVtXG4gICAgKi9cbiAgIHdpdGhvdXQoYXJyYXksIGl0ZW0pIHtcbiAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoZWxlbWVudCA9PiBlbGVtZW50ICE9PSBpdGVtKTtcbiAgIH1cbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./www/code/utils.js\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./www/code/start.js");
/******/ 	
/******/ })()
;